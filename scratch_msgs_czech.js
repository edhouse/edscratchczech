// This file was automatically generated.  Do not modify.

'use strict';

goog.provide('Blockly.ScratchMsgs.allLocales');

goog.require('Blockly.ScratchMsgs');

Blockly.ScratchMsgs.locales["bw"] =
{
  //catagory titles
  "CATEGORY_DRIVE" : 'evirD',
  "CATEGORY_LED" : 'DEL',
  "CATEGORY_SOUND" : 'dnuoS',
  "CATEGORY_VARIABLES" : 'selbairaV',
  "CATEGORY_EVENTS" : 'stnevE',
  "CATEGORY_CONTROL" : 'lortnoC',
  "CATEGORY_SENSING" : 'gnisneS',
  "CATEGORY_OPERATORS" : 'srotarepO',
  "CATEGORY_COMMENT" : 'tnemmoC',
  "CATEGORY_ADVANCED" : 'decnavdA',
  "CATEGORY_MYBLOCKS" : 'snoitcnuF',

  //Drive block Messages
  "DRIVE_FORWARDS_DISTANCE" : "rof sdrawrof",
  "DRIVE_BACKWARDS_DISTANCE" : "rof sdrawkcab",
  "DRIVE_LEFT_DISTANCE" : "rof tfel",
  "DRIVE_RIGHT_DISTANCE" : "rof thgir",
  "DRIVE_DISTANCE_DROPDOWN_CM" : "mc",
  "DRIVE_DISTANCE_DROPDOWN_INCH" : "hcni",
  "DRIVE_DISTANCE_DROPDOWN_SECONDS" : "sdnoces",
  "DRIVE_DISTANCE_DROPDOWN_DEGREES" : "seerged",
  "DRIVE_TURN_DROPDOWN_SPIN" : "nips",
  "DRIVE_TURN_DROPDOWN_FORWARDS" : "sdrawrof nrut",
  "DRIVE_TURN_DROPDOWN_BACKWARDS" : "sdrawkcab nrut",
  "DRIVE_FORWARDS_UNTIL" : "litnu sdrawrof",
  "DRIVE_BACKWARDS_UNTIL" : "litnu sdrawkcab",
  "DRIVE_LEFT_UNTIL" : "litnu tfel",
  "DRIVE_RIGHT_UNTIL" : "litnu thgir",
  "DRIVE_SET_LEFT_MOTOR" : "ot rotom tfel tes",
  "DRIVE_SET_RIGHT_MOTOR" : "ot rotom thgir tes",
  "DRIVE_SET_MOTOR_DROPDOWN_FORWARDS" : "sdrawrof",
  "DRIVE_SET_MOTOR_DROPDOWN_BACKWARDS" : "sdrawkcab",
  "DRIVE_SET_BOTH_MOTOR" : "ot srotom htob tes",
  "DRIVE_SET_BOTH_MOTOR_DROPDOWN_FORWARDS" : "sdrawrof evird",
  "DRIVE_SET_BOTH_MOTOR_DROPDOWN_BACKWARDS" : "sdrawkcab  evird",
  "DRIVE_SET_BOTH_MOTOR_DROPDOWN_SPIN_LEFT" : "tfel tobor nips",
  "DRIVE_SET_BOTH_MOTOR_DROPDOWN_SPIN_RIGHT" : "thgir tobor nips",
  "DRIVE_SET_BOTH_MOTOR_DROPDOWN_TURN_LEFT" : "tfel tobor nrut",
  "DRIVE_SET_BOTH_MOTOR_DROPDOWN_TURN_RIGHT" : "thgir tobor nrut",
  "DRIVE_AT_SPEED" : "deeps ta",
  "DRIVE_STOP" : "pots",
  "DRIVE_STOP_DROPDOWN_BOTH" : "srotom htob",
  "DRIVE_STOP_DROPDOWN_LEFT" : "rotom tfel",
  "DRIVE_STOP_DROPDOWN_RIGHT" : "rotom thgir",

  //LED Block Messages
  "LED_LEFT" : "DEL tfel nrut",
  "LED_RIGHT" : "DEL thgir nrut",
  "LED_DROPDOWN_ON" : "no",
  "LED_DROPDOWN_OFF" : "ffo",
  "LED_SEND_MESSAGE" : "egassem RI dnes",

  // Sound blocks
  "SOUND_BEEP" : "peeb",
  "SOUND_PLAY_NOTE" : 'a yalp',
  "SOUND_PLAY_NOTE_DROP_DURATION_WHOLE" : "elohw",
  "SOUND_PLAY_NOTE_DROP_DURATION_HALF" : "flah",
  "SOUND_PLAY_NOTE_DROP_DURATION_QUARTER" : "retrauq",
  "SOUND_PLAY_NOTE_DROP_DURATION_EIGHTH" : "hthgie",
  "SOUND_PLAY_NOTE_DROP_NOTE_C" : "C1",
  "SOUND_PLAY_NOTE_DROP_NOTE_B" : "B1",
  "SOUND_PLAY_NOTE_DROP_NOTE_A" : "A1",
  "SOUND_PLAY_NOTE_DROP_NOTE_G" : "G1",
  "SOUND_PLAY_NOTE_DROP_NOTE_F" : "F1",
  "SOUND_PLAY_NOTE_DROP_NOTE_E" : "E1",
  "SOUND_PLAY_NOTE_DROP_NOTE_D" : "D1",
  "SOUND_PLAY_NOTE_DROP_NOTE_MID_C" : "C elddim",
  "SOUND_PLAY_NOTE_DROP_NOTE_LOW_B" : "B wol",
  "SOUND_PLAY_NOTE_DROP_NOTE_REST" : "tser",
  "SOUND_PLAY_NOTE_DROP_MOD_NORMAL" : " - ",
  "SOUND_PLAY_NOTE_DROP_MOD_SHARP" : "prahs",
  "SOUND_PLAY_NOTE_DROP_MOD_FLAT" : "talf",
  "SOUND_SET_TEMPO" : "ot opmet cisum tes",
  "SOUND_SET_TEMPO_DROP_VERY_SLOW" : "wols yrev",
  "SOUND_SET_TEMPO_DROP_SLOW" : "wols",
  "SOUND_SET_TEMPO_DROP_MEDIUM" : "muidem",
  "SOUND_SET_TEMPO_DROP_FAST" : "tsaf",
  "SOUND_SET_TEMPO_DROP_VERY_FAST" : "tsaf yrev",
  "SOUND_PLAY_IN_BACKGROUND" : "dnuorgkcab ni cisum yalp",

  // Data blocks
  "DATA_BUTTONCREATE" : 'elbairav a ekaM',
  "DATA_BUTTONMANAGE" : 'selbairav eganaM',
  "DATA_SET" : "tes",
  "DATA_TO" : "ot",
  "DATA_INCVARIABLE" : 'tnemercni',
  "DATA_DECVARIABLE" : 'tnemerced',
  "DATA_BITSHIFT" : "tfihs tib",
  "DATA_BITSHIFTLEFT" : 'yb tfel',
  "DATA_BITSHIFTRIGHT" : 'yb thgir',

  // Event blocks
  "EVENT_ANY_OBSTACLE" : 'detceted elcatsbo ynA',
  "EVENT_OBSTACLE_AHEAD" : 'daeha detceted elcatsbO',
  "EVENT_OBSTACLE_LEFT" : 'tfel detceted elcatsbO',
  "EVENT_OBSTACLE_RIGHT" : 'thgir detceted elcatsbO',
  "EVENT_CLAP" : 'detceted palC',
  "EVENT_BUTTON_TRIANGLE" : 'desserp nottub elgnairT',
  "EVENT_BUTTON_ROUND" : 'desserp nottub dnuoR',
  "EVENT_LINE_REFLECTIVE" : 'ecafrus evitcelfer no rekcart eniL',
  "EVENT_LINE_NON_REFLECTIVE" : 'ecafrus evitcelfer-non no rekcart eniL',
  "EVENT_LINE_CHANGE" : 'ecafrus segnahc rekcart eniL',
  "EVENT_MESSAGE" : 'deviecer egassem RI',
  "EVENT_REMOTE" : 'deviecer edoc etomeR',
  "EVENT_DRIVE_STRAIN" : 'deniarts evirD',
  "EVENT_START" : 'tratS',

  //control blocks
  "CONTROL_FOREVER" : 'reverof',
  "CONTROL_REPEAT" : 'taeper',
  "CONTROL_IF" : 'fi',
  "CONTROL_THAN" : 'neht',
  "CONTROL_ELSE" : 'esle',
  "CONTROL_STOP" : 'pots',
  "CONTROL_STOP_ALL" : 'lla',
  "CONTROL_WAIT" : 'tiaw',
  "CONTROL_WAIT_SEC" : 'ces',
  "CONTROL_WAIT_MILLISECONDS" : 'sdnocesillim',
  "CONTROL_WAITUNTIL" : 'litnu tiaw',
  "CONTROL_REPEATUNTIL" : 'litnu taeper',


  // Sensing blocks
  "SENSING_TURN_LINE_TRACKING_LED" : 'DEL gnikcart enil nrut',
  "SENSING_TURN_OBSTACLE_BEAM" : 'maeb noitceted elcatsbo nrut',
  "SENSING_CLEAR" : 'raelc',
  "SENSING_SENSOR" : 'atad rosnes',
  "SENSING_CLAP_DETECTED" : 'detceted palc',
  "SENSING_BUTTON_PRESSED" : 'desserp nottub',
  "SENSING_OBSTACLE" : 'detceted elcatsbo',
  "SENSING_LINE_TRACKER" : 'no rekcart enil',
  "SENSING_LINE_SURFACE" : "ecafrus",
  "SENSING_REMOTE_NUM" : 'edoc etomer deviecer',
  "SENSING_REMOTE_BOOL" : 'edoc etomer',
  "SENSING_REMOTE_RECEIVED" : 'deviecer',
  "SENSING_IR_MESSAGE_DETECTED" : 'detceted egassem RI',
  "SENSING_IR_MESSAGE" : 'egassem RI deviecer',
  "SENSING_LIGHT_LEVEL" : 'fo level thgil',
  "SENSING_LIGHT_SENSOR" : 'rosnes',
  "SENSING_DRIVE_STRAIN" : 'detceted niarts evird',

  "SENSING_DROPDOWN_ON" : "no",
  "SENSING_DROPDOWN_OFF" : "ffo",

  "SENSING_CLEAR_DROPDOWN_CLAP" : "rotceted palc",
  "SENSING_CLEAR_DROPDOWN_KEY" : "dapyek",
  "SENSING_CLEAR_DROPDOWN_OBS" : "rotceted elcatsbo",
  "SENSING_CLEAR_DROPDOWN_REMOTE" : "edoc etomer",
  "SENSING_CLEAR_DROPDOWN_IR" : "egassem RI",

  "SENSING_KEY_DROPDOWN_ROUND" : "dnuor",
  "SENSING_KEY_DROPDOWN_TRIANGLE" : "elgnairt",

  "SENSING_OBS_DROPDOWN_ANY" : "erehwyna",
  "SENSING_OBS_DROPDOWN_AHEAD" : "daeha",
  "SENSING_OBS_DROPDOWN_LEFT" : "tfel",
  "SENSING_OBS_DROPDOWN_RIGHT" : "thgir",

  "SENSING_LINE_DROPDOWN_WHITE" : "evitcelfer ",
  "SENSING_LINE_DROPDOWN_BLACK" : "evitcelfer-non",

  "SENSING_LIGHT_DROPDOWN_LEFT" : "thgil tfel",
  "SENSING_LIGHT_DROPDOWN_RIGHT" : "thgil thgir",
  "SENSING_LIGHT_DROPDOWN_LINE" : "gnikcart enil",

  // Operators blocks
  "OPERATORS_ADD" : '%1 + %2',
  "OPERATORS_SUBTRACT" : '%1 - %2',
  "OPERATORS_MULTIPLY" : '%1 * %2',
  "OPERATORS_DIVIDE" : '%1 / %2',
  "OPERATORS_RANDOM" : 'neewteb rebmun modnar',
  "OPERATORS_LT" : '%1 < %2',
  "OPERATORS_LT_EQUAL" : '%1 <= %2',
  "OPERATORS_EQUALS" : '%1" : %2',
  "OPERATORS_GT_EQUAL" : '%1 >= %2',
  "OPERATORS_GT" : '%1 > %2',
  "OPERATORS_AND" : 'dna',
  "OPERATORS_OR" : 'ro',
  "OPERATORS_NOT_EQUALS" : '%1 != %2',
  "OPERATORS_NOT" : 'ton',
  "OPERATORS_ABS" : 'sba',
  "OPERATORS_BETWEEN" : 'neewteb si',

  "COMMENT_USER_COMMENT" : ':tnemmoc',

  "ADVANCED_USB_SEND_DATA" : 'dnes',
  "ADVANCED_USB_SEND_VIA" : 'BSU aiv',
  "ADVANCED_USB_RECEIVED_DATA" : 'BSU morf deviecer atad',
  "ADVANCED_USB_RECEIVED_DATA_VAR" : 'ot evas dna atad BSU rof tiaw',

  // Procedures blocks

  // Context menus
  "DUPLICATE" : 'etacilpuD',
  "DELETE" : 'eteleD',
  "ADD_COMMENT" : 'tnemmoC ddA',
  "REMOVE_COMMENT" : 'tnemmoC evomeR',
  "DELETE_BLOCK" : 'kcolB eteleD',
  "DELETE_X_BLOCKS" : 'skcolB %1 eteleD',
  "DELETE_ALL_BLOCKS" : '?skcolb %1 lla eteleD',
  "CLEAN_UP" : 'skcolB pu naelC',
  "HELP" : 'pleH',
  "UNDO" : 'odnU',
  "REDO" : 'odeR',
  "EDIT_PROCEDURE" : 'tidE',
  "SHOW_PROCEDURE_DEFINITION" : 'noitinifed ot oG',
  "WORKSPACE_COMMENT_DEFAULT_TEXT" : '...gnihtemos yaS',

  // Custom Procedures
  // @todo Remove these once fully managed by Scratch VM / Scratch GUI
  "NEW_PROCEDURE" : 'noitcnuf a ekaM',
  "MANAGE_PROCEDURE" : 'noitcnuf a eganaM',
  "PROCEDURE_ALREADY_EXISTS" : 'A procedure named "%1" already exists.',
  "PROCEDURE_DEFAULT_NAME" : 'block name',
  "PROCEDURE_USED" : 'To delete a block definition, first remove all uses of the block',

  "MENU_DROP_MENU" : "uneM", //no ID yet
  "MENU_DROP_NEW" : "weN", //navNew
  "MENU_DROP_LOAD_DEMO" : "omed daoL", //navPopLoadDemo
  "MENU_DROP_LOAD_LOCAL" : "retupmoc morf daoL", //navPopLoadLocal
  "MENU_DROP_SAVE_LOCAL" : "retupmoc ot evaS", //navPopLoadSave
  "MENU_DROP_UPDATE_FIRMWARE" : "erawmrif etadpU", //navPopFirmwareUpdate
  "MENU_DROP_DIAGNOSTICS" : "scitsongaiD", //navPopHelp
  "MENU_DROP_LANGUAGE_LABEL" : "egaugnaL", //navPopLanguage
  "MENU_DROP_ABOUT" : "tuobA", //navPopAbout
  "MENU_DROP_TERMS" : "esu fo smreT", //No ID yet

  "MENU_USB" : "BSU", //navPopUSB
  "MENU_SAVE" : "evaS ", //navPopLoadSaveAlt

  "MENU_VERSION_MAIN" : "3V nosidE ", //navVersionTop
"MENU_VERSION_SWITCH" : "2V/1V nosidE ot hctiwS", //navVersionSwitch
"MENU_VERSION_WHICH_VERSION" : "evah I od noisrev hcihW", //navVersionHelp
"MENU_PROGRAM" : "margorP ", //navProgram
"MENU_PROGRAM_FLASH" : "margorP ", //navProgramFlash


"MODAL_CREATE_VAR" : "elbairaV etaerC", //no ID yet
"MODAL_CREATE_VAR_NAME" : "emaN elbairaV", //no ID yet
"MODAL_CREATE_VAR_BUTTON" : "elbairaV etaerC", //no ID yet
"MODAL_CREATE_VAR_EXIT" : "tixE", //no ID yet
"MODAL_CREATE_VAR_SUCCESS" : ".yllufsseccus detaerc elbairav weN",

"MODAL_MANAGE_VAR" : " selbairaV", //no ID yet
"MODAL_MANAGE_VAR_NAME" : "emaN elbairaV", //no ID yet
"MODAL_MANAGE_VAR_ACTION" : "noitcA", //no ID yet
"MODAL_MANAGE_VAR_BUTTON_DELETE" : "eteled", //in code
"MODAL_MANAGE_VAR_BUTTON_RENAME" : "emaner", //in code
"MODAL_MANAGE_VAR_BUTTON_CONFIRM" : "mrifnoc", // in code 1378
"MODAL_MANAGE_VAR_BUTTON_CANCEL" : "lecnac", // in code 1378
"MODAL_MANAGE_VAR_CONFIRM_NOT_CHANGED" : ".niaga yrt esaelP .eman elbairav eht egnahc ton did uoY", //in code 1401
"MODAL_MANAGE_VAR_CONFIRM_SUCCESS" : "!yllufsseccus demaner elbairaV", //in code 1423

"MODAL_MANAGE_VAR_NAME_NONE" : ".eman elbairav a retne esaelP", //in code 1554
"MODAL_MANAGE_VAR_NAME_IN_USE" : ".eman taht htiw elbairav a evah ydaerla uoY", //in code 1558
"MODAL_MANAGE_VAR_NAME_UNSUPPORTED" : ".) _ ( serocsrednu dna ,srebmun ,srettel hsilgnE esacreppu ,srettel hsilgnE esacrewol niatnoc ylno nac seman elbairaV .retcarahc detroppusnu na sniatnoc eman elbairaV", //line 1563
"MODAL_MANAGE_VAR_NAME_NUMBER_START" : ".rebmun a htiw trats tonnac seman elbairaV", //in code 1567

"MODAL_MANAGE_VAR_DELETE_IN_USE" : "?ti eteled ot tnaw uoy erus uoy erA .margorp ruoy ni desu gnieb yltnerruc si elbairav sihT", //in code 11619
"MODAL_MANAGE_VAR_DELETE_CONFIRM" : "seY", //in code line 1619
"MODAL_MANAGE_VAR_DELETE_DECLINE" : "oN", //in code line 1619

"MODAL_CREATE_FUNCT" : "noitcnuF etaerC", //divCreateFunctTitle
"MODAL_CREATE_FUNCT_NAME" : "emaN noitcnuF", //divCreateFunctLabel
"MODAL_CREATE_FUNCT_WARNING" : ".rettel a htiw nigeb tsum dna ylno sretcarahc ciremunahplA", //divCreateFunctWarning
"MODAL_CREATE_FUNCT_BUTTON" : "noitcnuF etaerC", //btnCreateFunc
"MODAL_CREATE_FUNCT_BUTTON_EXIT" : "tixE", //btnCreateFuncDone
"MODAL_CREATE_FUNCT_SUCCESS" : ".yllufsseccus detaerc noitcnuf weN",

"MODAL_MANAGE_FUNCT" : "snoitcnuF ", //divManageFunctlabel
"MODAL_MANAGE_FUNCT_NAME" : "emaN noitcnuF", //divManageFunctName
"MODAL_MANAGE_FUNCT_ACTION" : "noitcA", //divManageFunctAction
"MODAL_MANAGE_FUNCT_BUTTON_DELETE" : "eteled", //in code workspace setup 655
"MODAL_MANAGE_FUNCT_BUTTON_RENAME" : "emaner", //in code workspace setup 656
"MODAL_MANAGE_FUNCT_BUTTON_CONFIRM" : "mrifnoc", // in code 1378
"MODAL_MANAGE_FUNCT_BUTTON_CANCEL" : "lecnac", // in code 1378
"MODAL_MANAGE_FUNCT_CONFIRM_NOT_CHANGED" : ".niaga yrt esaelP .eman noitcnuf eht egnahc ton did uoY", //in code 1401
"MODAL_MANAGE_FUNCT_CONFIRM_SUCCESS" : "!yllufsseccus demaner noitcnuF", //in code 1423

"MODAL_MANAGE_FUNCT_NAME_NONE" : ".eman noitcnuf a retne esaelP", //in code
"MODAL_MANAGE_FUNCT_NAME_IN_USE" : ".eman taht htiw noitcnuf a evah ydaerla uoY", //in code
"MODAL_MANAGE_FUNCT_NAME_START_WITH" : "htiw trats tonnac seman noitcnuf resU",
"MODAL_MANAGE_FUNCT_NAME_UNSUPPORTED" : ".) _ ( serocsrednu dna ,srebmun ,srettel hsilgnE esacreppu ,srettel hsilgnE esacrewol niatnoc ylno nac seman noitcnuF .retcarahc detroppusnu na sniatnoc eman noitcnuF", //line
"MODAL_MANAGE_FUNCT_NAME_NUMBER_START" : ".rebmun a htiw trats tonnac seman noitcnuF", //in code 1567

"MODAL_MANAGE_FUNCT_DELETE_IN_USE" : "?ti eteled ot tnaw uoy erus uoy erA .margorp ruoy ni desu gnieb yltnerruc si noitcnuf sihT", //in code 11619
"MODAL_MANAGE_FUNCT_DELETE_CONFIRM" : "seY", //in code line 1619
"MODAL_MANAGE_FUNCT_DELETE_DECLINE" : "oN", //in code line 1619

"MODAL_SAVE_TITLE" : "retupmoc ot evaS", //no ID yet
"MODAL_SAVE_PROG_TITLE" : "eman margorP", //no ID yet
"MODAL_SAVE_BUTTON" : "retupmoc ot evaS", //no ID yet
"MODAL_SAVE_ERROR_NO_NAME" : ".ti evas ot redro ni margorp eht eman ot deen uoY .margorp ruoy rof eman a retne esaelP", //1050 in function, replace
"MODAL_SAVE_ERROR_LONG_NAME" : ".gnol sretcarahc 552 fo mumixam a eb nac seman margorP .eman margorp taht htiw melborp a s'erehT .spoohW", //1052 in function, replace
"MODAL_SAVE_SAVING" : ".noos nigeb dluohs margorp ruoy fo daolnwod ehT .devas gnieb si margorp ruoY !KO", //268 in function, replace

"MODAL_LOAD_PC_TITLE" : "retupmoc morf daoL", //no ID yet
"MODAL_LOAD_PC_FILE_ERROR_1" : ".elif evas hctarcSdE na tceles esaelP", //no ID yet
"MODAL_LOAD_PC_FILE_ERROR_2" : "epyt elif era selif evas hctarcSdE llA", //no ID yet
"MODAL_LOAD_PC_FILE_ERROR_3" : "hctarcsde.", //no ID yet
"MODAL_LOAD_PC_FILE_BUTTON" : "...daolpu ot elif a tceleS", //no ID yet
"MODAL_LOAD_PC_BUTTON" : "margorp daoL", //btnLoadLocal
"MODAL_LOAD_PC_NO_FILE_ERROR_1" : "].)hctarcsde.( epyt elif era selif evas hctarcSdE llA[ .elif eht daol neht ,retupmoc ruoy morf elif evas hctarcSdE na tceles tsrif esaelP .tey elif a detceles t'nevah uoY", //IN FILE 398
"MODAL_LOAD_PC_FILE_DATA_ERROR_1" : ".elif taht ni atad eht htiw melborp a s'erehT .ho-hU", //IN FILE 417
"MODAL_LOAD_PC_FILE_DATA_ERROR_2" : "].)hctarcsde.( epyt elif era selif evas hctarcSdE llA[ .elif evas hctarcSdE tnereffid a daolpu esaelP", //IN FILE 417
"MODAL_LOAD_PC_FILE_TYPE_ERROR_1" : ".epyt elif tcerrocni na dedaolpu ev'uoY .ho-hU", //IN FILE 417
"MODAL_LOAD_PC_FILE_TYPE_ERROR_2" : "].)hctarcsde.( epyt elif era selif evas hctarcSdE llA[ .elif evas hctarcSdE na daolpu esaelP", //IN FILE 417
"MODAL_LOAD_PC_FILE_READY" : ":margorp daol ot ydaeR",

"MODAL_LOAD_DEMO_TITLE" : "omed daoL", //no ID yet
"MODAL_LOAD_DEMO_BUTTON" : "margorp daoL", //471 IN FILE


"MODAL_ABOUT_TITLE" : "hctarcSdE tuobA", //no ID yet
"MODAL_ABOUT_COPYRIGHT" : "dtL ytP cirborciM 3202 thgirypoC", //no ID yet
"MODAL_ABOUT_BODY_1" :  "elgooG yb depoleved esab edoc ylkcolB eht no tliub saw skcolB hctarcS .TIM yb depoleved esab edoc skcolB hctarcS eht gnisu depoleved saw ppa hctarcSdE ehT",
"MODAL_ABOUT_BODY_2" :  ":stiderc dna snoitubirtnoC",
"MODAL_ABOUT_BODY_3" :  "cirborciM ,notyaH neB yb depoleved relipmoc kcolb dna egaugnal gnimmargorp hctarcSdE",
"MODAL_ABOUT_BODY_4" :  "tnempoleveD beW nailliK ,nailliK naeS yb depoleved ecafretni resu hctarcSdE",
"MODAL_ABOUT_BODY_5" :  ")esab edoc nohtyPorciM( scitoboR egroeG ,egroeG neimaD yb depoleved erawmrif 3V nosidE",


"MODAL_LANGUAGE" : "egaugnaL", //divLanguageLabel


"MODAL_DIAGNOSTICS" : "scitsongaiD", //no ID yet
"MODAL_DIAGNOSTICS_CONNECT_ISSUES_TITLE" : "seussi ytivitcennoC", //no ID yet
"MODAL_DIAGNOSTICS_CONNECT_ISSUES_BODY" : ".relipmoc hctarcSdE eht htiw noitcennoc ruoy kcehc ot aedi doog a si ti ,tobor nosidE eht ot tnes dna delipmoc eb nac margorp ruoy taht erusne oT", //no ID yet
"MODAL_DIAGNOSTICS_CONNECT_ISSUES_BUTTON" : "rekcehc noitcennoc eht nuR", //no ID yet
"MODAL_DIAGNOSTICS_FIRMWARE_TITLE" : "erawmriF", //no ID yet
"MODAL_DIAGNOSTICS_FIRMWARE_BODY" : ":ereh taht kcehC .maet troppus hcet ruo ot gniklat nehw wonk ot lufesu eb nac nosidE ruoy ni noisrev erawmrif ehT", //no ID yet
"MODAL_DIAGNOSTICS_FIRMWARE_BUTTON" : "noisrev erawmrif teG", //no ID yet
"MODAL_DIAGNOSTICS_PROGRAMMING_TITLE" : "dohtem gnimmargorP", //divDiagnosticsProgLabel
"MODAL_DIAGNOSTICS_PROGRAMMING_BODY" : ".ecived siht no gnimmargorp hsalf neercs dna BSU neewteb hcitws ot uoy selbane noitpo sihT", //divDiagnosticsProgBody
"MODAL_DIAGNOSTICS_PROGRAMMING_BUTTON" : "dohtem gnimmargorp egnahC", //navPopProgrammingMethod
"MODAL_DIAGNOSTICS_IR_TITLE" : "sdnammoc etomer RI denrael raelC", //divDiagnosticsIRLabel
"MODAL_DIAGNOSTICS_IR_BODY" : ".tobor 3V nosidE na morf sdnammoc lortnoc etomer RI denrael lla raelc ot uoy swolla noitpo sihT", //divDiagnosticsIRBody
"MODAL_DIAGNOSTICS_IR_BUTTON" : "sedoc etomer raelC", //doClearRemoteCodes
"MODAL_DIAGNOSTICS_IR_SUCCESS" : ".deraelc neeb evah sedoc etomeR", // in file 347
"MODAL_DIAGNOSTICS_IR_ERROR" : ".derrucco sah rorre nAS", // in file 349

"MODAL_CONNECTION" : "noitcennoC", //no ID yet
"MODAL_CONNECTION_TEST_1" : " tluser eht sah evoba tset eht fI", //no ID yet
"MODAL_CONNECTION_TEST_EXAMPLE" : "DNUOF REVRES ON", //no ID yet
"MODAL_CONNECTION_TEST_2" : ":sesserdda eseht tsiletihw ot rotartsinimda krowten ruoy ksa ,siht yfitcer oT", //no ID yet
"MODAL_CONNECTION_TEST_3" : ":sesserdda eseht tsil etihw ot rotartsinimda krowten eht deen uoY", //no ID yet
"MODAL_CONNECTION_PORTS" : ".3448 dna 344 ,0808 ,08 strop kcolbnu ot sdeen osla rotartsinimda krowten ehT", //no ID yet
"MODAL_CONNECTION_BACK" : "scitsongaid ot kcaB", //no ID yet
"MODAL_CONNECTION_SERVER" : " :revreS", //in code
"MODAL_CONNECTION_SERVER_SEARCHING" : "gnihcraes",
"MODAL_CONNECTION_SERVER_NONE" : "DNUOF REVRES ON", //in code
"MODAL_CONNECTION_COMIPLE_TEST" : " :tseT elipmoC", //in code
"MODAL_CONNECTION_COMIPLE_TEST_WORKING" : "gnikrow",
"MODAL_CONNECTION_COMIPLE_TEST_ERROR" : "rorre elipmoc", //in code
"MODAL_CONNECTION_COMIPLE_TEST_COMPLETE" : " ni etelpmoc elipmoc", //in code


"MODAL_FIRMWARE_UPDATE_TITLE" : "erawmrif etadpU", //no ID yet
"MODAL_FIRMWARE_UPDATE_LATEST" : " :si noisrev erawmrif 3V nosidE tsetal ehT", //no ID yet
"MODAL_FIRMWARE_UPDATE_POPUP" : ".nosidE ruoy ni erawmrif eht etadpu ot pu-pop siht esU", //no ID yet
"MODAL_FIRMWARE_UPDATE_TO_UPDATE1" : ":erawmrif 3V nosidE etadpu oT", //no ID yet
"MODAL_FIRMWARE_UPDATE_TO_UPDATE2" : ".stpmorp eht wollof neht woleb nottub 'erawmrif etadpU' eht kcilc dna nosidE ruoy ni gulP", //no ID yet
"MODAL_FIRMWARE_UPDATE_TO_UPDATE_BUTTON" : " erawmrif etadpU", //no ID yet
"MODAL_FIRMWARE_UPDATE_TO_RECONNECT_BUTTON" : " nosidE tcennoceR", //no ID yet
"MODAL_FIRMWARE_UPDATE_FEEDBACK_START" : "...ydaeR", //811 IN FILE
//need text from the update process
"MODAL_FIRMWARE_UPDATE_TWO_STEP_START" : "gnitrats si etadpu erawmrif pets owt A",
"MODAL_FIRMWARE_UPDATE_BOOT_COMPLETE" : ".etelpmoc etadpu redaoltooB",
"MODAL_FIRMWARE_UPDATE_PLEASE_CLICK" : "kcilc esaelP",
"MODAL_FIRMWARE_UPDATE_ISSUE_LOADING" : "erawmrif gnidaol eussI",
"MODAL_FIRMWARE_UPDATE_ONE_STEP_START" : "gnitrats si etadpu erawmrif A",
"MODAL_FIRMWARE_UPDATE_ERROR_ISSUE_LOADING" : ".erawmrif gnidaol eussI :rorrE",
"MODAL_FIRMWARE_UPDATE_ERROR_ISSUE_DOWNLOADING" : ".erawmrif gnidaolnwod eussI :rorrE",
"MODAL_FIRMWARE_UPDATE_FIRM_COMPLETE" : ".etelpmoc etadpu erawmriF",
"MODAL_FIRMWARE_UPDATE_NONE_NEEDED" : ".etad ot pu si nosidE ruoy no erawmrif eht :deriuqer etadpu oN",

"MODAL_STATUS_TITLE" : "noisrev erawmriF", //no ID yet
"MODAL_STATUS_BUTTON" : "nosidE tcennoC",
"MODAL_STATUS_STATUS_LABEL" : ":sutatS",
"MODAL_STATUS_STATUS_NOT_CONNECTED" : "detcennoc ton", // 688
"MODAL_STATUS_STATUS_CONNECTED" : "detcennoc", // 665 647
"MODAL_STATUS_FIRMWARE_LABEL" : ":noisrev erawmriF",
"MODAL_STATUS_FIRMWARE_BOOT_MODE" : "edom redaoltoob",//698
"MODAL_STATUS_FIRMWARE_FACTORY_MODE" : "edom noitacilppa yrotcaf",//700
"MODAL_STATUS_FIRMWARE_USER_MODE" : "edom noitacilppa resu",//702
"MODAL_STATUS_FIRMWARE_TAG" : "erawmrif" ,//708
"MODAL_STATUS_BOOT_TAG" : "toob",//708
"MODAL_STATUS_FIRMWARE_UPDATE" : "etadpu erawmrif A",
"MODAL_STATUS_FIRMWARE_UPDATE_AVAILABLE" : "elbaliava si", //
"MODAL_STATUS_BOOT_UPDATE" : "etadpu toob A",
"MODAL_STATUS_FIRMWARE_UPDATE_BUTTON" : "erawmriF etadpU",
"MODAL_STATUS_FIRMWARE_UP_TO_DATE" : ".etad ot pu si nosidE ruoY",

"MODAL_PROGRAMING_METHOD_TITLE" : "dohtem gnimmargorP", //divProgMethodLabel
"MODAL_PROGRAMING_METHOD_BODY" : " gnimmargorp hsalf neercs selbane woleb noitpo ehT .secived diordnA emos htiw krow seod rehsalf neercs eht ,revewoH .sdaPi rof detroppus ylluf ylno si gnimmargorp hsalf neercs ,eroferehT .trop atad s'daPi eht ot ssecca lamron wolla ton od elppA esuaceb si sihT .sdaPi elppA rof depoleved neeb sah gnimmargorp hsalf neercS",//divProgMethodBody
"MODAL_PROGRAMING_METHOD_CURRENT_LABEL" : "gnisu yltnerruC", //code
"MODAL_PROGRAMING_METHOD_CURRENT_LABEL_USB" : "BSU", //code
"MODAL_PROGRAMING_METHOD_CURRENT_LABEL_FLASH" : "HSALF", //code
"MODAL_PROGRAMING_METHOD_CURRENT_LABEL_METHOD" : "dohtem.", //code
"MODAL_PROGRAMING_METHOD_BUTTON_USB" : "dohtem BSU ot teS", //btnChangeUSBMethod
"MODAL_PROGRAMING_METHOD_BUTTON_FLASH" : "dohtem HSALF ot teS", //btnChangeFlashMethod
"MODAL_PROGRAMING_METHOD_ACCORD_BUTTON_FLASH_GUARANTEE" : "?secived diordnA htiw krow ot deetnaraug ton gnihsalf neercs si yhW", //btnProgMethodFlashGuarantee
"MODAL_PROGRAMING_METHOD_ACCORD_BODY_FLASH_GUARANTEE" : ".secived diordnA lla rof gnihsalf neercs esimotsuc dna tset ot elbissop ton si tI .seigolonhcet neercs tnereffid fo tol a osla si ereht snaem sihT .sledom tnereffid fo sdnasuoht era ereht dna srerutcafunam tnereffid ynam yb edam era secived diordnA", //divProgMethodFlashGuarantee
"MODAL_PROGRAMING_METHOD_ACCORD_BUTTON_FLASH_SETTINGS" : "?gnihsalf neercs htiw krow ecived diordnA ym pleh thgim taht sgnittes ereht erA", //btnProgMethodFlashSettings
"MODAL_PROGRAMING_METHOD_ACCORD_BODY_FLASH_SETTINGS" : ".ssenthgirb %001 dna %09 ,%57 ,%05 htiw tseT .ssenthgirb neercs eht gnitsujda yrt ,oslA .snoitisop ruof eht fo eno hcae yrT .snoitisop ruof sah taht gnittes 'tsaf/elbailer' a si ereht wodniw pupop hsalf neercs eht no ,seY", //divProgMethodFlashSettings
"MODAL_PROGRAMING_METHOD_ACCORD_BUTTON_FLASH_FAIL" : "?ecived diordnA ym no krow ton seod gnihsalf neercs fi od I od tahW", //btnProgMethodFlashFail
"MODAL_PROGRAMING_METHOD_ACCORD_BODY_FLASH_FAIL" : ".cte nozamA ,yabe morf elbaliava ylpaehc dna nommoc era esehT .elbac rotpada na aiv trop atad s'ecived diordnA eht otni elbac 3V nosidE eht gulp ot deen lliw uoy margorp oT", //divProgMethodFlashFail
"MODAL_PROGRAMING_METHOD_BACK" : "scitsongaid ot kcaB", //divProgMethodBack


// "MODAL_PROGRAMING" : "margorP", //no ID yet
"MODAL_PROGRAMING_TITLE" : "gnimmargorP",
"MODAL_PROGRAMING_TITLE_COMPLETE" : "etelpmoc gnimmargorP",
"MODAL_PROGRAMING_TITLE_ERROR" : "rorre gnimmargorP",

"MODAL_PROGRAMING_TIP_1_TITLE" : "!buh BSU a no stobor nosidE retsulc t'noD :piT", //tips.js
"MODAL_PROGRAMING_TIP_1_TEXT" : ".retsni regrahCdE na esU", //tips.js
"MODAL_PROGRAMING_TIP_2_TITLE" : "!gnignah nosidE evael t'noD :piT", //tips.js
"MODAL_PROGRAMING_TIP_2_TEXT" : ".ecafrus dilos a no detroppus nosidE peeK", //tips.js
"MODAL_PROGRAMING_TIP_3_TITLE" : "!gnignah nosidE evael t'noD :piT", //tips.js
"MODAL_PROGRAMING_TIP_3_TEXT" : ".teltuo rewop a morf gnigrahc nehw elbac noisnetxe na esU", //tips.js
"MODAL_PROGRAMING_TIP_4_TITLE" : "!nosidE no llup t'noD :piT", //tips.js
"MODAL_PROGRAMING_TIP_4_TEXT" : ".tobor eht ton ,elbac BSU eht no gnillup yb gulpnU", //tips.js


//NEED MESSAGES
"MODAL_PROGRAMING_ERROR_NO_BLOCK" : ".kcolb trats eht ot detcennoc skcolb on htiw daolnwod tonnaC",//code
"MODAL_PROGRAMING_ERROR_RED" : ".srorrE deR htiw daolnwod tonnaC",
"MODAL_PROGRAMING_UPDATE_FIRMWARE" : "noisrev tsetal eht ot erawmrif eht etadpu ot deen lliw uoy nosidE ruoy margorp oT", //code
"MODAL_PROGRAMING_UPDATE_FIRMWARE_BUTTON" : "erawmrif etadpU",
"MODAL_PROGRAMING_UPDATE_FIRMWARE_NOW" : "...won gnitadpU .deriuqer detadpu erawmriF",
"MODAL_PROGRAMING_FIRMWARE_UPDATED" : ".detadpu erawmriF",
"MODAL_PROGRAMING_FIRMWARE_UPDATE_INCOMPLETE" : ".etadpu erawmrif etelpmocnI",
"MODAL_PROGRAMING_DONE" : ".nosidE ruoy ot dedaol sah margorp ehT !KO",
"MODAL_PROGRAMING_ERROR_JSON" : "!NOSJ ton si esnopseR",
"MODAL_PROGRAMING_ERROR_UNKNOWN" : "!rorrE nwonknU",


"MODAL_USB_CONTROL" : "slortnoC BSU", //no ID yet
"MODAL_USB_RUN_BUTTON" : "BSU nuR", //usbRun
"MODAL_USB_CONNECTED_STATUS" : "DETCENNOC", //IN FILE 583
"MODAL_USB_DISCONNECTED_STATUS" : "DETCENNOCSID", //IN FILE 590 AND 601
"MODAL_USB_RUNNING_STATUS" : "GNINNUR", //IN FILE 595
"MODAL_USB_DATA_TO" : "BSU ot ataD", //no ID yet
"MODAL_USB_DATA_TO_BUTTON" : "BSU ot dneS", //usbSend
"MODAL_USB_DATA_FROM" : "BSU morf ataD", //no ID yet
"MODAL_USB_DATA_FROM_CLEAR" : "raelC", //usbClear
"MODAL_USB_DATA_FROM_COPY" : "draobpilc ot ypoC", //usbExport AND 614 IN CODE
"MODAL_USB_DATA_FROM_COPIED" : "!deipoC", //612 IN CODE


"MODAL_BAD_BROWSER_TITLE" : "resworb detroppusnU", //no ID yet
"MODAL_BAD_BROWSER_USING" : " :gnisu eb ot raeppa uoY", //no ID yet
"MODAL_BAD_BROWSER_WEB_USB" : ".snoitcennoc BSU stroppus resworb bew ruoy taht seriuqer sihT .BSU aiv resworb bew ruoy morf yltcerid demmargorp si 3V nosidE ehT", //no ID yet
"MODAL_BAD_BROWSER_UNFORTUNATLY" : "yletanutrofnU", //no ID yet
"MODAL_BAD_BROWSER_UNSUPORTED" : ".tobor 3V nosidE ruoy margorp tonnac os ,snoitcennoc BSU troppus yltnerruc ton seod", //no ID yet
"MODAL_BAD_BROWSER_USE_CHROME" : ".emorhC elgooG gnisu dnemmocer eW", //no ID yet
"MODAL_BAD_BROWSER_GET_CHROME" : ".emorhC teG", //no ID yet

"MODAL_LOADING" : "...ecapskrow gnidaoL", //no ID yet

"MODAL_FLASHER_TITLE" : "rehsalF", //no ID yet
"MODAL_FLASHER_STEP_1" : "egami revo nosidE ecalP", //no ID yet
"MODAL_FLASHER_STEP_2" : "ecno nottub dnuor s'nosidE sserP", //no ID yet
"MODAL_FLASHER_STEP_3" : "'margorp daolnwoD' sserP", //no ID yet
"MODAL_FLASHER_RELIABLE" : "elbaileR", //no ID yet
"MODAL_FLASHER_FAST" : "tsaF", //no ID yet
"MODAL_FLASHER_ADJUST_SPEED" : ".elbailer tsom eht yllausu si deeps tsewol ehT .evoba deeps eht gnitsujda yrt ,hguone tsaf ton si ro krow ton seod daolnwod eht fI", //no ID yet
"MODAL_FLASHER_DOWNLOAD" : "margorp daolnwoD", //no ID yet
"MODAL_FLASHER_CANCEL" : "lecnaC", //no ID yet
"MODAL_FLASHER_TIPS_HEADING" : "spiT", //no ID yet
"MODAL_FLASHER_TIPS_BODY_1" : ".%09 ot %08 neewteb ssenthgirb neercs tsujdA", //divFlasherTipsBody1
"MODAL_FLASHER_TIPS_BODY_2" : " .sthgil thgirb ro thgilnus tcerid-ni dna tcerid morf yawa evoM", //divFlasherTipsBody2
"MODAL_FLASHER_TIPS_BODY_3" : ".erawmrif tsetal eht ot 3V nosidE detadpu evah uoy erusnE", //divFlasherTipsBody3
"MODAL_FLASHER_DOWNLOADING" : "gnidaolnwoD...",
"MODAL_FLASHER_COMPLETE" : "etelpmoC",
"MODAL_FLASHER_BYTES" : "ni setyb",
"MODAL_FLASHER_SECONDS" : "sdnoces",





  //Demo messages
  "DEMO_TEST_PROGRAM" : "margorp tseT",
  "DEMO_TEST_PROGRAM_DISC" : "rekaeps dna sDEL ,evird stseT",
  "DEMO_MOVE_WITH_MUSIC" : "cisum htiw evoM",
  "DEMO_MOVE_WITH_MUSIC_DISC" : "cisum gniyalp elihw evirD",
  "DEMO_FOLLOW_A_LINE" : "enil a wolloF",
  "DEMO_FOLLOW_A_LINE_DISC" : "enil kcalb a wollof ot rosnes enil eht esU",
  "DEMO_BOUNCE_IN_BORDERS" : "sredrob ni ecnuoB",
  "DEMO_BOUNCE_IN_BORDERS_DISC" : "redrob enil kcalb a edisni yats ot rosnes enil eht esU",
  "DEMO_WARNINGS" : "omed segassem gninraW",
  "DEMO_WARNINGS_DISC" : "segassem gninraw wolley dna segassem rorre der setartsnomeD",
  "DEMO_CLAP_CONTROL" : "gnivird dellortnoc palC",
  "DEMO_CLAP_CONTROL_DISC" : "sdrawrof evird ot eciwt palc ,nrut ot ecno palC",
  "DEMO_AVOID_OBSTACLES" : "selcatsbo diovA",
  "DEMO_AVOID_OBSTACLES_DISC" : "selcatsbo otni gnivird diova ot rosnes elcatsbo eht esU",
  "DEMO_FOLLOW_TORCH" : "hcrot a wolloF",
  "DEMO_FOLLOW_TORCH_DISC" : "thgil hsalf a wollof ot srosnes thgil eht esU",
  "DEMO_FOLLOW_A_LINE_IF" : "stnemetats fi gnisu enil a wolloF",
  "DEMO_FOLLOW_A_LINE_IF_DISC" : "kcolb ’fi‘ na gnisu enil a wollof ot rosnes enil eht esu ot yaw tnereffid A",

  //error messages
  "ERROR_RED_OBS_SETTING" : ".yrogetac 'gnisneS' eht morf kcolb 'maeb noitceted elcatsbo' eht gnisu no denrut si maeb noitceted elcatsbo eht sselnu krow ton od skcolb 'noitceted elcatsbO'",
"ERROR_RED_OBS_SETTING_EVENT" : ".margorp niam eht ni yrogetac 'gnisneS' eht morf kcolb 'maeb noitceted elcatsbo' eht gnisu no denrut si maeb noitceted elcatsbo eht sselnu krow ton od stneve 'noitceted elcatsbO'",
"ERROR_RED_LINE_SETTING" : ".yrogetac 'gnisneS' eht morf kcolb 'DEL gnikcart enil' eht gnisu no denrut si DEL noitceted enil eht sselnu krow ton od skcolb 'noitceted eniL'",
"ERROR_RED_LINE_SETTING_EVENT" : ".margorp niam eht ni yrogetac 'gnisneS' eht morf kcolb 'DEL gnikcart enil' eht gnisu no denrut si DEL noitceted enil eht sselnu krow ton od stneve 'noitceted eniL'",
"ERROR_RED_DRIVE_CLAP" : ".ysion oot era srotom eht esuaceb gnivird elihw spalc tceted tonnac nosidE",
"ERROR_RED_EMPTY_IN_FORWARDS" : ".tupni noitidnoc a deen skcolb 'litnu sdrawroF'",
"ERROR_RED_EMPTY_IN_BACKWARDS" : ".tupni noitidnoc a deen skcolb 'litnu sdrawkcaB'",
"ERROR_RED_EMPTY_IN_LEFT" : ".tupni noitidnoc a deen skcolb 'litnu tfeL'",
"ERROR_RED_EMPTY_IN_RIGHT" : ".tupni noitidnoc a deen skcolb 'litnu thgiR'",
"ERROR_RED_EMPTY_IN_SET_VAR" : ".elbairav a deen skcolb 'elbairav teS'",
"ERROR_RED_EMPTY_IN_INC_VAR" : ".elbairav a deen skcolb 'elbairav tnemercnI'",
"ERROR_RED_EMPTY_IN_DEC_VAR" : ".elbairav a deen skcolb 'elbairav tnemerceD'",
"ERROR_RED_EMPTY_IN_IF" : ".tupni noitidnoc a deen skcolb 'fI'",
"ERROR_RED_EMPTY_IN_IF_ELSE" : ".tupni noitidnoc a deen skcolb 'esle-fI'",
"ERROR_RED_EMPTY_IN_WAIT" : ".tupni noitidnoc a deen skcolb 'litnu tiaW'",
"ERROR_RED_EMPTY_IN_WAIT_MILLI" : ".eulav tupni na deen skcolb 'sdnocesillim tiaW'",
"ERROR_RED_EMPTY_IN_REP" : ".tupni noitidnoc a deen skcolb 'litnu taepeR'",
"ERROR_RED_EMPTY_IN_BS_RIGHT" : ".elbairav a deen skcolb 'thgir tfihs tiB'",
"ERROR_RED_EMPTY_IN_BS_LEFT" : ".elbairav a deen skcolb 'tfel tfihs tiB'",
"ERROR_RED_EMPTY_IN_OPERATOR_NOT" : ".tupni noitidnoc a deen skcolb 'toN'",
"ERROR_RED_EMPTY_IN_OPERATOR_AND" : ".tupni noitidnoc a deen skcolb 'dnA'",
"ERROR_RED_EMPTY_IN_OPERATOR_OR" : ".tupni noitidnoc a deen skcolb 'rO'",
"ERROR_RED_EMPTY_BACKGROUND_MUSIC" : ".kcolb 'eton' eno tsael ta niatnoc ot deen skcolb gnipuorg 'dnuorgkcab ni cisum yalP'",
"ERROR_RED_NO_START" : ".'wen' gnitceles dna unem eht ot gniog yb margorp wen a trats ,egassem rorre siht gniees era uoy fI .yltcerroc krow ot tneve 'trats' a evah tsum smargorP",
"ERROR_RED_NOT_BACKGROUND_MUSIC" : ".skcolb 'eton' tpecca ylno nac skcolb gnipuorg 'dnuorgkcab ni cisum yalP'",
"ERROR_RED_NO_MAIN_BLOCKS" : ".nur ot nosidE rof margorp niam on si ereht os ,tneve 'trats' eht ot detcennoc skcolb on era erehT",
"ERROR_RED_EMPTY_IN_USB_RECEIVED" : ".elbairav a deen skcolb 'atad bsu rof tiaw'",
"ERROR_RED_DEVIDE_BY_ZERO" : ".orez yb edived tonnac skcolb 'rotarepo ediveD'",
"ERROR_RED_FUNCTION_IN_FUNCTION" : "kcolb trats noitcnuf a rednu decalp eb tonnac skcolb llac noitcnuF",


"ERROR_YELLOW_RECEIVE_MESSAGE_OBS_ON" : ".egassem a eviecer ot gnitpmetta erofeb margorp eht ni ffo noitceted elcatsbo nrut ot erus ekaM .no si 'noitceted elcatsbo' elihw segassem eviecer tonnac nosidE",
"ERROR_YELLOW_RECEIVE_REMOTE_OBS_ON" : ".edoc etomer a eviecer ot gnitpmetta erofeb margorp eht ni ffo noitceted elcatsbo nrut ot erus ekaM .no si 'noitceted elcatsbo' elihw sedoc lortnoc etomer eviecer tonnac nosidE",
"ERROR_YELLOW_RECEIVE_MESSAGE_EVENT_OBS_ON" : ".egassem a eviecer ot gnitpmetta erofeb margorp niam eht ni ffo noitceted elcatsbo nrut ot erus ekaM .no si 'noitceted elcatsbo' elihw segassem eviecer tonnac nosidE",
"ERROR_YELLOW_RECEIVE_REMOTE_EVENT_OBS_ON" : ".edoc etomer a eviecer ot gnitpmetta erofeb margorp niam eht ni ffo noitceted elcatsbo nrut ot erus ekaM .no si 'noitceted elcatsbo' elihw sedoc lortnoc etomer eviecer tonnac nosidE",
"ERROR_YELLOW_READ_LIGHT_LINE_OFF" : ".ecafrus gnivird eht fo ssenevitcelfer gnirusaem fi yrogetac 'gnisneS' eht morf kcolb 'DEL gnikcart enil' eht gnisu no DEL noitceted enil eht gninrut redisnoC",
"ERROR_YELLOW_OPPERATOR_WAIT_UNTIL" : ".kcolb 'tiaw' eht piks ro reverof tiaw ot nosidE esuac yam kcolb 'litnu tiaw' a edisni kcolb 'rotarepo' nA",
"ERROR_YELLOW_OPPERATOR_REPEAT_UNTIL" : ".kcolb 'taeper' eht piks ro reverof pool ot nosidE esuac yam kcolb 'litnu taeper' a edisni kcolb 'rotarepo' nA",
"ERROR_YELLOW_OPPERATOR_WAIT" : ".kcolb 'tiaw' eht piks ot nosidE esuac yam kcolb 'tiaw' a edisni kcolb 'rotarepo' nA",
"ERROR_YELLOW_OPPERATOR_REPEAT" : ".kcolb 'taeper' eht piks ot nosidE esuac yam kcolb 'taeper' a edisni kcolb 'rotarepo' nA",
"ERROR_YELLOW_OPPERATOR_DRIVE_FOR_UNTIL" : ".kcolb evird eht piks ro reverof evird ot nosidE esuac yam kcolb 'litnu sdrawrof evird' a edisni kcolb 'rotarepo' nA",
"ERROR_YELLOW_OPPERATOR_DRIVE_BACK_UNTIL" : ".kcolb evird eht piks ro reverof evird ot nosidE esuac yam kcolb 'litnu sdrawkcab evird' a edisni kcolb 'rotarepo' nA",
"ERROR_YELLOW_OPPERATOR_DRIVE_LEFT_UNTIL" : ".kcolb evird eht piks ro reverof evird ot nosidE esuac yam kcolb 'litnu tfel evird' a edisni kcolb 'rotarepo' nA",
"ERROR_YELLOW_OPPERATOR_DRIVE_RIGHT_UNTIL" : ".kcolb evird eht piks ro reverof evird ot nosidE esuac yam kcolb 'litnu thgir evird' a edisni kcolb 'rotarepo' nA",
"ERROR_YELLOW_OPPERATOR_DRIVE_FOR_DIST" : ".kcolb evird eht piks ot nosidE esuac yam kcolb 'sdrawrof evird' a edisni kcolb 'rotarepo' nA",
"ERROR_YELLOW_OPPERATOR_DRIVE_BACK_DIST" : ".kcolb evird eht piks ot nosidE esuac yam kcolb 'sdrawkcab evird' a edisni kcolb 'rotarepo' nA",
"ERROR_YELLOW_OPPERATOR_DRIVE_LEFT_DIST" : ".kcolb evird eht piks ot nosidE esuac yam kcolb 'tfel evird' a edisni kcolb 'rotarepo' nA",
"ERROR_YELLOW_OPPERATOR_DRIVE_RIGHT_DIST" : ".kcolb evird eht piks ot nosidE esuac yam kcolb 'thgir evird' a edisni kcolb 'rotarepo' nA",
"ERROR_YELLOW_DRIVE_LIGHT" : ".kcolb evird eht piks ro reverof evird ot nosidE esuac yam kcolb 'evird' a edisni kcolb 'level thgil' nA",
"ERROR_YELLOW_OPPERATOR_IR_MESSAGE" : "552 neht regral eulav a dnes ot elba eb ton lliw kcolb 'egassem RI dnes' a edisni kcolb 'rotarepo' nA",
"ERROR_YELLOW_FOREVER_LOOP_IN" : ".nosidE no nottub erauqs eht sserp uoy litnu gnipool eunitnoc lliw pool 'reverof' A",
"ERROR_YELLOW_SET_MOTOR_LEFT" : ".noitarud s'rotom tfel eht lortnoc ot margorp eht ni desu skcolb lanoitidda era ereht erus ekaM .no rotom tfel eht nrut ylno lliw kcolb 'rotom tfel tes' ehT",
"ERROR_YELLOW_SET_MOTOR_RIGHT" : ".noitarud s'rotom thgir eht lortnoc ot margorp eht ni desu skcolb lanoitidda era ereht erus ekaM .no rotom thgir eht nrut ylno lliw kcolb 'rotom thgir tes' ehT",
"ERROR_YELLOW_SET_MOTOR_BOTH" : ".noitarud s'rotom eht lortnoc ot margorp eht ni desu skcolb lanoitidda era ereht erus ekaM .no srotom eht nrut ylno lliw kcolb 'srotom htob tes' ehT",
"ERROR_YELLOW_CLAP_EVENT_DRIVE" : ".gnivird si nosidE elihw yldetaeper reggirt ot skcolb 'tneve palc' eht esuac yam sihT .reggirt ot tneve 'palc' eht esuac yam hcihw esion setaerc srotom eht gnivirD",
"ERROR_YELLOW_FLOAT_BLOCKS" : ".nosidE otni demmargorp eb ton lliw kcolb 'noitinifed noitcnuf' ro kcolb 'tneve' wolley a ot detcennoc ton skcolB",
"ERROR_YELLOW_WAIT_TIME_LIGHT" : ".emit gnol a rof tiaw ot nosidE esuac yam hcihw eulav hgih yrev a nruter lliw level thgiL",
"ERROR_YELLOW_REPEAT_LOOP_LIGHT" : ".emit gnol a rof pool ot nosidE esuac yam hcihw eulav hgih yrev a nruter lliw level thgiL",
"ERROR_YELLOW_DRIVE_STRAIN" : ".gninnur era srotom eht elihw niarts tceted ylno lliw kcolb 'detceted niarts evird' ehT",
"ERROR_YELLOW_DRIVE_STRAIN_EVENT" : ".gninnur era srotom eht elihw reggirt ylno nac tneve 'deniarts evird' ehT",
"ERROR_YELLOW_COMMENT" : ".nosidE otni demmargorp eb ton lliw skcolb tnemmoC .sgniht fo kcart peek pleh ot seton era stnemmoC",
"ERROR_YELLOW_USB_USED" : "krow ot ecived a otni deggulp eb ot nosidE eriuqer skcolb BSU",
"ERROR_YELLOW_CLEAR_SENSOR" : ".yltcerroc krow ot margorp ruoy rof atad rosnes eht raelc ot deen yam uoY .yromem s'nosidE ni derots si atad rosnes emoS",
"ERROR_YELLOW_CLEAR_LEARN_MORE" : "eroM nraeL",


//FIX FIRMWARE

"MODAL_FIRMWARE_ERROR_TITLE" : "rorre erawmiF", //divFirmwareErrorLabel

"MODAL_FIRMWARE_ERROR_BODY_1" : ".tobor nosidE ruoy ni detceted neeb sah elif erawrmif detpurroc A", //divFirmwareErrorBody1
"MODAL_FIRMWARE_ERROR_BODY_2" : ".detpurretni saw taht etadpu erawrmif a gnirud derucco evah yam sihT", //divFirmwareErrorBody2
"MODAL_FIRMWARE_ERROR_BODY_3" : ".woleb nottub 'erawrmif xiF' eht gnikcilc yb dexitf eb nac sihT !cinap t'noD", //divFirmwareErrorBody3

"MODAL_FIRMWARE_ERROR_CANCEL_BODY_1" : "!gninraW", //divFirmwareErrorCancelBody1
"MODAL_FIRMWARE_ERROR_CANCEL_BODY_2" : ".demmargorp eb ton nac tobor nosidE ruoy taht snaem ssecorp siht gnilecnaC", //divFirmwareErrorCancelBody2
"MODAL_FIRMWARE_ERROR_CANCEL_BODY_3" : ".notrub erawrmif xiF eht gnikcilc yb won erawrmif eht xif uoy taht dednemmocer si tI", //divFirmwareErrorCancelBody3
"MODAL_FIRMWARE_ERROR_CANCEL_BODY_4" : ".emit retal a ta erawrmif eht xif nac uoy lecac ot esoohc uoy fI", //divFirmwareErrorCancelBody4

"MODAL_FIRMWARE_ERROR_BUTTON_FIX" : "erawmif xiF", //btnFixFirmware
"MODAL_FIRMWARE_ERROR_BUTTON_CANCEL" : "lecnaC", //btnFixFirmwareCancel
"MODAL_FIRMWARE_ERROR_BUTTON_CANCEL_CONFIRM" : "lancec mrifnoC", //btnFixFirmwareCancelConfirm

"HELP_TEXT_ALL_BLOCKS_EXAMPLE_USES" : ":sesu elpmaxE",
"HELP_TEXT_ALL_BLOCKS_EXAMPLE_LOAD" : "margorp nepO",
"HELP_TEXT_ALL_BLOCKS_WATCH_FOR" : " :rof tuo hctaW",

"HELP_TEXT_DRIVE_FORWARD_FOR_TITLE" : "rof sdrawrof",
"HELP_TEXT_DRIVE_FORWARD_FOR_BODY_1" : ".noitcerid drawrof eht ni tobor eht evom ot sleehw eht sevird kcolb ™€ârof sdrawrof˜€â ehT",
"HELP_TEXT_DRIVE_FORWARD_FOR_BODY_2" : ":sretemarap eerht sah kcolb ehT",
"HELP_TEXT_DRIVE_FORWARD_FOR_BODY_3" : ".kcolb rotarepo na ro gnisnes a ,elbairav a ,)yrav ton seod dna tupni eht otni depyt( tnatsnoc a eb naC “€â eulaV",
"HELP_TEXT_DRIVE_FORWARD_FOR_BODY_4" : ".sdnoces dna hcni ,mc :detceles eb nac taht snoitpo eerht era erehT “€â stinU",
"HELP_TEXT_DRIVE_FORWARD_FOR_BODY_5" : " .kcolb rotarepo na ro gnisnes a ,elbairav a ,)eulav tnatsnoc a sa( 01 ot 1 morf detceles rehtie eb nac deeps ehT “€â deepS",
"HELP_TEXT_DRIVE_FORWARD_FOR_BODY_6" : "  .kcolb ™€âot srotom htob tes˜€â eht ees siht od oT .emit emas eht ta margorp eht ni skcolb rehto nur ton lliw kcolb ™€ârof sdrawrof˜€â eht gnisu ,elpmaxe roF .nur lliw kcolb txen eht erofeb etelpmoc lliw kcolb ™€ârof sdrawrof˜€â ehT",
"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_1_TITLE" : " .niaga peeb neht ,1 deeps ta mc 51 drawrof tobor nosidE eht evird neht ,peeB :1 elpmaxE",
"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_1_BODY_1" : ".gnivird deppots sah nosidE litnu trats ton seod peeb dnoces eht ,oslA .gniyalp dehsinif sah peeb eht litnu gnivird trats ton seod tub ,speeb nosidE ,margorp elpmaxe siht nI",
"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_2_TITLE" : "rosnes a morf atad dna elbairav a gnisu ecnatsid evird eht gnitteS :2 elpmaxE",
"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_2_BODY_1" : ".thgil remmid rednu retrohs sevird dna thgil rethgirb rednu rehtruf sevird nosidE taht si tluser ehT  .5 deeps ta elbairav )ecnatsiD( eht ni eulav eht rof drawrof sevird neht nosidE ehT .05 yb dedivid )000,1 ot 1 morf eulav a( rosnes thgil tfel eht morf level thgil eht ot elbairav ™€âecnatsiD˜€â eht stes nosidE margorp elpmaxe siht nI",
"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_3_TITLE" : ".elbairav a gnisu deeps evird eht gnignahC :3 elpmaxE",
"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_3_BODY_1" : ".2 deeps ta mc5 rof drawrof sevird nosidE eht os ,2 si elbairav ™€âdeepS˜€â eht ni eulav eht kcolb sdrawrof eht fo taeper dnoces eht nI .elbairav ™€âdeepS˜€â eht )1+( stnemercni taeper eht ni kcolb txen ehT .1 deeps ta mc5 rof drawrof sevird nosidE eht os ,1 si elbairav ™€âdeepS˜€â eht ni eulav eht ,yllaitinI .elbairav eht ni deeps eht ta mc 5 drawrof sevird nosidE eht pool hcae hguorhT .semit 01 rof pool taeper a sretne neht margorp ehT .1 ot tes si ™€âdeepS˜€â elbairav eht ,margorp elpmaxe siht nI",
"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_3_BODY_2" : ".sdne margorp eht nehw gnippots litnu retsaf dna retsaf evird ot nosidE gnisuac ,pool taeper eht fo semit 01 lluf eht staeper ssecorp sihT",

"HELP_TEXT_DRIVE_BACKWARD_FOR_TITLE" : " rof sdrawkcab",
"HELP_TEXT_DRIVE_BACKWARD_FOR_BODY_1" : ".noitcerid drawkcab eht ni tobor eht evom ot sleehw eht sevird kcolb ™€ârof sdrawkcab˜€â ehT",
"HELP_TEXT_DRIVE_BACKWARD_FOR_BODY_2" : ":sretemarap eerht sah kcolb ehT",
"HELP_TEXT_DRIVE_BACKWARD_FOR_BODY_3" : ".kcolb rotarepo na ro gnisnes a ,elbairav a ,)yrav ton seod dna tupni eht otni depyt( tnatsnoc a eb naC “€â eulaV",
"HELP_TEXT_DRIVE_BACKWARD_FOR_BODY_4" : ".sdnoces dna hcni ,mc :detceles eb nac taht snoitpo eerht era erehT “€â stinU",
"HELP_TEXT_DRIVE_BACKWARD_FOR_BODY_5" : ".kcolb rotarepo na ro gnisnes a ,elbairav a ,)eulav tnatsnoc a sa( 01 ot 1 morf detceles rehtie eb nac deeps ehT “€â deepS",
"HELP_TEXT_DRIVE_BACKWARD_FOR_BODY_6" : "  .kcolb ™€âot srotom htob tes˜€â eht ees siht od oT .emit emas eht ta margorp eht ni skcolb rehto nur ton lliw kcolb ™€ârof sdrawkcab˜€â eht gnisu ,elpmaxe roF .nur lliw kcolb txen eht erofeb etelpmoc lliw kcolb ™€ârof sdrawkcab˜€â ehT",
"HELP_TEXT_DRIVE_BACKWARD_FOR_EXAMPLE_1_TITLE" : "gnivird elihw no sthgil DEL :1 elpmaxE",
"HELP_TEXT_DRIVE_BACKWARD_FOR_EXAMPLE_1_BODY_1" : "  .gnidne erofeb dnoces eno rof stiaw neht margorp ehT .gnivird deppots sah nosidE eht retfa ffo snrut DEL tfel ehT .dnoces eno rof sdrawkcab sevird nosidE eht elihw no syats dna no snrut DEL tfel eht ,margorp elpmaxe siht nI",
"HELP_TEXT_DRIVE_BACKWARD_FOR_EXAMPLE_2_TITLE" : "sdrawkcab evird elcatsbo na si ereht nehW :2 elpmaxE",
"HELP_TEXT_DRIVE_BACKWARD_FOR_EXAMPLE_2_BODY_1" : ".ti fo tnorf ni decalp stcejbo morf yawa gnikcab nosidE ni stluser sihT .pool a ni reverof staeper ruoivaheb sihT .01 deeps ta hcni eno sdrawkcab sevird nosidE eht sneppah siht nehw ,erehwyna detceted si elcatsbo na litnu gnissergorp morf margorp eht spots kcolb ™€âlitnu tiaw˜€â eht pool eht edisnI .pool reverof a sretne neht margorp ehT .no denrut tsrif si maeb noitceted elcatsbo eht ,margorp elpmaxe siht nI",


"HELP_TEXT_DRIVE_LEFT_FOR_TITLE" : "rof tfel",
"HELP_TEXT_DRIVE_LEFT_FOR_BODY_1" : " .noitcerid tfel eht ni tobor eht evom ot sleehw eht sevird kcolb ™€ârof tfel˜€â ehT",
"HELP_TEXT_DRIVE_LEFT_FOR_BODY_2" : ":sretemarap ruof sah kcolb ehT",
"HELP_TEXT_DRIVE_LEFT_FOR_BODY_3" : ".sdrawkcab nrut dna sdrawrof nrut ,nips :detceles eb nac taht snoitpo eerht era erehT “€â tnemevoM",
"HELP_TEXT_DRIVE_LEFT_FOR_BODY_4" : ".kcolb rotarepo na ro gnisnes a ,elbairav a ,)yrav ton seod dna tupni eht otni depyt( tnatsnoc a eb naC “€â eulaV",
"HELP_TEXT_DRIVE_LEFT_FOR_BODY_5" : ".sdnoces dna seerged :detceles eb nac taht snoitpo owt era erehT “€â stinU",
"HELP_TEXT_DRIVE_LEFT_FOR_BODY_6" : " .kcolb rotarepo na ro gnisnes a ,elbairav a ,)eulav tnatsnoc a sa( 01 ot 1 morf detceles rehtie eb nac deeps ehT “€â deepS",
"HELP_TEXT_DRIVE_LEFT_FOR_BODY_7" : ".dedeen si gninrut etarucca nehw tseb si 1 deepS .sdeeps hgih ta pils dna noitcart esol nac sleehw eht esuaceb si sihT .sdeeps rewol ta etarucca erom si gninnips dna gninruT",
"HELP_TEXT_DRIVE_LEFT_FOR_BODY_8" : ".kcolb ™€âot srotom htob tes˜€â eht ees siht od oT .emit emas eht ta margorp eht ni skcolb rehto nur ton lliw kcolb ™€ârof tfel˜€â eht gnisu ,elpmaxe roF .nur lliw kcolb txen eht erofeb etelpmoc tsum kcolb ™€ârof tfel˜€â ehT",
"HELP_TEXT_DRIVE_LEFT_FOR_EXAMPLE_1_TITLE" : "peeb ,nips ,peeb :1 margorp elpmaxE",
"HELP_TEXT_DRIVE_LEFT_FOR_EXAMPLE_1_BODY_1" : ".gninnips deppots sah nosidE litnu trats ton seod peeb dnoces eht ,oslA .gniyalp dehsinif sah peeb eht litnu gninnips trats ton seod tub ,speeb nosidE ,margorp elpmaxe siht nI",
"HELP_TEXT_DRIVE_LEFT_FOR_EXAMPLE_2_TITLE" : "erauqs a ni evirD :2 margorp elpmaxE",
"HELP_TEXT_DRIVE_LEFT_FOR_EXAMPLE_2_BODY_1" : ".nrettap erauqs a ni gnivird nosidE ni stluser sihT .semit ruof seerged 09 rof tfel drawrof gninrut dna 1 deeps ta mc01 rof sdrawrof gnivird staeper pool taeper eht ,margorp elpmaxe siht nI",

"HELP_TEXT_DRIVE_RIGHT_FOR_TITLE" : "rof thgir",
"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_1" : " .noitcerid tfel eht ni tobor eht evom ot sleehw eht sevird kcolb ™€ârof thgir˜€â ehT",
"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_2" : ":sretemarap ruof sah kcolb ehT",
"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_3" : ".sdrawkcab nrut dna sdrawrof nrut ,nips :detceles eb nac taht snoitpo eerht era erehT “€â tnemevoM",
"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_4" : ".kcolb rotarepo na ro gnisnes a ,elbairav a ,)yrav ton seod dna tupni eht otni depyt( tnatsnoc a eb naC “€â eulaV",
"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_5" : " .sdnoces dna seerged :detceles eb nac taht snoitpo owt era erehT “€â stinU",
"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_6" : ".kcolb rotarepo na ro gnisnes a ,elbairav a ,)eulav tnatsnoc a sa( 01 ot 1 morf detceles rehtie eb nac deeps ehT “€â deepS",
"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_7" : "    .dedeen si gninrut etarucca nehw tseb si 1 deepS .sdeeps hgih ta pils dna noitcart esol nac sleehw eht esuaceb si sihT .sdeeps rewol ta etarucca erom si gninnips dna gninruT",
"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_8" : ".kcolb ™€âot srotom htob tes˜€â eht ees siht od oT .emit emas eht ta margorp eht ni skcolb rehto nur ton lliw kcolb ™€ârof thgir˜€â eht gnisu ,elpmaxe roF .nur lliw kcolb txen eht erofeb etelpmoc tsum kcolb ™€ârof thgir˜€â ehT",
"HELP_TEXT_DRIVE_RIGHT_FOR_EXAMPLE_1_TITLE" : "peeb ,nips ,peeB :1 margorp elpmaxE",
"HELP_TEXT_DRIVE_RIGHT_FOR_EXAMPLE_1_BODY_1" : ".gninnips deppots sah nosidE litnu trats ton seod peeb dnoces eht ,oslA .gniyalp dehsinif sah peeb eht litnu gninnips trats ton seod tub ,speeb nosidE margorp elpmaxe siht nI",
"HELP_TEXT_DRIVE_RIGHT_FOR_EXAMPLE_2_TITLE" : "level thgil eht yb dellortnoc deeps eht htiw thgir nipS :2 elpmaxE",
"HELP_TEXT_DRIVE_RIGHT_FOR_EXAMPLE_2_BODY_1" : " .thgil remmid rednu rewols dna thgil rethgirb rednu retsaf snips nosidE taht si tluser ehT .)01 ot 0 tluser( 001 yb dedivid si dna )000,1 ot 1( rosnes thgil tfel eht morf gnidaer level thgil eht yb tes si deeps ehT .eerged 1 snips nosidE snur kcolb ™€ârof thgir˜€â eht emit hcaE .pool reverof a edisni thgir snips nosidE margorp elpmaxe siht nI",
"HELP_TEXT_DRIVE_RIGHT_FOR_EXAMPLE_3_TITLE" : "selcatsbo diovA :3 margorp elpmaxE",
"HELP_TEXT_DRIVE_RIGHT_FOR_EXAMPLE_3_BODY_1" : ".htap sti ni selcatsbo morf yawa gnivird nosidE ni stluser sihT .1 deeps ta seerged 081 rof thgir snips tobor nosidE eht dna kcolb txen eht ot sessergorp margorp eht ,sneppah siht nehW .erehwyna detceted si elcatsbo na litnu stiaw neht margorp ehT .sdrawrof evird ot tes era srotom htob erehw pool reverof a sretne neht margorp ehT .no denrut si maeb noitceted elcatsbo eht ,margorp elpmaxe siht nI",

"HELP_TEXT_DRIVE_FORWARD_UNTIL_TITLE" : "litnu sdrawrof",
"HELP_TEXT_DRIVE_FORWARD_UNTIL_BODY_1" : ".kcolb txen eht ot sessergorp margorp eht dna pots sleehw eht eurt si noitidnoc deificeps eht ecnO .eurt si noitidnoc deificeps eht litnu noitcerid sdrawrof eht ni tobor eht evom ot sleehw eht sevird kcolb ™€âlitnu sdrawrof˜€â ehT",
"HELP_TEXT_DRIVE_FORWARD_UNTIL_BODY_2" : ":sretemarap owt sah kcolb ehT",
"HELP_TEXT_DRIVE_FORWARD_UNTIL_BODY_3" : " .kcolb rotarepo ro gnisnes a rehtie eb nac taht kcolb depahs dnomaid a stpecca tupni lanoitidnoc ehT “€â tupni lanoitidnoC",
"HELP_TEXT_DRIVE_FORWARD_UNTIL_BODY_4" : " .kcolb rotarepo na ro gnisnes a ,elbairav a )eulav tnatsnoc a sa( 01 ot 1 morf detceles rehtie eb nac deeps ehT “€â deepS",
"HELP_TEXT_DRIVE_FORWARD_UNTIL_BODY_5" : ".kcolb ™€âot srotom htob tes˜€â eht ees siht od oT .emit emas eht ta margorp eht ni skcolb rehto nur ton lliw kcolb ™€âlitnu sdrawrof˜€â eht gnisu ,elpmaxe roF .nur lliw kcolb txen eht erofeb etelpmoc tsum kcolb ™€âlitnu sdrawrof˜€â ehT",
"HELP_TEXT_DRIVE_FORWARD_UNTIL_EXAMPLE_1_TITLE" : "elcatsbo na rof potS :1 margorp elpmaxE",
"HELP_TEXT_DRIVE_FORWARD_UNTIL_EXAMPLE_1_BODY_1" : "  .sdne margorp eht dna gnivom spots tobor eht ,sneppah siht nehW .detceted si elcatsbo na litnu 5 deeps ta drawrof sevird tobor eht neht ,no denrut si maeb noitceted elcatsbo eht ,margorp elpmaxe siht nI",
"HELP_TEXT_DRIVE_FORWARD_UNTIL_EXAMPLE_2_TITLE" : "sredrob ni ecnuoB :2 margorp elpmaxE",
"HELP_TEXT_DRIVE_FORWARD_UNTIL_EXAMPLE_2_BODY_1" : ".senil kcalb detceted morf yawa gnivird nosidE ni stluser sihT  .kcolb litnu sdrawrof eht ot kcab spool neht margorp ehT .5 deeps ta seerged 081 rof tfel tobor eht snips hcihw snur kcolb txen eht ,sneppah siht nehW .)kcalb .e.i( ecafrus evitcelfer-non a no si rekcart enil eht litnu 1 deeps ta drawrof tobor eht sevird kcolb litnu sdrawrof eht pool eht edisnI .pool reverof a sretne margorp eht neht ,no denrut si DEL rekcart enil eht ,margorp elpmaxe siht nI",

"HELP_TEXT_DRIVE_BACKWARD_UNTIL_TITLE" : "litnu sdrawkcab",
"HELP_TEXT_DRIVE_BACKWARD_UNTIL_BODY_1" : ".kcolb txen eht ot sessergorp margorp eht dna pots sleehw eht eurt si noitidnoc deificeps eht ecnO .eurt si noitidnoc deificeps eht litnu noitcerid sdrawkcab eht ni tobor eht evom ot sleehw eht sevird kcolb ™€âlitnu sdrawkcab˜€â ehT",
"HELP_TEXT_DRIVE_BACKWARD_UNTIL_BODY_2" : ":sretemarap owt sah kcolb ehT",
"HELP_TEXT_DRIVE_BACKWARD_UNTIL_BODY_3" : " .kcolb rotarepo ro gnisnes a rehtie eb nac taht kcolb depahs dnomaid a stpecca tupni lanoitidnoc ehT “€â tupni lanoitidnoC",
"HELP_TEXT_DRIVE_BACKWARD_UNTIL_BODY_4" : ".kcolb rotarepo na ro gnisnes a ,elbairav a ,)eulav tnatsnoc a sa( 01 ot 1 morf detceles rehtie eb nac deeps ehT “€â deepS",
"HELP_TEXT_DRIVE_BACKWARD_UNTIL_BODY_5" : ".kcolb ™€âot srotom htob tes˜€â eht ees siht od oT .emit emas eht ta margorp eht ni skcolb rehto nur ton lliw kcolb ™€âlitnu sdrawkcab˜€â eht gnisu ,elpmaxe roF .nur lliw kcolb txen eht erofeb etelpmoc tsum kcolb ™€âlitnu sdrawkcab˜€â ehT",
"HELP_TEXT_DRIVE_BACKWARD_UNTIL_EXAMPLE_1_TITLE" : "deniarts si evird nehw potS :1 margorp elpmaxE",
"HELP_TEXT_DRIVE_BACKWARD_UNTIL_EXAMPLE_1_BODY_1" : ".sdne margorp eht dna pots srotom eht ,sneppah siht nehW .)kcuts emoceb ro etator ot elbanu era( deniarts era sleehw eht litnu 01 deeps ta sdrawkcab sevird tobor eht ,margorp elpmaxe siht nI",
"HELP_TEXT_DRIVE_BACKWARD_UNTIL_EXAMPLE_2_TITLE" : "snottub htiw lortnoc evirD :2 margorp elpmaxE",
"HELP_TEXT_DRIVE_BACKWARD_UNTIL_EXAMPLE_2_BODY_1" : " .desserp eb ot nottub elgnairt eht rof gnitiaw ot kcab spool margorp eht dna pots sleehw s™€âtobor eht deneppah siht nehW .desserp si nottub dnuor eht litnu 1 deeps ta sdrawkcab sevird tobor eht ,sneppah siht nehW .dehsup si nottub elgnairt eht litnu stiaw pool eht ni kcolb tsrif ehT .pool reverof a htiw strats margorp eht ,elpmaxe siht nI",

"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_TITLE" : " litnu tfel",
"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_BODY_1" : " .kcolb txen eht ot sessergorp margorp eht dna pots sleehw eht eurt si noitidnoc deificeps eht ecnO .eurt si noitidnoc deificeps eht litnu noitcerid tfel eht ni tobor eht evom ot sleehw eht sevird kcolb ™€âlitnu tfel˜€â ehT",
"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_BODY_2" : " :sretemarap eerht sah kcolb ehT",
"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_BODY_3" : " .sdrawkcab nrut dna sdrawrof nrut ,nips :detceles eb nac taht snoitpo eerht era erehT “€â tnemevoM",
"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_BODY_4" : "  .kcolb rotarepo ro gnisnes a rehtie eb nac taht kcolb depahs dnomaid a stpecca tupni lanoitidnoc ehT “€â tupni lanoitidnoC",
"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_BODY_5" : " .kcolb rotarepo na ro gnisnes a ,elbairav a ,)eulav tnatsnoc a sa( 01 ot 1 morf detceles rehtie eb nac deeps ehT “€â deepS",
"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_BODY_6" : " .kcolb ™€âot srotom htob tes˜€â eht ees siht od oT .emit emas eht ta margorp eht ni skcolb rehto nur ton lliw kcolb ™€âlitnu tfel nips˜€â eht gnisu ,elpmaxe roF .nur lliw kcolb txen eht erofeb etelpmoc tsum kcolb ™€âlitnu tfel nips˜€â ehT",
"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_EXAMPLE_1_TITLE" : " deniarts si evird nehw potS :1 margorp elpmaxE",
"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_EXAMPLE_1_BODY_1" : " .sdne margorp eht dna spots rotom eht ,sneppah siht nehW .)kcuts semoceb ro etator ot elbanu( deniarts semoceb leehw eht litnu 1 deeps ta )gnivom leehw thgir( tfel drawrof sevird tobor eht ,margorp elpmaxe siht nI",
"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_EXAMPLE_2_TITLE" : " thgil wolloF :2 margorp elpmaxE",
"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_EXAMPLE_2_BODY_1" : "   .thgil sdrawot sevird tobor nosidE eht taht si siht fo tluser ehT .level thgil thgir eht naht retaerg si level thgil tfel eht litnu 5 deeps ta thgir tobor eht snrut kcolb txen ehT .snur kcolb txen eht dna spots rotom eht sneppah siht nehW .level thgil thgir eht naht ssel si level thgil tfel eht litnu 5 deeps ta tfel tobor eht snrut pool eht ni kcolb tsrif ehT .pool reverof a htiw strats margorp eht ,elpmaxe siht nI",

"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_TITLE" : " litnu thgir",
"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_BODY_1" : " .kcolb txen eht ot sessergorp margorp eht dna pots sleehw eht eurt si noitidnoc deificeps eht ecnO .eurt si noitidnoc deificeps eht litnu noitcerid thgir eht ni tobor eht evom ot sleehw eht sevird kcolb ™€âlitnu thgir˜€â ehT",
"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_BODY_2" : " :sretemarap eerht sah kcolb ehT",
"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_BODY_3" : " .sdrawkcab nrut dna sdrawrof nrut ,nips :detceles eb nac taht snoitpo eerht era erehT “€â tnemevoM",
"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_BODY_4" : "  .kcolb rotarepo ro gnisnes a rehtie eb nac taht kcolb depahs dnomaid a stpecca tupni lanoitidnoc ehT “€â tupni lanoitidnoC",
"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_BODY_5" : " .kcolb rotarepo na ro gnisnes a ,elbairav a ,)eulav tnatsnoc a sa( 01 ot 1 morf detceles rehtie eb nac deeps ehT “€â deepS",
"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_BODY_6" : " .kcolb ™€âot srotom htob tes˜€â eht ees siht od oT .emit emas eht ta margorp eht ni skcolb rehto nur ton lliw kcolb ™€âlitnu thgir nips˜€â eht gnisu ,elpmaxe roF .nur lliw kcolb txen eht erofeb etelpmoc tsum kcolb ™€âlitnu thgir˜€â ehT",
"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_EXAMPLE_1_TITLE" : " ecafrus kcalb no potS :1 margorp elpmaxE",
"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_EXAMPLE_1_BODY_1" : " .sdne margorp eht dna spots rotom taht sneppah siht nehW .)kcalb( ecafrus evitcelfer-non a stceted rekcart enil eht litnu 5 deeps ta thgir snips tobor eht margorp ,elpmaxe siht nI",
"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_EXAMPLE_2_TITLE" : "thgil wolloF :2 margorp elpmaxE",
"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_EXAMPLE_2_BODY_1" : " .thgil sdrawot sevird tobor nosidE eht taht si siht fo tluser ehT .level thgil thgir eht naht retaerg si level thgil tfel eht litnu 5 deeps ta thgir tobor eht snrut kcolb txen ehT .snur kcolb txen eht dna spots rotom eht sneppah siht nehW .level thgil thgir eht naht ssel si level thgil tfel eht litnu 5 deeps ta tfel tobor eht snrut pool eht ni kcolb tsrif ehT .pool reverof a htiw strats margorp eht ,elpmaxe siht nI",

"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_TITLE" : " ot srotom htob teS",
"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_BODY_1" : "  .kcolb txen eht ot seunitnoc margorp eht erofeb etelpmoc ot elgna ro emit ,ecnatsid a evah taht skcolb evird eht ot tnereffid si sihT .kcolb txen eht ot thgiarts eunitnoc nac margorp eht ,srotom eht stes kcolb evird siht sA .deeps dna noitcerid detceles eht ni tobor eht evom ot sleehw eht sevird kcolb ™€âot srotom htob tes˜€â ehT",
"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_BODY_2" : " :sretemarap owt sah kcolb ehT",
"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_BODY_3" : " .thgir tobor nrut dna tfel tobor nrut ,thgir tobor nips ,tfel tobor nips ,sdrawkcab evird ,sdrawrof evird :detceles eb nac taht snoitpo xis era erehT “€â tnemevoM",
"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_BODY_4" : " .kcolb rotarepo na ro gnisnes a ,elbairav a ,)eulav tnatsnoc a sa( 01 ot 1 morf detceles rehtie eb nac deeps ehT “€â deepS",
"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_EXAMPLE_1_TITLE" : " gnivird elihw cisuM :1 margorp elpmaxE",
"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_EXAMPLE_1_BODY" : " .gnivird spots tobor nosidE eht dna sdne margorp eht gniyalp sehsinif eton tsal eht retfA .gnivird llits si tobor eht elihw deyalp era seton eerht neht ,drawrof evird ot tes si tobor nosidE eht margorp elpmaxe siht nI",
"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_EXAMPLE_2_TITLE" : "  elcatsbo na litnu evirD :2 margorp elpmaxE",
"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_EXAMPLE_2_BODY" : "  .gnivird spots tobor eht dna sdne margorp eht ,sneppah siht nehW .detceted si elcatsbo yna litnu stiaw kcolb txen ehT .8 deeps ta sdrawrof evird ot tes era srotom htob neht ,no denrut si maeb noitceted elcatsbo eht margorp elpmaxe siht nI",
"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_EXAMPLE_3_TITLE" : " enil a wolloF :3 margorp elpmaxE",
"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_EXAMPLE_3_BODY" : " .enil evitcelfer-non a gniwollof nosidE ni stluser sihT .staeper dna pool reverof eht fo trats eht ot kcab spool margorp eht sneppah taht nehW .)kcalb( ecafrus evitcelfer-non a stceted rekcart enil eht litnu ereht margorp eht dloh kcolb ™€âlitnu tiaw˜€â eht dna 1 deeps ta thgir tobor nrut ot tes neht era srotom htob ,sneppah taht nehW .)etihw( ecafrus evitcelfer a stceted rekcart enil eht litnu ereht margorp eht sdloh kcolb ™€âlitnu tiaw˜€â eht neht ,1 deeps ta tfel tobor nrut ot tes era srotom htob pool eht edisnI .pool reverof a sretne margorp eht dna no denrut si DEL rekcart enil eht ,margorp elpmaxe siht nI",

"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_TITLE" : " ot rotom thgir tes",
"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_BODY_1" : "  .kcolb txen eht ot sevom margorp eht erofeb etelpmoc ot elgna ro emit ,ecnatsid a evah taht skcolb evird eht ot tnereffid si sihT .kcolb txen eht ot thgiarts eunitnoc nac margorp eht srotom eht stes kcolb evird siht sA .deeps dna noitcerid detceles eht ni tobor eht evom ot sleehw eht sevird kcolb ™€âot rotom thgir tes˜€â ehT",
"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_BODY_2" : " :sretemarap owt sah kcolb ehT",
"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_BODY_3" : " .sdrawkcab dna sdrawrof :detceles eb nac taht snoitpo owt era erehT “€â tnemevoM",
"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_BODY_4" : " .kcolb rotarepo na ro gnisnes a ,elbairav a ,)eulav tnatsnoc a sa( 01 ot 1 morf detceles rehtie eb nac deeps ehT “€â deepS",
"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_EXAMPLE_1_TITLE" : " sserp nottub a htiw ffo dna no rotoM :1 margorp elpmaxE",
"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_EXAMPLE_1_BODY" : "  .pool reverof eht fo trats eht ot kcab spool margorp eht dna deppots si rotom thgir eht ,sneppah siht nehW .kcolb desserp nottub dnuor litnu tiaw rehtona ot sessergorp neht margorp eht ,5 deeps ta sdrawrof ot tes si rotom thgir eht ,sneppah siht nehW .desserp si nottub dnuor eht litnu stiaw pool eht ni kcolb tsrif ehT .pool reverof a sretne margorp eht ,elpmaxe siht nI",

"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_TITLE" : " ot rotom tfel tes",
"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_BODY_1" : "  .kcolb txen eht ot sevom margorp eht erofeb etelpmoc ot elgna ro emit ,ecnatsid a evah taht skcolb evird eht ot tnereffid si sihT .kcolb txen eht ot thgiarts eunitnoc nac margorp eht srotom eht stes kcolb evird siht sA .deeps dna noitcerid detceles eht ni tobor eht evom ot sleehw eht sevird kcolb ™€âot rotom tfel tes˜€â ehT",
"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_BODY_2" : " :sretemarap owt sah kcolb ehT",
"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_BODY_3" : " .sdrawkcab dna sdrawrof :detceles eb nac taht snoitpo owt era erehT “€â tnemevoM",
"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_BODY_4" : " .kcolb rotarepo na ro gnisnes a ,elbairav a ,)eulav tnatsnoc a sa( 01 ot 1 morf detceles rehtie eb nac deeps ehT “€â deepS",
"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_EXAMPLE_1_TITLE" : " gniwollof thgiL :1 margorp elpmaxE",
"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_EXAMPLE_1_BODY" : "  .thgil tsethgirb eht sdrawot evird dna ecaf ot gniyrt syawla tobor nosidE eht ni stluser sihT .tsetsaf eht sevird thgil fo tnuoma tsael eht sah taht edis eht taht os deeps eht lortnoc stluser detaluclac ehT .pool reverof eht fo trats eht ot kcab spool neht margorp ehT .deeps muminim a tes ot tluser eht ot dedda osla si 3 ,001 yb dedivid rosnes thgir eht morf level thgil eht sunim rosnes tfel eht morf level thgil eht si deeps detaluclac ehT .deeps detaluclac a ta sdrawrof ot rotom thgir eht stes kcolb txen ehT .deeps muminim a tes ot tluser eht ot dedda osla si 3 ,001 yb dedivid rosnes tfel eht morf level thgil eht sunim rosnes thgir eht morf level thgil eht si deeps detaluclac ehT .deeps detaluclac a ta sdrawrof rotom tfel eht stes pool eht ni kcolb tsrif ehT .pool reverof a sretne margorp eht ,elpmaxe siht nI",


"HELP_TEXT_DRIVE_STOP_TITLE" : " pots",
"HELP_TEXT_DRIVE_STOP_BODY_1" : "  .sleehw eht gnivird morf srotom eht spots kcolb ™€âpots˜€â ehT",
"HELP_TEXT_DRIVE_STOP_BODY_2" : " .rotom thgir dna rotom tfel ,srotom htob era snoitpo ehT .deppots era s/rotom hcihw gnitceles rof retemarap eno ylno sah kcolb ™€âpots˜€â ehT",
"HELP_TEXT_DRIVE_STOP_EXAMPLE_1_TITLE" : " sserp nottub a htiw ffo dna no rotoM :1 margorp elpmaxE",
"HELP_TEXT_DRIVE_STOP_EXAMPLE_1_BODY" : " .pool reverof eht fo trats eht ot kcab spool margorp eht dna deppots si rotom thgir eht ,sneppah siht nehW .kcolb desserp nottub dnuor litnu tiaw rehtona ot sessergorp neht margorp eht ,5 deeps ta sdrawrof ot tes si rotom thgir eht ,sneppah siht nehW .desserp si nottub dnuor eht litnu stiaw pool eht ni kcolb tsrif ehT .pool reverof a sretne margorp eht ,elpmaxe siht nI",

"HELP_TEXT_LEDS_LEFT_TITLE" : "  DEL tfel nrut",
"HELP_TEXT_LEDS_LEFT_BODY_1" : "  .ffo ro no snoitpo owt era erehT .DEL tfel eht slortnoc kcolb ™€âDEL tfel nrut˜€â ehT",
"HELP_TEXT_LEDS_LEFT_EXAMPLE_1_TITLE" : " ecno DEL tfel knilB :1 margorp elpmaxE ",
"HELP_TEXT_LEDS_LEFT_EXAMPLE_1_BODY" : " .ffo DEL tfel eht snrut neht ,dnoces eno rof stiaw neht ,no DEL tfel eht gninrut yb snigeb margorp eht elpmaxe siht nI",
"HELP_TEXT_LEDS_LEFT_EXAMPLE_2_TITLE" : " reverof DEL tfel knilB :2 margorp elpmaxE",
"HELP_TEXT_LEDS_LEFT_EXAMPLE_2_BODY" : " .reverof staeper dna pool eht fo gninnigeb eht ot spmuj margorp eht neht ,dnoces eno rof stiaw margorp eht neht ,ffo denrut si DEL tfel eht neht ,dnoces eno rof stiaw margorp eht neht ,no denrut si DEL tfel eht pool eht edisnI .pool reverof a gniretne yb snigeb margorp eht ,elpmaxe siht nI",

"HELP_TEXT_LEDS_RIGHT_TITLE" : " DEL thgir nrut",
"HELP_TEXT_LEDS_RIGHT_BODY_1" : "  .ffo ro no snoitpo owt era erehT .DEL thgir eht slortnoc kcolb ™€âDEL thgir nrut˜€â ehT",
"HELP_TEXT_LEDS_RIGHT_EXAMPLE_1_TITLE" : " ecno DEL thgir knilB :1 margorp elpmaxE",
"HELP_TEXT_LEDS_RIGHT_EXAMPLE_1_BODY" : " .ffo DEL thgir eht snrut neht ,dnoces eno rof stiaw neht ,no DEL thgir eht gninrut yb snigeb margorp eht ,elpmaxe siht nI",
"HELP_TEXT_LEDS_RIGHT_EXAMPLE_2_TITLE" : " reverof DEL thgir knilB :2 margorp elpmaxE",
"HELP_TEXT_LEDS_RIGHT_EXAMPLE_2_BODY" : " .reverof staeper dna pool eht fo gninnigeb eht ot spmuj margorp eht neht ,dnoces eno rof stiaw margorp eht neht ,ffo denrut si DEL thgir eht neht ,dnoces eno rof stiaw margorp eht neht ,no denrut si DEL thgir eht pool eht edisnI .pool reverof a gniretne yb snigeb margorp eht ,elpmaxe siht nI",

"HELP_TEXT_LEDS_SEND_MESSAGE_TITLE" : " egassem RI dnes",
"HELP_TEXT_LEDS_SEND_MESSAGE_BODY_1" : " .kcolb rotarepo na ro gnisnes a ,elbairav a ,)yrav ton seod dna tupni eht otni depyt( tnatsnoc a eb nac eulav ehT .552 ot 0 morf eulav a si tnes eb nac taht atad ehT .thgil )RI( derarfni aiv atad sdnes kcolb ™€âegassem RI dnes˜€â ehT",
"HELP_TEXT_LEDS_SEND_MESSAGE_BODY_2" : " .)ffo ecnuob ot thgil RI eht rof sllaw dna gniliec etihw ,thgilnus tcerid on ,sroodni .e.i( snoitidnoc laedi rednu teef 03/retem 01 ot pu eb nac egnar mumixam ehT .langis thgil RI eht fo egnar ni si taht tobor nosidE rehto yna yb deviecer eb nac atad tnes ehT",
"HELP_TEXT_LEDS_SEND_MESSAGE_BODY_3" : " .)...2 sdnes 852 ,1 sdnes 752 ,0 sdnes 652 .e.i( ™€âdnuora parw˜€â lliw RI aiv tnes rebmun eht ,sneppah siht nehW .)stib-8( timil 552 eht deecxe dluoc elbairav eht ni rebmun eht ,elbairav a esu uoy fI",
"HELP_TEXT_LEDS_SEND_MESSAGE_EXAMPLE_1_TITLE" : " desserp nottub dnuor nehw 1 egassem RI dneS :1 margorp elpmaxE",
"HELP_TEXT_LEDS_SEND_MESSAGE_EXAMPLE_1_BODY" : " .pool reverof eht fo gninnigeb eht ot kcab spool neht margorp ehT .tnes si 1 egassem RI eht ,sneppah siht nehW .desserp eb ot nottub dnuor eht rof stiaw margorp eht pool eht edisnI .pool reverof a gniretne yb snigeb margorp eht ,elpmaxe siht nI",
"HELP_TEXT_LEDS_SEND_MESSAGE_EXAMPLE_2_TITLE" : " dnoces eno yreve level thgil dneS :2 margorp elpmaxE",
"HELP_TEXT_LEDS_SEND_MESSAGE_EXAMPLE_2_BODY" : " .pool reverof eht fo trats eht ot kcab spool neht dna dnoces eno rof stiaw neht margorp ehT .tnes eb ot rosnes thgil eht fo egnar lluf eht swolla noitaluclac lanoitidda sihT .)052 = 4/000,1( 552 si RI htiw tnes eb nac taht rebmun tsehgih eht tub ,000,1 ot 1 si rosnes thgil eht morf tuptuo eht sa ruof yb dedivid si eulav ehT .ruof yb dedivid rosnes thgil tfel eht morf gnidaer level thgil eht sdnes margorp eht pool eht edisnI .pool reverof a gniretne yb snigeb margorp eht ,elpmaxe siht nI",

"HELP_TEXT_SOUND_BEEP_TITLE" : "peeb",
"HELP_TEXT_SOUND_BEEP_BODY_1" : " .)sdnoces 521.0( Sm521 rof dnuos peeb zHk5.3 a syalp kcolb ™€âpeeb˜€â ehT ",
"HELP_TEXT_SOUND_BEEP_EXAMPLE_1_TITLE" : "desserp si nottub dnuor nehw peeB :1 margorp elpmaxE",
"HELP_TEXT_SOUND_BEEP_EXAMPLE_1_BODY" : " .staeper dna pool reverof eht fo trats eht ot kcab spool neht margorp ehT .deyalp si peeb eht ,sneppah siht nehW .desserp eb ot nottub dnuor eht rof stiaw margorp eht pool eht edisnI .pool reverof a gniretne yb snigeb margorp eht ,elpmaxe siht nI",

"HELP_TEXT_SOUND_PLAY_NOTE_TITLE" : "eton a yalp",
"HELP_TEXT_SOUND_PLAY_NOTE_BODY_1" : ".detceles eb ot eton fo epyt dna eton ,htgnel eht wolla sretemarap kcolb ehT .eton lacisum a syalp kcolb ™€âeton a yalp˜€â ehT",
"HELP_TEXT_SOUND_PLAY_NOTE_BODY_2" : ":sretemarap eerht sah kcolb ehT",
"HELP_TEXT_SOUND_PLAY_NOTE_BODY_3" : " .hthgie dna retrauq ,flah ,elohw :snoitpo ruof era erehT “€â htgneL",
"HELP_TEXT_SOUND_PLAY_NOTE_BODY_4" : ".tser dna B wol ,C elddim ,D ,E ,F ,G ,A ,B ,C :snoitpo net era erehT “€â etoN",
"HELP_TEXT_SOUND_PLAY_NOTE_BODY_5" : " .talf dna prahs ,)deifidom ton( - :snoitpo eerht era erehT “€â reifidom etoN",
"HELP_TEXT_SOUND_PLAY_NOTE_BODY_6" : ".kcolb ™€âdnuorgkcab ni cisum yalp˜€â eht ees siht od oT .emit emas eht ta margorp eht ni skcolb rehto nur ton lliw kcolb ™€âeton a yalp˜€â eht gnisu ,elpmaxe roF .nur lliw kcolb txen eht erofeb etelpmoc tsum kcolb ™€âeton a yalp˜€â ehT",
"HELP_TEXT_SOUND_PLAY_NOTE_EXAMPLE_1_TITLE" : "bmal elttil a dah yraM :1 margorp elpmaxE",
"HELP_TEXT_SOUND_PLAY_NOTE_EXAMPLE_1_BODY" : ".no gnivom erofeb ylluf eton hcae gniyalp ,redro ni bmal elttil a dah yraM emyhr yresrun eht rof seton eht syalp neht ,seton cisum eht rof opmet eht gnittes yb snigeb margorp eht ,elpmaxe siht nI",

"HELP_TEXT_SOUND_SET_TEMPO_TITLE" : "ot opmet cisum tes",
"HELP_TEXT_SOUND_SET_TEMPO_BODY_1" : " .ta deyalp era wollof taht opmet eht stes kcolb ™€âot pmet cisum tes˜€â ehT",
"HELP_TEXT_SOUND_SET_TEMPO_BODY_2" : ".tsaf yrev dna tsaf ,muidem ,wols ,wols yrev :snoitpo evif era erehT",
"HELP_TEXT_SOUND_SET_TEMPO_EXAMPLE_1_TITLE" : "bmal elttil a dah yraM :1 margorp elpmaxE",
"HELP_TEXT_SOUND_SET_TEMPO_EXAMPLE_1_BODY" : ".no gnivom erofeb ylluf eton hcae gniyalp ,deeps taht ta bmal elttil a dah yraM emyhr yresrun eht rof seton eht syalp neht ,seton cisum eht rof opmet eht gnittes yb snigeb margorp eht ,elpmaxe siht nI",

"HELP_TEXT_SOUND_PLAYINBACKGROUND_TITLE" : "dnuorgkcab ni cisum yalP",
"HELP_TEXT_SOUND_PLAYINBACKGROUND_BODY_1" : " .margorp eht fo strap rehto gninnur si tobor nosidE eht elihw yalp ot kcolb eht edisni decalp seton lacisum swolla kcolb ™€âdnuorgkcab ni cisum yalp˜€â ehT",
"HELP_TEXT_SOUND_PLAYINBACKGROUND_EXAMPLE_1_TITLE" : "gnicnad elihw bmal elttil a dah yrraM :1 margorp elpmaxE",
"HELP_TEXT_SOUND_PLAYINBACKGROUND_EXAMPLE_1_BODY" : ".cisum gniyalp elihw gnicnad nosidE ni stluser sihT .dnuorgkcab eht ni gniyalp llits enut eht htiw semit ruof nur skcolb thgir nips dna tfel nips eht dna pool taeper eht sretne margorp eht ,yalp ot trats kcolb ™€âdnuorgkcab ni cisum yalp˜€â eht edisni seton eht neht ,seton cisum eht rof opmet eht gnittes yb snigeb margorp eht ,margorp elpmaxe siht nI",

"HELP_TEXT_VARIABLE_TITLE" : "elbairaV",
"HELP_TEXT_VARIABLE_BODY_1" : " .elbairav a dellac si ti yhw si sihT .gninnur si margorp eht elihw egnahc dna yrav nac elbairav a ni atad ehT .margorp a yb desu dna derots eb nac atad erehw ecalp a si kcolb elbairav A",
"HELP_TEXT_VARIABLE_BODY_2" : ".)tib-23 dengis( 328,147,370,1 ot 428,147,370,1- morf egnar nac taht rebmun a si elbairav a ni atad ehT",
"HELP_TEXT_VARIABLE_BODY_3" : " :elpmaxe roF .margorp eht ot esnes sekam taht gnihtemos meht gniman yb desimotsuc eb dluohs selbairaV",
"HELP_TEXT_VARIABLE_BODY_4" : " .enot eruliaf a yalp lliw nosidE dna tlah lliw margorp eht neht ,328,147,370,1 ot 428,147,370,1- fo egnar eht sdeecxe elbairav a ni rebmun eht fI",
"HELP_TEXT_VARIABLE_EXAMPLE_1_TITLE" : "trats margorp eht ta tes etar hsalf modnar A :1 margorp elpmaxE",
"HELP_TEXT_VARIABLE_EXAMPLE_1_BODY_1" : "nur si margorp eht emit hcae sdeeps tnereffid ta sDEL sti gnihsalf nosidE ni stluser sihT .staeper dna pool reverof eht fo trats eht ot kcab spool neht margorp ehT .™€âetaRhsalF˜€â ni eulav dnocesillim eht rof stiaw niaga margorp eht neht ,sDEL thgir dna tfel eht ffo snrut neht ,™€âetaRhsalF˜€â ni eulav dnocesillim eht rof stiaw margorp eht neht ,no denrut era sDEL thgir dna tfel eht pool eht edisnI .pool reverof a sretne neht margorp ehT .001 dna 01 neewteb rebmun modnar a ot tes si ™€âetaRhsalF˜€â elbairav eht ,margorp elpmaxe siht nI",
"HELP_TEXT_VARIABLE_EXAMPLE_2_TITLE" : "revo nevird senil kcalb tnuoC :2 margorp elpmaxE",
"HELP_TEXT_VARIABLE_EXAMPLE_2_BODY_1" : " .™€âtnuoCeniL˜€â elbairav eht ni semit fo rebmun eht rof skcolb ™€âpeeb˜€â dna dnoces 1 rof tiaw eht staeper margorp eht detelpmoc sah mc 03 rof gnivird nehW .)1+( detnemercni si ™€âtnuoCeniL˜€â elbairav eht ,sneppah siht nehW .™€âecafrus evitcelfer-non no rekcart eniL˜€â kcolb tneve eht ot pmuj ot margorp eht reggirt lliw rekcart enil eht yb secafrus )kcalb( evitcelfer-non detceted yna drawrof gnivird elihW .5 deeps ta mc03 rof sdrawrof sevird tobor nosidE eht neht ,no denrut tsrif si DEL rekcart enil eht ,margorp elpmaxe siht nI",
"HELP_TEXT_VARIABLE_EXAMPLE_3_TITLE" : "retnuoc noitaidar thgiL :3 margorp elpmaxE",
"HELP_TEXT_VARIABLE_EXAMPLE_3_BODY_1" : " .rethgirb si level thgil eht nehw retsaf dna ssenkrad ni nehw wols peeb lliw nosidE taht si margorp siht fo tluser ehT .staeper dna pool reverof eht fo trats eht ot kcab spool dna C eton eht syalp neht margorp ehT .elbairav ™€âyaleD˜€â eht ni eulav eht rof stiaw kcolb txen ehT .)gnidaer level thgil eht gnitrevni( level thgil tfel eht sunim 0001 ot ™€âyaleD˜€â elbairav eht stes margorp eht pool eht edisnI .pool reverof a sretne neht margorp ehT .tsaf yrev ot tes tsrif si opmet cisum eht ,margorp elpmaxe siht nI",

"HELP_TEXT_DATA_SETVARIABLETO_TITLE" : "ot tes",
"HELP_TEXT_DATA_SETVARIABLETO_BODY_1" : " .elbairav a ni eulav a tes ot desu si kcolb ™€âot tes˜€â ehT",
"HELP_TEXT_DATA_SETVARIABLETO_BODY_2" : ":stupni owt era erehT",
"HELP_TEXT_DATA_SETVARIABLETO_BODY_3" : ".decalp si kcolb elbairav eht erehw si sihT “€â elbairaV",
"HELP_TEXT_DATA_SETVARIABLETO_BODY_4" : ".kcolb rotarepo na ro gnisnes a ,elbairav a ,)yrav ton seod dna tupni eht otni depyt( tnatsnoc a eb naC “€â eulaV",
"HELP_TEXT_DATA_SETVARIABLETO_EXAMPLE_1_TITLE" : "speeb fo rebmun eht teS :1 margorp elpmaxE",
"HELP_TEXT_DATA_SETVARIABLETO_EXAMPLE_1_BODY_1" : ".™€âspeeBfOrebmuN˜€â elbairav eht ni dleh 5 eulav eht rof gnipeeb eht staeper kcolb taeper eht neht ,5 ot tes si ™€âspeeBfOrebmuN˜€â elbairav eht ,margorp elpmaxe siht nI",
"HELP_TEXT_DATA_SETVARIABLETO_EXAMPLE_2_TITLE" : "trats margorp eht ta tes etar hsalf modnar A :2 margorp elpmaxE",
"HELP_TEXT_DATA_SETVARIABLETO_EXAMPLE_2_BODY_1" : "nur si margorp eht emit hcae sdeeps tnereffid ta sDEL sti gnihsalf nosidE ni stluser sihT .staeper dna pool reverof eht fo trats eht ot kcab spool neht margorp ehT .™€âetaRhsalF˜€â ni eulav dnocesillim eht rof stiaw niaga margorp eht neht ,sDEL thgir dna tfel eht ffo snrut neht ,™€âetaRhsalF˜€â ni eulav dnocesillim eht rof stiaw margorp eht neht ,no denrut era sDEL thgir dna tfel eht pool eht edisnI .pool reverof a sretne neht margorp ehT .001 dna 01 neewteb rebmun modnar a ot tes si ™€âetaRhsalF˜€â elbairav eht ,margorp elpmaxe siht nI",
"HELP_TEXT_DATA_SETVARIABLETO_EXAMPLE_3_TITLE" : "thgil eht wolloF :3 margorp elpmaxE",
"HELP_TEXT_DATA_SETVARIABLETO_EXAMPLE_3_BODY_1" : ".ecruos thgil tsethgirb eht sdrawot gnivird nosidE ni stluser sihT .staeper dna pool reverof eht fo trats eht ot kcab spool neht margorp ehT .deppots si rotom thgir eht dna drawrof evird ot tes si rotom tfel eht neht ,eslaf si tluser eht fI .deppots si rotom tfel eht dna sdrawrof evird ot tes si rotom thgir eht neht ,eurt si tluser eht fI .0 naht retaerg si ™€âthgiRsvtfeLthgiL˜€â elbairav eht ni eulav eht rehtehw stset neht kcolb ™€âesle fi˜€â ehT .level thgil thgir eht sunim level thgil tfel eht ot ™€âthgiRsvtfeLthgiL˜€â elbairav eht stes margorp eht pool eht edisnI .pool reverof a gniretne yb snigeb margorp eht ,elpmaxe siht nI",

"HELP_TEXT_DATA_INCVARIABLE_TITLE" : "tnemercni",
"HELP_TEXT_DATA_INCVARIABLE_BODY_1" : ".kcolb eht ni decalp elbairav eht ot )1 sdda( stnemercni kcolb ™€âtnemercni˜€â ehT",
"HELP_TEXT_DATA_INCVARIABLE_EXAMPLE_1_TITLE" : " gnihsalf gnitareleceD :1 margorp elpmaxE",
"HELP_TEXT_DATA_INCVARIABLE_EXAMPLE_1_BODY_1" : " .dnoces eno si ffo era sDEL eht emit eht dna dnoces eno si no era sDEL eht emit eht spool 000,1 retfA .regnol dna regnol ffo dna no dneps sDEL eht taht emit eht gnikam emit hcae detnemercni si ™€âyaleD˜€â elbairav eht ,pool reverof eht hguorht staeper margorp eht sA .staeper dna pool reverof eht fo trats eht ot kcab spool neht margorp ehT .sdnocesillim ni ™€âyaleD˜€â elbairav eht ni eulav eht rof stiaw margorp eht ,niaga neht dna no denrut si DEL tfel eht dna ffo denrut si DEL thgir eht neht ,sdnocesillim ni ™€âyaleD˜€â elbairav eht ni eulav eht rof stiaw margorp eht neht ,ffo denrut si DEL tfel eht dna no denrut si DEL thgir eht neht ,)1+( detnemercni si ™€âyaleD˜€â elbairav eht pool eht edisnI .pool reverof a sretne neht margorp eht 0 ot tes si ™€âyaleD˜€â elbairav eht ,margorp elpmaxe siht nI",

"HELP_TEXT_DATA_DECVARIABLE_TITLE" : "tnemerced",
"HELP_TEXT_DATA_DECVARIABLE_BODY_1" : ".kcolb eht ni decalp elbairav eht ot )1 sunim( stnemerced kcolb ™€âtnemerced˜€â ehT",
"HELP_TEXT_DATA_DECVARIABLE_EXAMPLE_1_TITLE" : " gnihsalf gnitareleccA :1 margorp elpmaxE",
"HELP_TEXT_DATA_DECVARIABLE_EXAMPLE_1_BODY_1" : " .dnocesillim eno si ffo era sDEL eht emit eht dna dnocesillim eno si no era sDEL eht emit eht spool 001 retfA .retsaf ffo dna no dneps sDEL eht taht emit eht gnikam emit hcae detnemerced si ™€âyaleD˜€â elbairav eht ,pool reverof eht hguorht staeper margorp eht sA .staeper dna pool reverof eht fo trats eht ot kcab spool neht margorp ehT .sdnocesillim ni ™€âyaleD˜€â elbairav eht ni eulav eht rof stiaw margorp eht ,niaga neht dna no denrut si DEL tfel eht dna ffo denrut si DEL thgir eht neht ,sdnocesillim ni ™€âyaleD˜€â elbairav eht ni eulav eht rof stiaw margorp eht neht ,ffo denrut si DEL tfel eht dna no denrut si DEL thgir eht neht ,)1-( detnemerced si ™€âyaleD˜€â elbairav eht pool eht edisnI .pool reverof a sretne neht margorp eht 001 ot tes si ™€âyaleD˜€â elbairav eht ,margorp elpmaxe siht nI",


"HELP_TEXT_BIT_SHIFT_RIGHT_TITLE" : "thgir tfihs tib",
"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_1" : ".eulav tes eht yb thgir stib eht gnitfihs yb mrof yranib sti ni kcolb elbairav detcennoc eht stsujda yllacitamehtam kcolb ™€âyb thgir tfihs tib˜€â ehT",
"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_2" : ":gnol stib-8 era taht srebmun yranib fo selpmaxe emos era ereH .s0 dna s1 fo gnirts a si retupmoc a edisni rebmun hcaE .1 dna 0 srebmun eht fo desirpmoc ylno si taht metsys rebmun a si tI .yranib dellac si esu sretupmoc taht tamrof rebmun ehT",
"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_HUMAN" : "lamiced/namuH",
"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_COMPUTER" : "yraniB tib-8/retupmoC",
"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_3" : ":gnol stib-23 era taht srebmun yranib fo selpmaxe emos era ereH",
"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_4" : "!pleh nac kcolb thgir tfihs tib eht erehw si sihT .kcolb egassem RI dnes eht aiv tnes eb tonnac gnidaer rosnes thgil eht fo egnar lluf eht neht ,552 si rebmun tib-8 elbissop tsehgih eht sA .0001 ot 1 fo egnar a evah srosnes thgil eht sa hcus ,srosnes emos ,rehtruF .kcolb egassem RI dnes eht aiv tnes eb nac srebmun tib-8 ylno tub ,)dengis tib-13 yllautca( srebmun tib-23 egral erots ot elba era skcolb elbairav ,elpmaxe roF .srebmun yranib tib-23 dna tib-8 htob sesu 3V nosidE",
"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_5" : ":seulav mumixam dna muminim eht era ereH .yranib tib-01 si gnidaer rosnes thgil ehT",
"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_6" : "   .0001 fo gnidaer thgil lautca eht ot rebmun tnereffid yrev a si sihT .)lamiced/namuh( 232 ro )yranib( 01011111 eb dluow sihT .stib-8 tsal eht eb ylno dluow rebmun deviecer eht kcolb egassem RI dnes eht htiw tnes saw 0001 rebmun eht fI",
"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_7" : " .)2 yb tfel tfihs( stib-01 ot kcab gnidaer level thgil eht erotser ot desu eb nac kcolb ™€âtfel tfihs tib˜€â eht dne gniviecer eht no ,nehT .atad eht fo hcum oot gnisol tuohtiw )2 yb thgir tfihs( rebmun tib-8 na otni rebmun eht netrohs ot desu eb nac kcolb thgir tfihs tib eht ,kcolb egassem RI dnes eht aiv atad level thgil eht dnes oT",
"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_4_LINE_1_BOX_1" : "egatS",
"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_4_LINE_2_BOX_1" : "gnidaer thgiL",
"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_4_LINE_3_BOX_1" : ")2( thgir tfihs tiB",
"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_4_LINE_4_BOX_1" : "eviecer/dnes atad RI",
"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_4_LINE_5_BOX_1" : ")2( tfel tfihs tiB",
"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_BIT" : "tib",
"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_8" : ".ssecorp siht hguorht deniater neeb sah atad lanigiro eht fo %99 naht erom gniniatnoc stib tnacifingis tsom eht ,revewoH .tsol neeb sah noitamrofni emos sa ,emas eht yltcefrep ton si rebmun gnitluser eht oiranecs siht nI",

"HELP_TEXT_BIT_SHIFT_LEFT_TITLE" : "tfel tfihs tib",
"HELP_TEXT_BIT_SHIFT_LEFT_BODY_1" : ".eulav tes eht yb tfel stib eht gnitfihs yb mrof yranib sti ni kcolb elbairav detcennoc eht stsujda yllacitamehtam kcolb ™€âyb tfel tfihs tib˜€â ehT",
"HELP_TEXT_BIT_SHIFT_LEFT_BODY_2" : ":gnol stib-8 era taht srebmun yranib fo selpmaxe emos era ereH .s0 dna s1 fo gnirts a si retupmoc a edisni rebmun hcaE .1 dna 0 srebmun eht fo desirpmoc ylno si taht metsys rebmun a si tI .yranib dellac si esu sretupmoc taht tamrof rebmun ehT",
"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_HUMAN" : "lamiced/namuH",
"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_COMPUTER" : "yraniB tib-8/retupmoC",
"HELP_TEXT_BIT_SHIFT_LEFT_BODY_3" : ":gnol stib-23 era taht srebmun yranib fo selpmaxe emos era ereH",
"HELP_TEXT_BIT_SHIFT_LEFT_BODY_4" : "!pleh nac kcolb thgir tfihs tib eht erehw si sihT .kcolb egassem RI dnes eht aiv tnes eb tonnac gnidaer rosnes thgil eht fo egnar lluf eht neht ,552 si rebmun tib-8 elbissop tsehgih eht sA .0001 ot 1 fo egnar a evah srosnes thgil eht sa hcus ,srosnes emos ,rehtruF .kcolb egassem RI dnes eht aiv tnes eb nac srebmun tib-8 ylno tub ,)dengis tib-13 yllautca( srebmun tib-23 egral erots ot elba era skcolb elbairav ,elpmaxe roF .srebmun yranib tib-23 dna tib-8 htob sesu 3V nosidE",
"HELP_TEXT_BIT_SHIFT_LEFT_BODY_5" : ":seulav mumixam dna muminim eht era ereH .yranib tib-01 si gnidaer rosnes thgil ehT",
"HELP_TEXT_BIT_SHIFT_LEFT_BODY_6" : "   .0001 fo gnidaer thgil lautca eht ot rebmun tnereffid yrev a si sihT .)lamiced/namuh( 232 ro )yranib( 01011111 eb dluow sihT .stib-8 tsal eht eb ylno dluow rebmun deviecer eht kcolb egassem RI dnes eht htiw tnes saw 0001 rebmun eht fI",
"HELP_TEXT_BIT_SHIFT_LEFT_BODY_7" : " .)2 yb tfel tfihs( stib-01 ot kcab gnidaer level thgil eht erotser ot desu eb nac kcolb ™€âtfel tfihs tib˜€â eht dne gniviecer eht no ,nehT .atad eht fo hcum oot gnisol tuohtiw )2 yb thgir tfihs( rebmun tib-8 na otni rebmun eht netrohs ot desu eb nac kcolb thgir tfihs tib eht ,kcolb egassem RI dnes eht aiv atad level thgil eht dnes oT",
"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_4_LINE_1_BOX_1" : "egatS",
"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_4_LINE_2_BOX_1" : "gnidaer thgiL",
"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_4_LINE_3_BOX_1" : ")2( thgir tfihs tiB",
"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_4_LINE_4_BOX_1" : "eviecer/dnes atad RI",
"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_4_LINE_5_BOX_1" : ")2( tfel tfihs tiB",
"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_BIT" : "tib",
"HELP_TEXT_BIT_SHIFT_LEFT_BODY_8" : ".ssecorp siht hguorht deniater neeb sah atad lanigiro eht fo %99 naht erom gniniatnoc stib tnacifingis tsom eht ,revewoH .tsol neeb sah noitamrofni emos sa ,emas eht yltcefrep ton si rebmun gnitluser eht oiranecs siht nI",


"HELP_TEXT_EVENT_ANYOBSTACLE_TITLE" : " detceted elcatsbo ynA",
"HELP_TEXT_EVENT_ANYOBSTACLE_BODY_1" : ".rotceted elcatsbo eht yb detceted si elcatsbo yna nehw kcolb siht ot pmuj ot margorp eht sesuac kcolb tneve ™€âdetceted elcatsbo ynA˜€â ehT",
"HELP_TEXT_EVENT_ANYOBSTACLE_BODY_2" : ".margorp niam eht ni no denrut si maeb rotceted elcatsbo eht taht erusne syawlA",
"HELP_TEXT_EVENT_ANYOBSTACLE_EXAMPLE_1_TITLE" : ".detceted si elcatsbo yna nehw peeB :1 margorp elpmaxE",
"HELP_TEXT_EVENT_ANYOBSTACLE_EXAMPLE_1_BODY_1" : ".margorp niam eht ni morf tfel ti erehw ot snruter neht margorp ehT .speeb tobor nosidE eht dna nur ot kcolb ™€âpeeb˜€â eht sesuac sihT .kcolb tneve ™€âdetceted elcatsbo ynA˜€â eht ot seog dna pool reverof eht fo tuo spmuj margorp eht ,detceted si elcatsbo yna nehW .kcolb pool reverof eht sretne neht margorp eht ,no denrut tsrif si rotceted elcatsbo eht ,margorp elpmaxe siht nI",
"HELP_TEXT_EVENT_ANYOBSTACLE_EXAMPLE_2_TITLE" : "elcatsbo na si ereht nehw gnivird potS :2 margorp elpmaxE",
"HELP_TEXT_EVENT_ANYOBSTACLE_EXAMPLE_2_BODY_1" : ".margorp niam eht ni morf tfel ti erehw ot snruter neht margorp ehT .gninnur morf srotom htob spots dna nur ot kcolb ™€âsrotom htob pots˜€â eht sesuac sihT .kcolb tneve ™€âdetceted elcatsbo ynA˜€â eht ot seog dna pool reverof eht fo tuo spmuj margorp eht ,detceted si elcatsbo yna nehW .kcolb pool reverof eht sretne neht margorp eht ,5 deeps ta sdrawrof evird ot tes era srotom htob neht ,no denrut tsrif si rotceted elcatsbo eht ,margorp elpmaxe siht nI",
"HELP_TEXT_EVENT_ANYOBSTACLE_EXAMPLE_3_TITLE" : "selcatsbo diovA :3 margorp elpmaxE",
"HELP_TEXT_EVENT_ANYOBSTACLE_EXAMPLE_3_BODY_1" : ".htap sti ni selcatsbo morf yawa gnivird nosidE ni stluser sihT  .niaga 5 deeps ta drawrof evird ot tes era srotom htob dna pool reverof eht ni tfel ti erehw ot snruter neht margorp ehT .1 deeps ta seerged 021 rof tfel nips neht ,1 deeps ta mc 5 rof sdrawkcab nosidE eht evird kcolb tneve ™€âdetceted elcatsbo ynA˜€â eht rednu skcolb ehT .kcolb tneve ™€âdetceted elcatsbo ynA˜€â eht ot seog dna pool reverof eht fo tuo spmuj margorp eht ,detceted si elcatsbo yna nehW .5 deeps ta sdrawrof evird ot tes era srotom htob pool eht edisni ,pool reverof a sretne margorp eht neht ,no denrut tsrif si rotceted elcatsbo eht ,margorp elpmaxe siht nI",

"HELP_TEXT_OBSTACLE_LEFT_EVENT_TITLE" : "tfel detceted elcatsbO",
"HELP_TEXT_OBSTACLE_LEFT_EVENT_BODY_1" : ".rotceted elcatsbo eht yb tfel eht no detceted si elcatsbo na nehw kcolb siht ot pmuj ot margorp eht sesuac kcolb tneve ™€âtfel detceted elcatsbO˜€â ehT",
"HELP_TEXT_OBSTACLE_LEFT_EVENT_BODY_2" : ".margorp niam eht ni no denrut si maeb rotceted elcatsbo eht taht erusne syawlA",
"HELP_TEXT_OBSTACLE_LEFT_EVENT_EXAMPLE_1_TITLE" : "tfel eht no detceted si elcatsbo na nehw peeB :1 margorp elpmaxE",
"HELP_TEXT_OBSTACLE_LEFT_EVENT_EXAMPLE_1_BODY_1" : ".kcolb pool reverof eht ni tfel ti erehw ot snruter neht margorp ehT .speeb tobor nosidE eht dna nur ot kcolb ™€âpeeb˜€â eht sesuac sihT .kcolb tneve ™€âtfel detceted elcatsbO˜€â eht ot seog dna pool reverof eht fo tuo spmuj margorp eht ,tfel eht ot detceted si elcatsbo na nehW .kcolb pool reverof eht sretne neht margorp eht ,no denrut tsrif si rotceted elcatsbo eht ,margorp elpmaxe siht nI",

"HELP_TEXT_OBSTACLE_RIGHT_EVENT_TITLE" : "thgir detceted elcatsbO",
"HELP_TEXT_OBSTACLE_RIGHT_EVENT_BODY_1" : ".rotceted elcatsbo eht yb thgir eht no detceted si elcatsbo na nehw kcolb siht ot pmuj ot margorp eht sesuac kcolb tneve ™€âthgir detceted elcatsbO˜€â ehT",
"HELP_TEXT_OBSTACLE_RIGHT_EVENT_BODY_2" : ".margorp niam eht ni no denrut si maeb rotceted elcatsbo eht taht erusne syawlA",
"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_1_TITLE" : "thgir eht no detceted si elcatsbo na nehw peeB :1 margorp elpmaxE",
"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_1_BODY_1" : ".kcolb pool reverof eht ni tfel ti erehw ot snruter neht margorp ehT .speeb tobor nosidE eht dna nur ot kcolb peeb eht sesuac sihT .kcolb tneve ™€âthgir detceted elcatsbO˜€â eht ot seog dna pool reverof eht fo tuo spmuj margorp eht ,thgir eht ot detceted si elcatsbo na nehW .kcolb pool reverof eht sretne neht margorp eht ,no denrut tsrif si rotceted elcatsbo eht ,margorp elpmaxe siht nI",
"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_2_TITLE" : "redave elcatsbO :2 margorp elpmaxE",
"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_2_BODY_1" : "¦€ânehW .kcolb pool reverof eht sretne neht margorp eht ,no denrut tsrif si rotceted elcatsbo eht ,margorp elpmaxe siht nI",
"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_2_BODY_2" : ".kcolb pool reverof eht ni tfel ti erehw ot snruter neht dna 01 deeps ta sdnoces 52.0 rof sdrawkcab sevird tobor nosidE eht dna kcolb tneve ™€âdaeha detceted elcatsbO˜€â eht ot spmuj margorp eht daeha detceted si elcatsbo na¦€â",
"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_2_BODY_3" : ".kcolb pool reverof eht ni tfel ti erehw ot snruter neht dna 01 deeps ta sdnoces 52.0 rof sdrawkcab tfel snrut tobor nosidE eht dna kcolb tneve ™€âthgir detceted elcatsbO˜€â eht ot spmuj margorp eht thgir eht ot detceted si elcatsbo na¦€â",
"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_2_BODY_4" : ".kcolb pool reverof eht ni tfel ti erehw ot snruter neht dna 01 deeps ta sdnoces 52.0 rof sdrawkcab thgir snrut tobor nosidE eht dna kcolb tneve ™€âtfel detceted elcatsbO˜€â eht ot spmuj margorp eht tfel eht ot detceted si elcatsbo na¦€â",

"HELP_TEXT_OBSTACLE_AHEAD_EVENT_TITLE" : "daeha detceted elcatsbO",
"HELP_TEXT_OBSTACLE_AHEAD_EVENT_BODY_1" : " .elcatsbo na detceted evah srotceted elcatsbo thgir dna tfel eht htob ,emit emas eht ta ,taht snaem sihT .rotceted elcatsbo eht yb daeha detceted si elcatsbo na nehw kcolb siht ot pmuj ot margorp eht sesuac kcolb tneve ™€âdaeha detceted elcatsbO˜€â ehT",
"HELP_TEXT_OBSTACLE_AHEAD_EVENT_BODY_2" : ".margorp niam eht ni no denrut si maeb rotceted elcatsbo eht taht erusne syawlA",
"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_1_TITLE" : "daeha detceted si elcatsbo na nehw peeB :1 margorp elpmaxE",
"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_1_BODY_1" : ".kcolb pool reverof eht ni tfel ti erehw ot snruter neht margorp ehT .speeb tobor nosidE eht dna nur ot kcolb ™€âpeeb˜€â eht sesuac sihT .kcolb tneve ™€âthgir detceted elcatsbO˜€â eht ot seog dna pool reverof eht fo tuo spmuj margorp eht ,thgir eht ot detceted si elcatsbo na nehW .kcolb pool reverof eht sretne neht margorp eht ,no denrut tsrif si rotceted elcatsbo eht ,margorp elpmaxe siht nI",
"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_2_TITLE" : "redave elcatsbo ehT :2 margorp elpmaxE",
"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_2_BODY_1" : "¦€ânehW .kcolb pool reverof eht sretne neht margorp eht ,no denrut tsrif si rotceted elcatsbo eht ,margorp elpmaxe siht nI",
"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_2_BODY_2" : ".kcolb pool reverof eht ni tfel ti erehw ot snruter neht dna 01 deeps ta sdnoces 52.0 rof sdrawkcab sevird tobor nosidE eht dna kcolb tneve ™€âdaeha detceted elcatsbO˜€â eht ot spmuj margorp eht daeha detceted si elcatsbo na¦€â",
"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_2_BODY_3" : ".kcolb pool reverof eht ni tfel ti erehw ot snruter neht dna 01 deeps ta sdnoces 52.0 rof sdrawkcab tfel snrut tobor nosidE eht dna kcolb tneve thgir detceted elcatsbO˜€â eht ot spmuj margorp eht thgir eht ot detceted si elcatsbo na¦€â",
"HELP_TEXT_OBSTACLE_AHEADT_EVENT_EXAMPLE_2_BODY_4" : ".kcolb pool reverof eht ni tfel ti erehw ot snruter neht dna 01 deeps ta sdnoces 52.0 rof sdrawkcab thgir snrut tobor nosidE eht dna kcolb tneve ™€âtfel detceted elcatsbO˜€â eht ot spmuj margorp eht tfel eht ot detceted si elcatsbo na¦€â",

"HELP_TEXT_CLAP_EVENT_TITLE" : "detceted palC",
"HELP_TEXT_CLAP_EVENT_BODY_1" : ".detceted si palc a nehw kcolb siht ot pmuj ot margorp eht sesuac kcolb tneve ™€âdetceted palC˜€â ehT",
"HELP_TEXT_CLAP_EVENT_BODY_2" : " .)margorp elpmaxe ees( ™€ârotceted palc˜€â ot tes kcolb ™€âatad rosnes raelc˜€â eht htiw deraelc eb nac atad rosnes palc eht neht ,snoitceted esion detnawnu ro eslaf eb ot ylekil era ereht fi ,oslA .gnivird nehw rosnes palc eht esu ot ton tseb s™€âti os ,reggirt ot rosnes palc eht esuac gnipmub dna esion rotom eht gnivird si nosidE nehW",
"HELP_TEXT_CLAP_EVENT_EXAMPLE_1_TITLE" : "sesion duol fo deracs si nosidE :margorp elpmaxE",
"HELP_TEXT_CLAP_EVENT_EXAMPLE_1_BODY_1" : "  .pool reverof eht ot snruter won margorp ehT .gnivird elihw derrucco evah yam taht snoitceted palc eslaf yna tuo sraelc kcolb ™€âatad rosnes raelc˜€â eht )thgirf sti morf srevocer nosidE nehw( ,yllaniF  .)thgirf ni revihs( etarbiv ot nosidE eht gnisuac nur yldetaeper skcolb thgir nips dna tfel nips eht erehw semit 52 ot tes pool taeper a gniretne neht ,)thgirf ni pmuj( 01 deeps ta mc 5 sdrawkcab gnivird ,nur neht kcolb tneve ™€âdetceted palC˜€â eht woleb skcolb ehT .kcolb tneve ™€âdetceted palC˜€â eht ot seog dna pool reverof eht fo tuo spmuj margorp eht ,detceted si )dnuos yracs duol rehto ro( palc a nehW .sneppah gnihton dna pool reverof ytpme na gniretne yb snigeb margorp eht ,elpmaxe siht nI",

"HELP_TEXT_TRIANGLEBUTTON_EVENT_TITLE" : "desserp nottub elgnairT",
"HELP_TEXT_TRIANGLEBUTTON_EVENT_BODY_1" : ".desserp si nottub elgnairt eht nehw kcolb siht ot pmuj ot margorp eht sesuac kcolb tneve ™€âdesserp nottub elgnairT˜€â ehT",
"HELP_TEXT_TRIANGLEBUTTON_EVENT_EXAMPLE_1_TITLE" : "snottub htiw gnittes deeps hsalf DEL lortnoC :margorp elpmaxE",
"HELP_TEXT_TRIANGLEBUTTON_EVENT_EXAMPLE_1_BODY_1" : " .)sdnoces 1.0( sdnocesillim 001 rof ffo dna )sdnoces 1.0( sdnocesillim 001 rof no gnieb sDEL eht ni stluser sihT .sdnocesillim ni elbairav ™€âyaleD˜€â eht ni eulav eht rof tiaw a htiw ffo dna no denrut era sDEL thgir dna tfel eht ,pool reverof eht edisnI .pool reverof a sretne neht margorp eht ,001 ot ™€âyaleD˜€â dellac elbairav eht gnittes yb snigeb margorp eht ,elpmaxe siht nI",
"HELP_TEXT_TRIANGLEBUTTON_EVENT_EXAMPLE_1_BODY_2" : "    .retsaf ffo dna no hsalf meht sekam sihT .)sdnoces 50.0( sdnocesillim 05 won si ffo dna no gnieb sDEL eht neewteb emit eht os ,05 si ™€âyaleD˜€â dellac elbairav eht ni eulav eht won tub ,pool reverof eht ot snruter neht margorp ehT .peeb a gniyalp neht ,05 ot ™€âyaleD˜€â dellac elbairav eht gnittes ,nur neht kcolb tneve ™€âdesserp nottub elgnairT˜€â eht woleb skcolb ehT .kcolb tneve ™€âdesserp nottub elgnairT˜€â eht ot spmuj margorp eht ,desserp si nottub elgnairt eht nehW",
"HELP_TEXT_TRIANGLEBUTTON_EVENT_EXAMPLE_1_BODY_3" : "    .rewols ffo dna no hsalf meht sekam sihT .)sdnoces 2.0( sdnocesillim 002 won si ffo dna no gnieb sDEL eht neewteb emit eht os ,002 si ™€âyaleD˜€â dellac elbairav eht ni eulav eht won tub ,pool reverof eht ot snruter neht margorp ehT .peeb a gniyalp neht ,002 ot ™€âyaleD˜€â dellac elbairav eht gnittes ,nur neht kcolb tneve ™€âdesserp nottub dnuoR˜€â eht woleb skcolb ehT .kcolb tneve ™€âdesserp nottub dnuoR˜€â eht ot spmuj margorp eht ,desserp si nottub dnuor eht nehW",

"HELP_TEXT_ROUNDBUTTON_EVENT_TITLE" : "desserp nottub dnuoR",
"HELP_TEXT_ROUNDBUTTON_EVENT_BODY_1" : ".desserp si nottub dnuor eht nehw kcolb siht ot pmuj ot margorp eht sesuac kcolb tneve ™€âdesserp nottub dnuoR˜€â ehT",
"HELP_TEXT_ROUNDBUTTON_EVENT_EXAMPLE_1_TITLE" : "snottub htiw gnittes deeps hsalf DEL lortnoC :margorp elpmaxE",
"HELP_TEXT_ROUNDBUTTON_EVENT_EXAMPLE_1_BODY_1" : " .)sdnoces 1.0( sdnocesillim 001 rof ffo dna )sdnoces 1.0( sdnocesillim 001 rof no gnieb sDEL eht ni stluser sihT .sdnocesillim ni elbairav ™€âyaleD˜€â eht ni eulav eht rof tiaw a htiw ffo dna no denrut era sDEL thgir dna tfel eht ,pool reverof eht edisnI .pool reverof a sretne neht margorp eht ,001 ot ™€âyaleD˜€â dellac elbairav eht gnittes yb snigeb margorp eht ,elpmaxe siht nI",
"HELP_TEXT_ROUNDBUTTON_EVENT_EXAMPLE_1_BODY_2" : "    .retsaf ffo dna no hsalf meht sekam sihT .)sdnoces 50.0( sdnocesillim 05 won si ffo dna no gnieb sDEL eht neewteb emit eht os ,05 si ™€âyaleD˜€â dellac elbairav eht ni eulav eht won tub ,pool reverof eht ot snruter neht margorp ehT .peeb a gniyalp neht ,05 ot ™€âyaleD˜€â dellac elbairav eht gnittes ,nur neht kcolb tneve ™€âdesserp nottub elgnairT˜€â eht woleb skcolb ehT .kcolb tneve ™€âdesserp nottub elgnairT˜€â eht ot spmuj margorp eht ,desserp si nottub elgnairt eht nehW",
"HELP_TEXT_ROUNDBUTTON_EVENT_EXAMPLE_1_BODY_3" : "     .rewols ffo dna no hsalf meht sekam sihT .)sdnoces 2.0( sdnocesillim 002 won si ffo dna no gnieb sDEL eht neewteb emit eht os ,002 si ™€âyaleD˜€â dellac elbairav eht ni eulav eht won tub ,pool reverof eht ot snruter neht margorp ehT .peeb a gniyalp neht ,002 ot ™€âyaleD˜€â dellac elbairav eht gnittes ,nur neht kcolb tneve ™€âdesserp nottub dnuoR˜€â eht woleb skcolb ehT .kcolb tneve ™€âdesserp nottub dnuoR˜€â eht ot spmuj margorp eht ,desserp si nottub dnuor eht nehW",

"HELP_TEXT_LINEREFLECTIVE_EVENT_TITLE" : "ecafrus evitcelfer no rekcart eniL",
"HELP_TEXT_LINEREFLECTIVE_EVENT_BODY_1" : "  .)etihw .e.i( ecafrus evitcelfer a ot )kcalb .e.i( ecafrus evitcelfer-non a morf egnahc a stceted rosnes rekcart enil eht nehw kcolb siht ot pmuj ot margorp eht sesuac kcolb tneve ™€âecafrus evitcelfer no rekcart eniL˜€â ehT",
"HELP_TEXT_LINEREFLECTIVE_EVENT_BODY_2" : " .krow ot kcolb tneve ™€âecafrus evitcelfer no rekcart eniL˜€â eht rof no denrut eb tsum DEL rekcart enil ehT",
"HELP_TEXT_LINEREFLECTIVE_EVENT_EXAMPLE_1_TITLE" : "enil a fo egde eht wolloF :margorp elpmaxE",
"HELP_TEXT_LINEREFLECTIVE_EVENT_EXAMPLE_1_BODY_1" : " .)enil a fo egde eht rof gnikool( thgir nrut ot tobor eht sesuac neht margorp eht ,DEL gnikcart enil eht no gninrut yb snigeb margorp eht ,elpmaxe siht nI",
"HELP_TEXT_LINEREFLECTIVE_EVENT_EXAMPLE_1_BODY_2" : "  .)ecafrus )etihw( evitcelfer eht sdrawot kcab gninrut( tfel nrut ot tobor eht tes ot kcolb evird eht snur dna kcolb ™€âecafrus evitcelfer-non no rekcart eniL˜€â eht ot spmuj margorp eht ,ecafrus )kcalb( evitcelfer-non ot )etihw( evitcelfer a morf egnahc a stceted rekcart enil eht nehW",
"HELP_TEXT_LINEREFLECTIVE_EVENT_EXAMPLE_1_BODY_3" : "  .)ecafrus )kcalb( evitcelfer-non eht sdrawot kcab gninrut( thgir nrut ot tobor eht tes ot kcolb evird eht snur dna kcolb tneve ™€âecafrus evitcelfer no rekcart eniL˜€â eht ot spmuj margorp eht ,ecafrus evitcelfer ot evitcelfer-non a morf egnahc a stceted rekcart enil eht nehW",
"HELP_TEXT_LINEREFLECTIVE_EVENT_EXAMPLE_1_BODY_4" : ".enil eht fo egde eht gniwollof drawrof sevom ti thgir ro tfel rehtie snrut tobor eht emit hcaE",


"HELP_TEXT_LINENONREFLECTIVE_EVENT_TITLE" : "ecafrus evitcelfer-non no rekcart eniL",
"HELP_TEXT_LINENONREFLECTIVE_EVENT_BODY_1" : "   .)kcalb .e.i( ecafrus evitcelfer-non a ot )etihw .e.i( ecafrus evitcelfer a morf egnahc a stceted rosnes rekcart enil eht nehw kcolb siht ot pmuj ot margorp eht sesuac kcolb tneve ™€âecafrus evitcelfer-non no rekcart eniL˜€â ehT",
"HELP_TEXT_LINENONREFLECTIVE_EVENT_BODY_2" : " .krow ot kcolb tneve ecafrus evitcelfer-non no rekcart eniL eht rof no denrut eb tsum DEL rekcart enil ehT",
"HELP_TEXT_LINENONREFLECTIVE_EVENT_EXAMPLE_1_TITLE" : "enil a fo egde eht wolloF :margorp elpmaxE",
"HELP_TEXT_LINENONREFLECTIVE_EVENT_EXAMPLE_1_BODY_1" : " .)enil a fo egde eht rof gnikool( thgir nrut ot tobor eht sesuac neht margorp eht ,DEL gnikcart enil eht no gninrut yb snigeb margorp eht ,elpmaxe siht nI",
"HELP_TEXT_LINENONREFLECTIVE_EVENT_EXAMPLE_1_BODY_2" : "  .)ecafrus )etihw( evitcelfer eht sdrawot kcab gninrut( tfel nrut ot tobor eht tes ot kcolb evird eht snur dna kcolb ™€âecafrus evitcelfer-non no rekcart eniL˜€â eht ot spmuj margorp eht ,ecafrus )kcalb( evitcelfer-non ot )etihw( evitcelfer a morf egnahc a stceted rekcart enil eht nehW",
"HELP_TEXT_LINENONREFLECTIVE_EVENT_EXAMPLE_1_BODY_3" : "  .)ecafrus )kcalb( evitcelfer-non eht sdrawot kcab gninrut( thgir nrut ot tobor eht tes ot kcolb evird eht snur dna kcolb ™€âecafrus evitcelfer no rekcart eniL˜€â eht ot spmuj margorp eht ,ecafrus evitcelfer ot evitcelfer-non a morf egnahc a stceted rekcart enil eht nehW",
"HELP_TEXT_LINENONREFLECTIVE_EVENT_EXAMPLE_1_BODY_4" : ".enil eht fo egde eht gniwollof drawrof sevom ti thgir ro tfel rehtie snrut tobor eht emit hcaE",

"HELP_TEXT_LINECHANGE_EVENT_TITLE" : "ecafrus segnahc rekcart eniL",
"HELP_TEXT_LINECHANGE_EVENT_BODY_1" : " .ecafrus )kcalb .e.i( evitcelfer-non a ot ecafrus )etihw .e.i( evitcelfer a morf a ro ecafrus )etihw .e.i( evitcelfer ot ecafrus )kcalb .e.i( evitcelfer-non a morf egnahc a rehtie stceted rosnes rekcart enil eht nehw kcolb siht ot pmuj ot margorp eht sesuac kcolb tneve ™€âecafrus segnahc rekcart eniL˜€â ehT",
"HELP_TEXT_LINECHANGE_EVENT_BODY_2" : ".krow ot kcolb tneve ecafrus segnahc rekcart eniL eht rof no denrut eb tsum DEL rekcart enil ehT",
"HELP_TEXT_LINECHANGE_EVENT_EXAMPLE_1_TITLE" : "egnahc rof gnippotS :margorp elpmaxE",
"HELP_TEXT_LINECHANGE_EVENT_EXAMPLE_1_BODY_1" : " .drawrof evird niaga ot srotom htob gnittes neht ,niaga gnipeeb ,dnoces 1 gnitiaw ,gnipeeb ,srotom htob gnippots ,snur neht ™€âecafrus segnahc rekcart eniL˜€â eht woleb edoc ehT .kcolb ™€âecafrus segnahc rekcart eniL˜€â eht ot spmuj margorp eht ,sneppah siht nehW .)etihw ot kcalb ro kcalb ot etihw( ecafrus eht fo ytivitcelfer eht ni egnahc a stceted rosnes rekcart enil eht litnu sdrawrof evird ot eunitnoc neht lliw tobor ehT .pool reverof a sretne dna 1 deeps ta drawrof sevird neht tobor eht ,DEL rekcart enil eht no gninrut yb snigeb margorp eht ,elpmaxe siht nI",

"HELP_TEXT_MESSAGE_EVENT_TITLE" : "deviecer egassem RI",
"HELP_TEXT_MESSAGE_EVENT_BODY_1" : ".deviecer si tobor nosidE rehtona morf egassem )RI( derarfnI na nehw kcolb siht ot pmuj ot margorp eht sesuac kcolb tneve ™€âdeviecer egassem RI˜€â ehT",
"HELP_TEXT_MESSAGE_EVENT_BODY_3" : "   .selcatsbo tceted ot desu gnieb si reviecer RI eht nehw krow ton lliw kcolb tneve deviecer egassem RI ehT",
"HELP_TEXT_MESSAGE_EVENT_BODY_4" : "  .kcolb ™€âneht fi˜€â na gnisu dedoced neht dna elbairav a otni tup eb atad egassem eht taht seriuqer egassem eht gnidoceD .egassem RI eht ni atad eht edoced ton seod kcolb tneve deviecer egassem RI ehT .tobor nosidE rehtona morf deviecer si egassem RI yna nehw kcolb tneve ™€âdeviecer egassem RI˜€â eht ot pmuj lliw margorp ehT",
"HELP_TEXT_MESSAGE_EVENT_EXAMPLE_1_TITLE" : "eciwt ro ecno peeb ot egassem RI evieceR :margorp elpmaxE",
"HELP_TEXT_MESSAGE_EVENT_EXAMPLE_1_BODY_1" : ".pool reverof eht ot snruter won margorp ehT .eciwt syalp kcolb peeb eht neht ,eurt fi ,2 ot lauqe si ti fi detset si elbairav eht ,txeN .ecno deyalp si kcolb peeb eht neht ,eurt fi ,1 ot lauqe si ti fi detset si elbairav eht elbairav a ni si atad egassem eht taht woN .deraelc osla si ti daer si egassem RI deviecer eht morf atad eht emit hcae sa deriuqer si sihT .™€âegasseMdevieceR˜€â elbairav eht ni derots si atad egassem deviecer eht tsriF .snur neht kcolb tneve ™€âdeviecer egassem RI˜€â eht woleb edoc ehT .kcolb tneve ™€âdeviecer egassem RI˜€â eht ot spmuj margorp eht deviecer si egassem RI na nehW .sneppah gnihton dna pool reverof ytpme na gniretne yb snigeb margorp eht ,elpmaxe siht nI",
"HELP_TEXT_MESSAGE_EVENT_EXAMPLE_2_TITLE" : ":margorp gnidnes egassem RI",
"HELP_TEXT_MESSAGE_EVENT_EXAMPLE_2_BODY_1" : ".2 rebmun eht htiw tnes si egassem RI na dna kcolb tneve ™€âdesserp nottub dnuoR˜€â eht ot spmuj margorp eht ,desserp si nottub dnuor eht nehW .1 rebmun eht htiw tnes si egassem RI na dna kcolb tneve ™€âdesserp nottub elgnairT˜€â eht ot spmuj margorp eht ,desserp si nottub elgnairt eht nehW .pool reverof ytpme na sretne tsrif margorp ehT .egassem RI eht gnidnes si taht tobor nosidE eht ni desu si margorp evoba ehT",

"HELP_TEXT_DRIVESTRAIN_EVENT_TITLE" : "deniarts evirD",
"HELP_TEXT_DRIVESTRAIN_EVENT_BODY_1" : " .)niarts rednu( etator ot elbanu era tub ,nevird gnieb era srotom htob ro eno nehw kcolb siht ot pmuj ot margorp eht sesuac kcolb tneve ™€âdeniarts evirD˜€â ehT",
"HELP_TEXT_DRIVESTRAIN_EVENT_EXAMPLE_1_TITLE" : "etator tonnac leehw tfel eht nehw mralA :margorp elpmaxE",
"HELP_TEXT_DRIVESTRAIN_EVENT_EXAMPLE_1_BODY_1" : "  .pool reverof eht ot snruter neht margorp ehT .peeb a syalp hcihw kcolb ™€âpeeb˜€â eht si kcolb tneve ™€âdeniarts evirD˜€â eht woleb edoc ehT .woleb edoc eht snur dna kcolb tneve ™€âdeniarts evirD˜€â eht ot spmuj margorp eht ,niarts rednu gnieb ot eud etator tonnac leehw eht nehW .pool reverof a sretne neht ,sdrawrof evird ot rotom tfel eht gnittes yb snigeb margorp eht ,elpmaxe siht nI",

"HELP_TEXT_REMOTE_EVENT_TITLE" : "deviecer edoc etomeR",
"HELP_TEXT_REMOTE_EVENT_BODY_1" : ".deviecer si edoc lortnoc-etomer a nehw kcolb siht ot pmuj ot margorp eht sesuac kcolb tneve ™€âdeviecer edoc etomeR˜€â ehT",
"HELP_TEXT_REMOTE_EVENT_BODY_3" : " .ot ti demmargorp evah uoy tahw od ton dna tobor lortnoc-etomer a sa dnopser lliw tobor nosidE eht sa tegrof ot ysae si sihT .margorp ruoy trats ot nottub elgnairt eht sserp uoy erus ekaM",
"HELP_TEXT_REMOTE_EVENT_BODY_4" : " :ereh siht tuoba erom nraeL .edoc etomer hcihw ot dnopserroc lortnoc etomer ruoy fo snottub hcihw thguat eb tsrif tsum tobor nosidE eht skcolb lortnoc etomer eht esu oT",
"HELP_TEXT_REMOTE_EVENT_BODY_5" : ".woleb 1 margorp elpmaxe eeS .™€âkcolb deviecer edoc etomer˜€â eht fo stnetnoc eht raelc ot kcolb ™€âatad rosnes raelc˜€â eht esu ot deen yam uoy ,yltnatcepxenu sevaheb margorp eht fI",
"HELP_TEXT_REMOTE_EVENT_BODY_6" : ".)5202 dim elbaliava( etomeRdE eht htiw tseb skrow gnidoced lortnoc-etomer decnavdA .rehtona ot dnarb lortnoc etomer eno morf ruoivaheb detcepxenu emos esuac nac siht ,atad gnidoced nehW .stamrof atad tnereffid ylthgils sesu dnarb hcae revewoh ,slortnoc etomer VT dradnats fo %09 yletamixorppa htiw krow lliw sedoc etomer derarfni gnivieceR",
"HELP_TEXT_REMOTE_EVENT_EXAMPLE_1_TITLE" : " sdrawkcab ro sdrawrof evird lortnoc etomeR :margorp elpmaxE",
"HELP_TEXT_REMOTE_EVENT_EXAMPLE_1_BODY" : ".pool reverof ytpme eht ot snruter margorp ehT .srotom htob spots kcolb ™€âpots˜€â eht deviecer gnieb regnol on era dna detset neeb evah sedoc etomer eht retfa ,yllaniF .2 slauqe regnol on deviecer gnieb edoc eht litnu seunitnoc sihT .sdrawkcab evird ot tes era srotom htob neht ,eurt fi ,2 ot lauqe si ti fi ees ot detset si edoc deviecer eht ,txeN .1 slauqe regnol on deviecer gnieb edoc eht litnu seunitnoc siht ,sdrawrof evird ot tes era srotom htob neht ,eurt fi ,1 ot lauqe si ti fi ees ot detset si edoc etomer eht ,snur kcolb tneve ™€âdeviecer edoc etomeR˜€â eht woleb edoc ehT .kcolb tneve ™€âdeviecer edoc etomeR˜€â eht ot spmuj margorp eht deviecer si edoc lortnoc-etomer a nehW .pool reverof ytpme na gniretne yb snigeb margorp eht ,elpmaxe siht nI",

"HELP_TEXT_CONTROL_WAIT_TITLE" : "ces tiaW",
"HELP_TEXT_CONTROL_WAIT_BODY_1" : ".)syad 4.21( sdnoces 147,370,1 ot )dnocesillim 1( sdnoces 100.0 morf eb nac emit fo tnuoma ehT .sdnoces ni emit fo tnuoma na rof margorp eht sesuap kcolb ™€âces tiaw˜€â ehT",
"HELP_TEXT_CONTROL_WAIT_BODY_2" : ":retemarap eno tsuj sah kcolb tiaw ehT",
"HELP_TEXT_CONTROL_WAIT_BODY_3" : ".kcolb rotarepo na ro gnisnes a ,elbairav a ,)yrav ton seod dna tupni eht otni depyt( tnatsnoc a eb naC “€â eulaV",
"HELP_TEXT_CONTROL_WAIT_EXAMPLE_1_TITLE" : " DEL tfel eht knilB :1 margorp elpmaxE",
"HELP_TEXT_CONTROL_WAIT_EXAMPLE_1_BODY" : " .trats eht ot spool neht dna sdnoces 5.0 rof stiaw dna sesuap niaga margorp eht neht ,ffo denrut si DEL tfel eht neht ,sdnoces 5.0 rof stiaw dna sesuap margorp eht neht ,no denrut si DEL tfel eht pool eht edisnI .pool reverof a gniretne yb snigeb margorp eht ,elpmaxe siht nI",
"HELP_TEXT_CONTROL_WAIT_EXAMPLE_2_TITLE" : " tekcirc tobor emitthgiN :2 margorp elpmaxE",
"HELP_TEXT_CONTROL_WAIT_EXAMPLE_2_BODY" : ".dnuof eb t™€ânac ti os ,emitthgin ta tekcirc a ot ralimis ruoivaheb ni stluser sihT .pool reverof eht fo gninnigeb eht ot kcab spool neht margorp ehT .eton a syalp rekaeps eht sdne tiaw siht nehW .003 dna 02 neewteb sdnoces fo rebmun modnar a rof tiaw ot sessergorp margorp eht ,sneppah siht nehW .001 naht ssel si rosnes thgil tfel eht no thgil fo level eht litnu margorp eht fo noissergorp eht sesuap taht kcolb litnu tiaw a si ereht pool eht edisnI .pool reverof a gniretne yb snigeb margorp eht ,elpmaxe siht nI",

"HELP_TEXT_CONTROL_REPEAT_TITLE" : "taepeR",
"HELP_TEXT_CONTROL_REPEAT_BODY_1" : " .semit fo rebmun tes siht ylno rof nur kcolb taeper eht edisni skcolb eht llA .semit fo rebmun tes a spool ylno taht pool fo epyt a si kcolb ™€âtaeper˜€â ehT",
"HELP_TEXT_CONTROL_REPEAT_BODY_2" : " :retemarap eno tsuj sah kcolb taeper ehT",
"HELP_TEXT_CONTROL_REPEAT_BODY_3" : ".kcolb rotarepo na ro gnisnes a ,elbairav a ,)yrav ton seod dna tupni eht otni depyt( tnatsnoc a eb naC “€â eulaV",
"HELP_TEXT_CONTROL_REPEAT_EXAMPLE_1_TITLE" : "erauqs a ni evirD :1 margorp elpmaxE",
"HELP_TEXT_CONTROL_REPEAT_EXAMPLE_1_BODY" : ".erauqs a fo epahs eht ni sevird tobor nosidE eht taht si tluser ehT .semit ruof nur kcolb taeper eht edisni skcolb owt esehT .seerged 09 thgir snips neht ,mc01 drawrof sevird tobor eht kcolb taeper eht edisnI .semit ruof taeper ot tes si taht kcolb taeper a otni gniretne yb snigeb margorp eht ,elpmaxe siht nI",

"HELP_TEXT_CONTROL_FOREVER_TITLE" : "reveroF",
"HELP_TEXT_CONTROL_FOREVER_BODY_1" : "¦€âdna niaga dna niaga nur neht dna nur kcolb reverof eht edisni decalp skcolb ehT .)deppots si margorp eht sselnu( reverof yllanoitidnocnu spool taht kcolb pool fo epyt a si kcolb ™€âreverof˜€â ehT",
"HELP_TEXT_CONTROL_FOREVER_EXAMPLE_1_TITLE" : "DEL a knilB :margorp elpmaxE",
"HELP_TEXT_CONTROL_FOREVER_EXAMPLE_1_BODY" : ".™€âreverof˜€â staeper ecneuqes eht dna kcolb no DEL tfel nrut eht ot kcab spool neht margorp ehT .sdnoces 52.0 rof margorp eht sesuap kcolb tiaw eht neht ,ffo denrut si DEL tfel eht neht ,sdnoces 52.0 rof margorp eht sesuap kcolb tiaw eht neht ,no denrut si DEL tfel eht pool reverof eht edisnI .pool reverof a gniretne yb snigeb margorp eht ,elpmaxe siht nI",

"HELP_TEXT_CONTROL_IF_TITLE" : "neht fI",
"HELP_TEXT_CONTROL_IF_BODY_1" : ".margorp eht ni kcolb txen eht ot seunitnoc margorp eht neht ,eurt ton si noitidnoc eht fI .eurt si noitidnoc tupni eht fi skcolb eht snur kcolb ™€âneht fi˜€â ehT",
"HELP_TEXT_CONTROL_IF_BODY_2" : ":retemarap tupni eno sah kcolb sihT",
"HELP_TEXT_CONTROL_IF_BODY_3" : ".kcolb gnisnes ro kcolb rotarepo na rehtie eb nac taht skcolb depahs dnomaid stpecca tupni lanoitidnoc ehT “€â tupni lanoitidnoC",
"HELP_TEXT_CONTROL_IF_BODY_4" : " .tixe lliw margorp eht dna ecno nur eb lliw tset eht neht ,kcolb ™€âneht fi˜€â na tsuj sah margorp a fI .semit elpitlum detset eb nac noitidnoc ™€âneht fi˜€â eht taht os ,pool reverof a edisni desu yllausu si kcolb ™€âneht fi˜€â ehT",
"HELP_TEXT_CONTROL_IF_EXAMPLE_1_TITLE" : "palc a si ereht fi DEL knilB :1 margorp elpmaxE",
"HELP_TEXT_CONTROL_IF_EXAMPLE_1_BODY" : " .palc a stceted ti revenehw dnoces eno rof DEL tfel sti sknilb tobor nosidE eht taht si tluser ehT  .pool reverof eht fo trats eht ot kcab spool won margorp ehT .ffo denrut si DEL tfel eht neht ,dnoces eno rof sesuap margorp eht neht ,no denrut si DEL tfel eht tsriF .nur kcolb ™€âneht fi˜€â eht edisni skcolb eht neht ,)eurt( detceted neeb sah palc a fI .pool reverof eht fo trats ot kcab spool margorp eht dna deppiks si kcolb ™€âneht fi˜€â eht fo stnetnoc eht neht ,eslaf fI .palc a neeb sah ereht fi stset taht kcolb ™€âneht fi˜€â eht si pool reverof eht ni kcolb tsrif ehT .pool reverof a gniretne yb snigeb margorp eht ,elpmaxe siht n",
"HELP_TEXT_CONTROL_IF_EXAMPLE_2_TITLE" : "mrala nepo warD :2 margorp elpmaxE",
"HELP_TEXT_CONTROL_IF_EXAMPLE_2_BODY" : ".001 evoba level thgil a stceted ti revenehw yldipar speeb nosidE eht taht si tluser ehT  .pool reverof eht fo trats eht ot kcab spool margorp eht dna deppiks si kcolb peeb eht neht ,)001 naht ssel si level thgil( eurt ton si ti fI .mrala na ekil speeb tobor nosidE eht dna snur kcolb peeb eht neht )001 naht retaerg si level thgil( eurt si siht fI .001 naht retaerg si rosnes thgil tfel eht no thgil fo level eht fi stset taht kcolb ™€âneht fi˜€â eht si pool reverof eht ni kcolb tsrif ehT .pool reverof a gniretne yb snigeb margorp eht ,elpmaxe siht nI",

"HELP_TEXT_CONTROL_IF_ELSE_TITLE " : "esle neht fI",
"HELP_TEXT_CONTROL_IF_ELSE_BODY_1" : ".nur skcolb fo tes dnoces eht neht ,eslaf si noitidnoc eht fI .eurt si noitidnoc tupni eht fi skcolb fo tes tsrif eht snur kcolb ™€âesle neht fi˜€â ehT",
"HELP_TEXT_CONTROL_IF_ELSE_BODY_2" : ":retemarap tupni eno sah kcolb sihT",
"HELP_TEXT_CONTROL_IF_ELSE_BODY_3" : ".kcolb gnisnes ro kcolb rotarepo na rehtie eb nac taht skcolb depahs dnomaid stpecca tupni lanoitidnoc ehT “€â tupni lanoitidnoC",
"HELP_TEXT_CONTROL_IF_ELSE_BODY_4" : ".tixe lliw margorp eht dna ecno nur eb lliw tset eht neht ,kcolb ™€âesle neht fi˜€â na tsuj sah margorp a fI .semit elpitlum detset eb nac noitidnoc ™€âesle neht fi˜€â eht taht os ,pool reverof a edisni desu yllausu si kcolb ™€âesle neht fi˜€â ehT",
"HELP_TEXT_CONTROL_IF_ELSE_EXAMPLE_1_TITLE" : "sredrob ni ecnuoB :1 margorp elpmaxE",
"HELP_TEXT_CONTROL_IF_ELSE_EXAMPLE_1_BODY" : ".senil kcalb detceted morf yawa gnivird nosidE ni stluser sihT .dnuora gninrut dna enil kcalb a ffo ™€âgnicnuob˜€â tobor nosidE eht ni stluser sihT .drawrof evird ot srotom htob gnittes ,snur kcolb esle eht neht ,)etihw no( eslaf si siht fi ,)kcalb( ecafrus evitcelfer-non a no si rosnes rekcart enil eht fi tset niaga ecno ot kcab spool neht dna kcolb ™€âesle˜€â eht revo spmuj margorp ehT .seerged 09 gninnips neht dna sdrawkcab tobor eht gnivird nur skcolb fo tes tsrif eht neht eurt si siht fI .)kcalb( ecafrus evitcelfer-non a no si rosnes rekcart enil eht fi stset taht kcolb ™€âesle neht fi˜€â eht si pool reverof eht ni kcolb tsrif ehT .pool reverof a sretne neht ,no DEL rosnes rekcart enil eht gninrut yb snigeb margorp eht ,elpmaxe siht nI",
"HELP_TEXT_CONTROL_IF_ELSE_EXAMPLE_2_TITLE" : "thgil eht wolloF :2 margorp elpmaxE",
"HELP_TEXT_CONTROL_IF_ELSE_EXAMPLE_2_BODY" : ".)sevird nosidE erehw lortnoc ot thgilhsalf a gnisu yrt( ecruos thgil tsethgirb eht sdrawot sevird tobor nosidE eht taht si tluser ehT .)thgil eht sdrawot snrut tobor eht( nur ™€âthgir tobor nrut ot srotom htob tes˜€â kcolb eht woN .skcolb ™€âesle˜€â eht era nur ot kcolb txen eht neht ,)thgir eht no rethgirb si thgil( eslaf si tluser eht fi ,ylevitanretlA .)thgil eht sdrawot tfel snrut tobor eht( ™€âtfel tobor nrut ot srotom htob tes˜€â eht si nur ot kcolb txen eht neht )tfel eht no rethgirb si thgil( eurt si siht fI .rosnes tfel eht no level thgil eht naht ssel si rosnes thgir eht no level thgil eht fi stset taht kcolb ™€âesle neht fi˜€â eht si pool reverof eht ni kcolb tsrif ehT .pool reverof a gniretne yb snigeb margorp eht ,elpmaxe siht nI",

"HELP_TEXT_CONTROL_WAIT_UNTIL_TITLE" : "litnu tiaW",
"HELP_TEXT_CONTROL_WAIT_UNTIL_BODY_1" : ".eurt si noitidnoc tupni eht litnu margorp eht sesuap kcolb ™€âlitnu tiaw˜€â ehT",
"HELP_TEXT_CONTROL_WAIT_UNTIL_BODY_2" : ":retemarap tupni eno sah kcolb sihT",
"HELP_TEXT_CONTROL_WAIT_UNTIL_BODY_3" : ".kcolb gnisnes ro kcolb rotarepo na rehtie eb nac taht skcolb depahs dnomaid stpecca tupni lanoitidnoc ehT “€â tupni lanoitidnoC",
"HELP_TEXT_CONTROL_WAIT_UNTIL_BODY_4" : ".tixe lliw margorp eht dna ecno nur eb lliw tset eht neht ,kcolb ™€âlitnu tiaw˜€â a tsuj sah margorp a fI .semit elpitlum detset eb nac noitidnoc ™€âlitnu tiaw˜€â eht taht os ,pool reverof a edisni desu yllausu si kcolb ™€âlitnu tiaw˜€â ehT",
"HELP_TEXT_CONTROL_WAIT_UNTIL_EXAMPLE_1_TITLE" : "palc a si ereht fi DEL knilB :1 margorp elpmaxE",
"HELP_TEXT_CONTROL_WAIT_UNTIL_EXAMPLE_1_BODY" : " .palc a stceted ti revenehw dnoces eno rof DEL tfel sti sknilb tobor nosidE eht taht si tluser ehT .dnoces eno rof no snrut DEL tfel eht palc a si ereht emit hcaE .kcolb ™€âlitnu tiaw˜€â eht ot kcab spool won margorp ehT .ffo DEL tfel eht nrut neht ,dnoces eno rof tiaw neht ,no DEL tfel eht nrut ot sessergorp margorp eht ,detceted si palc a nehW .detceted si palc a litnu tiaw dna ereh esuap lliw margorp ehT .kcolb ™€âdetceted palc˜€â tupni lanoitidnoc a htiw kcolb ™€âlitnu tiaw˜€â eht si txeN .atad palc eslaf yna sraelc taht kcolb ˜€âatad rosnes raelc˜€â eht si pool reverof eht ni kcolb tsrif ehT .pool reverof a gniretne yb snigeb margorp eht ,elpmaxe siht nI",
"HELP_TEXT_CONTROL_WAIT_UNTIL_EXAMPLE_2_TITLE" : "rotceted thgil tsethgirb fo ecruoS :2 margorp elpmaxE",
"HELP_TEXT_CONTROL_WAIT_UNTIL_EXAMPLE_2_BODY" : "thgil fo ecruos tsethgirb eht sdrawot gnitniop si ti nehw gnipeeb tobor nosidE eht ni stluser sihT .staeper margorp eht dna kcolb ™€âlitnu tiaw˜€â eht ot kcab spool won margorp ehT .kcolb peeb eht ot sessergorp margorp eht neht ,lauqe si srosnes thgil htob no level thgil eht nehW .ereh sesuap margorp eht neht ,)lauqe ton era slevel thgil eht( eurt ton si noitidnoc eht fI .rosnes thgil tfel eht no level thgil eht lauqe ot rosnes thgil thgir eht no level thgil eht gniriuqer rotarepo na gnisu tupni lanoitidnoc a htiw kcolb ™€âlitnu tiaw˜€â eht si pool reverof eht ni kcolb tsrif ehT .pool reverof a gniretne yb snigeb margorp eht ,elpmaxe siht nI",

"HELP_TEXT_CONTROL_REPEAT_UNTIL_TITLE" : "litnu taepeR",
"HELP_TEXT_CONTROL_REPEAT_UNTIL_BODY_1" : ".eurt si noitidnoc tupni eht litnu ,ti edisni skcolb eht snur kcolb ™€âlitnu taeper˜€â ehT",
"HELP_TEXT_CONTROL_REPEAT_UNTIL_BODY_2" : ":retemarap tupni eno sah kcolb sihT",
"HELP_TEXT_CONTROL_REPEAT_UNTIL_BODY_3" : ".kcolb gnisnes ro kcolb rotarepo na rehtie eb nac taht skcolb depahs dnomaid stpecca tupni lanoitidnoc ehT “€â tupni lanoitidnoC",
"HELP_TEXT_CONTROL_REPEAT_UNTIL_BODY_4" : " .tixe lliw margorp eht dna ecno nur eb lliw tset eht neht ,kcolb ™€âlitnu taeper˜€â a tsuj sah margorp a fI .semit elpitlum detset eb nac noitidnoc ™€âlitnu taeper˜€â eht taht os ,pool reverof a edisni desu netfo si kcolb ™€âlitnu taeper˜€â ehT",
"HELP_TEXT_CONTROL_REPEAT_UNTIL_EXAMPLE_1_TITLE" : "gnidnuos morf mrala eht potS :1 margorp elpmaxE",
"HELP_TEXT_CONTROL_REPEAT_UNTIL_EXAMPLE_1_BODY" : ".)mrala eht gnitteser dna gnippots( desserp si nottub dnuor eht ™€âlitnu˜€â ,)dnuos mrala eht( revo dna revo taeper dna nur eb ot kcolb peeb eht sesuac siht ,kcolb ™€âlitnu taeper˜€â eht ot sessergorp margorp eht ,detceted si elcatsbo na nehW .detceted si )redurtni( elcatsbo na litnu ereh tiaw dna esuap lliw margorp ehT .)rotceted redurtni eht( erehwyna detceted elcatsbo fo tupni lanoitidnoc a htiw kcolb ™€âlitnu tiaw˜€â a si pool reverof eht ni kcolb tsrif ehT .pool reverof a sretne neht dna )mrala eht gnittes( rotceted elcatsbo eht no gninut yb snigeb margorp eht ,elpmaxe siht nI",
"HELP_TEXT_CONTROL_REPEAT_UNTIL_EXAMPLE_2_TITLE" : "thgil mraw tuohtiw dloc srevihs nosidE :2 margorp elpmaxE",
"HELP_TEXT_CONTROL_REPEAT_UNTIL_EXAMPLE_2_BODY" : ".)yppah dna mraw si tobor nosidE ehT( sesuap margorp eht dna eurt semoceb noitidnoc eht neht ,)thgil thgirb yrev otni sevom nosidE( 089 evoba sesaercni rosnes thgil tfel eht fo level thgil eht fI .)gnirevihs( thgir dna tfel tobor nosidE eht gninnips ylkciuq ,nur woleb skcolb eht neht ,eurt ton si siht fI .)thgilnus/thgirb yrev( 089 naht retaerg eb ot rosnes thgil tfel eht fo level thgil eht gniriuqer rotarepo na gnisu tupni lanoitidnoc a htiw kcolb ™€âlitnu taeper˜€â eht si pool reverof eht ni kcolb tsrif ehT .pool reverof a gniretne yb snigeb margorp eht ,elpmaxe siht nI",

"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_TITLE" : "sdnocesilliM tiaW",
"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_BODY_1" : ".sdnoces 100.0 ro dnoces a fo )0001/1( shtdnasuoht-eno eno si dnocesillim A .)sm( sdnocesillim ni emit fo tnuoma na rof margorp eht sesuap kcolb ™€âsdnocesillim tiaw˜€â ehT",
"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_BODY_2" : "sdnoces 5.1 = sdnocesillim 0051",
"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_BODY_3" : "sdnoces 1.0 = sdnocesillim 001",
"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_BODY_4" : "sdnoces 520.0 = sdnocesillim 52",
"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_BODY_5" : ":retemarap eno tsuj sah kcolb ™€âsdnocesillim tiaw˜€â ehT",
"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_BODY_6" : "kcolb rotarepo na ro gnisnes a ,elbairav a eb naC “€â eulaV",
"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_EXAMPLE_1_TITLE" : "DEL gniknilb tsaF :1 margorp elpmaxE",
"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_EXAMPLE_1_BODY" : " .pool reverof eht fo trats eht ot kcab spool won margorp ehT .sdnocesillim 05 rof sesuap kcolb ™€âsdnocesillim tiaw˜€â eht neht ,ffo denrut si DEL tfel eht nehT .sdnocesillim 05 esac siht ni ,sdnocesillim ™€âyaleD˜€â ni eulav eht rof sesuap kcolb ™€âsdnocesillim tiaw˜€â eht neht ,no denrut si DEL tfel eht pool reverof eht edisnI .pool reverof a sretne neht ,05 ot ™€âyaleD˜€â elbairav eht gnittes yb snigeb margorp eht ,elpmaxe siht nI",
"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_EXAMPLE_2_TITLE" : "sthgil yzarC :2 margorp elpmaxE",
"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_EXAMPLE_2_BODY" : ".sthgil DEL s™€âtobor nosidE eht fo gnihsalf desimodnar a si tluser ehT .sdnocesillim 003 dna 03 neewteb srebmun modnar etareneg ot tes era esehT .meht edisni skcolb ™€ârebmun modnar˜€â eht yb tes si sdnocesillim ni emit ehT .skcolb ™€âsdnocesillim tiaw˜€â eht yb dellortnoc era ffo dna no gninrut neewteb semit tiaw ehT .ffo dna no denrut era sDEL thgir dna tfel eht ,pool reverof eht edisnI .pool reverof a gniretne yb snigeb margorp eht ,elpmaxe siht nI",

"HELP_TEXT_SENSING_TURNLINETRACKINGLED_TITLE" : "ffo/no DEL gnikcart enil nruT",
"HELP_TEXT_SENSING_TURNLINETRACKINGLED_BODY_1" : " .ffo ro no rehtie ot DEL rekcart enil eht stes kcolb ™€âffo/no DEL rekcart enil nrut˜€â ehT",
"HELP_TEXT_SENSING_TURNLINETRACKINGLED_BODY_2" : " .krow ot rosnes gnikcart enil eht rof no eb tsum DEL rekcart enil ehT",
"HELP_TEXT_SENSING_TURNLINETRACKINGLED_EXAMPLE_1_TITLE" : "ecafrus kcalb no potS :margorp elpmaxE",
"HELP_TEXT_SENSING_TURNLINETRACKINGLED_EXAMPLE_1_BODY" : " .pots srotom eht dna sdne margorp eht sneppah siht nehw ,)kcalb( ecafrus evitcelfer-non a stceted rosnes rekcart enil eht litnu stiaw neht margorp ehT .sdrawrof evird ot tes era srotom htob neht ,no DEL gnikcart enil eht gninrut yb snigeb margorp eht ,elpmaxe siht nI",

"HELP_TEXT_SENSING_TURNOBSTACLEBEAM_TITLE" : "ffo/no maeb noitceted elcatsbo nruT",
"HELP_TEXT_SENSING_TURNOBSTACLEBEAM_BODY_1" : ".ffo ro no rehtie ot maeb noitceted elcatsbo eht stes kcolb ™€âffo/no maeb noitceted elcatsbo nrut˜€â ehT",
"HELP_TEXT_SENSING_TURNOBSTACLEBEAM_BODY_2" : ".krow ot noitceted elcatsbo rof no eb tsum maeb noitceted elcatsbo ehT",
"HELP_TEXT_SENSING_TURNOBSTACLEBEAM_EXAMPLE_1_TITLE" : "elcatsbo na rof potS :margorp elpmaxE",
"HELP_TEXT_SENSING_TURNOBSTACLEBEAM_EXAMPLE_1_BODY" : " .pots srotom eht dna sdne margorp eht sneppah siht nehw ,erehwyna detceted si elcatsbo na litnu stiaw neht margorp ehT .sdrawrof evird ot tes era srotom htob neht ,no maeb noitceted elcatsbo eht gninrut yb snigeb margorp eht ,elpmaxe siht nI",

"HELP_TEXT_SENSING_CLEARSENSOR_TITLE" : "atad rosnes raelC",
"HELP_TEXT_SENSING_CLEARSENSOR_BODY_1" : " .siht ekil snoitceted detnawnu yna fo atad rosnes eht raelc ot desu si kcolb ™€âatad rosnes raelc˜€â ehT .neppah t™€ândid taht palc dnoces a tceted ot margorp eht sesuac sihT .palc a fo noitceted lanoitidda na reggirt-er nac dna ysion etiuq si gnivird ,yllareneG .palc a gnitceted fo tluser a sa tobor nosidE eht sevird margorp a nehw si elpmaxe nA .tnaw uoy taht yaw eht ni gnikrow morf margorp eht pots taht snoitceted detnawnu ro eslaf eb thgim ereht nehw desu si kcolb sihT .rosnes detceles eht morf )snoitceted( atad rosnes yna sraelc kcolb ™€âatad rosnes raelc˜€â ehT",
"HELP_TEXT_SENSING_CLEARSENSOR_BODY_2" : ":snoitpo tupni evif sah kcolb ™€âatad rosnes raelc™€â ehT",
"HELP_TEXT_SENSING_CLEARSENSOR_BODY_3" : "rotceted palc",
"HELP_TEXT_SENSING_CLEARSENSOR_BODY_4" : "dapyek",
"HELP_TEXT_SENSING_CLEARSENSOR_BODY_5" : "rotceted elcatsbo",
"HELP_TEXT_SENSING_CLEARSENSOR_BODY_6" : "edoc etomer",
"HELP_TEXT_SENSING_CLEARSENSOR_BODY_7" : "egassem RI",
"HELP_TEXT_SENSING_CLEARSENSOR_EXAMPLE_1_TITLE" : "nips dna palC :1 margorp elpmaxE",
"HELP_TEXT_SENSING_CLEARSENSOR_EXAMPLE_1_BODY" : " .palc a si yllautca ereht litnu dereggirt eb ton lliw kcolb ™€âlitnu tiaw˜€â eht dna noitceted eht sraelc kcolb ™€âatad rosnes raelc˜€â eht neht tub ,)noitceted palc eht otno gnidloh llits( pool reverof eht fo trats eht ot kcab spool margorp ehT .palc dnoces a saw ereht taht skniht rotceted palc eht won os ,rotceted palc eht sreggirt-er esion siht ,esion ekam diks dna sleehw ,srotom eht gninnips eht gniruD .sdnoces owt rof tfel snips tobor eht dna sessergorp margorp eht sneppah siht nehw ,detceted si palc a litnu stiaw margorp eht txen ,rotceted palc eht raelc ot tes si kcolb ™€âatad rosnes raelc˜€â eht ,pool reverof eht edisnI .pool reverof a gniretne yb snigeb margorp eht ,elpmaxe siht nI",

"HELP_TEXT_SENSING_CLAPDETECTED_TITLE" : "detceted palC",
"HELP_TEXT_SENSING_CLAPDETECTED_BODY_1" : ".)detceted neeb ton sah palc( eslaf ro )detceted neeb sah palc( eurt rehtie eb ylno nac kcolb eht ni atad eht os kcolb depahs dnomaid a si tI .detceted neeb sah palc a ton ro rehtehw setacidni taht kcolb tupni rosnes a si kcolb ™€âdetceted palc˜€â ehT",
"HELP_TEXT_SENSING_CLAPDETECTED_BODY_2" : ".snoitceted palc detnawnu ro eslaf raelc ot kcolb ™€âatad rosnes raelc˜€â eht esU .reggirt eslaf ot kcolb ™€âdetceted palc˜€â eht esuac nac gnivird srotom eht sa hcus sesion rehtO",
"HELP_TEXT_SENSING_CLAPDETECTED_EXAMPLE_1_TITLE" : "palc a si ereht fi DEL knilB :1 margorp elpmaxE",
"HELP_TEXT_SENSING_CLAPDETECTED_EXAMPLE_1_BODY" : " .palc a stceted ti revenehw dnoces eno rof DEL tfel sti sknilb tobor nosidE eht taht si tluser ehT  .pool reverof eht fo trats eht ot kcab spool neht margorp ehT .ffo snrut DEL tfel eht neht ,dnoces eno rof stiaw margorp eht neht ,no snrut DEL tfel eht ,detceted si palc a nehW .detceted neeb sah palc a fi stset taht kcolb ™€âneht fi˜€â na si ereht pool reverof eht edisnI .pool reverof a gniretne yb snigeb margorp eht ,elpmaxe siht nI",

"HELP_TEXT_SENSING_BUTTONPRESSED_TITLE" : "desserP nottuB",
"HELP_TEXT_SENSING_BUTTONPRESSED_BODY_1" : ":snoitpo nottub owt era erehT .desserp neeb sah nottub a ton ro rehtehw setacidni taht tupni rosnes a si kcolb ™€âdesserp nottub˜€â ehT",
"HELP_TEXT_SENSING_BUTTONPRESSED_BODY_2" : "dnuor",
"HELP_TEXT_SENSING_BUTTONPRESSED_BODY_3" : "elgnairt",
"HELP_TEXT_SENSING_BUTTONPRESSED_BODY_4" : ".)desserp neeb ton sah nottub( eslaf ro )desserp neeb sah nottub( eurt rehtie eb ylno nac kcolb eht ni atad eht os kcolb depahs dnomaid a si kcolb ™€âdesserp nottub˜€â ehT",
"HELP_TEXT_SENSING_BUTTONPRESSED_EXAMPLE_1_TITLE" : "sserp nottub no peeB :margorp elpmaxE",
"HELP_TEXT_SENSING_BUTTONPRESSED_EXAMPLE_1_BODY" : ".pool reverof eht fo trats eht ot kcab spool neht dna kcolb ™€âpeeb˜€â eht snur margorp eht ,desserp si nottub dnuor eht nehW .desserp neeb sah nottub dnuor eht fi stset taht kcolb ™€âneht fi˜€â na si ereht pool reverof eht edisnI .pool reverof a gniretne yb snigeb margorp eht ,elpmaxe siht nI",

"HELP_TEXT_SENSING_OBSTACLE_TITLE" : "detceteD elcatsbO",
"HELP_TEXT_SENSING_OBSTACLE_BODY_1" : ":snoitpo noitceted ruof era erehT .detceted neeb sah elcatsbo na ton ro rehtehw setacidni taht kcolb tupni rosnes a si kcolb ™€âdetceted elcatsbo˜€â ehT",
"HELP_TEXT_SENSING_OBSTACLE_BODY_2" : "erehwyna",
"HELP_TEXT_SENSING_OBSTACLE_BODY_3" : "daeha",
"HELP_TEXT_SENSING_OBSTACLE_BODY_4" : "tfel",
"HELP_TEXT_SENSING_OBSTACLE_BODY_5" : "thgir",
"HELP_TEXT_SENSING_OBSTACLE_BODY_6" : ".)detceted neeb ton sah elcatsbo( eslaf ro )detceted neeb sah elcatsbo( eurt rehtie eb ylno nac kcolb eht ni atad eht os kcolb depahs dnomaid a si kcolb ™€âdetceted elcatsbo˜€â ehT",
"HELP_TEXT_SENSING_OBSTACLE_BODY_7" : " .no maeb noitceted elcatsbo eht nrut ot desu eb tsum kcolb ™€âffo/no maeb noitceted elcatsbo nrut˜€â eht kcolb ™€âdetceted elcatsbo˜€â eht esu oT",
"HELP_TEXT_SENSING_OBSTACLE_EXAMPLE_1_TITLE" : "selcatsbo diovA :margorp elpmaxE",
"HELP_TEXT_SENSING_OBSTACLE_EXAMPLE_1_BODY" : ".htap sti ni selcatsbo morf yawa gnivird nosidE ni stluser sihT  .sdrawrof evird ot tes niaga era srotom htob pool reverof eht fo gninnigeb eht tA .pool reverof eht fo trats eht ot kcab spool dna seerged 081 snips tobor eht ,sneppah siht nehW .erehwyna detceted neeb sah elcatsbo na fi stset taht kcolb ™€âneht fi˜€â na si ereht neht ,sdrawrof evird htob ot tes era srotom eht pool reverof eht edisnI .pool reverof a sretne neht ,no ot maeb noitceted elcatsbo eht gnittes yb snigeb margorp eht ,elpmaxe siht nI",

"HELP_TEXT_SENSING_LINETRACKER_TITLE" : "ecafrus no rekcart eniL",
"HELP_TEXT_SENSING_LINETRACKER_BODY_1" : ".DEL der s™€ârekcart enil eht morf thgil der eht tcelfer ton osla lliw ecafrus neerg ro eulb a tub ,kcalb yllausu si sihT .rosnes thgil eht ot kcab thgil s™€âDEL rekcart enil eht tcelfer ton seod taht ecafrus a si ecafrus evitcelfer-non A .DEL der s™€ârekcart enil eht morf thgil der eht tcelfer osla lliw ecafrus der a tub ,ecafrus etihw a yllausu si sihT .rosnes thgil eht ot kcab thgil s™€âDEL rekcart enil eht stcelfer taht ecafrus a si ecafrus evitcelfer A .evitcelfer si ecafrus eht ton ro rehtehw setacidni taht kcolb tupni rosnes a si kcolb ™€âecafrus no rekcart enil˜€â ehT",
"HELP_TEXT_SENSING_LINETRACKER_BODY_2" : ":snoitpo noitceted owt era erehT",
"HELP_TEXT_SENSING_LINETRACKER_BODY_3" : ")etihw( evitcelfer",
"HELP_TEXT_SENSING_LINETRACKER_BODY_4" : ")kcalb( evitcelfer-non",
"HELP_TEXT_SENSING_LINETRACKER_BODY_5" : ".)detceted neeb ton sah epyt ecafrus( eslaf ro )detceted neeb sah epyt ecafrus( eurt rehtie eb ylno nac kcolb eht ni atad eht os kcolb depahs dnomaid a si kcolb ™€âecafrus no rekcart enil˜€â ehT",
"HELP_TEXT_SENSING_LINETRACKER_BODY_6" : ".no DEL gnikcart enil eht nrut ot desu eb tsum kcolb ™€âffo/no DEL gnikcart enil nrut˜€â eht kcolb ™€âecafrus no rekcart enil˜€â eht esu oT",
"HELP_TEXT_SENSING_LINETRACKER_EXAMPLE_1_TITLE" : "sredrob ni ecnuoB :margorp elpmaxE",
"HELP_TEXT_SENSING_LINETRACKER_EXAMPLE_1_BODY" : ".senil kcalb detceted morf yawa gnivird nosidE ni stluser sihT .sdrawrof evird ot tes niaga era srotom htob pool reverof eht fo gninnigeb eht tA .pool reverof eht fo trats eht ot kcab spool dna seerged 081 snips tobor eht ,eurt si siht nehW .evitcelfer-non si ecafrus eht fi stset taht kcolb ™€âneht fi˜€â na si ereht neht ,sdrawrof evird htob ot tes era srotom eht pool reverof eht edisnI .pool reverof a sretne neht ,no DEL gnikcart enil eht gninrut yb snigeb margorp eht ,elpmaxe siht nI",

"HELP_TEXT_SENSING_REMOTE_BOOL_TITLE" : "deviecer edoc etomeR",
"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_1" : ".deviecer neeb sah edoc lortnoc-etomer ralucitrap a ton ro rehtehw setacidni taht kcolb tupni rosnes a si kcolb ™€âdeviecer edoc etomer˜€â ehT",
"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_2" : ".7 ot 0 morf snoitpo edoc etomer thgie era erehT",
"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_3" : ".)deviecer neeb ton sah edoc( eslaf ro )deviecer neeb sah edoc( eurt rehtie eb ylno nac kcolb eht ni atad eht os kcolb depahs dnomaid a si kcolb ™€âdeviecer edoc etomer˜€â ehT",
"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_4" : ".ot ti demmargorp evah uoy tahw od ton dna tobor lortnoc-etomer a sa dnopser lliw tobor nosidE eht sa tegrof ot ysae si sihT .margorp ruoy trats ot nottub elgnairt eht sserp uoy erus ekaM",
"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_5" : " :ereh siht tuoba erom nraeL .edoc etomer hcihw ot dnopserroc lortnoc etomer ruoy fo snottub hcihw thguat eb tsrif tsum tobor nosidE eht kcolb ™€âdeviecer edoc etomer˜€â eht esu oT",
"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_6" : ".woleb 1 margorp elpmaxe eeS .kcolb ™€âdeviecer edoc etomer˜€â eht fo stnetnoc eht raelc ot kcolb ™€âatad rosnes raelc˜€â eht esu ot deen yam uoy ,yldetcepxenu sevaheb margorp eht fI",
"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_7" : ".)5202 dim elbaliava( etomeRdE eht htiw tseb skrow gnidoced lortnoc-etomer decnavdA .rehtona ot dnarb lortnoc etomer eno morf ruoivaheb detcepxenu emos esuac nac secnereffid eseht ,atad RI gnidoced si nosidE nehW .stamrof atad RI tnereffid ylthgils sesu dnarb VT hcae revewoh ,slortnoc etomer )RI( derarfni VT dradnats fo %09 yletamixorppa htiw krow lliw kcolb ™€âdeviecer edoc etomer˜€â ehT",
"HELP_TEXT_SENSING_REMOTE_BOOL_EXAMPLE_1_TITLE" : "?owt ro peeb enO :1 margorp elpmaxE",
"HELP_TEXT_SENSING_REMOTE_BOOL_EXAMPLE_1_BODY" : " .pool reverof eht fo gninnigeb eht ot kcab spool neht margorp ehT .deraelc neht si atad rosnes eht dna eciwt syalp kcolb ™€âpeeb˜€â eht neht eurt si siht fI .2 edoc etomer si edoc etomer deviecer eht fi stset dna kcolb ™€âneht fi˜€â txen eht ot sessergorp margorp eht ,eslaf si ti fI .deraelc neht si atad rosnes eht dna ecno syalp kcolb ™€âpeeb˜€â eht neht eurt si siht fI .1 edoc etomer si edoc etomer deviecer eht fi stset ™€âneht fi˜€â tsrif ehT .edoc etomer deviecer eht tset taht skcolb ™€âneht fi˜€â owt era ereht pool reverof eht edisnI .pool reverof a gniretne yb snigeb margorp eht ,elpmaxe siht nI",
"HELP_TEXT_SENSING_REMOTE_BOOL_EXAMPLE_2_TITLE" : ")etomeRdE eht htiw tseb skrow( dnammoc lortnoc etomer no nipS :2 margorp elpmaxE",
"HELP_TEXT_SENSING_REMOTE_BOOL_EXAMPLE_2_BODY" : ".nwod dleh si nottub etomer eht elihw gninnips nosidE ni stluser sihT .pool reverof eht fo trats eht ot pool neht dna srotom htob pots ot sessergorp margorp eht ,sneppah siht nehW .)desserp gnieb regnol on si nottub lortnoc-etomer eht( 0 edoc etomer eb ton tsum edoc etomer deviecer eht ssap oT .sessap noitidnoc kcolb ™€âlitnu tiaw˜€â eht litnu seunitnoc sihT .thgir tobor eht nips ot tes era srotom htob neht ,eurt si siht fI .deviecer neeb sah 0 edoc etomer fi stset kcolb ™€âneht fi˜€â eht pool reverof eht edisnI .pool reverof a gniretne yb snigeb margorp eht ,elpmaxe siht nI",

"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_TITLE" : "detceted egassem RI",
"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_BODY_1" : ".secnatsid trohs atad etacinummoc ot snaem a sa lufesu si sekam sihT .snamuh ot elbisiv ton si taht thgil fo dnab a ot srefer derarfnI .™€âderarfni˜€â rof trohs si ™€âRI˜€â mret ehT .tobor nosidE rehtona morf )deviecer( detceted neeb sah egassem RI na ton ro rehtehw setacidni taht tupni rosnes a si kcolb ™€âdetceted egassem RI˜€â ehT",
"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_BODY_2" : ".)deviecer neeb ton sah egassem RI( eslaf ro )deviecer neeb sah egassem RI( eurt rehtie eb ylno nac kcolb eht ni atad eht os kcolb depahs dnomaid a si kcolb ™€âdetceted egassem RI˜€â ehT",
"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_BODY_4" : " .margorp elpmaxe eht eeS .kcolb ™€âegassem RI deviecer˜€â eht esu egassem RI eht ni atad eht daer oT .deviecer neeb sah egassem RI na fi margorp eht sllet ylno tI .deviecer saw taht egassem RI eht fo stnetnoc eht wonk ton seod kcolb ™€âdetceted egassem RI˜€â ehT",
"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_BODY_5" : ")teef 03( sretem 01 ot pu eb nac egnar lacipyt ehT .thgilnus tcerid morf yawa sroodni tseb skrow stobor nosidE neewteb gnigassem derarfnI",
"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_EXAMPLE_1_TITLE" : "ffo dna no thgil etomer nosidE :margorp elpmaxE",
"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_EXAMPLE_1_BODY" : ".pool reverof eht fo trats eht ot kcab spool neht margorp ehT .ffo denrut si DEL tfel eht neht ,eurt si siht fi ,2 ot lauqe si egasseM RI˜€â ni atad eht fi stset kcolb ™€âneht fi˜€â sihT .kcolb ™€âneht fi˜€â txen eht ot no sevom margorp eht neht ,eurt ton si siht fI .no denrut si DEL tfel eht neht ,eurt si siht fi ,1 ot lauqe si ™€âegasseMRI˜€â ni atad eht fi stset tnemetats ™€âneht fi˜€â txen ehT .tsol ro deraelc gnieb tuohtiw semit elpitlum detset/daer eb ot egassem deviecer eht swolla siht gnioD .kcolb ™€âegassem RI deviecer˜€â eht morf eulav eht ot tes si ™€âegasseMRI˜€â elbairav eht neht eurt si siht fi ,deviecer neeb sah egassem RI na fi stset kcolb ™€âneht fi˜€â tsrif eht pool reverof eht edisnI .pool reverof a gniretne yb snigeb margorp eht ,elpmaxe siht nI",
"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_EXAMPLE_2_TITLE" : ".margorp siht snur tobor nosidE gnidnes egassem RI ehT",
"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_EXAMPLE_2_BODY" : ".)ffo DEL eht nrut( 2 rebmun eht htiw egassem RI na sdnes nottub dnuor eht gnisserp dna )no DEL eht nrut( 1 rebmun eht htiw egassem RI na sdnes nottub elgnairt eht gnisserP",

"HELP_TEXT_SENSING_DRIVESTRAINED_TITLE" : "detceted niarts evirD",
"HELP_TEXT_SENSING_DRIVESTRAINED_BODY_1" : ".)evird ot gniyrt nehw gnitator morf detneverp yllacisyhp( niarts rednu gnieb ot eud gnitator deppots evah sleehw eht fo htob ro eno ton ro rehtehw setacidni taht kcolb tupni rosnes a si kcolb ™€âdetceted niarts evird˜€â ehT",
"HELP_TEXT_SENSING_DRIVESTRAINED_BODY_2" : ".)niarts rednu ton si leehw( eslaf ro )niarts rednu si leehw( eurt rehtie eb ylno nac kcolb eht ni atad eht os kcolb depahs dnomaid a si kcolb ™€âdetceted niarts evird˜€â ehT",
"HELP_TEXT_SENSING_DRIVESTRAINED_EXAMPLE_1_TITLE" : "mrala deniarts leehW :margorp elpmaxE",
"HELP_TEXT_SENSING_DRIVESTRAINED_EXAMPLE_1_BODY" : ".etator nac leehw eht dna devomer si niarts eht litnu nur ot eunitnoc lliw kcolb ™€âpeeb˜€â ehT .nur si kcolb ™€âpeeb˜€â eht eurt si siht nehW .detceted si niarts evird fi stset taht kcolb ™€âneht fi˜€â na si ereht pool eht edisnI .pool reverof a sretne margorp eht txen ,sdrawrof evird ot leehw tfel eht gnittes yb snigeb margorp eht ,elpmaxe siht nI",

"HELP_TEXT_SENSING_REMOTE_NUM_TITLE" : "edoc etomer devieceR",
"HELP_TEXT_SENSING_REMOTE_NUM_BODY_1" : ".7 ot 0 morf rebmun a si atad ehT .lortnoc etomer a morf deviecer atad sniatnoc taht kcolb tupni rosnes a si kcolb ™€âedoc etomer deviecer˜€â ehT",
"HELP_TEXT_SENSING_REMOTE_NUM_BODY_2" : ".margorp elpmaxe eeS  .kcolb )™€âneht fi˜€â( lanoitidnoc a htiw ti gnitset erofeb elbairav a otni kcolb ™€âedoc etomer deviecer˜€â eht morf atad eht tup ot tseb syawla si tI .deraelc era stnetnoc sti ,kcolb siht snur margorp a nehW",
"HELP_TEXT_SENSING_REMOTE_NUM_EXAMPLE_1_TITLE" : "ffo dna no thgil lortnoc etomeR :margorp elpmaxE",
"HELP_TEXT_SENSING_REMOTE_NUM_EXAMPLE_1_BODY" : ".pool reverof eht fo trats eht ot kcab spool neht margorp ehT .ffo denrut si DEL tfel eht neht ,eurt si siht fI .2 ot lauqe si ™€âedoCetomeR˜€â fo stnetnoc fi stset kcolb ™€âneht fi˜€â txen eht neht ,eslaf si siht fI .no denrut si DEL tfel eht neht eurt si siht fI .1 ot lauqe si ™€âedoCetomeR˜€â fo stnetnoc fi stset kcolb ™€âneht fi˜€â tsrif ehT .detset eb won nac ™€âedoCetomeR˜€â elbairav ehT .™€âedoCetomeR˜€â elbairav eht otni kcolb ™€âedoc etomer deviecer˜€â eht morf atad eht stup pool reverof eht edisni kcolb tsrif ehT .pool reverof a gniretne yb snigeb margorp eht ,elpmaxe siht nI",

"HELP_TEXT_SENSING_IRMESSAGE_TITLE" : "egassem RI devieceR",
"HELP_TEXT_SENSING_IRMESSAGE_BODY_1" : ".552 ot 0 fo egnar a sah dna rebmun yranib tib-8 na no desab si atad ehT .secnatsid trohs atad etacinummoc ot snaem a sa lufesu ti sekam sihT .snamuh ot elbisiv ton si taht thgil fo dnab a ot srefer derarfnI .™€âderarfni˜€â rof trohs si ™€âRI˜€â mret ehT .tobor nosidE rehtona morf deviecer atad sniatnoc taht kcolb tupni rosnes a si kcolb ™€âegassem RI deviecer˜€â ehT",
"HELP_TEXT_SENSING_IRMESSAGE_BODY_2" : ".kcolb )kcolb ™€âneht fi˜€â( lanoitidnoc a htiw ti gnitset erofeb elbairav a otni ™€âedoc etomer deviecer˜€â eht morf atad eht tup ot tseb syawla si tI .deraelc si stnetnoc sti kcolb siht snur margorp a nehW",
"HELP_TEXT_SENSING_IRMESSAGE_BODY_3" : ".)teef 03( sretem 01 ot pu eb nac egnar lacipyt ehT .thgilnus tcerid morf yawa sroodni tseb skrow stobor nosidE neewteb gnigassem derarfnI",
"HELP_TEXT_SENSING_IRMESSAGE_EXAMPLE_1_TITLE" : "noitulover ecnad a tratS :margorp elpmaxE",
"HELP_TEXT_SENSING_IRMESSAGE_EXAMPLE_1_BODY" : ".pool reverof eht fo trats eht ot kcab spool neht margorp eht ,semit ruof taeper servueonam ecnad ehT .cisum ot cnys ni gnicnad stobor nosidE fo ssalc elohw a si ereht fi tnatropmi yllaer si sihT .ecnatsid ton emit no desab si sevom eseht fo hcaE .servueonam ecnad s™€âtobor nosidE eht era pool taeper eht edisnI .semit ruof rof pool taeper a sretne margorp eht ,sneppah siht nehW .3 ot lauqe si taht deviecer si egassem RI na litnu stiaw neht margorp eht ,atad rosnes egassem RI eht sraelc pool reverof eht edisni kcolb tsrif ehT .pool reverof a gniretne yb snigeb margorp eht ,elpmaxe siht nI",
"HELP_TEXT_SENSING_IRMESSAGE_EXAMPLE_2_TITLE" : "3 egassem RI dneS :margorp elpmaxE",
"HELP_TEXT_SENSING_IRMESSAGE_EXAMPLE_2_BODY" : ".pool reverof eht fo trats eht ot kcab spool neht margorp ehT .thgil derarfni aiv dettimsnart si 3 rebmun egassem eht sneppah siht nehw ,desserp si nottub dnuor eht litnu stiaw pool reverof eht edisni kcolb tsrif ehT .pool reverof a gniretne yb snigeb margorp eht ,elpmaxe siht nI",

"HELP_TEXT_SENSING_LIGHTLEVEL_TITLE" : "rosnes fo level thgiL",
"HELP_TEXT_SENSING_LIGHTLEVEL_BODY_1" : ".detadpu yltnatsnoc si atad kcolb ™€ârosnes fo level thgil˜€â ehT .0001 dna 1 neewteb rebmun a si level thgil ehT .srosnes thgil eht morf atad sniatnoc taht kcolb tupni rosnes a si kcolb ™€ârosnes fo level thgil˜€â ehT",
"HELP_TEXT_SENSING_LIGHTLEVEL_BODY_2" : ":morf tceles ot stupni rosnes thgil eerht era erehT",
"HELP_TEXT_SENSING_LIGHTLEVEL_BODY_3" : ")edis tfel tnorf eht ta rosnes( thgil tfel -",
"HELP_TEXT_SENSING_LIGHTLEVEL_BODY_4" : ")edis thgir tnorf eht ta rosnes( thgil thgir -",
"HELP_TEXT_SENSING_LIGHTLEVEL_BODY_5" : ")tobor eht rednu senil tceted ot desu rosnes( gnikcart enil -",
"HELP_TEXT_SENSING_LIGHTLEVEL_EXAMPLE_1_TITLE" : "thgil thgiN :margorp elpmaxE",
"HELP_TEXT_SENSING_LIGHTLEVEL_EXAMPLE_1_BODY" : ".thgil mid a ni s™€âti elihw no gnieb sDEL s™€ânosidE ni stluser sihT .staeper dna pool reverof eht fo trats eht ot spool neht margorp ehT .ffo nrut sDEL thgir dna tfel eht dna ™€âesle˜€â ot spmuj margorp eht neht ,eslaf si siht fI .no nrut sDEL thgir dna tfel eht neht ,eurt si siht fI .05 naht ssel si rosnes thgil tfel eht no gnidaer level thgil eht fi stset pool reverof eht edisni kcolb tsrif ehT .pool reverof a gniretne yb snigeb margorp eht ,elpmaxe siht nI",


"HELP_TEXT_ADDITION_TITLE" : "noitiddA",
"HELP_TEXT_ADDITION_BODY" : " .kcolb rotarepo na ro gnisnes ,elbairav a ,)yrav ton seod dna tupni eht otni depyt( tnatsnoc a eb nac seulav ehT .rehtegot seulav owt sdda kcolb rotarepo noitidda ehT",
"HELP_TEXT_ADDITION_EXAMPLE_1_TITLE" : ".2 eulav tnatsnoc eht ot dedda si 2 eulav tnatsnoc ehT",
"HELP_TEXT_ADDITION_EXAMPLE_2_TITLE" : " .2 eulav tnatsnoc eht ot dedda si ™€âretnuoC˜€â elbairav ehT",
"HELP_TEXT_ADDITION_EXAMPLE_3_TITLE" : ".01 eulav tnatsnoc eht ot dedda si ™€ârosnes fo level thgil˜€â tupni rosnes ehT",

"HELP_TEXT_SUBTRACTION_TITLE" : "noitcartbuS",
"HELP_TEXT_SUBTRACTION_BODY" : ".kcolb rotarepo na ro gnisnes ,elbairav a ,)yrav ton seod dna tupni eht otni depyt( tnatsnoc a eb nac seulav ehT .rehtona morf eulav eno stcartbus kcolb rotarepo noitcartbus ehT",
"HELP_TEXT_SUBTRACTION_EXAMPLE_1_TITLE" : ".002 eulav tnatsnoc eht morf detcartbus si 01 eulav tnatsnoc ehT",
"HELP_TEXT_SUBTRACTION_EXAMPLE_2_TITLE" : ".™€âretnuoC˜€â elbairav eht morf detcartbus si 001 eulav tnatsnoc ehT",
"HELP_TEXT_SUBTRACTION_EXAMPLE_3_TITLE" : ".™€ârosnes fo level thgil˜€â tupni rosnes eht morf detcartbus si 01 eulav tnatsnoc ehT",
"HELP_TEXT_SUBTRACTION_EXAMPLE_4_TITLE" : "retnuoc noitaidar thgiL :margorp elpmaxE",
"HELP_TEXT_SUBTRACTION_EXAMPLE_4_BODY" : " .rethgirb si level thgil eht nehw retsaf dna ssenkrad ni nehw wols gnipeeb nosidE eht ni stluser sihT .staeper dna pool reverof eht fo trats eht ot kcab spool dna C eton eht syalp neht margorp ehT .elbairav )yaleD( eht ni eulav eht rof stiaw kcolb txen ehT .)gnidaer level thgil eht gnitrevni( level thgil tfel eht sunim 0001 ot )yaleD( elbairav eht stes margorp eht pool eht edisnI .pool reverof a sretne neht margorp ehT .tsaf yrev ot tes tsrif si opmet cisum eht ,margorp elpmaxe siht nI",

"HELP_TEXT_MULTIPLICATION_TITLE" : "noitacilpitluM",
"HELP_TEXT_MULTIPLICATION_BODY" : ".kcolb rotarepo na ro gnisnes ,elbairav a ,)yrav ton seod dna tupni eht otni depyt( tnatsnoc a eb nac seulav ehT .seulav owt seilpitlum kcolb rotarepo noitacilpitlum ehT",
"HELP_TEXT_MULTIPLICATION_EXAMPLE_1_TITLE" : ".4 eulav tnatsnoc eht yb deilpitlum si 2 eulav tnatsnoc ehT",
"HELP_TEXT_MULTIPLICATION_EXAMPLE_2_TITLE" : ".2 eulav tnatsnoc eht yb deilpitlum si ™€âretnuoC˜€â elbairav ehT",
"HELP_TEXT_MULTIPLICATION_EXAMPLE_3_TITLE" : ".4 eulav tnatsnoc eht yb deilpitlum si ™€ârosnes fo level thgil˜€â tupni rosnes ehT",

"HELP_TEXT_DIVISION_TITLE" : "noisiviD",
"HELP_TEXT_DIVISION_BODY_1" : ".kcolb rotarepo na ro gnisnes ,elbairav a ,)yrav ton seod dna tupni eht otni depyt( tnatsnoc a eb nac seulav ehT .eulav rehtona yb eulav eno sedivid kcolb rotarepo noisivid ehT",
"HELP_TEXT_DIVISION_BODY_2" : ".orez si tupni tsom thgir eht fi rorre na ecneirepxe lliw nosidE ,orez yb edivid ot elbissop ton si ti",
"HELP_TEXT_DIVISION_EXAMPLE_1_TITLE" : ".2 eulav tnatsnoc eht yb dedivid si 01 eulav tnatsnoc ehT",
"HELP_TEXT_DIVISION_EXAMPLE_2_TITLE" : " .2 eulav tnatsnoc eht yb dedivid si ™€âretnuoC˜€â elbairav ehT",
"HELP_TEXT_DIVISION_EXAMPLE_3_TITLE" : ".01 yb dedivid si ™€ârosnes fo level thgil˜€â tupni rosnes ehT",
"HELP_TEXT_DIVISION_EXAMPLE_4_TITLE" : "rosnes a morf atad dna elbairav a gnisu ecnatsid evird eht gnitteS :margorp elpmaxE",
"HELP_TEXT_DIVISION_EXAMPLE_4_BODY" : ".mc02 fo ecnatsid mumixam a ot ,thgil thgirb ni rehtruf gnivird nosidE ni stluser sihT  .5 deeps ta elbairav )ecnatsiD( eht ni eulav eht rof drawrof sevird neht nosidE ehT .05 yb dedivid )000,1 ot 1 morf eulav a( rosnes thgil tfel eht morf level thgil eht ot elbairav )ecnatsiD( eht stes nosidE ,margorp elpmaxe siht nI",

"HELP_TEXT_RANDOM_NUMBER_TITLE" : "rebmun modnar",
"HELP_TEXT_RANDOM_NUMBER_BODY" : ".kcolb rotarepo na ro gnisnes ,elbairav a ,)yrav ton seod dna tupni eht otni depyt( tnatsnoc a eb nac seulav ehT .seulav owt neewteb rebmun modnar a setareneg kcolb ™€âneewteb rebmun modnar˜€â ehT",
"HELP_TEXT_RANDOM_NUMBER_EXAMPLE_1_TITLE" : ".001 eulav tnatsnoc eht dna 01 eulav tnatsnoc eht neewteb rebmun modnar a etareneG",
"HELP_TEXT_RANDOM_NUMBER_EXAMPLE_2_TITLE" : ".0005 eulav tnatsnoc eht dna ™€âretnuoC˜€â elbairav eht neewteb rebmun modnar a etareneG",
"HELP_TEXT_RANDOM_NUMBER_EXAMPLE_3_TITLE" : ".™€ârosnes fo level thgil˜€â tupni rosnes eht dna 01 eulav tnatsnoc eht neewteb rebmun modnar a etareneG",
"HELP_TEXT_RANDOM_NUMBER_EXAMPLE_4_TITLE" : "sthgil yzarC :margorp elpmaxE",
"HELP_TEXT_RANDOM_NUMBER_EXAMPLE_4_BODY" : ".sthgil DEL s™€âtobor nosidE eht fo gnihsalf tnetsisnocni dna yzarc a si tluser ehT .sdnocesillim 003 dna 03 neewteb srebmun modnar etareneg ot tes era esehT .meht edisni skcolb ™€ârebmun modnar˜€â eht yb tes si sdnocesillim ni emit ehT .skcolb ™€âsdnocesillim tiaw˜€â eht yb dellortnoc era ffo dna no gninrut neewteb semit tiaw ehT .ffo dna no denrut era sDEL thgir dna tfel eht ,pool reverof eht edisnI .pool reverof a gniretne yb snigeb margorp eht ,elpmaxe siht nI",

"HELP_TEXT_ABS_VAL_TITLE" : "sba",
"HELP_TEXT_ABS_VAL_BODY" : ".kcolb rotarepo na ro gnisnes ,elbairav a ,)yrav ton seod dna tupni eht otni depyt( tnatsnoc a eb nac eulav ehT .evitisop syawla si taht eulav a si eulav etulosba nA .eulav etulosba na ot eulav a strevnoc kcolb )eulav etulosba( sba ehT",
"HELP_TEXT_ABS_VAL_EXAMPLE_1_BODY" : ".3 eulav eht fo tluser a saH",
"HELP_TEXT_ABS_VAL_EXAMPLE_2_BODY" : ".3 eulav eht fo tluser a saH",
"HELP_TEXT_ABS_VAL_EXAMPLE_3_TITLE" : "slevel thgil neewteb ecnereffid eht troper :margorp elpmaxE",
"HELP_TEXT_ABS_VAL_EXAMPLE_3_BODY" : ".eulav )etulosba( evitisop a syawla si eulav sihT .BSU aiv ™€âecnereffiD˜€â elbairav eht ni eulav eht sdnes neht dna dnoces eno rof stiaw neht margorp ehT .)srebmun evitagen on( evitisop syawla si tluser eht taht serusne kcolb ™€âsba˜€â ehT .rosnes thgil tfel eht morf level thgil eht sunim rosnes thgil thgir eht morf level thgil eht fo eulav etulosba eht ot ™€âecnereffiD˜€â elbairav eht stes pool reverof eht ni kcolb tsrif ehT .pool reverof a gniretne yb snigeb margorp eht ,elpmaxe siht nI",

"HELP_TEXT_LESS_THAN_TITLE" : "naht sseL",
"HELP_TEXT_LESS_THAN_BODY_1" : ".kcolb rotarepo na ro gnisnes ,elbairav a ,)yrav ton seod dna tupni eht otni depyt( tnatsnoc a eb nac seulav ehT .eslaf ro eurt rehtie si taht tluser a snruter dna eulav dnoces eht naht ssel si eulav tsrif eht fi enimreted ot seulav tupni owt serapmoc kcolb ™€ânaht ssel˜€â ehT",
"HELP_TEXT_LESS_THAN_BODY_2" : " .eslaf ro eurt rehtie eb ylno nac kcolb eht fo tluser eht os kcolb depahs dnomaid a si kcolb ™€ânaht ssel˜€â ehT",
"HELP_TEXT_LESS_THAN_EXAMPLE_1_BODY" : "eurt :tluseR",
"HELP_TEXT_LESS_THAN_EXAMPLE_2_BODY" : "eslaf :tluseR",
"HELP_TEXT_LESS_THAN_EXAMPLE_3_TITLE" : ".021 eulav tnatsnoc eht naht ssel ™€âretnuoC˜€â elbairav eht sI",
"HELP_TEXT_LESS_THAN_EXAMPLE_4_TITLE" : ".005 eulav tnatsnoc eht naht ssel rosnes tfel eht morf level thgil eht sI",


"HELP_TEXT_LESS_THAN_EQUAL_TITLE" : "ot lauqe ro naht sseL",
"HELP_TEXT_LESS_THAN_EQUAL_BODY_1" : ".kcolb rotarepo na ro gnisnes ,elbairav a ,)yrav ton seod dna tupni eht otni depyt( tnatsnoc a eb nac seulav ehT .eslaf ro eurt rehtie si taht tluser a snruter dna eulav dnoces eht ot lauqe ro naht ssel si eulav tsrif eht fi enimreted ot seulav tupni owt serapmoc kcolb ™€âot lauqe ro naht ssel˜€â ehT",
"HELP_TEXT_LESS_THAN_EQUAL_BODY_2" : ".eslaf ro eurt rehtie eb ylno nac kcolb eht fo tluser eht os kcolb depahs dnomaid a si kcolb ™€âot lauqe ro naht ssel˜€â ehT",
"HELP_TEXT_LESS_THAN_EQUAL_EXAMPLE_1_BODY" : "eurt :tluseR",
"HELP_TEXT_LESS_THAN_EQUAL_EXAMPLE_2_BODY" : "eslaf :tluseR",
"HELP_TEXT_LESS_THAN_EQUAL_EXAMPLE_3_BODY" : "eurt :tluseR",
"HELP_TEXT_LESS_THAN_EQUAL_EXAMPLE_4_TITLE" : ".021 eulav tnatsnoc eht ot lauqe ro naht ssel ™€âretnuoC˜€â elbairav eht sI",
"HELP_TEXT_LESS_THAN_EQUAL_EXAMPLE_5_TITLE" : ".005 eulav tnatsnoc eht ot lauqe ro naht ssel rosnes tfel eht morf level thgil eht sI",

"HELP_TEXT_EQUAL_TITLE" : "ot lauqE",
"HELP_TEXT_EQUAL_BODY_1" : ".kcolb rotarepo na ro gnisnes ,elbairav a ,)yrav ton seod dna tupni eht otni depyt( tnatsnoc a eb nac seulav ehT .eslaf ro eurt rehtie si taht tluser a snruter dna eulav dnoces eht ot lauqe si eulav tsrif eht fi enimreted ot seulav tupni owt serapmoc kcolb ™€âot lauqe˜€â ehT",
"HELP_TEXT_EQUAL_BODY_2" : " .eslaf ro eurt rehtie eb ylno nac kcolb eht fo tluser eht os kcolb depahs dnomaid a si kcolb ™€âot lauqe˜€â ehT",
"HELP_TEXT_EQUAL_EXAMPLE_1_BODY" : "eurt :tluseR",
"HELP_TEXT_EQUAL_EXAMPLE_2_BODY" : "eslaf :tluseR",
"HELP_TEXT_EQUAL_EXAMPLE_3_TITLE" : ".06 eulav tnatsnoc eht ot lauqe ™€âretnuoC˜€â elbairav eht sI",
"HELP_TEXT_EQUAL_EXAMPLE_4_TITLE" : ".3 eulav tnatsnoc eht ot lauqe edoc etomer deviecer eht sI",


"HELP_TEXT_GREATER_THAN_EQUAL_TITLE" : "ot lauqe ro naht retaerG",
"HELP_TEXT_GREATER_THAN_EQUAL_BODY_1" : ".kcolb rotarepo na ro gnisnes ,elbairav a ,)yrav ton seod dna tupni eht otni depyt( tnatsnoc a eb nac seulav ehT .eslaf ro eurt rehtie si taht tluser a snruter dna eulav dnoces eht ot lauqe ro naht retaerg si eulav tsrif eht fi enimreted ot seulav tupni owt serapmoc kcolb ™€âot lauqe ro naht retaerg˜€â ehT",
"HELP_TEXT_GREATER_THAN_EQUAL_BODY_2" : " .eslaf ro eurt rehtie eb ylno nac kcolb eht fo tluser eht os kcolb depahs dnomaid a si kcolb ™€âot lauqe ro naht retaerg˜€â ehT",
"HELP_TEXT_GREATER_THAN_EQUAL_EXAMPLE_1_BODY" : "eurt :tluseR",
"HELP_TEXT_GREATER_THAN_EQUAL_EXAMPLE_2_BODY" : "eslaf :tluseR",
"HELP_TEXT_GREATER_THAN_EQUAL_EXAMPLE_3_BODY" : "eurt :tluseR",
"HELP_TEXT_GREATER_THAN_EQUAL_EXAMPLE_4_TITLE" : ".021 eulav tnatsnoc eht ot lauqe ro naht retaerg ™€âretnuoC˜€â elbairav eht sI",
"HELP_TEXT_GREATER_THAN_EQUAL_EXAMPLE_5_TITLE" : ".005 eulav tnatsnoc eht ot lauqe ro naht retaerg rosnes tfel eht morf level thgil eht sI",

"HELP_TEXT_GREATER_THAN_TITLE" : "naht retaerG",
"HELP_TEXT_GREATER_THAN_BODY_1" : ".kcolb rotarepo na ro gnisnes ,elbairav a ,)yrav ton seod dna tupni eht otni depyt( tnatsnoc a eb nac seulav ehT .eslaf ro eurt rehtie si taht tluser a snruter dna eulav dnoces eht naht retaerg si eulav tsrif eht fi enimreted ot seulav tupni owt serapmoc kcolb ™€ânaht retaerg˜€â ehT",
"HELP_TEXT_GREATER_THAN_BODY_2" : "eslaf ro eurt rehtie eb ylno nac kcolb eht fo tluser eht os kcolb depahs dnomaid a si kcolb ™€ânaht retaerg˜€â ehT",
"HELP_TEXT_GREATER_THAN_EXAMPLE_1_BODY" : "eurt :tluseR",
"HELP_TEXT_GREATER_THAN_EXAMPLE_2_BODY" : "eslaf :tluseR",
"HELP_TEXT_GREATER_THAN_EXAMPLE_3_TITLE" : ".021 eulav tnatsnoc eht naht retaerg ™€âretnuoC˜€â elbairav eht sI",
"HELP_TEXT_GREATER_THAN_EXAMPLE_4_TITLE" : ".005 eulav tnatsnoc eht naht retaerg rosnes tfel eht morf level thgil eht sI",

"HELP_TEXT_NOT_EQUAL_TITLE" : "ot lauqe toN",
"HELP_TEXT_NOT_EQUAL_BODY_1" : ".kcolb rotarepo na ro gnisnes ,elbairav a ,)yrav ton seod dna tupni eht otni depyt( tnatsnoc a eb nac seulav ehT .eslaf ro eurt rehtie si taht tluser a snruter dna eulav dnoces eht ot lauqe ton si eulav tsrif eht fi enimreted ot seulav tupni owt serapmoc kcolb ™€âot lauqe ton˜€â ehT",
"HELP_TEXT_NOT_EQUAL_BODY_2" : " .eslaf ro eurt rehtie eb ylno nac kcolb eht fo tluser eht os kcolb depahs dnomaid a si kcolb ™€âot lauqe ton˜€â ehT",
"HELP_TEXT_NOT_EQUAL_EXAMPLE_1_BODY" : "eurt :tluseR",
"HELP_TEXT_NOT_EQUAL_EXAMPLE_2_BODY" : "eslaf :tluseR",
"HELP_TEXT_NOT_EQUAL_EXAMPLE_3_TITLE" : ".021 eulav tnatsnoc eht ot lauqe ton ™€âretnuoC˜€â elbairav eht sI",
"HELP_TEXT_NOT_EQUAL_EXAMPLE_4_TITLE" : ".3 eulav tnatsnoc eht ot lauqe ton edoc etomer deviecer eht sI",

"HELP_TEXT_IS_BETWEEN_TITLE" : " neewteb sI",
"HELP_TEXT_IS_BETWEEN_BODY_1" : ".kcolb rotarepo na ro gnisnes ,elbairav a ,)yrav ton seod dna tupni eht otni depyt( tnatsnoc a eb nac seulav ehT .seulav rehto owt fo egnar a nihtiw si eulav a fi senimreted kcolb ™€âneewteb si˜€â ehT",
"HELP_TEXT_IS_BETWEEN_BODY_2" : ".eslaf ro eurt rehtie eb ylno nac kcolb eht fo tluser eht os kcolb depahs dnomaid a si kcolb ™€âneewteb si˜€â ehT",
"HELP_TEXT_IS_BETWEEN_EXAMPLE_1_BODY" : "eurt :tluseR",
"HELP_TEXT_IS_BETWEEN_EXAMPLE_2_BODY" : "eslaf :tluseR",
"HELP_TEXT_IS_BETWEENL_EXAMPLE_3_TITLE" : ".021 eulav tnatsnoc eht dna 06 eulav tnatsnoc eht neewteb ™€âretnuoC˜€â elbairav eht sI",
"HELP_TEXT_IS_BETWEEN_EXAMPLE_4_TITLE" : ".057 eulav tnatsnoc eht dna 052 eulav tnatsnoc eht neewteb rosnes thgil tfel fo level thgil rosnes eht sI",

"HELP_TEXT_AND_TITLE" : "dnA",
"HELP_TEXT_AND_BODY_1" : ".kcolb gnisnes ro kcolb rotarepo na rehtie eb nac taht skcolb depahs dnomaid tpecca stupni ehT  .eslaf si tluser eht neht ,eslaf era stupni htob ro eno fI .eurt eb osla lliw tluser eht neht ,eurt era stupni htob fI .eurt htob era stupni owt fi senimreted kcolb ™€âdna˜€â ehT",
"HELP_TEXT_AND_BODY_2" : ".eslaf ro eurt rehtie eb ylno nac kcolb eht fo tluser eht os kcolb depahs dnomaid a si kcolb ™€âdna˜€â ehT",
"HELP_TEXT_AND_EXAMPLE_1_BODY" : "eurt :tluseR",
"HELP_TEXT_AND_EXAMPLE_2_BODY" : "eslaf :tluseR",
"HELP_TEXT_AND_EXAMPLE_3_TITLE" : " .detceted niarts evird €âdnaœ€â ecafrus evitcelfer no rekcart enil eht htob sI",
"HELP_TEXT_AND_EXAMPLE_4_TITLE" : ".3 eulav tnatsnoc eht ot lauqe si edoc etomer deviecer €âdnaœ€â 05 naht retaerg ™€âretnuoC˜€â elbairav eht sI",

"HELP_TEXT_OR_TITLE" : "rO",
"HELP_TEXT_OR_BODY_1" : ".kcolb gnisnes ro kcolb rotarepo na rehtie eb nac taht skcolb depahs dnomaid tpecca stupni ehT .eslaf eb lliw tluser eht neht ,eslaf era stupni htob fI .eurt eb lliw tluser eht neht ,eurt era stupni htob ro eno fI .eurt era tupni dnoces eht €âroœ€â tupni tsrif eht fi senimreted kcolb ™€âro˜€â ehT",
"HELP_TEXT_OR_BODY_2" : ".eslaf ro eurt rehtie eb ylno nac kcolb eht fo tluser eht os kcolb depahs dnomaid a si kcolb ™€âro˜€â ehT",
"HELP_TEXT_OR_EXAMPLE_1_BODY" : "eurt :tluseR",
"HELP_TEXT_OR_EXAMPLE_2_BODY" : "eurt :tluseR",
"HELP_TEXT_OR_EXAMPLE_3_BODY" : "eslaf :tluseR",
"HELP_TEXT_OR_EXAMPLE_4_TITLE" : " .detceted niarts evird €âroœ€â ecafrus evitcelfer no rekcart enil eht rehtie sI",
"HELP_TEXT_OR_EXAMPLE_5_TITLE" : ".3 eulav tnatsnoc eht ot lauqe si edoc etomer deviecer €âroœ€â 05 eulav tnatsnoc eht naht ssel ™€âretnuoC˜€â elbairav eht rehtie sI",

"HELP_TEXT_NOT_TITLE" : "toN",
"HELP_TEXT_NOT_BODY_1" : ".kcolb gnisnes ro kcolb rotarepo na rehtie eb nac taht skcolb depahs dnomaid stpecca tupni ehT  .eslaf eb lliw tuptuo eht neht neht ,eurt si tupni eht fI .eurt eb lliw tuptuo eht neht ,eslaf si tupni eht fI .eurt €âtonœ€â si tupni eht fi senimreted kcolb ™€âton˜€â ehT",
"HELP_TEXT_NOT_BODY_2" : ".eslaf ro eurt rehtie eb ylno nac kcolb eht fo tluser eht os kcolb depahs dnomaid a si kcolb ™€âton˜€â ehT",
"HELP_TEXT_NOT_EXAMPLE_1_BODY" : "eslaf :tluseR",
"HELP_TEXT_NOT_EXAMPLE_2_BODY" : "eurt :tluseR",
"HELP_TEXT_NOT_EXAMPLE_3_TITLE" : ".deviecer ton 0 edoc etomer sI",
"HELP_TEXT_NOT_EXAMPLE_4_TITLE" : ")etomeRdE eht htiw tseb skrow( dnammoc lortnoc etomer no nipS :margorp elpmaxE",
"HELP_TEXT_NOT_EXAMPLE_4_BODY" : ".nwod dleh si nottub etomer eht elihw gninnips nosidE ni stluser sihT .pool reverof eht fo trats eht ot pool neht dna srotom htob pots ot sessergorp margorp eht ,sneppah siht nehW .)desserp gnieb regnol on si nottub lortnoc-etomer eht( 0 edoc etomer eb ton tsum edoc etomer deviecer eht ,ssap oT .sessap noitidnoc kcolb ™€âlitnu tiaw˜€â eht litnu seunitnoc sihT .thgir tobor eht nips ot tes era srotom htob neht ,eurt si siht fI .deviecer neeb sah 0 edoc etomer fi stset kcolb ™€âneht fi˜€â eht pool reverof eht edisnI .pool reverof a gniretne yb snigeb margorp eht ,elpmaxe siht nI",

"HELP_TEXT_COMMENT_TITLE" : "tnemmoc",
"HELP_TEXT_COMMENT_BODY_1" : ".ti etorw uoy retfa emit gnol a margorp ruoy tide ot deen uoy ro margorp ruoy tide ot sdeen esle enoemos nehw spleh margorp a ni stnemmoc gnikaM .krow ot dednetni si margorp eht woh egaugnal nialp ni ebircsed seton ehT .margorp a ot seton dda ot desu si kcolb ™€âtnemmoc˜€â ehT",
"HELP_TEXT_COMMENT_BODY_2" : ".margorp ruoy fo ruoivaheb eht egnahc ton od os nosidE otni demmargorp ton era stnemmoc",
"HELP_TEXT_COMMENT_EXAMPLE_1_TITLE" : " egaugnal nialp ni skrow margorp eht woh nialpxe stnemmoC :margorp elpmaxE",

"HELP_TEXT_SEND_USB_TITLE" : "BSU aiv dnes",
"HELP_TEXT_SEND_USB_BODY_1" : ".kcolb rotarepo na ro gnisnes a ,elbairav a ,)yrav ton seod dna tupni eht otni depyt( tnatsnoc a eb rehtie nac eulav ehT .noitcennoc BSU eht aiv retupmoc a ot eulav a stimsnart kcolb ™€âBSU aiv dnes˜€â ehT",
"HELP_TEXT_SEND_USB_BODY_2" : " .wodniw BSU morf ataD eht ni raeppa lliw 3V nosidE eht morf deviecer atad ehT .tobor 3V nosidE eht ot tcennoc ot BSU nuR kcilC .raeppa lliw wodniw pu-pop a dna hctarcSdE ni nottub BSU eht kcilc ,retupmoc eht no rebmun eht ees oT",
"HELP_TEXT_SEND_USB_BODY_3" : ".margorp a gubed pleh ot desu eb osla nac kcolb ™€âBSU ot dnes˜€â ehT",
"HELP_TEXT_SEND_USB_BODY_4" : " .trop BSU a ot detcennoc elihw rotom a evird ot elba eb ot nerdlihc rof dednetni stcudorp wolla ton od taht sdradnats ytefas lanoitanretni ot eud si sihT .BSU ot detcennoc elihw evird ton lliw sleehw 3V nosidE ehT",
"HELP_TEXT_SEND_USB_EXAMPLE_1_TITLE" : "level thgil erusaeM :margorp elpmaxE",
"HELP_TEXT_SEND_USB_EXAMPLE_1_BODY" : ".staeper dna dnoces eno stiaw neht margorp ehT .BSU aiv rosnes thgil tfel eht fo level thgil eht sdnes pool eht edisni kcolb tsrif ehT .pool reverof a gniretne yb strats margorp eht ,elpmaxe siht nI",

"HELP_TEXT_SAVE_USB_TITLE" : "ot evas dna atad BSU rof tiaw",
"HELP_TEXT_SAVE_USB_BODY_1" : " .elbairav a otni atad eht secalp neht dna BSU aiv deviecer si atad litnu margorp eht sesuap kcolb ™€âot evas dna atad BSU rof tiaw˜€â ehT",
"HELP_TEXT_SAVE_USB_BODY_2" : " .trop BSU a ot detcennoc elihw rotom a evird ot elba eb ot nerdlihc rof dednetni stcudorp wolla ton od taht sdradnats ytefas lanoitanretni ot eud si sihT .BSU ot detcennoc elihw evird ton lliw sleehw 3V nosidE ehT",
"HELP_TEXT_SAVE_USB_EXAMPLE_1_TITLE" : "BSU morf speeb fo rebmuN :margorp elpmaxE",
"HELP_TEXT_SAVE_USB_EXAMPLE_1_BODY_1" : ".BSU aiv tnes semit fo rebmun eht gnipeeb nosidE ni stluser sihT .nur skcolb ™€âces tiaw˜€â dna kcolb ™€âpeeb˜€â eht kcolb ™€âtaeper˜€â eht edisnI .elbairav ™€âtnuoC˜€â eht fo eulav eht rof staeper hcihw kcolb taeper eht ot sessergorp neht margorp ehT .™€âtnuoC˜€â elbairav eht ot devas si atad eht ,deviecer si atad nehW .BSU morf deviecer si atad litnu stiaw pool eht edisni kcolb tsrif ehT .pool reverof a gniretne yb strats margorp eht ,elpmaxe siht nI",
"HELP_TEXT_SAVE_USB_EXAMPLE_1_BODY_2" : "  .nottub ™€âBSU ot dneS˜€â eht kcilc dna xob ™€âBSU ot ataD˜€â eht otni rebmun a epyt ,3V nosidE eht ot atad dnes oT .tobor 3V nosidE eht ot tcennoc ot BSU nuR kcilC .raeppa lliw wodniw pu-pop a dna ppa hctarcSdE eht ni nottub BSU eht kcilc ,margorp siht tset oT",

"HELP_TEXT_FUNCTION_START_TITLE" : "trats noitcnuF",
"HELP_TEXT_FUNCTION_START_BODY_1" : ".noitcnuf motsuc a etaerc ot kcolb trats noitcnuf eht ot skcolb tcennoC .snigeb noitcnuf ruoy erehw si kcolb trats noitcnuf ehT",
"HELP_TEXT_FUNCTION_START_BODY_2" : "  .ecno nettirw eb ot deen ylno margorp a fo strap evititeper eht sa margorp a fo ezis eht ecuder ot pleh osla snoitcnuF .daer ot reisae ti gnikam depuorg eb nac edoc eht sa margorp a yfilpmis ot pleh skcolb noitcnuF",
"HELP_TEXT_FUNCTION_START_BODY_3" : ".skcolb trats noitcnuf rednu decalp eb tonnac skcolb llac noitcnuF",
"HELP_TEXT_FUNCTION_START_EXAMPLE_1_TITLE" : "erauqs a fo epahs eht ni evirD :1 margorp elpmaxE",
"HELP_TEXT_FUNCTION_START_EXAMPLE_1_BODY" : "  .erauqs a ni gnivird nosidE ni stluser sihT .pool taeper eht edisni semit ruof dellac si noitcnuf sihT .seerged 09 thgir nips neht ,mc01 sdrawrof evird ot detcurtsni si tobor eht kcolb siht rednU .kcolb trats noitcnuf gnidnopserroc eht ot spmuj ti kcolb siht ot steg margorp eht nehW .™€ânruTdnAevirD˜€â deman llac noitcnuf a si kcolb taeper eht edisnI .pool semit ruof rof taeper a gniretne yb strats margorp eht ,elpmaxe siht nI",
"HELP_TEXT_FUNCTION_START_EXAMPLE_2_TITLE" : " selcatsbo dna senil diovA :2 margorp elpmaxE",
"HELP_TEXT_FUNCTION_START_EXAMPLE_2_BODY" : ".stceted ti stcejbo dna senil morf yawa gnivird nosidE ni stluser sihT .ffo tfel ti erehw margorp niam eht ot kcab stixe dna ffo sDEL eht snrut dna seerged 571 snips ,sdrawkcab sevird ,speeb ,thgil DEL eht no snrut ,srotom eht spots neht margorp ehT .™€âdnuorAnruT˜€â kcolb trats noitcnuf eht ot pmuj ot margorp eht sesuac ™€âdnuorAnruT˜€â kcolb llac noitcnuf eht neht ,eurt fi ,)kcalb( evitcelfer-non si ecafrus eht fi stset kcolb ™€âneht fi˜€â txen ehT .ffo tfel ti erehw margorp niam eht ot kcab stixe dna ffo sDEL eht snrut dna seerged 571 snips ,sdrawkcab sevird ,speeb ,thgil DEL eht no snrut ,srotom eht spots neht margorp ehT .™€âdnuorAnruT˜€â kcolb trats noitcnuf eht ot pmuj ot margorp eht sesuac ™€âdnuorAnruT˜€â kcolb llac noitcnuf eht neht ,eurt fi ,detceted elcatsbo yna rof stset kcolb ™€âneht fi˜€â eht ,txeN .drawrof evird ot tes era srotom htob pool reverof eht edisnI .pool reverof a sretne neht dna DEL rekcart enil dna rotceted elcatsbo eht no gninrut yb strats margorp eht ,elpmaxe siht nI",

"HELP_TEXT_FUNCTION_CALL_TITLE" : "llac noitcnuF",
"HELP_TEXT_FUNCTION_CALL_BODY_1" : " .kcolb trats noitcnuf eht ot pmuj ot margorp eht sllet kcolb llac noitcnuf ehT",
};

Blockly.ScratchMsgs.locales['en'] ={
	"CONTROL_FOREVER" : "forever",
	"CONTROL_REPEAT" : "repeat",
	"CONTROL_IF" : "if",
	"CONTROL_THAN" : "then",
	"CONTROL_ELSE" : "else",
	"CONTROL_STOP" : "stop",
	"CONTROL_STOP_ALL" : "all",
	"CONTROL_WAIT" : "wait",
	"CONTROL_WAIT_SEC" : "sec",
	"CONTROL_WAIT_MILLISECONDS" : "milliseconds",
	"CONTROL_WAITUNTIL" : "wait until",
	"CONTROL_REPEATUNTIL" : "repeat until",
	"DATA_BUTTONCREATE" : "Make a variable",
	"DATA_BUTTONMANAGE" : "Manage variables",
	"DATA_SET" : "set",
	"DATA_TO" : "to",
	"DATA_INCVARIABLE" : "increment",
	"DATA_DECVARIABLE" : "decrement",
	"DATA_BITSHIFT" : "bit shift",
	"DATA_BITSHIFTLEFT" : "left by",
	"DATA_BITSHIFTRIGHT" : "right by",
	"EVENT_ANY_OBSTACLE" : "Any obstacle detected",
	"EVENT_OBSTACLE_AHEAD" : "Obstacle detected ahead",
	"EVENT_OBSTACLE_LEFT" : "Obstacle detected left",
	"EVENT_OBSTACLE_RIGHT" : "Obstacle detected right",
	"EVENT_CLAP" : "Clap detected",
	"EVENT_BUTTON_TRIANGLE" : "Triangle button pressed",
	"EVENT_BUTTON_ROUND" : "Round button pressed",
	"EVENT_LINE_REFLECTIVE" : "Line tracker on reflective surface",
	"EVENT_LINE_NON_REFLECTIVE" : "Line tracker on non-reflective surface",
	"EVENT_LINE_CHANGE" : "Line tracker changes surface",
	"EVENT_MESSAGE" : "IR message received",
	"EVENT_REMOTE" : "Remote code received",
	"EVENT_DRIVE_STRAIN" : "Drive strained",
	"EVENT_START" : "Start",
	"OPERATORS_RANDOM" : "random number between",
	"OPERATORS_AND" : "and",
	"OPERATORS_OR" : "or",
	"OPERATORS_NOT" : "not",
	"OPERATORS_ABS" : "abs",
	"OPERATORS_BETWEEN" : "is between",
	"SENSING_TURN_LINE_TRACKING_LED" : "turn line tracking LED",
	"SENSING_TURN_OBSTACLE_BEAM" : "turn obstacle detection beam",
	"SENSING_CLEAR" : "clear",
	"SENSING_SENSOR" : "sensor data",
	"SENSING_CLAP_DETECTED" : "clap detected",
	"SENSING_BUTTON_PRESSED" : "button pressed",
	"SENSING_OBSTACLE" : "obstacle detected",
	"SENSING_LINE_TRACKER" : "line tracker on",
	"SENSING_LINE_SURFACE" : "surface",
	"SENSING_REMOTE_NUM" : "received remote code",
	"SENSING_REMOTE_BOOL" : "remote code",
	"SENSING_REMOTE_RECEIVED" : "received",
	"SENSING_IR_MESSAGE_DETECTED" : "IR message detected",
	"SENSING_IR_MESSAGE" : "received IR message",
	"SENSING_LIGHT_LEVEL" : "light level of",
	"SENSING_LIGHT_SENSOR" : "sensor",
	"SENSING_DRIVE_STRAIN" : "drive strain detected",
	"SENSING_DROPDOWN_ON" : "on",
	"SENSING_DROPDOWN_OFF" : "off",
	"SENSING_CLEAR_DROPDOWN_CLAP" : "clap detector",
	"SENSING_CLEAR_DROPDOWN_KEY" : "keypad",
	"SENSING_CLEAR_DROPDOWN_OBS" : "obstacle detector",
	"SENSING_CLEAR_DROPDOWN_REMOTE" : "remote code",
	"SENSING_CLEAR_DROPDOWN_IR" : "IR message",
	"SENSING_KEY_DROPDOWN_ROUND" : "round",
	"SENSING_KEY_DROPDOWN_TRIANGLE" : "triangle",
	"SENSING_OBS_DROPDOWN_ANY" : "anywhere",
	"SENSING_OBS_DROPDOWN_AHEAD" : "ahead",
	"SENSING_OBS_DROPDOWN_LEFT" : "left",
	"SENSING_OBS_DROPDOWN_RIGHT" : "right",
	"SENSING_LINE_DROPDOWN_WHITE" : "reflective",
	"SENSING_LINE_DROPDOWN_BLACK" : "non-reflective",
	"SENSING_LIGHT_DROPDOWN_LEFT" : "left light",
	"SENSING_LIGHT_DROPDOWN_RIGHT" : "right light",
	"SENSING_LIGHT_DROPDOWN_LINE" : "line tracking",
	"COMMENT_USER_COMMENT" : "comment:",
	"ADVANCED_USB_SEND_DATA" : "send",
	"ADVANCED_USB_SEND_VIA" : "via USB",
	"ADVANCED_USB_RECEIVED_DATA" : "data received from USB",
	"ADVANCED_USB_RECEIVED_DATA_VAR" : "wait for USB data and save to",
	"SOUND_BEEP" : "beep",
	"SOUND_PLAY_NOTE" : "play a",
	"SOUND_PLAY_NOTE_DROP_DURATION_WHOLE" : "whole",
	"SOUND_PLAY_NOTE_DROP_DURATION_HALF" : "half",
	"SOUND_PLAY_NOTE_DROP_DURATION_QUARTER" : "quarter",
	"SOUND_PLAY_NOTE_DROP_DURATION_EIGHTH" : "eighth",
	"SOUND_PLAY_NOTE_DROP_NOTE_C" : "C",
	"SOUND_PLAY_NOTE_DROP_NOTE_B" : "B",
	"SOUND_PLAY_NOTE_DROP_NOTE_A" : "A",
	"SOUND_PLAY_NOTE_DROP_NOTE_G" : "G",
	"SOUND_PLAY_NOTE_DROP_NOTE_F" : "F",
	"SOUND_PLAY_NOTE_DROP_NOTE_E" : "E",
	"SOUND_PLAY_NOTE_DROP_NOTE_D" : "D",
	"SOUND_PLAY_NOTE_DROP_NOTE_MID_C" : "middle C",
	"SOUND_PLAY_NOTE_DROP_NOTE_LOW_B" : "low B",
	"SOUND_PLAY_NOTE_DROP_NOTE_REST" : "rest",
	"SOUND_PLAY_NOTE_DROP_MOD_SHARP" : "sharp",
	"SOUND_PLAY_NOTE_DROP_MOD_FLAT" : "flat",
	"SOUND_SET_TEMPO" : "set music tempo to",
	"SOUND_SET_TEMPO_DROP_VERY_SLOW" : "very slow",
	"SOUND_SET_TEMPO_DROP_SLOW" : "slow",
	"SOUND_SET_TEMPO_DROP_MEDIUM" : "medium",
	"SOUND_SET_TEMPO_DROP_FAST" : "fast",
	"SOUND_SET_TEMPO_DROP_VERY_FAST" : "very fast",
	"SOUND_PLAY_IN_BACKGROUND" : "play music in background",
	"CATEGORY_SOUND" : "Sound",
	"CATEGORY_EVENTS" : "Events",
	"CATEGORY_CONTROL" : "Control",
	"CATEGORY_SENSING" : "Sensing",
	"CATEGORY_OPERATORS" : "Operators",
	"CATEGORY_VARIABLES" : "Variables",
	"CATEGORY_MYBLOCKS" : "Functions",
	"CATEGORY_DRIVE" : "Drive",
	"CATEGORY_COMMENT" : "Comment",
	"CATEGORY_LED" : "LEDs",
	"CATEGORY_ADVANCED" : "Advanced",
	"DUPLICATE" : "Duplicate",
	"DELETE" : "Delete",
	"DELETE_BLOCK" : "Delete Block",
	"CONTEXT_DELETE" : "Delete",
	"CONTEXT_DELETE_ALL" : "Delete all",
	"CONTEXT_BLOCKS" : "Blocks",
	"CLEAN_UP" : "Clean up Blocks",
	"HELP" : "Help",
	"UNDO" : "Undo",
	"REDO" : "Redo",
	"CHANGE_VALUE_TITLE" : "Change value:",
	"RENAME_VARIABLE" : "Rename variable",
	"RENAME_VARIABLE_MODAL_TITLE" : "Rename Variable",
	"NEW_VARIABLE" : "Make a Variable",
	"NEW_VARIABLE_TITLE" : "New variable name:",
	"VARIABLE_MODAL_TITLE" : "New Variable",
	"NEW_PROCEDURE" : "Make a function",
	"MANAGE_PROCEDURE" : "Manage a function",
	"PROCEDURE_DEFAULT_NAME" : "block name",
	"PROCEDURE_USED" : "To delete a block definition, first remove all uses of the block",
	"DRIVE_FORWARDS_DISTANCE" : "forwards for",
	"DRIVE_BACKWARDS_DISTANCE" : "backwards for",
	"DRIVE_LEFT_DISTANCE" : "left for",
	"DRIVE_RIGHT_DISTANCE" : "right for",
	"DRIVE_DISTANCE_DROPDOWN_CM" : "cm",
	"DRIVE_DISTANCE_DROPDOWN_INCH" : "inch",
	"DRIVE_DISTANCE_DROPDOWN_SECONDS" : "seconds",
	"DRIVE_DISTANCE_DROPDOWN_DEGREES" : "degrees",
	"DRIVE_TURN_DROPDOWN_SPIN" : "spin",
	"DRIVE_TURN_DROPDOWN_FORWARDS" : "turn forwards",
	"DRIVE_TURN_DROPDOWN_BACKWARDS" : "turn backwards",
	"DRIVE_FORWARDS_UNTIL" : "forwards until",
	"DRIVE_BACKWARDS_UNTIL" : "backwards until",
	"DRIVE_LEFT_UNTIL" : "left until",
	"DRIVE_RIGHT_UNTIL" : "right until",
	"DRIVE_SET_LEFT_MOTOR" : "set left motor to",
	"DRIVE_SET_RIGHT_MOTOR" : "set right motor to",
	"DRIVE_SET_MOTOR_DROPDOWN_FORWARDS" : "forwards",
	"DRIVE_SET_MOTOR_DROPDOWN_BACKWARDS" : "backwards",
	"DRIVE_SET_BOTH_MOTOR" : "set both motors to",
	"DRIVE_SET_BOTH_MOTOR_DROPDOWN_FORWARDS" : "drive forwards",
	"DRIVE_SET_BOTH_MOTOR_DROPDOWN_BACKWARDS" : "drive backwards",
	"DRIVE_SET_BOTH_MOTOR_DROPDOWN_SPIN_LEFT" : "spin robot left",
	"DRIVE_SET_BOTH_MOTOR_DROPDOWN_SPIN_RIGHT" : "spin robot right",
	"DRIVE_SET_BOTH_MOTOR_DROPDOWN_TURN_LEFT" : "turn robot left",
	"DRIVE_SET_BOTH_MOTOR_DROPDOWN_TURN_RIGHT" : "turn robot right",
	"DRIVE_AT_SPEED" : "at speed",
	"DRIVE_STOP" : "stop",
	"DRIVE_STOP_DROPDOWN_BOTH" : "both motors",
	"DRIVE_STOP_DROPDOWN_LEFT" : "left motor",
	"DRIVE_STOP_DROPDOWN_RIGHT" : "right motor",
  "LED_LEFT" : "left LED",
  "LED_RIGHT" : "right LED",
	"LED_DROPDOWN_ON" : "on",
	"LED_DROPDOWN_OFF" : "off",
	"LED_SEND_MESSAGE" : "send IR message",
	"DEMO_TEST_PROGRAM" : "Test program",
	"DEMO_TEST_PROGRAM_DISC" : "Tests drive, LEDs and speaker",
	"DEMO_MOVE_WITH_MUSIC" : "Move with music",
	"DEMO_MOVE_WITH_MUSIC_DISC" : "Drive while playing music",
	"DEMO_FOLLOW_A_LINE" : "Follow a line",
	"DEMO_FOLLOW_A_LINE_DISC" : "Use the line sensor to follow a black line",
	"DEMO_BOUNCE_IN_BORDERS" : "Bounce in borders",
	"DEMO_BOUNCE_IN_BORDERS_DISC" : "Use the line sensor to stay inside a black line border",
	"DEMO_WARNINGS" : "Warning messages demo",
	"DEMO_WARNINGS_DISC" : "Demonstrates red error messages and yellow warning messages",
	"DEMO_CLAP_CONTROL" : "Clap controlled driving",
	"DEMO_CLAP_CONTROL_DISC" : "Clap once to turn, clap twice to drive forwards",
	"DEMO_AVOID_OBSTACLES" : "Avoid obstacles",
	"DEMO_AVOID_OBSTACLES_DISC" : "Use the obstacle sensor to avoid driving into obstacles",
	"DEMO_FOLLOW_TORCH" : "Follow a torch",
	"DEMO_FOLLOW_TORCH_DISC" : "Use the light sensors to follow a flash light",
	"DEMO_FOLLOW_A_LINE_IF" : "Follow a line using if statements",
	"DEMO_FOLLOW_A_LINE_IF_DISC" : "A different way to use the line sensor to follow a line using an if block",
	"MENU_DROP_MENU" : "Menu",
	"MENU_DROP_NEW" : "New",
	"MENU_DROP_LOAD_DEMO" : "Load demo",
	"MENU_DROP_LOAD_LOCAL" : "Load from computer",
	"MENU_DROP_SAVE_LOCAL" : "Save to computer",
	"MENU_DROP_UPDATE_FIRMWARE" : "Update firmware",
	"MENU_DROP_DIAGNOSTICS" : "Diagnostics",
	"MENU_DROP_LANGUAGE_LABEL" : "Language",
	"MENU_DROP_ABOUT" : "About",
	"MENU_DROP_TERMS" : "Terms of use",
	"MENU_USB" : "USB",
	"MENU_SAVE" : "Save",
	"MENU_VERSION_MAIN" : "Edison V3",
	"MENU_VERSION_SWITCH" : "Switch to Edison V1/V2",
	"MENU_VERSION_WHICH_VERSION" : "Which version do I have?",
	"MENU_PROGRAM" : "Program",
	"MENU_PROGRAM_FLASH" : "Program",
	"MODAL_CREATE_VAR" : "Create Variable",
	"MODAL_CREATE_VAR_NAME" : "Variable Name",
	"MODAL_CREATE_VAR_BUTTON" : "Create Variable",
	"MODAL_CREATE_VAR_EXIT" : "Exit",
	"MODAL_CREATE_VAR_SUCCESS" : "New variable created successfully.",
	"MODAL_MANAGE_VAR" : "Variables",
	"MODAL_MANAGE_VAR_NAME" : "Variable Name",
	"MODAL_MANAGE_VAR_ACTION" : "Action",
	"MODAL_MANAGE_VAR_BUTTON_DELETE" : "delete",
	"MODAL_MANAGE_VAR_BUTTON_RENAME" : "rename",
	"MODAL_MANAGE_VAR_BUTTON_CONFIRM" : "confirm",
	"MODAL_MANAGE_VAR_BUTTON_CANCEL" : "cancel",
	"MODAL_MANAGE_VAR_CONFIRM_NOT_CHANGED" : "You did not change the variable name. Please try again.",
	"MODAL_MANAGE_VAR_CONFIRM_SUCCESS" : "Variable renamed successfully!",
	"MODAL_MANAGE_VAR_NAME_NONE" : "Please enter a variable name.",
	"MODAL_MANAGE_VAR_NAME_IN_USE" : "You already have a variable with that name.",
	"MODAL_MANAGE_VAR_NAME_UNSUPPORTED" : "Variable name contains an unsupported character. Variable names can only contain lowercase English letters, uppercase English letters, numbers, and underscores ( _ ).",
	"MODAL_MANAGE_VAR_NAME_NUMBER_START" : "Variable names cannot start with a number.",
	"MODAL_MANAGE_VAR_DELETE_IN_USE" : "This variable is currently being used in your program. Are you sure you want to delete it?",
	"MODAL_MANAGE_VAR_DELETE_CONFIRM" : "Yes",
	"MODAL_MANAGE_VAR_DELETE_DECLINE" : "No",
	"MODAL_CREATE_FUNCT" : "Create Function",
	"MODAL_CREATE_FUNCT_NAME" : "Function Name",
	"MODAL_CREATE_FUNCT_WARNING" : "Alphanumeric characters only and must begin with a letter.",
	"MODAL_CREATE_FUNCT_BUTTON" : "Create Function",
	"MODAL_CREATE_FUNCT_BUTTON_EXIT" : "Exit",
	"MODAL_CREATE_FUNCT_SUCCESS" : "New function created successfully.",
	"MODAL_MANAGE_FUNCT" : "Functions",
	"MODAL_MANAGE_FUNCT_NAME" : "Function Name",
	"MODAL_MANAGE_FUNCT_ACTION" : "Action",
	"MODAL_MANAGE_FUNCT_BUTTON_DELETE" : "delete",
	"MODAL_MANAGE_FUNCT_BUTTON_RENAME" : "rename",
	"MODAL_MANAGE_FUNCT_BUTTON_CONFIRM" : "confirm",
	"MODAL_MANAGE_FUNCT_BUTTON_CANCEL" : "cancel",
	"MODAL_MANAGE_FUNCT_CONFIRM_NOT_CHANGED" : "You did not change the function name. Please try again.",
	"MODAL_MANAGE_FUNCT_CONFIRM_SUCCESS" : "Function renamed successfully!",
	"MODAL_MANAGE_FUNCT_NAME_NONE" : "Please enter a function name.",
	"MODAL_MANAGE_FUNCT_NAME_IN_USE" : "You already have a function with that name.",
	"MODAL_MANAGE_FUNCT_NAME_START_WITH" : "User function names cannot start with",
	"MODAL_MANAGE_FUNCT_NAME_UNSUPPORTED" : "Function name contains an unsupported character. Function names can only contain lowercase English letters, uppercase English letters, numbers, and underscores ( _ ).",
	"MODAL_MANAGE_FUNCT_NAME_NUMBER_START" : "Function names cannot start with a number.",
	"MODAL_MANAGE_FUNCT_DELETE_IN_USE" : "This function is currently being used in your program. Are you sure you want to delete it?",
	"MODAL_MANAGE_FUNCT_DELETE_CONFIRM" : "Yes",
	"MODAL_MANAGE_FUNCT_DELETE_DECLINE" : "No",
	"MODAL_SAVE_TITLE" : "Save to computer",
	"MODAL_SAVE_PROG_TITLE" : "Program name",
	"MODAL_SAVE_BUTTON" : "Save to computer",
	"MODAL_SAVE_ERROR_NO_NAME" : "Please enter a name for your program. You need to name the program in order to save it.",
	"MODAL_SAVE_ERROR_LONG_NAME" : "Whoops. There's a problem with that program name. Program names can be a maximum of 255 characters long.",
	"MODAL_SAVE_SAVING" : "OK! Your program is being saved. The download of your program should begin soon.",
	"MODAL_LOAD_PC_TITLE" : "Load from computer",
	"MODAL_LOAD_PC_FILE_ERROR_1" : "Please select an EdScratch save file.",
	"MODAL_LOAD_PC_FILE_ERROR_2" : "All EdScratch save files are file type",
	"MODAL_LOAD_PC_FILE_ERROR_3" : ".edscratch",
	"MODAL_LOAD_PC_FILE_BUTTON" : "Select a file to upload...",
	"MODAL_LOAD_PC_BUTTON" : "Load program",
	"MODAL_LOAD_PC_NO_FILE_ERROR_1" : "You haven't selected a file yet. Please first select an EdScratch save file from your computer, then load the file. [All EdScratch save files are file type (.edscratch).]",
	"MODAL_LOAD_PC_FILE_DATA_ERROR_1" : "Uh-oh. There's a problem with the data in that file.",
	"MODAL_LOAD_PC_FILE_DATA_ERROR_2" : "Please upload a different EdScratch save file. [All EdScratch save files are file type (.edscratch).]",
	"MODAL_LOAD_PC_FILE_TYPE_ERROR_1" : "Uh-oh. You've uploaded an incorrect file type.",
	"MODAL_LOAD_PC_FILE_TYPE_ERROR_2" : "Please upload an EdScratch save file. [All EdScratch save files are file type (.edscratch).]",
	"MODAL_LOAD_PC_FILE_READY" : "Ready to load program:",
	"MODAL_LOAD_DEMO_TITLE" : "Load demo",
	"MODAL_LOAD_DEMO_BUTTON" : "Load program",

  "MODAL_COOKIES_TITLE" : "Cookies",
  "MODAL_COOKIES_BODY_1" : "We use Google Analytics to measure how visitors use this web app so we can improve it based on user needs. For instance, which options visitors use most often, and if they get error messages from the web app. These cookies don't collect information that identifies a visitor.",
  "MODAL_COOKIES_BODY_2" : "We do not allow Google to use or share the data about how you use this site and all information these cookies collect is aggregated and therefore anonymous. It is only used to improve how the web app works. This cookie is stored for a period of one year.",
  "MODAL_COOKIES_ACCEPT" : "Accept cookies",
  "MODAL_COOKIES_BUTTON_YES" : "Yes",
  "MODAL_COOKIES_BUTTON_NO" : "No",
  "MODAL_ABOUT_TITLE" : "About EdScratch",
	"MODAL_ABOUT_COPYRIGHT" : "Copyright 2023 Microbric Pty Ltd",
	"MODAL_ABOUT_BODY_1" : "The EdScratch app was developed using the Scratch Blocks code base developed by MIT. Scratch Blocks was built on the Blockly code base developed by Google.",
	"MODAL_ABOUT_BODY_2" : "Contributions and credits:",
	"MODAL_ABOUT_BODY_3" : "EdScratch programming language and block compiler developed by Ben Hayton, Microbric",
	"MODAL_ABOUT_BODY_4" : "EdScratch user interface developed by Sean Killian, Killian Web Development",
	"MODAL_ABOUT_BODY_5" : "Edison V3 firmware developed by Damien George, George Robotics (MicroPython code base)",
	"MODAL_LANGUAGE" : "Language",
	"MODAL_DIAGNOSTICS" : "Diagnostics",
	"MODAL_DIAGNOSTICS_CONNECT_ISSUES_TITLE" : "Connectivity issues",
	"MODAL_DIAGNOSTICS_CONNECT_ISSUES_BODY" : "To ensure that your program can be compiled and sent to the Edison robot, it is a good idea to check your connection with the EdScratch compiler.",
	"MODAL_DIAGNOSTICS_CONNECT_ISSUES_BUTTON" : "Run the connection checker",
	"MODAL_DIAGNOSTICS_FIRMWARE_TITLE" : "Fix firmware",
	"MODAL_DIAGNOSTICS_FIRMWARE_BODY" : "If Edison V3 isn't behaving as expected, it might be a firmware issue. Click Fix firmware to push a firmware update.",
	"MODAL_DIAGNOSTICS_FIRMWARE_BUTTON" : "Fix firmware",
	"MODAL_DIAGNOSTICS_PROGRAMMING_TITLE" : "Programming method",
	"MODAL_DIAGNOSTICS_PROGRAMMING_BODY" : "This option enables you to swtich between USB and screen flash programming on this device.",
	"MODAL_DIAGNOSTICS_PROGRAMMING_BUTTON" : "Change programming method",
	"MODAL_DIAGNOSTICS_IR_TITLE" : "Clear learned IR remote commands",
	"MODAL_DIAGNOSTICS_IR_BODY" : "This option allows you to clear all learned IR remote control commands from an Edison V3 robot.",
	"MODAL_DIAGNOSTICS_IR_BUTTON" : "Clear remote codes",
	"MODAL_DIAGNOSTICS_IR_SUCCESS" : "Remote codes have been cleared.",
	"MODAL_DIAGNOSTICS_IR_ERROR" : "An error has occurred.",
	"MODAL_CONNECTION" : "Connection",
	"MODAL_CONNECTION_TEST_1" : "If the test above has the result",
	"MODAL_CONNECTION_TEST_EXAMPLE" : "NO SERVER FOUND",
	"MODAL_CONNECTION_TEST_2" : "then a firewall may be blocking access to the compiler.",
	"MODAL_CONNECTION_TEST_3" : "To rectify this, ask your network administrator to whitelist these addresses:",
	"MODAL_CONNECTION_PORTS" : "The network administrator also needs to unblock ports 80, 8080, 443 and 8443.",
	"MODAL_CONNECTION_BACK" : "Back to diagnostics",
	"MODAL_CONNECTION_SERVER" : "Server:",
	"MODAL_CONNECTION_SERVER_SEARCHING" : "searching",
	"MODAL_CONNECTION_SERVER_NONE" : "NO SERVER FOUND",
	"MODAL_CONNECTION_COMIPLE_TEST" : "Compile Test:",
	"MODAL_CONNECTION_COMIPLE_TEST_WORKING" : "working",
	"MODAL_CONNECTION_COMIPLE_TEST_ERROR" : "compile error",
	"MODAL_CONNECTION_COMIPLE_TEST_COMPLETE" : "compile complete in",
	"MODAL_STATUS_TITLE" : "Fix firmware",
	"MODAL_STATUS_BUTTON" : "Connect Edison",
	"MODAL_STATUS_STATUS_LABEL" : "Status:",
	"MODAL_STATUS_STATUS_NOT_CONNECTED" : "not connected",
	"MODAL_STATUS_STATUS_CONNECTED" : "connected",
	"MODAL_STATUS_FIRMWARE_LABEL" : "Firmware version:",
	"MODAL_STATUS_FIRMWARE_BOOT_MODE" : "bootloader mode",
	"MODAL_STATUS_FIRMWARE_FACTORY_MODE" : "factory application mode",
	"MODAL_STATUS_FIRMWARE_USER_MODE" : "user application mode",
	"MODAL_STATUS_FIRMWARE_TAG" : "firmware",
	"MODAL_STATUS_BOOT_TAG" : "boot",
	"MODAL_STATUS_FIRMWARE_UPDATE" : "A firmware update",
	"MODAL_STATUS_FIRMWARE_UPDATE_AVAILABLE" : "is available",
	"MODAL_STATUS_BOOT_UPDATE" : "A boot update",
	"MODAL_STATUS_FIRMWARE_UPDATE_BUTTON" : "Force firmware update",
	"MODAL_STATUS_FIRMWARE_UP_TO_DATE" : "Your Edison is up to date.",
	"MODAL_PROGRAMING_METHOD_TITLE" : "Programming method",
	"MODAL_PROGRAMING_METHOD_BODY" : "Screen flash programming has been developed for Apple iPads. This is because Apple do not allow normal access to the iPad's data port. Therefore, screen flash programming is only fully supported for iPads. However, the screen flasher does work with some Android devices. The option below enables screen flash programming on this device. If this device is not an iPad then it is not guaranteed to work.",
	"MODAL_PROGRAMING_METHOD_CURRENT_LABEL" : "Currently using",
	"MODAL_PROGRAMING_METHOD_CURRENT_LABEL_USB" : "USB",
	"MODAL_PROGRAMING_METHOD_CURRENT_LABEL_FLASH" : "FLASH",
	"MODAL_PROGRAMING_METHOD_CURRENT_LABEL_METHOD" : "method.",
	"MODAL_PROGRAMING_METHOD_BUTTON_USB" : "Set to USB method",
	"MODAL_PROGRAMING_METHOD_BUTTON_FLASH" : "Set to FLASH method",
	"MODAL_PROGRAMING_METHOD_ACCORD_BUTTON_FLASH_GUARANTEE" : "Why is screen flashing not guaranteed to work with Android devices?",
	"MODAL_PROGRAMING_METHOD_ACCORD_BODY_FLASH_GUARANTEE" : "Android devices are made by many different manufacturers and there are thousands of different models. This means there is also a lot of different screen technologies. It is not possible to test and customise screen flashing for all Android devices.",
	"MODAL_PROGRAMING_METHOD_ACCORD_BUTTON_FLASH_SETTINGS" : "Are there settings that might help my Android device work with screen flashing?",
	"MODAL_PROGRAMING_METHOD_ACCORD_BODY_FLASH_SETTINGS" : "Yes, on the screen flash popup window there is a reliable/fast setting that has four positions. Try each one of the four positions. Also, try adjusting the screen brightness. Test with 50%, 75%, 90% and 100% brightness.",
	"MODAL_PROGRAMING_METHOD_ACCORD_BUTTON_FLASH_FAIL" : "What do I do if screen flashing does not work on my Android device?",
	"MODAL_PROGRAMING_METHOD_ACCORD_BODY_FLASH_FAIL" : "To program you will need to plug the Edison V3 cable into the Android device's data port via an adaptor cable. These are common and cheaply available from ebay, Amazon etc.",
	"MODAL_PROGRAMING_METHOD_BACK" : "Back to diagnostics",
	"MODAL_PROGRAMING_TITLE" : "Programming",
	"MODAL_PROGRAMING_TITLE_COMPLETE" : "Programming complete",
	"MODAL_PROGRAMING_TITLE_ERROR" : "Programming error",
	"MODAL_PROGRAMING_TIP_1_TITLE" : "Tip: Don't cluster Edison robots on a USB hub!",
	"MODAL_PROGRAMING_TIP_1_TEXT" : "Use an EdCharger instead.",
	"MODAL_PROGRAMING_TIP_2_TITLE" : "Tip: Don't leave Edison hanging!",
	"MODAL_PROGRAMING_TIP_2_TEXT" : "Keep Edison supported on a solid surface.",
	"MODAL_PROGRAMING_TIP_3_TITLE" : "Tip: Don't leave Edison hanging!",
	"MODAL_PROGRAMING_TIP_3_TEXT" : "Use an extension cable when charging from a power outlet.",
	"MODAL_PROGRAMING_TIP_4_TITLE" : "Tip: Don't pull on Edison!",
	"MODAL_PROGRAMING_TIP_4_TEXT" : "Unplug by pulling on the USB cable, not the robot.",
	"MODAL_PROGRAMING_ERROR_NO_BLOCK" : "Cannot download with no blocks connected to the start block.",
	"MODAL_PROGRAMING_ERROR_RED" : "Cannot download with Red Errors.",
	"MODAL_PROGRAMING_UPDATE_FIRMWARE" : "To program your Edison you will need to update the firmware to the latest version",
	"MODAL_PROGRAMING_UPDATE_FIRMWARE_BUTTON" : "Update firmware",
	"MODAL_PROGRAMING_UPDATE_FIRMWARE_NOW" : "Firmware updated required. Updating now...",
	"MODAL_PROGRAMING_FIRMWARE_UPDATED" : "Firmware updated.",
	"MODAL_PROGRAMING_FIRMWARE_UPDATED_NOW_PROGRAMMING" : "Now programming Edison...",
	"MODAL_PROGRAMING_FIRMWARE_UPDATE_INCOMPLETE" : "Incomplete firmware update.",
	"MODAL_PROGRAMING_DONE" : "OK! The program has loaded to your Edison.",
	"MODAL_PROGRAMING_ERROR_JSON" : "Response is not JSON!",
	"MODAL_PROGRAMING_ERROR_UNKNOWN" : "Unknown Error!",
	"MODAL_FIRMWARE_UPDATE_TITLE" : "Firmware update",
	"MODAL_FIRMWARE_UPDATE_LATEST" : "The latest Edison V3 firmware version is:",
	"MODAL_FIRMWARE_UPDATE_POPUP" : "Use this pop-up to update the firmware in your Edison.",
	"MODAL_FIRMWARE_UPDATE_TO_UPDATE1" : "To update Edison V3 firmware:",
	"MODAL_FIRMWARE_UPDATE_TO_UPDATE2" : "Plug in your Edison and click the Update firmware button below then follow the prompts.",
	"MODAL_FIRMWARE_UPDATE_TO_UPDATE_BUTTON" : "Update firmware",
	"MODAL_FIRMWARE_UPDATE_TO_RECONNECT_BUTTON" : "Reconnect Edison",
	"MODAL_FIRMWARE_UPDATE_FEEDBACK_START" : "Ready...",
	"MODAL_FIRMWARE_UPDATE_TWO_STEP_START" : "A two step firmware update is starting",
	"MODAL_FIRMWARE_UPDATE_BOOT_COMPLETE" : "Bootloader update complete.",
	"MODAL_FIRMWARE_UPDATE_PLEASE_CLICK" : "Please click",
	"MODAL_FIRMWARE_UPDATE_ISSUE_LOADING" : "Issue loading firmware",
	"MODAL_FIRMWARE_UPDATE_ONE_STEP_START" : "A firmware update is starting",
	"MODAL_FIRMWARE_UPDATE_ERROR_ISSUE_LOADING" : "Error: Issue loading firmware.",
	"MODAL_FIRMWARE_UPDATE_ERROR_ISSUE_DOWNLOADING" : "Error: Issue downloading firmware.",
	"MODAL_FIRMWARE_UPDATE_FIRM_COMPLETE" : "Firmware update complete.",
	"MODAL_FIRMWARE_UPDATE_NONE_NEEDED" : "No update required: the firmware on your Edison is up to date.",
	"MODAL_FIRMWARE_UPDATE_PROBLEMS" : "Having problems?",
	"MODAL_FIRMWARE_UPDATE_SEE_DIAG" : "See diagnostics",
	"MODAL_USB_CONTROL" : "USB Controls",
	"MODAL_USB_RUN_BUTTON" : "Run USB",
	"MODAL_USB_CONNECTED_STATUS" : "CONNECTED",
	"MODAL_USB_DISCONNECTED_STATUS" : "DISCONNECTED",
	"MODAL_USB_RUNNING_STATUS" : "RUNNING",
	"MODAL_USB_DATA_TO" : "Data to USB",
	"MODAL_USB_DATA_TO_BUTTON" : "Send to USB",
	"MODAL_USB_DATA_FROM" : "Data from USB",
	"MODAL_USB_DATA_FROM_CLEAR" : "Clear",
	"MODAL_USB_DATA_FROM_COPY" : "Copy to clipboard",
	"MODAL_USB_DATA_FROM_COPIED" : "Copied!",
	"MODAL_BAD_BROWSER_TITLE" : "Unsupported browser",
	"MODAL_BAD_BROWSER_USING" : "You appear to be using:",
	"MODAL_BAD_BROWSER_WEB_USB" : "The Edison V3 is programmed directly from your web browser via USB. This requires that your web browser supports USB connections.",
	"MODAL_BAD_BROWSER_UNFORTUNATLY" : "Unfortunately",
	"MODAL_BAD_BROWSER_UNSUPORTED" : "does not currently support USB connections, so cannot program your Edison V3 robot.",
	"MODAL_BAD_BROWSER_USE_CHROME" : "We recommend using Google Chrome.",
	"MODAL_BAD_BROWSER_GET_CHROME" : "Get Chrome.",
	"MODAL_LOADING" : "Loading workspace...",
	"MODAL_FLASHER_TITLE" : "Flasher",
	"MODAL_FLASHER_STEP_1" : "Place Edison over image",
	"MODAL_FLASHER_STEP_2" : "Press Edison's round button once",
	"MODAL_FLASHER_STEP_3" : "Press Download program",
	"MODAL_FLASHER_RELIABLE" : "Reliable",
	"MODAL_FLASHER_FAST" : "Fast",
	"MODAL_FLASHER_ADJUST_SPEED" : "If the download does not work or is not fast enough, try adjusting the speed above. The lowest speed is usually the most reliable.",
	"MODAL_FLASHER_DOWNLOAD" : "Download program",
	"MODAL_FLASHER_CANCEL" : "Cancel",
	"MODAL_FLASHER_TIPS_HEADING" : "Tips",
	"MODAL_FLASHER_TIPS_BODY_1" : "Adjust screen brightness between 80% to 90%.",
	"MODAL_FLASHER_TIPS_BODY_2" : "Move away from direct and in-direct sunlight or bright lights.",
	"MODAL_FLASHER_TIPS_BODY_3" : "Ensure you have updated Edison V3 to the latest firmware.",
	"MODAL_FLASHER_DOWNLOADING" : "Downloading...",
	"MODAL_FLASHER_COMPLETE" : "Complete",
	"MODAL_FLASHER_BYTES" : "bytes in",
	"MODAL_FLASHER_SECONDS" : "seconds",
	"ERROR_RED_OBS_SETTING" : "Obstacle detection blocks do not work unless the obstacle detection beam is turned on using the obstacle detection beam block from the Sensing category.",
	"ERROR_RED_OBS_SETTING_EVENT" : "Obstacle detection events do not work unless the obstacle detection beam is turned on using the obstacle detection beam block from the Sensing category in the main program.",
	"ERROR_RED_LINE_SETTING" : "Line detection blocks do not work unless the line detection LED is turned on using the line tracking LED block from the Sensing category.",
	"ERROR_RED_LINE_SETTING_EVENT" : "Line detection events do not work unless the line detection LED is turned on using the line tracking LED block from the Sensing category in the main program.",
	"ERROR_RED_DRIVE_CLAP" : "Edison cannot detect claps while driving because the motors are too noisy.",
	"ERROR_RED_EMPTY_IN_FORWARDS" : "Forwards until blocks need a condition input.",
	"ERROR_RED_EMPTY_IN_BACKWARDS" : "Backwards until blocks need a condition input.",
	"ERROR_RED_EMPTY_IN_LEFT" : "Left until blocks need a condition input.",
	"ERROR_RED_EMPTY_IN_RIGHT" : "Right until blocks need a condition input.",
	"ERROR_RED_EMPTY_IN_SET_VAR" : "Set variable blocks need a variable.",
	"ERROR_RED_EMPTY_IN_INC_VAR" : "Increment variable blocks need a variable.",
	"ERROR_RED_EMPTY_IN_DEC_VAR" : "Decrement variable blocks need a variable.",
	"ERROR_RED_EMPTY_IN_IF" : "If blocks need a condition input.",
	"ERROR_RED_EMPTY_IN_IF_ELSE" : "If-else blocks need a condition input.",
	"ERROR_RED_EMPTY_IN_WAIT" : "Wait until blocks need a condition input.",
	"ERROR_RED_EMPTY_IN_WAIT_MILLI" : "Wait milliseconds blocks need an input value.",
	"ERROR_RED_EMPTY_IN_REP" : "Repeat until blocks need a condition input.",
	"ERROR_RED_EMPTY_IN_BS_RIGHT" : "Bit shift right blocks need a variable.",
	"ERROR_RED_EMPTY_IN_BS_LEFT" : "Bit shift left blocks need a variable.",
	"ERROR_RED_EMPTY_IN_OPERATOR_NOT" : "Not blocks need a condition input.",
	"ERROR_RED_EMPTY_IN_OPERATOR_AND" : "And blocks need a condition input.",
	"ERROR_RED_EMPTY_IN_OPERATOR_OR" : "Or blocks need a condition input.",
	"ERROR_RED_EMPTY_BACKGROUND_MUSIC" : "Play music in background grouping blocks need to contain at least one note block.",
	"ERROR_RED_NO_START" : "Programs must have a start event to work correctly. If you are seeing this error message, start a new program by going to the menu and selecting new.",
	"ERROR_RED_NOT_BACKGROUND_MUSIC" : "Play music in background grouping blocks can only accept note blocks.",
	"ERROR_RED_NO_MAIN_BLOCKS" : "There are no blocks connected to the start event, so there is no main program for Edison to run.",
	"ERROR_RED_EMPTY_IN_USB_RECEIVED" : "wait for usb data blocks need a variable.",
	"ERROR_RED_DEVIDE_BY_ZERO" : "Devide operator blocks cannot devide by zero.",
	"ERROR_RED_FUNCTION_IN_FUNCTION" : "Function call blocks cannot be placed under a function start block",
	"ERROR_YELLOW_RECEIVE_MESSAGE_OBS_ON" : "Edison cannot receive messages while obstacle detection is on. Make sure to turn obstacle detection off in the program before attempting to receive a message.",
	"ERROR_YELLOW_RECEIVE_REMOTE_OBS_ON" : "Edison cannot receive remote control codes while obstacle detection is on. Make sure to turn obstacle detection off in the program before attempting to receive a remote code.",
	"ERROR_YELLOW_RECEIVE_MESSAGE_EVENT_OBS_ON" : "Edison cannot receive messages while obstacle detection is on. Make sure to turn obstacle detection off in the main program before attempting to receive a message.",
	"ERROR_YELLOW_RECEIVE_REMOTE_EVENT_OBS_ON" : "Edison cannot receive remote control codes while obstacle detection is on. Make sure to turn obstacle detection off in the main program before attempting to receive a remote code.",
	"ERROR_YELLOW_READ_LIGHT_LINE_OFF" : "Consider turning the line detection LED on using the line tracking LED block from the Sensing category if measuring reflectiveness of the driving surface.",
	"ERROR_YELLOW_OPPERATOR_WAIT_UNTIL" : "An operator block inside a wait until block may cause Edison to wait forever or skip the wait block.",
	"ERROR_YELLOW_OPPERATOR_REPEAT_UNTIL" : "An operator block inside a repeat until block may cause Edison to loop forever or skip the repeat block.",
	"ERROR_YELLOW_OPPERATOR_WAIT" : "An operator block inside a wait block may cause Edison to skip the wait block.",
	"ERROR_YELLOW_OPPERATOR_REPEAT" : "An operator block inside a repeat block may cause Edison to skip the repeat block.",
	"ERROR_YELLOW_OPPERATOR_DRIVE_FOR_UNTIL" : "An operator block inside a drive forwards until block may cause Edison to drive forever or skip the drive block.",
	"ERROR_YELLOW_OPPERATOR_DRIVE_BACK_UNTIL" : "An operator block inside a drive backwards until block may cause Edison to drive forever or skip the drive block.",
	"ERROR_YELLOW_OPPERATOR_DRIVE_LEFT_UNTIL" : "An operator block inside a drive left until block may cause Edison to drive forever or skip the drive block.",
	"ERROR_YELLOW_OPPERATOR_DRIVE_RIGHT_UNTIL" : "An operator block inside a drive right until block may cause Edison to drive forever or skip the drive block.",
	"ERROR_YELLOW_OPPERATOR_DRIVE_FOR_DIST" : "An operator block inside a drive forwards block may cause Edison to skip the drive block.",
	"ERROR_YELLOW_OPPERATOR_DRIVE_BACK_DIST" : "An operator block inside a drive backwards block may cause Edison to skip the drive block.",
	"ERROR_YELLOW_OPPERATOR_DRIVE_LEFT_DIST" : "An operator block inside a drive left block may cause Edison to skip the drive block.",
	"ERROR_YELLOW_OPPERATOR_DRIVE_RIGHT_DIST" : "An operator block inside a drive right block may cause Edison to skip the drive block.",
	"ERROR_YELLOW_DRIVE_LIGHT" : "An light level block inside a drive block may cause Edison to drive forever or skip the drive block.",
	"ERROR_YELLOW_OPPERATOR_IR_MESSAGE" : "An operator block inside a send IR message block will not be able to send a value larger then 255",
	"ERROR_YELLOW_FOREVER_LOOP_IN" : "A forever loop will continue looping until you press the square button on Edison.",
	"ERROR_YELLOW_SET_MOTOR_LEFT" : "The set left motor block will only turn the left motor on. Make sure there are additional blocks used in the program to control the left motor's duration.",
	"ERROR_YELLOW_SET_MOTOR_RIGHT" : "The set right motor block will only turn the right motor on. Make sure there are additional blocks used in the program to control the right motor's duration.",
	"ERROR_YELLOW_SET_MOTOR_BOTH" : "The set both motors block will only turn the motors on. Make sure there are additional blocks used in the program to control the motor's duration.",
	"ERROR_YELLOW_CLAP_EVENT_DRIVE" : "Driving the motors creates noise which may cause the clap event to trigger. This may cause the clap event blocks to trigger repeatedly while Edison is driving.",
	"ERROR_YELLOW_FLOAT_BLOCKS" : "Blocks not connected to a yellow event block or function definition block will not be programmed into Edison.",
	"ERROR_YELLOW_WAIT_TIME_LIGHT" : "Light level will return a very high value which may cause Edison to wait for a long time.",
	"ERROR_YELLOW_REPEAT_LOOP_LIGHT" : "Light level will return a very high value which may cause Edison to loop for a long time.",
	"ERROR_YELLOW_DRIVE_STRAIN" : "The drive strain detected block will only detect strain while the motors are running.",
	"ERROR_YELLOW_DRIVE_STRAIN_EVENT" : "The drive strained event can only trigger while the motors are running.",
	"ERROR_YELLOW_COMMENT" : "Comments are notes to help keep track of things. Comment blocks will not be programmed into Edison.",
	"ERROR_YELLOW_USB_USED" : "USB blocks require Edison to be plugged into a device to work",
	"ERROR_YELLOW_CLEAR_SENSOR" : "Some sensor data is stored in Edison's memory. You may need to clear the sensor data for your program to work correctly.",
	"ERROR_YELLOW_CLEAR_LEARN_MORE" : "Learn More",
	"MODAL_FIRMWARE_ERROR_TITLE" : "Firmware error",
	"MODAL_FIRMWARE_ERROR_BODY_1" : "A corrupted firmware file has been detected in your Edison robot.",
	"MODAL_FIRMWARE_ERROR_BODY_2" : "This may have occurred during a firmware update that was interrupted.",
	"MODAL_FIRMWARE_ERROR_BODY_3" : "Don't panic! This can be fixed by clicking the Fix firmware button below.",
	"MODAL_FIRMWARE_ERROR_CANCEL_BODY_1" : "Warning!",
	"MODAL_FIRMWARE_ERROR_CANCEL_BODY_2" : "Canceling this process means that your Edison robot can not be programmed.",
	"MODAL_FIRMWARE_ERROR_CANCEL_BODY_3" : "It is recommended that you fix the firmware now by clicking the Fix firmware button.",
	"MODAL_FIRMWARE_ERROR_CANCEL_BODY_4" : "If you choose to cancel you can fix the firmware at a later time.",
	"MODAL_FIRMWARE_ERROR_BUTTON_FIX" : "Fix firmware",
	"MODAL_FIRMWARE_ERROR_BUTTON_CANCEL" : "Cancel",
	"MODAL_FIRMWARE_ERROR_BUTTON_CANCEL_CONFIRM" : "Confirm cancel",
	"MODAL_NEW_CONFIRM_HEADING" : "Are you sure?",
	"MODAL_NEW_CONFIRM_BODY_TEXT_1" : "Are you sure you want to start a new program?",
	"MODAL_NEW_CONFIRM_BODY_TEXT_2" : "Any changes may be lost!",
	"MODAL_NEW_CONFIRM_BUTTON_CANCEL" : "Cancel",
	"MODAL_NEW_CONFIRM_BUTTON_PROCEED" : "Proceed",
	"CHANGELANG" : "Change language",
	"HELP_TEXT_ALL_TITLE" : "Block help",
	"HELP_TEXT_ALL_BLOCKS_EXAMPLE_USES" : "Example uses:",
	"HELP_TEXT_ALL_BLOCKS_EXAMPLE_LOAD" : "Open program",
	"HELP_TEXT_ALL_BLOCKS_WATCH_FOR" : "Watch out for:",
	"HELP_TEXT_DRIVE_FORWARD_FOR_TITLE" : "forwards for",
	"HELP_TEXT_DRIVE_FORWARD_FOR_BODY_1" : "The forwards for block drives the wheels to move the robot in the forward direction.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_BODY_2" : "The block has three parameters:",
	"HELP_TEXT_DRIVE_FORWARD_FOR_BODY_3" : "Value - Can be a constant (typed into the input and does not vary), a variable, a sensing or an operator block.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_BODY_4" : "Units - There are three options that can be selected: cm, inch and seconds.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_BODY_5" : "Speed - The speed can be either selected from 1 to 10 (as a constant value), a variable, a sensing or an operator block.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_BODY_6" : "The forwards for block will complete before the next block will run. For example, using the forwards for block will not run other blocks in the program at the same time. To do this see the set both motors to block.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_1_TITLE" : "Example 1: Beep, then drive the Edison robot forward 15 cm at speed 1, then beep again.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_1_BODY_1" : "In this example program, Edison beeps, but does not start driving until the beep has finished playing. Also, the second beep does not start until Edison has stopped driving.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_2_TITLE" : "Example 2: Setting the drive distance using a variable and data from a sensor",
	"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_2_BODY_1" : "In this example program Edison sets the Distance variable to the light level from the left light sensor (a value from 1 to 1,000) divided by 50. The Edison then drives forward for the value in the (Distance) variable at speed 5. The result is that Edison drives further under brighter light and drives shorter under dimmer light.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_3_TITLE" : "Example 3: Changing the drive speed using a variable.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_3_BODY_1" : "In this example program, the variable Speed is set to 1. The program then enters a repeat loop for 10 times. Through each loop the Edison drives forward 5 cm at the speed in the variable. Initially, the value in the Speed variable is 1, so the Edison drives forward for 5cm at speed 1. The next block in the repeat increments (+1) the Speed variable. In the second repeat of the forwards block the value in the Speed variable is 2, so the Edison drives forward for 5cm at speed 2.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_3_BODY_2" : "This process repeats the full 10 times of the repeat loop, causing Edison to drive faster and faster until stopping when the program ends.",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_TITLE" : "backwards for",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_BODY_1" : "The backwards for block drives the wheels to move the robot in the backward direction.",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_BODY_2" : "The block has three parameters:",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_BODY_3" : "Value - Can be a constant (typed into the input and does not vary), a variable, a sensing or an operator block.",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_BODY_4" : "Units - There are three options that can be selected: cm, inch and seconds.",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_BODY_5" : "Speed - The speed can be either selected from 1 to 10 (as a constant value), a variable, a sensing or an operator block.",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_BODY_6" : "The backwards for block will complete before the next block will run. For example, using the backwards for block will not run other blocks in the program at the same time. To do this see the set both motors to block.",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_EXAMPLE_1_TITLE" : "Example 1: LED lights on while driving",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_EXAMPLE_1_BODY_1" : "In this example program, the left LED turns on and stays on while the Edison drives backwards for one second. The left LED turns off after the Edison has stopped driving. The program then waits for one second before ending.",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_EXAMPLE_2_TITLE" : "Example 2: When there is an obstacle drive backwards",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_EXAMPLE_2_BODY_1" : "In this example program, the obstacle detection beam is first turned on. The program then enters a forever loop. Inside the loop the wait until block stops the program from progressing until an obstacle is detected anywhere, when this happens the Edison drives backwards one inch at speed 10. This behaviour repeats forever in a loop. This results in Edison backing away from objects placed in front of it.",
	"HELP_TEXT_DRIVE_LEFT_FOR_TITLE" : "left for",
	"HELP_TEXT_DRIVE_LEFT_FOR_BODY_1" : "The left for block drives the wheels to move the robot in the left direction.",
	"HELP_TEXT_DRIVE_LEFT_FOR_BODY_2" : "The block has four parameters:",
	"HELP_TEXT_DRIVE_LEFT_FOR_BODY_3" : "Movement - There are three options that can be selected: spin, turn forwards and turn backwards.",
	"HELP_TEXT_DRIVE_LEFT_FOR_BODY_4" : "Value - Can be a constant (typed into the input and does not vary), a variable, a sensing or an operator block.",
	"HELP_TEXT_DRIVE_LEFT_FOR_BODY_5" : "Units - There are two options that can be selected: degrees and seconds.",
	"HELP_TEXT_DRIVE_LEFT_FOR_BODY_6" : "Speed - The speed can be either selected from 1 to 10 (as a constant value), a variable, a sensing or an operator block.",
	"HELP_TEXT_DRIVE_LEFT_FOR_BODY_7" : "Turning and spinning is more accurate at lower speeds. This is because the wheels can lose traction and slip at high speeds. Speed 1 is best when accurate turning is needed.",
	"HELP_TEXT_DRIVE_LEFT_FOR_BODY_8" : "The left for block must complete before the next block will run. For example, using the left for block will not run other blocks in the program at the same time. To do this see the set both motors to block.",
	"HELP_TEXT_DRIVE_LEFT_FOR_EXAMPLE_1_TITLE" : "Example program 1: beep, spin, beep",
	"HELP_TEXT_DRIVE_LEFT_FOR_EXAMPLE_1_BODY_1" : "In this example program, Edison beeps, but does not start spinning until the beep has finished playing. Also, the second beep does not start until Edison has stopped spinning.",
	"HELP_TEXT_DRIVE_LEFT_FOR_EXAMPLE_2_TITLE" : "Example program 2: Drive in a square",
	"HELP_TEXT_DRIVE_LEFT_FOR_EXAMPLE_2_BODY_1" : "In this example program, the repeat loop repeats driving forwards for 10cm at speed 1 and turning forward left for 90 degrees four times. This results in Edison driving in a square pattern.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_TITLE" : "right for",
	"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_1" : "The right for block drives the wheels to move the robot in the left direction.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_2" : "The block has four parameters:",
	"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_3" : "Movement - There are three options that can be selected: spin, turn forwards and turn backwards.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_4" : "Value - Can be a constant (typed into the input and does not vary), a variable, a sensing or an operator block.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_5" : "Units - There are two options that can be selected: degrees and seconds.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_6" : "Speed - The speed can be either selected from 1 to 10 (as a constant value), a variable, a sensing or an operator block.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_7" : "Turning and spinning is more accurate at lower speeds. This is because the wheels can lose traction and slip at high speeds. Speed 1 is best when accurate turning is needed.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_8" : "The right for block must complete before the next block will run. For example, using the right for block will not run other blocks in the program at the same time. To do this see the set both motors to block.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_EXAMPLE_1_TITLE" : "Example program 1: Beep, spin, beep",
	"HELP_TEXT_DRIVE_RIGHT_FOR_EXAMPLE_1_BODY_1" : "In this example program Edison beeps, but does not start spinning until the beep has finished playing. Also, the second beep does not start until Edison has stopped spinning.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_EXAMPLE_2_TITLE" : "Example 2: Spin right with the speed controlled by the light level",
	"HELP_TEXT_DRIVE_RIGHT_FOR_EXAMPLE_2_BODY_1" : "In this example program Edison spins right inside a forever loop. Each time the right for block runs Edison spins 1 degree. The speed is set by the light level reading from the left light sensor (1 to 1,000) and is divided by 100 (result 0 to 10). The result is that Edison spins faster under brighter light and slower under dimmer light.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_EXAMPLE_3_TITLE" : "Example program 3: Avoid obstacles",
	"HELP_TEXT_DRIVE_RIGHT_FOR_EXAMPLE_3_BODY_1" : "In this example program, the obstacle detection beam is turned on. The program then enters a forever loop where both motors are set to drive forwards. The program then waits until an obstacle is detected anywhere. When this happens, the program progresses to the next block and the Edison robot spins right for 180 degrees at speed 1. This results in Edison driving away from obstacles in its path.",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_TITLE" : "forwards until",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_BODY_1" : "The forwards until block drives the wheels to move the robot in the forwards direction until the specified condition is true. Once the specified condition is true the wheels stop and the program progresses to the next block.",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_BODY_2" : "The block has two parameters:",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_BODY_3" : "Conditional input - The conditional input accepts a diamond shaped block that can be either a sensing or operator block.",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_BODY_4" : "Speed - The speed can be either selected from 1 to 10 (as a constant value) a variable, a sensing or an operator block.",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_BODY_5" : "The forwards until block must complete before the next block will run. For example, using the forwards until block will not run other blocks in the program at the same time. To do this see the set both motors to block.",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_EXAMPLE_1_TITLE" : "Example program 1: Stop for an obstacle",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_EXAMPLE_1_BODY_1" : "In this example program, the obstacle detection beam is turned on, then the robot drives forward at speed 5 until an obstacle is detected. When this happens, the robot stops moving and the program ends.",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_EXAMPLE_2_TITLE" : "Example program 2: Bounce in borders",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_EXAMPLE_2_BODY_1" : "In this example program, the line tracker LED is turned on, then the program enters a forever loop. Inside the loop the forwards until block drives the robot forward at speed 1 until the line tracker is on a non-reflective surface (i.e. black). When this happens, the next block runs which spins the robot left for 180 degrees at speed 5. The program then loops back to the forwards until block. This results in Edison driving away from detected black lines.",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_TITLE" : "backwards until",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_BODY_1" : "The backwards until block drives the wheels to move the robot in the backwards direction until the specified condition is true. Once the specified condition is true the wheels stop and the program progresses to the next block.",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_BODY_2" : "The block has two parameters:",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_BODY_3" : "Conditional input - The conditional input accepts a diamond shaped block that can be either a sensing or operator block.",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_BODY_4" : "Speed - The speed can be either selected from 1 to 10 (as a constant value), a variable, a sensing or an operator block.",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_BODY_5" : "The backwards until block must complete before the next block will run. For example, using the backwards until block will not run other blocks in the program at the same time. To do this see the set both motors to block.",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_EXAMPLE_1_TITLE" : "Example program 1: Stop when drive is strained",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_EXAMPLE_1_BODY_1" : "In this example program, the robot drives backwards at speed 10 until the wheels are strained (are unable to rotate or become stuck). When this happens, the motors stop and the program ends.",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_EXAMPLE_2_TITLE" : "Example program 2: Drive control with buttons",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_EXAMPLE_2_BODY_1" : "In this example, the program starts with a forever loop. The first block in the loop waits until the triangle button is pushed. When this happens, the robot drives backwards at speed 1 until the round button is pressed. When this happened the robot's wheels stop and the program loops back to waiting for the triangle button to be pressed.",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_TITLE" : "left until",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_BODY_1" : "The left until block drives the wheels to move the robot in the left direction until the specified condition is true. Once the specified condition is true the wheels stop and the program progresses to the next block.",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_BODY_2" : "The block has three parameters:",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_BODY_3" : "Movement - There are three options that can be selected: spin, turn forwards and turn backwards.",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_BODY_4" : "Conditional input - The conditional input accepts a diamond shaped block that can be either a sensing or operator block.",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_BODY_5" : "Speed - The speed can be either selected from 1 to 10 (as a constant value), a variable, a sensing or an operator block.",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_BODY_6" : "The spin left until block must complete before the next block will run. For example, using the spin left until block will not run other blocks in the program at the same time. To do this see the set both motors to block.",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_EXAMPLE_1_TITLE" : "Example program 1: Stop when drive is strained",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_EXAMPLE_1_BODY_1" : "In this example program, the robot drives forward left (right wheel moving) at speed 1 until the wheel becomes strained (unable to rotate or becomes stuck). When this happens, the motor stops and the program ends.",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_EXAMPLE_2_TITLE" : "Example program 2: Follow light",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_EXAMPLE_2_BODY_1" : "In this example, the program starts with a forever loop. The first block in the loop turns the robot left at speed 5 until the left light level is less than the right light level. When this happens the motor stops and the next block runs. The next block turns the robot right at speed 5 until the left light level is greater than the right light level. The result of this is that the Edison robot drives towards light.",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_TITLE" : "right until",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_BODY_1" : "The right until block drives the wheels to move the robot in the right direction until the specified condition is true. Once the specified condition is true the wheels stop and the program progresses to the next block.",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_BODY_2" : "The block has three parameters:",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_BODY_3" : "Movement - There are three options that can be selected: spin, turn forwards and turn backwards.",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_BODY_4" : "Conditional input - The conditional input accepts a diamond shaped block that can be either a sensing or operator block.",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_BODY_5" : "Speed - The speed can be either selected from 1 to 10 (as a constant value), a variable, a sensing or an operator block.",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_BODY_6" : "The right until block must complete before the next block will run. For example, using the spin right until block will not run other blocks in the program at the same time. To do this see the set both motors to block.",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_EXAMPLE_1_TITLE" : "Example program 1: Stop on black surface",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_EXAMPLE_1_BODY_1" : "In this example, program the robot spins right at speed 5 until the line tracker detects a non-reflective surface (black). When this happens that motor stops and the program ends.",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_EXAMPLE_2_TITLE" : "Example program 2: Follow light",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_EXAMPLE_2_BODY_1" : "In this example, the program starts with a forever loop. The first block in the loop turns the robot left at speed 5 until the left light level is less than the right light level. When this happens the motor stops and the next block runs. The next block turns the robot right at speed 5 until the left light level is greater than the right light level. The result of this is that the Edison robot drives towards light.",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_TITLE" : "Set both motors to",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_BODY_1" : "The set both motors to block drives the wheels to move the robot in the selected direction and speed. As this drive block sets the motors, the program can continue straight to the next block. This is different to the drive blocks that have a distance, time or angle to complete before the program continues to the next block.",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_BODY_2" : "The block has two parameters:",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_BODY_3" : "Movement - There are six options that can be selected: drive forwards, drive backwards, spin robot left, spin robot right, turn robot left and turn robot right.",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_BODY_4" : "Speed - The speed can be either selected from 1 to 10 (as a constant value), a variable, a sensing or an operator block.",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_EXAMPLE_1_TITLE" : "Example program 1: Music while driving",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_EXAMPLE_1_BODY" : "In this example program the Edison robot is set to drive forward, then three notes are played while the robot is still driving. After the last note finishes playing the program ends and the Edison robot stops driving.",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_EXAMPLE_2_TITLE" : "Example program 2: Drive until an obstacle",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_EXAMPLE_2_BODY" : "In this example program the obstacle detection beam is turned on, then both motors are set to drive forwards at speed 8. The next block waits until any obstacle is detected. When this happens, the program ends and the robot stops driving.",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_EXAMPLE_3_TITLE" : "Example program 3: Follow a line",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_EXAMPLE_3_BODY" : "In this example program, the line tracker LED is turned on and the program enters a forever loop. Inside the loop both motors are set to turn robot left at speed 1, then the wait until block holds the program there until the line tracker detects a reflective surface (white). When that happens, both motors are then set to turn robot right at speed 1 and the wait until block hold the program there until the line tracker detects a non-reflective surface (black). When that happens the program loops back to the start of the forever loop and repeats. This results in Edison following a non-reflective line.",
	"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_TITLE" : "set right motor to",
	"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_BODY_1" : "The set right motor to block drives the wheels to move the robot in the selected direction and speed. As this drive block sets the motors the program can continue straight to the next block. This is different to the drive blocks that have a distance, time or angle to complete before the program moves to the next block.",
	"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_BODY_2" : "The block has two parameters:",
	"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_BODY_3" : "Movement - There are two options that can be selected: forwards and backwards.",
	"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_BODY_4" : "Speed - The speed can be either selected from 1 to 10 (as a constant value), a variable, a sensing or an operator block.",
	"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_EXAMPLE_1_TITLE" : "Example program 1: Motor on and off with a button press",
	"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_EXAMPLE_1_BODY" : "In this example, the program enters a forever loop. The first block in the loop waits until the round button is pressed. When this happens, the right motor is set to forwards at speed 5, the program then progresses to another wait until round button pressed block. When this happens, the right motor is stopped and the program loops back to the start of the forever loop.",
	"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_TITLE" : "set left motor to",
	"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_BODY_1" : "The set left motor to block drives the wheels to move the robot in the selected direction and speed. As this drive block sets the motors the program can continue straight to the next block. This is different to the drive blocks that have a distance, time or angle to complete before the program moves to the next block.",
	"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_BODY_2" : "The block has two parameters:",
	"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_BODY_3" : "Movement - There are two options that can be selected: forwards and backwards.",
	"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_BODY_4" : "Speed - The speed can be either selected from 1 to 10 (as a constant value), a variable, a sensing or an operator block.",
	"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_EXAMPLE_1_TITLE" : "Example program 1: Light following",
	"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_EXAMPLE_1_BODY" : "In this example, the program enters a forever loop. The first block in the loop sets the left motor forwards at a calculated speed. The calculated speed is the light level from the right sensor minus the light level from the left sensor divided by 100, 3 is also added to the result to set a minimum speed. The next block sets the right motor to forwards at a calculated speed. The calculated speed is the light level from the left sensor minus the light level from the right sensor divided by 100, 3 is also added to the result to set a minimum speed. The program then loops back to the start of the forever loop. The calculated results control the speed so that the side that has the least amount of light drives the fastest. This results in the Edison robot always trying to face and drive towards the brightest light.",
	"HELP_TEXT_DRIVE_STOP_TITLE" : "stop",
	"HELP_TEXT_DRIVE_STOP_BODY_1" : "The stop block stops the motors from driving the wheels.",
	"HELP_TEXT_DRIVE_STOP_BODY_2" : "The stop block has only one parameter for selecting which motor/s are stopped. The options are both motors, left motor and right motor.",
	"HELP_TEXT_DRIVE_STOP_EXAMPLE_1_TITLE" : "Example program 1: Motor on and off with a button press",
	"HELP_TEXT_DRIVE_STOP_EXAMPLE_1_BODY" : "In this example, the program enters a forever loop. The first block in the loop waits until the round button is pressed. When this happens, the right motor is set to forwards at speed 5, the program then progresses to another wait until round button pressed block. When this happens, the right motor is stopped and the program loops back to the start of the forever loop.",
	"HELP_TEXT_LEDS_LEFT_TITLE" : "turn left LED",
	"HELP_TEXT_LEDS_LEFT_BODY_1" : "The turn left LED block controls the left LED. There are two options on or off.",
	"HELP_TEXT_LEDS_LEFT_EXAMPLE_1_TITLE" : "Example program 1: Blink left LED once",
	"HELP_TEXT_LEDS_LEFT_EXAMPLE_1_BODY" : "In this example the program begins by turning the left LED on, then waits for one second, then turns the left LED off.",
	"HELP_TEXT_LEDS_LEFT_EXAMPLE_2_TITLE" : "Example program 2: Blink left LED forever",
	"HELP_TEXT_LEDS_LEFT_EXAMPLE_2_BODY" : "In this example, the program begins by entering a forever loop. Inside the loop the left LED is turned on, then the program waits for one second, then the left LED is turned off, then the program waits for one second, then the program jumps to the beginning of the loop and repeats forever.",
	"HELP_TEXT_LEDS_RIGHT_TITLE" : "turn right LED",
	"HELP_TEXT_LEDS_RIGHT_BODY_1" : "The turn right LED block controls the right LED. There are two options on or off.",
	"HELP_TEXT_LEDS_RIGHT_EXAMPLE_1_TITLE" : "Example program 1: Blink right LED once",
	"HELP_TEXT_LEDS_RIGHT_EXAMPLE_1_BODY" : "In this example, the program begins by turning the right LED on, then waits for one second, then turns the right LED off.",
	"HELP_TEXT_LEDS_RIGHT_EXAMPLE_2_TITLE" : "Example program 2: Blink right LED forever",
	"HELP_TEXT_LEDS_RIGHT_EXAMPLE_2_BODY" : "In this example, the program begins by entering a forever loop. Inside the loop the right LED is turned on, then the program waits for one second, then the right LED is turned off, then the program waits for one second, then the program jumps to the beginning of the loop and repeats forever.",
	"HELP_TEXT_LEDS_SEND_MESSAGE_TITLE" : "send IR message",
	"HELP_TEXT_LEDS_SEND_MESSAGE_BODY_1" : "The send IR message block sends data via infrared (IR) light. The data that can be sent is a value from 0 to 255. The value can be a constant (typed into the input and does not vary), a variable, a sensing or an operator block.",
	"HELP_TEXT_LEDS_SEND_MESSAGE_BODY_2" : "The sent data can be received by any other Edison robot that is in range of the IR light signal. The maximum range can be up to 10 meter/30 feet under ideal conditions (i.e. indoors, no direct sunlight, white ceiling and walls for the IR light to bounce off).",
	"HELP_TEXT_LEDS_SEND_MESSAGE_BODY_3" : "If you use a variable, the number in the variable could exceed the 255 limit (8-bits). When this happens, the number sent via IR will 'wrap around' (i.e. 256 sends 0, 257 sends 1, 258 sends 2...).",
	"HELP_TEXT_LEDS_SEND_MESSAGE_EXAMPLE_1_TITLE" : "Example program 1: Send IR message 1 when round button pressed",
	"HELP_TEXT_LEDS_SEND_MESSAGE_EXAMPLE_1_BODY" : "In this example, the program begins by entering a forever loop. Inside the loop the program waits for the round button to be pressed. When this happens, the IR message 1 is sent. The program then loops back to the beginning of the forever loop.",
	"HELP_TEXT_LEDS_SEND_MESSAGE_EXAMPLE_2_TITLE" : "Example program 2: Send light level every one second",
	"HELP_TEXT_LEDS_SEND_MESSAGE_EXAMPLE_2_BODY" : "In this example, the program begins by entering a forever loop. Inside the loop the program sends the light level reading from the left light sensor divided by four. The value is divided by four as the output from the light sensor is 1 to 1,000, but the highest number that can be sent with IR is 255 (1,000/4 = 250). This additional calculation allows the full range of the light sensor to be sent. The program then waits for one second and then loops back to the start of the forever loop.",
	"HELP_TEXT_SOUND_BEEP_TITLE" : "beep",
	"HELP_TEXT_SOUND_BEEP_BODY_1" : "The beep block plays a 3.5kHz beep sound for 125mS (0.125 seconds).",
	"HELP_TEXT_SOUND_BEEP_EXAMPLE_1_TITLE" : "Example program 1: Beep when round button is pressed",
	"HELP_TEXT_SOUND_BEEP_EXAMPLE_1_BODY" : "In this example, the program begins by entering a forever loop. Inside the loop the program waits for the round button to be pressed. When this happens, the beep is played. The program then loops back to the start of the forever loop and repeats.",
	"HELP_TEXT_SOUND_PLAY_NOTE_TITLE" : "play a note",
	"HELP_TEXT_SOUND_PLAY_NOTE_BODY_1" : "The play a note block plays a musical note. The block parameters allow the length, note and type of note to be selected.",
	"HELP_TEXT_SOUND_PLAY_NOTE_BODY_2" : "The block has three parameters:",
	"HELP_TEXT_SOUND_PLAY_NOTE_BODY_3" : "Length - There are four options: whole, half, quarter and eighth.",
	"HELP_TEXT_SOUND_PLAY_NOTE_BODY_4" : "Note - There are ten options: C, B, A, G, F, E, D, middle C, low B and rest.",
	"HELP_TEXT_SOUND_PLAY_NOTE_BODY_5" : "Note modifier - There are three options: - (not modified), sharp and flat.",
	"HELP_TEXT_SOUND_PLAY_NOTE_BODY_6" : "The play a note block must complete before the next block will run. For example, using the play a note block will not run other blocks in the program at the same time. To do this see the play music in background block.",
	"HELP_TEXT_SOUND_PLAY_NOTE_EXAMPLE_1_TITLE" : "Example program 1: Mary had a little lamb",
	"HELP_TEXT_SOUND_PLAY_NOTE_EXAMPLE_1_BODY" : "In this example, the program begins by setting the tempo for the music notes, then plays the notes for the nursery rhyme Mary had a little lamb in order, playing each note fully before moving on.",
	"HELP_TEXT_SOUND_SET_TEMPO_TITLE" : "set music tempo to",
	"HELP_TEXT_SOUND_SET_TEMPO_BODY_1" : "The set music temp to block sets the tempo that following notes are played at.",
	"HELP_TEXT_SOUND_SET_TEMPO_BODY_2" : "There are five options: very slow, slow, medium, fast and very fast.",
	"HELP_TEXT_SOUND_SET_TEMPO_EXAMPLE_1_TITLE" : "Example program 1: Mary had a little lamb",
	"HELP_TEXT_SOUND_SET_TEMPO_EXAMPLE_1_BODY" : "In this example, the program begins by setting the tempo for the music notes, then plays the notes for the nursery rhyme Mary had a little lamb at that speed, playing each note fully before moving on.",
	"HELP_TEXT_SOUND_PLAYINBACKGROUND_TITLE" : "Play music in background",
	"HELP_TEXT_SOUND_PLAYINBACKGROUND_BODY_1" : "The play music in background block allows musical notes placed inside the block to play while the Edison robot is running other parts of the program.",
	"HELP_TEXT_SOUND_PLAYINBACKGROUND_EXAMPLE_1_TITLE" : "Example program 1: Mary had a little lamb while dancing",
	"HELP_TEXT_SOUND_PLAYINBACKGROUND_EXAMPLE_1_BODY" : "In this example program, the program begins by setting the tempo for the music notes, then the notes inside the play music in background block start to play, the program enters the repeat loop and the spin left and spin right blocks run four times with the tune still playing in the background. This results in Edison dancing while playing music.",
	"HELP_TEXT_VARIABLE_TITLE" : "Variable",
	"HELP_TEXT_VARIABLE_BODY_1" : "A variable block is a place where data can be stored and used by a program. The data in a variable can vary and change while the program is running. This is why it is called a variable.",
	"HELP_TEXT_VARIABLE_BODY_2" : "The data in a variable is a number that can range from -1,073,741,824 to 1,073,741,823 (signed 32-bit).",
	"HELP_TEXT_VARIABLE_BODY_3" : "Variables should be customised by naming them something that makes sense to the program. For example:",
	"HELP_TEXT_VARIABLE_BODY_4" : "If the number in a variable exceeds the range of -1,073,741,824 to 1,073,741,823, then the program will halt and Edison will play a failure tone.",
	"HELP_TEXT_VARIABLE_EXAMPLE_1_TITLE" : "Example program 1: A random flash rate set at the program start",
	"HELP_TEXT_VARIABLE_EXAMPLE_1_BODY_1" : "In this example program, the variable 'FlashRate' is set to a random number between 10 and 100. The program then enters a forever loop. Inside the loop the left and right LEDs are turned on, then the program waits for the millisecond value in 'FlashRate', then turns off the left and right LEDs, then the program again waits for the millisecond value in 'FlashRate'. The program then loops back to the start of the forever loop and repeats. This results in Edison flashing its LEDs at different speeds each time the program is run",
	"HELP_TEXT_VARIABLE_EXAMPLE_2_TITLE" : "Example program 2: Count black lines driven over",
	"HELP_TEXT_VARIABLE_EXAMPLE_2_BODY_1" : "In this example program, the line tracker LED is first turned on, then the Edison robot drives forwards for 30cm at speed 5. While driving forward any detected non-reflective (black) surfaces by the line tracker will trigger the program to jump to the event block Line tracker on non-reflective surface. When this happens, the variable 'LineCount' is incremented (+1). When driving for 30 cm has completed the program repeats the wait for 1 second and beep blocks for the number of times in the variable 'LineCount'.",
	"HELP_TEXT_VARIABLE_EXAMPLE_3_TITLE" : "Example program 3: Light radiation counter",
	"HELP_TEXT_VARIABLE_EXAMPLE_3_BODY_1" : "In this example program, the music tempo is first set to very fast. The program then enters a forever loop. Inside the loop the program sets the variable 'Delay' to 1000 minus the left light level (inverting the light level reading). The next block waits for the value in the 'Delay' variable. The program then plays the note C and loops back to the start of the forever loop and repeats. The result of this program is that Edison will beep slow when in darkness and faster when the light level is brighter.",
	"HELP_TEXT_DATA_SETVARIABLETO_TITLE" : "set to",
	"HELP_TEXT_DATA_SETVARIABLETO_BODY_1" : "The set to block is used to set a value in a variable.",
	"HELP_TEXT_DATA_SETVARIABLETO_BODY_2" : "There are two inputs:",
	"HELP_TEXT_DATA_SETVARIABLETO_BODY_3" : "Variable - This is where the variable block is placed.",
	"HELP_TEXT_DATA_SETVARIABLETO_BODY_4" : "Value - Can be a constant (typed into the input and does not vary), a variable, a sensing or an operator block.",
	"HELP_TEXT_DATA_SETVARIABLETO_EXAMPLE_1_TITLE" : "Example program 1: Set the number of beeps",
	"HELP_TEXT_DATA_SETVARIABLETO_EXAMPLE_1_BODY_1" : "In this example program, the variable 'NumberOfBeeps' is set to 5, then the repeat block repeats the beeping for the value 5 held in the variable 'NumberOfBeeps'.",
	"HELP_TEXT_DATA_SETVARIABLETO_EXAMPLE_2_TITLE" : "Example program 2: A random flash rate set at the program start",
	"HELP_TEXT_DATA_SETVARIABLETO_EXAMPLE_2_BODY_1" : "In this example program, the variable 'FlashRate' is set to a random number between 10 and 1000. The program then enters a forever loop. Inside the loop the left and right LEDs are turned on, then the program waits for the millisecond value in 'FlashRate', then turns off the left and right LEDs, then the program again waits for the millisecond value in 'FlashRate'. The program then loops back to the start of the forever loop and repeats. This results in Edison flashing its LEDs at different speeds each time the program is run",
	"HELP_TEXT_DATA_SETVARIABLETO_EXAMPLE_3_TITLE" : "Example program 3: Follow the light",
	"HELP_TEXT_DATA_SETVARIABLETO_EXAMPLE_3_BODY_1" : "In this example, the program begins by entering a forever loop. Inside the loop the program sets the variable 'LightLeftvsRight' to the left light level minus the right light level. The if else block then tests whether the value in the variable 'LightLeftvsRight' is greater than 0. If the result is true, then the right motor is set to drive forwards and the left motor is stopped. If the result is false, then the left motor is set to drive forward and the right motor is stopped. The program then loops back to the start of the forever loop and repeats. This results in Edison driving towards the brightest light source.",
	"HELP_TEXT_DATA_INCVARIABLE_TITLE" : "increment",
	"HELP_TEXT_DATA_INCVARIABLE_BODY_1" : "The increment block increments (adds 1) to the variable placed in the block.",
	"HELP_TEXT_DATA_INCVARIABLE_EXAMPLE_1_TITLE" : "Example program 1: Decelerating flashing",
	"HELP_TEXT_DATA_INCVARIABLE_EXAMPLE_1_BODY_1" : "In this example program, the variable 'Delay' is set to 0 the program then enters a forever loop. Inside the loop the variable 'Delay' is incremented (+1), then the right LED is turned on and the left LED is turned off, then the program waits for the value in the variable 'Delay' in milliseconds, then the right LED is turned off and the left LED is turned on and then again, the program waits for the value in the variable 'Delay' in milliseconds. The program then loops back to the start of the forever loop and repeats. As the program repeats through the forever loop, the variable 'Delay' is incremented each time making the time that the LEDs spend on and off longer and longer. After 1,000 loops the time the LEDs are on is one second and the time the LEDs are off is one second.",
	"HELP_TEXT_DATA_DECVARIABLE_TITLE" : "decrement",
	"HELP_TEXT_DATA_DECVARIABLE_BODY_1" : "The decrement block decrements (minus 1) to the variable placed in the block.",
	"HELP_TEXT_DATA_DECVARIABLE_EXAMPLE_1_TITLE" : "Example program 1: Accelerating flashing",
	"HELP_TEXT_DATA_DECVARIABLE_EXAMPLE_1_BODY_1" : "In this example program, the variable 'Delay' is set to 100 the program then enters a forever loop. Inside the loop the variable 'Delay' is decremented (-1), then the right LED is turned on and the left LED is turned off, then the program waits for the value in the variable 'Delay' in milliseconds, then the right LED is turned off and the left LED is turned on and then again, the program waits for the value in the variable 'Delay' in milliseconds. The program then loops back to the start of the forever loop and repeats. As the program repeats through the forever loop, the variable 'Delay' is decremented each time making the time that the LEDs spend on and off less. After 100 loops the time the LEDs are on is one millisecond and the time the LEDs are off is one millisecond.",
	"HELP_TEXT_BIT_SHIFT_RIGHT_TITLE" : "bit shift right",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_1" : "The bit shift right by block mathematically adjusts the connected variable block in its binary form by shifting the bits right by the set value.",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_2" : "The number format that computers use is called binary. It is a number system that is only comprised of the numbers 0 and 1. Each number inside a computer is a string of 1s and 0s. Here are some examples of binary numbers that are 8-bits long:",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_HUMAN" : "Human/decimal",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_COMPUTER" : "Computer/8-bit Binary",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_3" : "Here are some examples of binary numbers that are 32-bits long:",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_4" : "Edison V3 uses both 8-bit and 32-bit binary numbers. For example, variable blocks are able to store large 32-bit numbers (actually 31-bit signed), but only 8-bit numbers can be sent via the send IR message block. Further, some sensors, such as the light sensors have a range of 1 to 1000. As the highest possible 8-bit number is 255, then the full range of the light sensor reading cannot be sent via the send IR message block. This is where the bit shift right block can help!",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_5" : "The light sensor reading is 10-bit binary. Here are the minimum and maximum values:",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_6" : "If the number 1000 was sent with the send IR message block the received number would only be the last 8-bits. This would be 11111010 (binary) or 232 (human/decimal). This is a very different number to the actual light reading of 1000.",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_7" : "To send the light level data via the send IR message block, the bit shift right block can be used to shorten the number into an 8-bit number (shift right by 2) without losing too much of the data. Then, on the receiving end the bit shift left block can be used to restore the light level reading back to 10-bits (shift left by 2).",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_4_LINE_1_BOX_1" : "Stage",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_4_LINE_2_BOX_1" : "Light reading",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_4_LINE_3_BOX_1" : "Bit shift right (2)",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_4_LINE_4_BOX_1" : "IR data send/receive",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_4_LINE_5_BOX_1" : "Bit shift left (2)",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_BIT" : "bit",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_8" : "In this scenario the resulting number is not perfectly the same, as some information has been lost. However, the most significant bits containing more than 99% of the original data has been retained through this process.",
	"HELP_TEXT_BIT_SHIFT_LEFT_TITLE" : "bit shift left",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_1" : "The bit shift left by block mathematically adjusts the connected variable block in its binary form by shifting the bits left by the set value.",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_2" : "The number format that computers use is called binary. It is a number system that is only comprised of the numbers 0 and 1. Each number inside a computer is a string of 1s and 0s. Here are some examples of binary numbers that are 8-bits long:",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_HUMAN" : "Human/decimal",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_COMPUTER" : "Computer/8-bit Binary",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_3" : "Here are some examples of binary numbers that are 32-bits long:",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_4" : "Edison V3 uses both 8-bit and 32-bit binary numbers. For example, variable blocks are able to store large 32-bit numbers (actually 31-bit signed), but only 8-bit numbers can be sent via the send IR message block. Further, some sensors, such as the light sensors have a range of 1 to 1000. As the highest possible 8-bit number is 255, then the full range of the light sensor reading cannot be sent via the send IR message block. This is where the bit shift right block can help!",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_5" : "The light sensor reading is 10-bit binary. Here are the minimum and maximum values:",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_6" : "If the number 1000 was sent with the send IR message block the received number would only be the last 8-bits. This would be 11111010 (binary) or 232 (human/decimal). This is a very different number to the actual light reading of 1000.",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_7" : "To send the light level data via the send IR message block, the bit shift right block can be used to shorten the number into an 8-bit number (shift right by 2) without losing too much of the data. Then, on the receiving end the bit shift left block can be used to restore the light level reading back to 10-bits (shift left by 2).",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_4_LINE_1_BOX_1" : "Stage",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_4_LINE_2_BOX_1" : "Light reading",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_4_LINE_3_BOX_1" : "Bit shift right (2)",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_4_LINE_4_BOX_1" : "IR data send/receive",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_4_LINE_5_BOX_1" : "Bit shift left (2)",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_BIT" : "bit",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_8" : "In this scenario the resulting number is not perfectly the same, as some information has been lost. However, the most significant bits containing more than 99% of the original data has been retained through this process.",
	"HELP_TEXT_EVENT_ANYOBSTACLE_TITLE" : "Any obstacle detected",
	"HELP_TEXT_EVENT_ANYOBSTACLE_BODY_1" : "The Any obstacle detected event block causes the program to jump to this block when any obstacle is detected by the obstacle detector.",
	"HELP_TEXT_EVENT_ANYOBSTACLE_BODY_2" : "Always ensure that the obstacle detector beam is turned on in the main program.",
	"HELP_TEXT_EVENT_ANYOBSTACLE_EXAMPLE_1_TITLE" : "Example program 1: Beep when any obstacle is detected.",
	"HELP_TEXT_EVENT_ANYOBSTACLE_EXAMPLE_1_BODY_1" : "In this example program, the obstacle detector is first turned on, the program then enters the forever loop block. When any obstacle is detected, the program jumps out of the forever loop and goes to the Any obstacle detected event block. This causes the beep block to run and the Edison robot beeps. The program then returns to where it left from in the main program.",
	"HELP_TEXT_EVENT_ANYOBSTACLE_EXAMPLE_2_TITLE" : "Example program 2: Stop driving when there is an obstacle",
	"HELP_TEXT_EVENT_ANYOBSTACLE_EXAMPLE_2_BODY_1" : "In this example program, the obstacle detector is first turned on, then both motors are set to drive forwards at speed 5, the program then enters the forever loop block. When any obstacle is detected, the program jumps out of the forever loop and goes to the Any obstacle detected event block. This causes the stop both motors block to run and stops both motors from running. The program then returns to where it left from in the main program.",
	"HELP_TEXT_EVENT_ANYOBSTACLE_EXAMPLE_3_TITLE" : "Example program 3: Avoid obstacles",
	"HELP_TEXT_EVENT_ANYOBSTACLE_EXAMPLE_3_BODY_1" : "In this example program, the obstacle detector is first turned on, then the program enters a forever loop, inside the loop both motors are set to drive forwards at speed 5. When any obstacle is detected, the program jumps out of the forever loop and goes to the Any obstacle detected event block. The blocks under the Any obstacle detected event block drive the Edison backwards for 1 cm at speed 1, then spin left for 120 degrees at speed 1. The program then returns to where it left in the forever loop and both motors are set to drive forward at speed 5 again. This results in Edison driving away from obstacles in its path.",
	"HELP_TEXT_OBSTACLE_LEFT_EVENT_TITLE" : "Obstacle detected left",
	"HELP_TEXT_OBSTACLE_LEFT_EVENT_BODY_1" : "The Obstacle detected left event block causes the program to jump to this block when an obstacle is detected on the left by the obstacle detector.",
	"HELP_TEXT_OBSTACLE_LEFT_EVENT_BODY_2" : "Always ensure that the obstacle detector beam is turned on in the main program.",
	"HELP_TEXT_OBSTACLE_LEFT_EVENT_EXAMPLE_1_TITLE" : "Example program 1: Beep when an obstacle is detected on the left",
	"HELP_TEXT_OBSTACLE_LEFT_EVENT_EXAMPLE_1_BODY_1" : "In this example program, the obstacle detector is first turned on, the program then enters the forever loop block. When an obstacle is detected to the left, the program jumps out of the forever loop and goes to the Obstacle detected left event block. This causes the beep block to run and the Edison robot beeps. The program then returns to where it left in the forever loop block.",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_TITLE" : "Obstacle detected right",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_BODY_1" : "The Obstacle detected right event block causes the program to jump to this block when an obstacle is detected on the right by the obstacle detector.",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_BODY_2" : "Always ensure that the obstacle detector beam is turned on in the main program.",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_1_TITLE" : "Example program 1: Beep when an obstacle is detected on the right",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_1_BODY_1" : "In this example program, the obstacle detector is first turned on, the program then enters the forever loop block. When an obstacle is detected to the right, the program jumps out of the forever loop and goes to the Obstacle detected right event block. This causes the beep block to run and the Edison robot beeps. The program then returns to where it left in the forever loop block.",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_2_TITLE" : "Example program 2: Obstacle evader",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_2_BODY_1" : "In this example program, the obstacle detector is first turned on, the program then enters the forever loop block. When…",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_2_BODY_2" : "…an obstacle is detected ahead the program jumps to the Obstacle detected ahead event block and the Edison robot drives backwards for 0.25 seconds at speed 10 and then returns to where it left in the forever loop block.",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_2_BODY_3" : "…an obstacle is detected to the right the program jumps to the Obstacle detected right event block and the Edison robot turns left backwards for 0.25 seconds at speed 10 and then returns to where it left in the forever loop block.",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_2_BODY_4" : "…an obstacle is detected to the left the program jumps to the Obstacle detected left event block and the Edison robot turns right backwards for 0.25 seconds at speed 10 and then returns to where it left in the forever loop block.",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_TITLE" : "Obstacle detected ahead",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_BODY_1" : "The Obstacle detected ahead event block causes the program to jump to this block when an obstacle is detected ahead by the obstacle detector. This means that, at the same time, both the left and right obstacle detectors have detected an obstacle.",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_BODY_2" : "Always ensure that the obstacle detector beam is turned on in the main program.",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_1_TITLE" : "Example program 1: Beep when an obstacle is detected ahead",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_1_BODY_1" : "In this example program, the obstacle detector is first turned on, the program then enters the forever loop block. When an obstacle is detected to the right, the program jumps out of the forever loop and goes to the Obstacle detected right event block. This causes the beep block to run and the Edison robot beeps. The program then returns to where it left in the forever loop block.",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_2_TITLE" : "Example program 2: The obstacle evader",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_2_BODY_1" : "In this example program, the obstacle detector is first turned on, the program then enters the forever loop block. When…",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_2_BODY_2" : "…an obstacle is detected ahead the program jumps to the Obstacle detected ahead event block and the Edison robot drives backwards for 0.25 seconds at speed 10 and then returns to where it left in the forever loop block.",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_2_BODY_3" : "…an obstacle is detected to the right the program jumps to the Obstacle detected right event block and the Edison robot turns left backwards for 0.25 seconds at speed 10 and then returns to where it left in the forever loop block.",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_2_BODY_4" : "…an obstacle is detected to the left the program jumps to the Obstacle detected left event block and the Edison robot turns right backwards for 0.25 seconds at speed 10 and then returns to where it left in the forever loop block.",
	"HELP_TEXT_CLAP_EVENT_TITLE" : "Clap detected",
	"HELP_TEXT_CLAP_EVENT_BODY_1" : "The Clap detected event block causes the program to jump to this block when a clap is detected.",
	"HELP_TEXT_CLAP_EVENT_BODY_2" : "When Edison is driving the motor noise and bumping cause the clap sensor to trigger, so it's best not to use the clap sensor when driving. Also, if there are likely to be false or unwanted noise detections, then the clap sensor data can be cleared with the clear sensor data block set to clap detector (see example program).",
	"HELP_TEXT_CLAP_EVENT_EXAMPLE_1_TITLE" : "Example program: Edison is scared of loud noises",
	"HELP_TEXT_CLAP_EVENT_EXAMPLE_1_BODY_1" : "In this example, the program begins by entering an empty forever loop and nothing happens. When a clap (or other loud scary sound) is detected, the program jumps out of the forever loop and goes to the Clap detected event block. The blocks below the Clap detected event block then run, driving backwards 5 cm at speed 10 (jump in fright), then entering a repeat loop set to 25 times where the spin left and spin right blocks repeatedly run causing the Edison to vibrate (shiver in fright). Finally, (when Edison recovers from its fright) the clear sensor data block clears out any false clap detections that may have occurred while driving. The program now returns to the forever loop.",
	"HELP_TEXT_TRIANGLEBUTTON_EVENT_TITLE" : "Triangle button pressed",
	"HELP_TEXT_TRIANGLEBUTTON_EVENT_BODY_1" : "The Triangle button pressed event block causes the program to jump to this block when the triangle button is pressed.",
	"HELP_TEXT_TRIANGLEBUTTON_EVENT_EXAMPLE_1_TITLE" : "Example program: Control LED flash speed setting with buttons",
	"HELP_TEXT_TRIANGLEBUTTON_EVENT_EXAMPLE_1_BODY_1" : "In this example, the program begins by setting the variable called 'Delay' to 100, the program then enters a forever loop. Inside the forever loop, the left and right LEDs are turned on and off with a wait for the value in the 'Delay' variable in milliseconds. This results in the LEDs being on for 100 milliseconds (0.1 seconds) and off for 100 milliseconds (0.1 seconds).",
	"HELP_TEXT_TRIANGLEBUTTON_EVENT_EXAMPLE_1_BODY_2" : "When the triangle button is pressed, the program jumps to the Triangle button pressed event block. The blocks below the Triangle button pressed event block then run, setting the variable called 'Delay' to 50, then playing a beep. The program then returns to the forever loop, but now the value in the variable called 'Delay' is 50, so the time between the LEDs being on and off is now 50 milliseconds (0.05 seconds). This makes them flash on and off faster.",
	"HELP_TEXT_TRIANGLEBUTTON_EVENT_EXAMPLE_1_BODY_3" : "When the round button is pressed, the program jumps to the Round button pressed event block. The blocks below the Round button pressed event block then run, setting the variable called 'Delay' to 200, then playing a beep. The program then returns to the forever loop, but now the value in the variable called 'Delay' is 200, so the time between the LEDs being on and off is now 200 milliseconds (0.2 seconds). This makes them flash on and off slower.",
	"HELP_TEXT_ROUNDBUTTON_EVENT_TITLE" : "Round button pressed",
	"HELP_TEXT_ROUNDBUTTON_EVENT_BODY_1" : "The Round button pressed event block causes the program to jump to this block when the round button is pressed.",
	"HELP_TEXT_ROUNDBUTTON_EVENT_EXAMPLE_1_TITLE" : "Example program: Control LED flash speed setting with buttons",
	"HELP_TEXT_ROUNDBUTTON_EVENT_EXAMPLE_1_BODY_1" : "In this example, the program begins by setting the variable called 'Delay' to 100, the program then enters a forever loop. Inside the forever loop, the left and right LEDs are turned on and off with a wait for the value in the 'Delay' variable in milliseconds. This results in the LEDs being on for 100 milliseconds (0.1 seconds) and off for 100 milliseconds (0.1 seconds).",
	"HELP_TEXT_ROUNDBUTTON_EVENT_EXAMPLE_1_BODY_2" : "When the triangle button is pressed, the program jumps to the Triangle button pressed event block. The blocks below the Triangle button pressed event block then run, setting the variable called 'Delay' to 50, then playing a beep. The program then returns to the forever loop, but now the value in the variable called 'Delay' is 50, so the time between the LEDs being on and off is now 50 milliseconds (0.05 seconds). This makes them flash on and off faster.",
	"HELP_TEXT_ROUNDBUTTON_EVENT_EXAMPLE_1_BODY_3" : "When the round button is pressed, the program jumps to the Round button pressed event block. The blocks below the Round button pressed event block then run, setting the variable called 'Delay' to 200, then playing a beep. The program then returns to the forever loop, but now the value in the variable called 'Delay' is 200, so the time between the LEDs being on and off is now 200 milliseconds (0.2 seconds). This makes them flash on and off slower.",
	"HELP_TEXT_LINEREFLECTIVE_EVENT_TITLE" : "Line tracker on reflective surface",
	"HELP_TEXT_LINEREFLECTIVE_EVENT_BODY_1" : "The Line tracker on reflective surface event block causes the program to jump to this block when the line tracker sensor detects a change from a non-reflective surface (i.e. black) to a reflective surface (i.e. white).",
	"HELP_TEXT_LINEREFLECTIVE_EVENT_BODY_2" : "The line tracker LED must be turned on for the Line tracker on reflective surface event block to work.",
	"HELP_TEXT_LINEREFLECTIVE_EVENT_EXAMPLE_1_TITLE" : "Example program: Follow the edge of a line",
	"HELP_TEXT_LINEREFLECTIVE_EVENT_EXAMPLE_1_BODY_1" : "In this example, the program begins by turning on the line tracking LED, the program then causes the robot to turn right (looking for the edge of a line).",
	"HELP_TEXT_LINEREFLECTIVE_EVENT_EXAMPLE_1_BODY_2" : "When the line tracker detects a change from a reflective (white) to non-reflective (black) surface, the program jumps to the Line tracker on non-reflective surface block and runs the drive block to set the robot to turn left (turning back towards the reflective (white) surface).",
	"HELP_TEXT_LINEREFLECTIVE_EVENT_EXAMPLE_1_BODY_3" : "When the line tracker detects a change from a non-reflective to reflective surface, the program jumps to the Line tracker on reflective surface event block and runs the drive block to set the robot to turn right (turning back towards the non-reflective (black) surface).",
	"HELP_TEXT_LINEREFLECTIVE_EVENT_EXAMPLE_1_BODY_4" : "Each time the robot turns either left or right it moves forward following the edge of the line.",
	"HELP_TEXT_LINENONREFLECTIVE_EVENT_TITLE" : "Line tracker on non-reflective surface",
	"HELP_TEXT_LINENONREFLECTIVE_EVENT_BODY_1" : "The Line tracker on non-reflective surface event block causes the program to jump to this block when the line tracker sensor detects a change from a reflective surface (i.e. white) to a non-reflective surface (i.e. black).",
	"HELP_TEXT_LINENONREFLECTIVE_EVENT_BODY_2" : "The line tracker LED must be turned on for the Line tracker on non-reflective surface event block to work.",
	"HELP_TEXT_LINENONREFLECTIVE_EVENT_EXAMPLE_1_TITLE" : "Example program: Follow the edge of a line",
	"HELP_TEXT_LINENONREFLECTIVE_EVENT_EXAMPLE_1_BODY_1" : "In this example, the program begins by turning on the line tracking LED, the program then causes the robot to turn right (looking for the edge of a line).",
	"HELP_TEXT_LINENONREFLECTIVE_EVENT_EXAMPLE_1_BODY_2" : "When the line tracker detects a change from a reflective (white) to non-reflective (black) surface, the program jumps to the Line tracker on non-reflective surface block and runs the drive block to set the robot to turn left (turning back towards the reflective (white) surface).",
	"HELP_TEXT_LINENONREFLECTIVE_EVENT_EXAMPLE_1_BODY_3" : "When the line tracker detects a change from a non-reflective to reflective surface, the program jumps to the Line tracker on reflective surface block and runs the drive block to set the robot to turn right (turning back towards the non-reflective (black) surface).",
	"HELP_TEXT_LINENONREFLECTIVE_EVENT_EXAMPLE_1_BODY_4" : "Each time the robot turns either left or right it moves forward following the edge of the line.",
	"HELP_TEXT_LINECHANGE_EVENT_TITLE" : "Line tracker changes surface",
	"HELP_TEXT_LINECHANGE_EVENT_BODY_1" : "The Line tracker changes surface event block causes the program to jump to this block when the line tracker sensor detects either a change from a non-reflective (i.e. black) surface to reflective (i.e. white) surface or a from a reflective (i.e. white) surface to a non-reflective (i.e. black) surface.",
	"HELP_TEXT_LINECHANGE_EVENT_BODY_2" : "The line tracker LED must be turned on for the Line tracker changes surface event block to work.",
	"HELP_TEXT_LINECHANGE_EVENT_EXAMPLE_1_TITLE" : "Example program: Stopping for change",
	"HELP_TEXT_LINECHANGE_EVENT_EXAMPLE_1_BODY_1" : "In this example, the program begins by turning on the line tracker LED, the robot then drives forward at speed 1 and enters a forever loop. The robot will then continue to drive forwards until the line tracker sensor detects a change in the reflectivity of the surface (white to black or black to white). When this happens, the program jumps to the Line tracker changes surface block. The code below the Line tracker changes surface then runs, stopping both motors, beeping, waiting 1 second, beeping again, then setting both motors to again drive forward.",
	"HELP_TEXT_MESSAGE_EVENT_TITLE" : "IR message received",
	"HELP_TEXT_MESSAGE_EVENT_BODY_1" : "The IR message received event block causes the program to jump to this block when an Infrared (IR) message from another Edison robot is received.",
	"HELP_TEXT_MESSAGE_EVENT_BODY_3" : "The IR message received event block will not work when the IR receiver is being used to detect obstacles.",
	"HELP_TEXT_MESSAGE_EVENT_BODY_4" : "The program will jump to the IR message received event block when any IR message is received from another Edison robot. The IR message received event block does not decode the data in the IR message. Decoding the message requires that the message data be put into a variable and then decoded using an if then block.",
	"HELP_TEXT_MESSAGE_EVENT_EXAMPLE_1_TITLE" : "Example program: Receive IR message to beep once or twice",
	"HELP_TEXT_MESSAGE_EVENT_EXAMPLE_1_BODY_1" : "In this example, the program begins by entering an empty forever loop and nothing happens. When an IR message is received the program jumps to the IR message received event block. The code below the IR message received event block then runs. First the received message data is stored in the variable 'ReceivedMessage'. This is required as each time the data from the received IR message is read it is also cleared. Now that the message data is in a variable the variable is tested if it is equal to 1, if true, then the beep block is played once. Next, the variable is tested if it is equal to 2, if true, then the beep block plays twice. The program now returns to the forever loop.",
	"HELP_TEXT_MESSAGE_EVENT_EXAMPLE_2_TITLE" : "IR message sending program:",
	"HELP_TEXT_MESSAGE_EVENT_EXAMPLE_2_BODY_1" : "The above program is used in the Edison robot that is sending the IR message. The program first enters an empty forever loop. When the triangle button is pressed, the program jumps to the Triangle button pressed event block and an IR message is sent with the number 1. When the round button is pressed, the program jumps to the Round button pressed event block and an IR message is sent with the number 2.",
	"HELP_TEXT_DRIVESTRAIN_EVENT_TITLE" : "Drive strained",
	"HELP_TEXT_DRIVESTRAIN_EVENT_BODY_1" : "The Drive strained event block causes the program to jump to this block when one or both motors are being driven, but are unable to rotate (under strain).",
	"HELP_TEXT_DRIVESTRAIN_EVENT_EXAMPLE_1_TITLE" : "Example program: Alarm when the left wheel cannot rotate",
	"HELP_TEXT_DRIVESTRAIN_EVENT_EXAMPLE_1_BODY_1" : "In this example, the program begins by setting the left motor to drive forwards, then enters a forever loop. When the wheel cannot rotate due to being under strain, the program jumps to the Drive strained event block and runs the code below. The code below the Drive strained event block is the beep block which plays a beep. The program then returns to the forever loop.",
	"HELP_TEXT_REMOTE_EVENT_TITLE" : "Remote code received",
	"HELP_TEXT_REMOTE_EVENT_BODY_1" : "The Remote code received event block causes the program to jump to this block when a remote-control code is received.",
	"HELP_TEXT_REMOTE_EVENT_BODY_3" : "Make sure you press the triangle button to start your program. This is easy to forget as the Edison robot will respond as a remote-control robot and not do what you have programmed it to.",
	"HELP_TEXT_REMOTE_EVENT_BODY_4" : "To use the remote control blocks the Edison robot must first be taught which buttons of your remote control correspond to which remote code. Learn more about this here:",
	"HELP_TEXT_REMOTE_EVENT_BODY_5" : "If the program behaves unexpectantly, you may need to use the clear sensor data block to clear the contents of the remote code received block. See example program 1 below.",
	"HELP_TEXT_REMOTE_EVENT_BODY_6" : "Receiving infrared remote codes will work with approximately 90% of standard TV remote controls, however each brand uses slightly different data formats. When decoding data, this can cause some unexpected behaviour from one remote control brand to another. Advanced remote-control decoding works best with the EdRemote (available mid 2025).",
	"HELP_TEXT_REMOTE_EVENT_EXAMPLE_1_TITLE" : "Example program: Remote control drive forwards or backwards",
	"HELP_TEXT_REMOTE_EVENT_EXAMPLE_1_BODY" : "In this example, the program begins by entering an empty forever loop. When a remote-control code is received the program jumps to the Remote code received event block. The code below the Remote code received event block runs, the remote code is tested to see if it is equal to 1, if true, then both motors are set to drive forwards, this continues until the code being received no longer equals 1. Next, the received code is tested to see if it is equal to 2, if true, then both motors are set to drive backwards. This continues until the code being received no longer equals 2. Finally, after the remote codes have been tested and are no longer being received the stop block stops both motors. The program returns to the empty forever loop.",
	"HELP_TEXT_CONTROL_WAIT_TITLE" : "Wait sec",
	"HELP_TEXT_CONTROL_WAIT_BODY_1" : "The wait sec block pauses the program for an amount of time in seconds. The amount of time can be from 0.001 seconds (1 millisecond) to 1,073,741 seconds (12.4 days).",
	"HELP_TEXT_CONTROL_WAIT_BODY_2" : "The wait block has just one parameter:",
	"HELP_TEXT_CONTROL_WAIT_BODY_3" : "Value - Can be a constant (typed into the input and does not vary), a variable, a sensing or an operator block.",
	"HELP_TEXT_CONTROL_WAIT_EXAMPLE_1_TITLE" : "Example program 1: Blink the left LED",
	"HELP_TEXT_CONTROL_WAIT_EXAMPLE_1_BODY" : "In this example, the program begins by entering a forever loop. Inside the loop the left LED is turned on, then the program pauses and waits for 0.5 seconds, then the left LED is turned off, then the program again pauses and waits for 0.5 seconds and then loops to the start.",
	"HELP_TEXT_CONTROL_WAIT_EXAMPLE_2_TITLE" : "Example program 2: Nighttime robot cricket",
	"HELP_TEXT_CONTROL_WAIT_EXAMPLE_2_BODY" : "In this example, the program begins by entering a forever loop. Inside the loop there is a wait until block that pauses the progression of the program until the level of light on the left light sensor is less than 100. When this happens, the program progresses to wait for a random number of seconds between 20 and 300. When this wait ends the speaker plays a note. The program then loops back to the beginning of the forever loop. This results in behaviour similar to a cricket at nighttime, so it can't be found.",
	"HELP_TEXT_CONTROL_REPEAT_TITLE" : "Repeat",
	"HELP_TEXT_CONTROL_REPEAT_BODY_1" : "The repeat block is a type of loop that only loops a set number of times. All the blocks inside the repeat block run for only this set number of times.",
	"HELP_TEXT_CONTROL_REPEAT_BODY_2" : "The repeat block has just one parameter:",
	"HELP_TEXT_CONTROL_REPEAT_BODY_3" : "Value - Can be a constant (typed into the input and does not vary), a variable, a sensing or an operator block.",
	"HELP_TEXT_CONTROL_REPEAT_EXAMPLE_1_TITLE" : "Example program 1: Drive in a square",
	"HELP_TEXT_CONTROL_REPEAT_EXAMPLE_1_BODY" : "In this example, the program begins by entering into a repeat block that is set to repeat four times. Inside the repeat block the robot drives forward 10cm, then spins right 90 degrees. These two blocks inside the repeat block run four times. The result is that the Edison robot drives in the shape of a square.",
	"HELP_TEXT_CONTROL_FOREVER_TITLE" : "Forever",
	"HELP_TEXT_CONTROL_FOREVER_BODY_1" : "The forever block is a type of loop block that loops unconditionally forever (unless the program is stopped). The blocks placed inside the forever block run and then run again and again and…",
	"HELP_TEXT_CONTROL_FOREVER_EXAMPLE_1_TITLE" : "Example program: Blink a LED",
	"HELP_TEXT_CONTROL_FOREVER_EXAMPLE_1_BODY" : "In this example, the program begins by entering a forever loop. Inside the forever loop the left LED is turned on, then the wait block pauses the program for 0.25 seconds, then the left LED is turned off, then the wait block pauses the program for 0.25 seconds. The program then loops back to the turn left LED on block and the sequence repeats forever.",
	"HELP_TEXT_CONTROL_IF_TITLE" : "If then",
	"HELP_TEXT_CONTROL_IF_BODY_1" : "The if then block runs the blocks if the input condition is true. If the condition is not true, then the program continues to the next block in the program.",
	"HELP_TEXT_CONTROL_IF_BODY_2" : "This block has one input parameter:",
	"HELP_TEXT_CONTROL_IF_BODY_3" : "Conditional input - The conditional input accepts diamond shaped blocks that can be either an operator block or sensing block.",
	"HELP_TEXT_CONTROL_IF_BODY_4" : "The if then block is usually used inside a forever loop, so that the if then condition can be tested multiple times. If a program has just an if then block, then the test will be run once and the program will exit.",
	"HELP_TEXT_CONTROL_IF_EXAMPLE_1_TITLE" : "Example program 1: Blink LED if there is a clap",
	"HELP_TEXT_CONTROL_IF_EXAMPLE_1_BODY" : "n this example, the program begins by entering a forever loop. The first block in the forever loop is the if then block that tests if there has been a clap. If false, then the contents of the if then block is skipped and the program loops back to start of the forever loop. If a clap has been detected (true), then the blocks inside the if then block run. First the left LED is turned on, then the program pauses for one second, then the left LED is turned off. The program now loops back to the start of the forever loop. The result is that the Edison robot blinks its left LED for one second whenever it detects a clap.",
	"HELP_TEXT_CONTROL_IF_EXAMPLE_2_TITLE" : "Example program 2: Draw open alarm",
	"HELP_TEXT_CONTROL_IF_EXAMPLE_2_BODY" : "In this example, the program begins by entering a forever loop. The first block in the forever loop is the if then block that tests if the level of light on the left light sensor is greater than 100. If this is true (light level is greater than 100) then the beep block runs and the Edison robot beeps like an alarm. If it is not true (light level is less than 100), then the beep block is skipped and the program loops back to the start of the forever loop. The result is that the Edison beeps rapidly whenever it detects a light level above 100.",
	"HELP_TEXT_CONTROL_IF_ELSE_TITLE" : "If then else",
	"HELP_TEXT_CONTROL_IF_ELSE_BODY_1" : "The if then else block runs the first set of blocks if the input condition is true. If the condition is false, then the second set of blocks run.",
	"HELP_TEXT_CONTROL_IF_ELSE_BODY_2" : "This block has one input parameter:",
	"HELP_TEXT_CONTROL_IF_ELSE_BODY_3" : "Conditional input - The conditional input accepts diamond shaped blocks that can be either an operator block or sensing block.",
	"HELP_TEXT_CONTROL_IF_ELSE_BODY_4" : "The if then else block is usually used inside a forever loop, so that the if then else condition can be tested multiple times. If a program has just an if then else block, then the test will be run once and the program will exit.",
	"HELP_TEXT_CONTROL_IF_ELSE_EXAMPLE_1_TITLE" : "Example program 1: Bounce in borders",
	"HELP_TEXT_CONTROL_IF_ELSE_EXAMPLE_1_BODY" : "In this example, the program begins by turning the line tracker sensor LED on, then enters a forever loop. The first block in the forever loop is the if then else block that tests if the line tracker sensor is on a non-reflective surface (black). If this is true then the first set of blocks run driving the robot backwards and then spinning 90 degrees. The program jumps over the else block and then loops back to once again test if the line tracker sensor is on a non-reflective surface (black), if this is false (on white), then the else block runs, setting both motors to drive forward. This results in the Edison robot 'bouncing' off a black line and turning around. This results in Edison driving away from detected black lines.",
	"HELP_TEXT_CONTROL_IF_ELSE_EXAMPLE_2_TITLE" : "Example program 2: Follow the light",
	"HELP_TEXT_CONTROL_IF_ELSE_EXAMPLE_2_BODY" : "In this example, the program begins by entering a forever loop. The first block in the forever loop is the if then else block that tests if the light level on the right sensor is less than the light level on the left sensor. If this is true (light is brighter on the left) then the next block to run is the set both motors to turn robot left (the robot turns left towards the light). Alternatively, if the result is false (light is brighter on the right), then the next block to run are the else blocks. Now the block set both motors to turn robot right run (the robot turns towards the light). The result is that the Edison robot drives towards the brightest light source (try using a flashlight to control where Edison drives).",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_TITLE" : "Wait until",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_BODY_1" : "The wait until block pauses the program until the input condition is true.",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_BODY_2" : "This block has one input parameter:",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_BODY_3" : "Conditional input - The conditional input accepts diamond shaped blocks that can be either an operator block or sensing block.",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_BODY_4" : "The wait until block is usually used inside a forever loop, so that the wait until condition can be tested multiple times. If a program has just a wait until block, then the test will be run once and the program will exit.",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_EXAMPLE_1_TITLE" : "Example program 1: Blink LED if there is a clap",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_EXAMPLE_1_BODY" : "In this example, the program begins by entering a forever loop. The first block in the forever loop is the clear sensor data block that clears any false clap data. Next is the wait until block with a conditional input clap detected block. The program will pause here and wait until a clap is detected. When a clap is detected, the program progresses to turn the left LED on, then wait for one second, then turn the left LED off. The program now loops back to the wait until block. Each time there is a clap the left LED turns on for one second. The result is that the Edison robot blinks its left LED for one second whenever it detects a clap.",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_EXAMPLE_2_TITLE" : "Example program 2: Source of brightest light detector",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_EXAMPLE_2_BODY" : "In this example, the program begins by entering a forever loop. The first block in the forever loop is the wait until block with a conditional input using an operator requiring the light level on the right light sensor to equal the light level on the left light sensor. If the condition is not true (the light levels are not equal), then the program pauses here. When the light level on both light sensors is equal, then the program progresses to the beep block. The program now loops back to the wait until block and the program repeats. This results in the Edison robot beeping when it is pointing towards the brightest source of light",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_TITLE" : "Repeat until",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_BODY_1" : "The repeat until block runs the blocks inside it, until the input condition is true.",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_BODY_2" : "This block has one input parameter:",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_BODY_3" : "Conditional input - The conditional input accepts diamond shaped blocks that can be either an operator block or sensing block.",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_BODY_4" : "The repeat until block is often used inside a forever loop, so that the repeat until condition can be tested multiple times. If a program has just a repeat until block, then the test will be run once and the program will exit.",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_EXAMPLE_1_TITLE" : "Example program 1: Stop the alarm from sounding",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_EXAMPLE_1_BODY" : "In this example, the program begins by tuning on the obstacle detector (setting the alarm) and then enters a forever loop. The first block in the forever loop is a wait until block with a conditional input of obstacle detected anywhere (the intruder detector). The program will pause and wait here until an obstacle (intruder) is detected. When an obstacle is detected, the program progresses to the repeat until block, this causes the beep block to be run and repeat over and over (the alarm sound), 'until' the round button is pressed (stopping and resetting the alarm).",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_EXAMPLE_2_TITLE" : "Example program 2: Edison shivers cold without warm light",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_EXAMPLE_2_BODY" : "In this example, the program begins by entering a forever loop. The first block in the forever loop is the repeat until block with a conditional input using an operator requiring the light level of the left light sensor to be greater than 980 (very bright/sunlight). If this is not true, then the blocks below run, quickly spinning the Edison robot left and right (shivering). If the light level of the left light sensor increases above 980 (Edison moves into very bright light), then the condition becomes true and the program pauses (The Edison robot is warm and happy).",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_TITLE" : "Wait Milliseconds",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_BODY_1" : "The wait milliseconds block pauses the program for an amount of time in milliseconds (ms). A millisecond is one one-thousandths (1/1000) of a second or 0.001 seconds.",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_BODY_2" : "1500 milliseconds = 1.5 seconds",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_BODY_3" : "100 milliseconds = 0.1 seconds",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_BODY_4" : "25 milliseconds = 0.025 seconds",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_BODY_5" : "The wait milliseconds block has just one parameter:",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_BODY_6" : "Value - Can be a variable, a sensing or an operator block",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_EXAMPLE_1_TITLE" : "Example program 1: Fast blinking LED",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_EXAMPLE_1_BODY" : "In this example, the program begins by setting the variable 'Delay' to 50, then enters a forever loop. Inside the forever loop the left LED is turned on, then the wait milliseconds block pauses for the value in 'Delay' milliseconds, in this case 50 milliseconds. Then the left LED is turned off, then the wait milliseconds block pauses for 50 milliseconds. The program now loops back to the start of the forever loop.",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_EXAMPLE_2_TITLE" : "Example program 2: Crazy lights",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_EXAMPLE_2_BODY" : "In this example, the program begins by entering a forever loop. Inside the forever loop, the left and right LEDs are turned on and off. The wait times between turning on and off are controlled by the wait milliseconds blocks. The time in milliseconds is set by the random number blocks inside them. These are set to generate random numbers between 30 and 300 milliseconds. The result is a randomised flashing of the Edison robot's LED lights.",
	"HELP_TEXT_SENSING_TURNLINETRACKINGLED_TITLE" : "Turn line tracking LED on/off",
	"HELP_TEXT_SENSING_TURNLINETRACKINGLED_BODY_1" : "The turn line tracker LED on/off block sets the line tracker LED to either on or off.",
	"HELP_TEXT_SENSING_TURNLINETRACKINGLED_BODY_2" : "The line tracker LED must be on for the line tracking sensor to work.",
	"HELP_TEXT_SENSING_TURNLINETRACKINGLED_EXAMPLE_1_TITLE" : "Example program: Stop on black surface",
	"HELP_TEXT_SENSING_TURNLINETRACKINGLED_EXAMPLE_1_BODY" : "In this example, the program begins by turning the line tracking LED on, then both motors are set to drive forwards. The program then waits until the line tracker sensor detects a non-reflective surface (black), when this happens the program ends and the motors stop.",
	"HELP_TEXT_SENSING_TURNOBSTACLEBEAM_TITLE" : "Turn obstacle detection beam on/off",
	"HELP_TEXT_SENSING_TURNOBSTACLEBEAM_BODY_1" : "The turn obstacle detection beam on/off block sets the obstacle detection beam to either on or off.",
	"HELP_TEXT_SENSING_TURNOBSTACLEBEAM_BODY_2" : "The obstacle detection beam must be on for obstacle detection to work.",
	"HELP_TEXT_SENSING_TURNOBSTACLEBEAM_EXAMPLE_1_TITLE" : "Example program: Stop for an obstacle",
	"HELP_TEXT_SENSING_TURNOBSTACLEBEAM_EXAMPLE_1_BODY" : "In this example, the program begins by turning the obstacle detection beam on, then both motors are set to drive forwards. The program then waits until an obstacle is detected anywhere, when this happens the program ends and the motors stop.",
	"HELP_TEXT_SENSING_CLEARSENSOR_TITLE" : "Clear sensor data",
	"HELP_TEXT_SENSING_CLEARSENSOR_BODY_1" : "The clear sensor data block clears any sensor data (detections) from the selected sensor. This block is used when there might be false or unwanted detections that stop the program from working in the way that you want. An example is when a program drives the Edison robot as a result of detecting a clap. Generally, driving is quite noisy and can re-trigger an additional detection of a clap. This causes the program to detect a second clap that didn't happen. The clear sensor data block is used to clear the sensor data of any unwanted detections like this.",
	"HELP_TEXT_SENSING_CLEARSENSOR_BODY_2" : "The clear sensor data block has five input options:",
	"HELP_TEXT_SENSING_CLEARSENSOR_BODY_3" : "clap detector",
	"HELP_TEXT_SENSING_CLEARSENSOR_BODY_4" : "keypad",
	"HELP_TEXT_SENSING_CLEARSENSOR_BODY_5" : "obstacle detector",
	"HELP_TEXT_SENSING_CLEARSENSOR_BODY_6" : "remote code",
	"HELP_TEXT_SENSING_CLEARSENSOR_BODY_7" : "IR message",
	"HELP_TEXT_SENSING_CLEARSENSOR_EXAMPLE_1_TITLE" : "Example program 1: Clap and spin",
	"HELP_TEXT_SENSING_CLEARSENSOR_EXAMPLE_1_BODY" : "In this example, the program begins by entering a forever loop. Inside the forever loop, the clear sensor data block is set to clear the clap detector, next the program waits until a clap is detected, when this happens the program progresses and the robot spins left for two seconds. During the spinning the motors, wheels and skid make noise, this noise re-triggers the clap detector, so now the clap detector thinks that there was a second clap. The program loops back to the start of the forever loop (still holding onto the clap detection), but then the clear sensor data block clears the detection and the wait until block will not be triggered until there actually is a clap.",
	"HELP_TEXT_SENSING_CLAPDETECTED_TITLE" : "Clap detected",
	"HELP_TEXT_SENSING_CLAPDETECTED_BODY_1" : "The clap detected block is a sensor input block that indicates whether or not a clap has been detected. It is a diamond shaped block so the data in the block can only be either true (clap has been detected) or false (clap has not been detected).",
	"HELP_TEXT_SENSING_CLAPDETECTED_BODY_2" : "Other noises such as the motors driving can cause the clap detected block to false trigger. Use the clear sensor data block to clear false or unwanted clap detections.",
	"HELP_TEXT_SENSING_CLAPDETECTED_EXAMPLE_1_TITLE" : "Example program 1: Blink LED if there is a clap",
	"HELP_TEXT_SENSING_CLAPDETECTED_EXAMPLE_1_BODY" : "In this example, the program begins by entering a forever loop. Inside the forever loop there is an if then block that tests if a clap has been detected. When a clap is detected, the left LED turns on, then the program waits for one second, then the left LED turns off. The program then loops back to the start of the forever loop. The result is that the Edison robot blinks its left LED for one second whenever it detects a clap.",
	"HELP_TEXT_SENSING_BUTTONPRESSED_TITLE" : "Button Pressed",
	"HELP_TEXT_SENSING_BUTTONPRESSED_BODY_1" : "The button pressed block is a sensor input that indicates whether or not a button has been pressed. There are two button options:",
	"HELP_TEXT_SENSING_BUTTONPRESSED_BODY_2" : "round",
	"HELP_TEXT_SENSING_BUTTONPRESSED_BODY_3" : "triangle",
	"HELP_TEXT_SENSING_BUTTONPRESSED_BODY_4" : "The button pressed block is a diamond shaped block so the data in the block can only be either true (button has been pressed) or false (button has not been pressed).",
	"HELP_TEXT_SENSING_BUTTONPRESSED_EXAMPLE_1_TITLE" : "Example program: Beep on button press",
	"HELP_TEXT_SENSING_BUTTONPRESSED_EXAMPLE_1_BODY" : "In this example, the program begins by entering a forever loop. Inside the forever loop there is an if then block that tests if the round button has been pressed. When the round button is pressed, the program runs the beep block and then loops back to the start of the forever loop.",
	"HELP_TEXT_SENSING_OBSTACLE_TITLE" : "Obstacle Detected",
	"HELP_TEXT_SENSING_OBSTACLE_BODY_1" : "The obstacle detected block is a sensor input block that indicates whether or not an obstacle has been detected. There are four detection options:",
	"HELP_TEXT_SENSING_OBSTACLE_BODY_2" : "anywhere",
	"HELP_TEXT_SENSING_OBSTACLE_BODY_3" : "ahead",
	"HELP_TEXT_SENSING_OBSTACLE_BODY_4" : "left",
	"HELP_TEXT_SENSING_OBSTACLE_BODY_5" : "right",
	"HELP_TEXT_SENSING_OBSTACLE_BODY_6" : "The obstacle detected block is a diamond shaped block so the data in the block can only be either true (obstacle has been detected) or false (obstacle has not been detected).",
	"HELP_TEXT_SENSING_OBSTACLE_BODY_7" : "To use the obstacle detected block the turn obstacle detection beam on/off block must be used to turn the obstacle detection beam on.",
	"HELP_TEXT_SENSING_OBSTACLE_EXAMPLE_1_TITLE" : "Example program: Avoid obstacles",
	"HELP_TEXT_SENSING_OBSTACLE_EXAMPLE_1_BODY" : "In this example, the program begins by setting the obstacle detection beam to on, then enters a forever loop. Inside the forever loop the motors are set to both drive forwards, then there is an if then block that tests if an obstacle has been detected anywhere. When this happens, the robot spins 180 degrees and loops back to the start of the forever loop. At the beginning of the forever loop both motors are again set to drive forwards. This results in Edison driving away from obstacles in its path.",
	"HELP_TEXT_SENSING_LINETRACKER_TITLE" : "Line tracker on surface",
	"HELP_TEXT_SENSING_LINETRACKER_BODY_1" : "The line tracker on surface block is a sensor input block that indicates whether or not the surface is reflective. A reflective surface is a surface that reflects the line tracker LED's light back to the light sensor. This is usually a white surface, but a red surface will also reflect the red light from the line tracker's red LED. A non-reflective surface is a surface that does not reflect the line tracker LED's light back to the light sensor. This is usually black, but a blue or green surface will also not reflect the red light from the line tracker's red LED.",
	"HELP_TEXT_SENSING_LINETRACKER_BODY_2" : "There are two detection options:",
	"HELP_TEXT_SENSING_LINETRACKER_BODY_3" : "reflective (white)",
	"HELP_TEXT_SENSING_LINETRACKER_BODY_4" : "non-reflective (black)",
	"HELP_TEXT_SENSING_LINETRACKER_BODY_5" : "The line tracker on surface block is a diamond shaped block so the data in the block can only be either true (surface type has been detected) or false (surface type has not been detected).",
	"HELP_TEXT_SENSING_LINETRACKER_BODY_6" : "To use the line tracker on surface block the turn line tracking LED on/off block must be used to turn the line tracking LED on.",
	"HELP_TEXT_SENSING_LINETRACKER_EXAMPLE_1_TITLE" : "Example program: Bounce in borders",
	"HELP_TEXT_SENSING_LINETRACKER_EXAMPLE_1_BODY" : "In this example, the program begins by turning the line tracking LED on, then enters a forever loop. Inside the forever loop the motors are set to both drive forwards, then there is an if then block that tests if the surface is non-reflective. When this is true, the robot spins 180 degrees and loops back to the start of the forever loop. At the beginning of the forever loop both motors are again set to drive forwards. This results in Edison driving away from detected black lines.",
	"HELP_TEXT_SENSING_REMOTE_BOOL_TITLE" : "Remote code received",
	"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_1" : "The remote code received block is a sensor input block that indicates whether or not a particular remote-control code has been received.",
	"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_2" : "There are eight remote code options from 0 to 7.",
	"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_3" : "The remote code received block is a diamond shaped block so the data in the block can only be either true (code has been received) or false (code has not been received).",
	"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_4" : "Make sure you press the triangle button to start your program. This is easy to forget as the Edison robot will respond as a remote-control robot and not do what you have programmed it to.",
	"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_5" : "To use the remote code received block the Edison robot must first be taught which buttons of your remote control correspond to which remote code. Learn more about this here:",
	"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_6" : "If the program behaves unexpectedly, you may need to use the clear sensor data block to clear the contents of the remote code received block. See example program 1 below.",
	"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_7" : "The remote code received block will work with approximately 90% of standard TV infrared (IR) remote controls, however each TV brand uses slightly different IR data formats. When Edison is decoding IR data, these differences can cause some unexpected behaviour from one remote control brand to another. Advanced remote-control decoding works best with the EdRemote (available mid 2025).",
	"HELP_TEXT_SENSING_REMOTE_BOOL_EXAMPLE_1_TITLE" : "Example program 1: One beep or two?",
	"HELP_TEXT_SENSING_REMOTE_BOOL_EXAMPLE_1_BODY" : "In this example, the program begins by entering a forever loop. Inside the forever loop there are two if then blocks that test the received remote code. The first if then tests if the received remote code is remote code 1. If this is true then the beep block plays once and the sensor data is then cleared. If it is false, the program progresses to the next if then block and tests if the received remote code is remote code 2. If this is true then the beep block plays twice and the sensor data is then cleared. The program then loops back to the beginning of the forever loop.",
	"HELP_TEXT_SENSING_REMOTE_BOOL_EXAMPLE_2_TITLE" : "Example program 2: Spin on remote control command (works best with the EdRemote)",
	"HELP_TEXT_SENSING_REMOTE_BOOL_EXAMPLE_2_BODY" : "In this example, the program begins by entering a forever loop. Inside the forever loop the if then block tests if remote code 0 has been received. If this is true, then both motors are set to spin the robot right. This continues until the wait until block condition passes. To pass the received remote code must not be remote code 0 (the remote-control button is no longer being pressed). When this happens, the program progresses to stop both motors and then loop to the start of the forever loop. This results in Edison spinning while the remote button is held down.",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_TITLE" : "IR message detected",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_BODY_1" : "The IR message detected block is a sensor input that indicates whether or not an IR message has been detected (received) from another Edison robot. The term 'IR' is short for 'infrared'. Infrared refers to a band of light that is not visible to humans. This makes is useful as a means to communicate data short distances.",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_BODY_2" : "The IR message detected block is a diamond shaped block so the data in the block can only be either true (IR message has been received) or false (IR message has not been received).",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_BODY_4" : "The IR message detected block does not know the contents of the IR message that was received. It only tells the program if an IR message has been received. To read the data in the IR message use the received IR message block. See the example program.",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_BODY_5" : "Infrared messaging between Edison robots works best indoors away from direct sunlight. The typical range can be up to 10 meters (30 feet).",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_EXAMPLE_1_TITLE" : "Example program: Edison remote light on and off",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_EXAMPLE_1_BODY" : "In this example, the program begins by entering a forever loop. Inside the forever loop the first if then block tests if an IR message has been received, if this is true then the variable 'IRMessage' is set to the value from the received IR message block. Doing this allows the received message to be read/tested multiple times without being cleared or lost. The next if then statement tests if the data in 'IRMessage' is equal to 1, if this is true, then the left LED is turned on. If this is not true, then the program moves on to the next if then block. This if then block tests if the data in 'IR Message' is equal to 2, if this is true, then the left LED is turned off. The program then loops back to the start of the forever loop.",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_EXAMPLE_2_TITLE" : "The IR message sending Edison robot runs this program.",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_EXAMPLE_2_BODY" : "Pressing the triangle button sends an IR message with the number 1 (turn the LED on) and pressing the round button sends an IR message with the number 2 (turn the LED off)",
	"HELP_TEXT_SENSING_DRIVESTRAINED_TITLE" : "Drive strain detected",
	"HELP_TEXT_SENSING_DRIVESTRAINED_BODY_1" : "The drive strain detected block is a sensor input block that indicates whether or not one or both of the wheels have stopped rotating due to being under strain (physically prevented from rotating when trying to drive).",
	"HELP_TEXT_SENSING_DRIVESTRAINED_BODY_2" : "The drive strain detected block is a diamond shaped block so the data in the block can only be either true (wheel is under strain) or false (wheel is not under strain).",
	"HELP_TEXT_SENSING_DRIVESTRAINED_EXAMPLE_1_TITLE" : "Example program: Wheel strained alarm",
	"HELP_TEXT_SENSING_DRIVESTRAINED_EXAMPLE_1_BODY" : "In this example, the program begins by setting the left wheel to drive forwards, next the program enters a forever loop. Inside the loop there is an if then block that tests if drive strain is detected. When this is true the beep block is run. The beep block will continue to run until the strain is removed and the wheel can rotate.",
	"HELP_TEXT_SENSING_REMOTE_NUM_TITLE" : "Received remote code",
	"HELP_TEXT_SENSING_REMOTE_NUM_BODY_1" : "The received remote code block is a sensor input block that contains data received from a remote control. The data is a number from 0 to 7.",
	"HELP_TEXT_SENSING_REMOTE_NUM_BODY_2" : "When a program runs this block, its contents are cleared. It is always best to put the data from the received remote code block into a variable before testing it with a conditional (if then) block. See example program.",
	"HELP_TEXT_SENSING_REMOTE_NUM_EXAMPLE_1_TITLE" : "Example program: Remote control light on and off",
	"HELP_TEXT_SENSING_REMOTE_NUM_EXAMPLE_1_BODY" : "In this example, the program begins by entering a forever loop. The first block inside the forever loop puts the data from the received remote code block into the variable 'RemoteCode'. The variable 'RemoteCode' can now be tested. The first if then block tests if contents of 'RemoteCode' is equal to 1. If this is true then the left LED is turned on. If this is false, then the next if then block tests if contents of 'RemoteCode' is equal to 2. If this is true, then the left LED is turned off. The program then loops back to the start of the forever loop.",
	"HELP_TEXT_SENSING_IRMESSAGE_TITLE" : "Received IR message",
	"HELP_TEXT_SENSING_IRMESSAGE_BODY_1" : "The received IR message block is a sensor input block that contains data received from another Edison robot. The term 'IR' is short for 'infrared'. Infrared refers to a band of light that is not visible to humans. This makes it useful as a means to communicate data short distances. The data is based on an 8-bit binary number and has a range of 0 to 255.",
	"HELP_TEXT_SENSING_IRMESSAGE_BODY_2" : "When a program runs this block its contents is cleared. It is always best to put the data from the received remote code into a variable before testing it with a conditional (if then block) block.",
	"HELP_TEXT_SENSING_IRMESSAGE_BODY_3" : "Infrared messaging between Edison robots works best indoors away from direct sunlight. The typical range can be up to 10 meters (30 feet).",
	"HELP_TEXT_SENSING_IRMESSAGE_EXAMPLE_1_TITLE" : "Example program: Start a dance revolution",
	"HELP_TEXT_SENSING_IRMESSAGE_EXAMPLE_1_BODY" : "In this example, the program begins by entering a forever loop. The first block inside the forever loop clears the IR message sensor data, the program then waits until an IR message is received that is equal to 3. When this happens, the program enters a repeat loop for four times. Inside the repeat loop are the Edison robot's dance manoeuvres. Each of these moves is based on time not distance. This is really important if there is a whole class of Edison robots dancing in sync to music. The dance manoeuvres repeat four times, the program then loops back to the start of the forever loop.",
	"HELP_TEXT_SENSING_IRMESSAGE_EXAMPLE_2_TITLE" : "Example program: Send IR message 3",
	"HELP_TEXT_SENSING_IRMESSAGE_EXAMPLE_2_BODY" : "In this example, the program begins by entering a forever loop. The first block inside the forever loop waits until the round button is pressed, when this happens the message number 3 is transmitted via infrared light. The program then loops back to the start of the forever loop.",
	"HELP_TEXT_SENSING_LIGHTLEVEL_TITLE" : "Light level of sensor",
	"HELP_TEXT_SENSING_LIGHTLEVEL_BODY_1" : "The light level of sensor block is a sensor input block that contains data from the light sensors. The light level is a number between 1 and 1000. The light level of sensor block data is constantly updated.",
	"HELP_TEXT_SENSING_LIGHTLEVEL_BODY_2" : "There are three light sensor inputs to select from:",
	"HELP_TEXT_SENSING_LIGHTLEVEL_BODY_3" : "- left light (sensor at the front left side)",
	"HELP_TEXT_SENSING_LIGHTLEVEL_BODY_4" : "- right light (sensor at the front right side)",
	"HELP_TEXT_SENSING_LIGHTLEVEL_BODY_5" : "- line tracking (sensor used to detect lines under the robot)",
	"HELP_TEXT_SENSING_LIGHTLEVEL_EXAMPLE_1_TITLE" : "Example program: Night light",
	"HELP_TEXT_SENSING_LIGHTLEVEL_EXAMPLE_1_BODY" : "In this example, the program begins by entering a forever loop. The first block inside the forever loop tests if the light level reading on the left light sensor is less than 50. If this is true, then the left and right LEDs turn on. If this is false, then the program jumps to else and the left and right LEDs turn off. The program then loops to the start of the forever loop and repeats. This results in Edison's LEDs being on while it's in a dim light.",
	"HELP_TEXT_ADDITION_TITLE" : "Addition",
	"HELP_TEXT_ADDITION_BODY" : "The addition operator block adds two values together. The values can be a constant (typed into the input and does not vary), a variable, sensing or an operator block.",
	"HELP_TEXT_ADDITION_EXAMPLE_1_TITLE" : "The constant value 2 is added to the constant value 2.",
	"HELP_TEXT_ADDITION_EXAMPLE_2_TITLE" : "The variable 'Counter' is added to the constant value 2.",
	"HELP_TEXT_ADDITION_EXAMPLE_3_TITLE" : "The sensor input light level of sensor is added to the constant value 10.",
	"HELP_TEXT_SUBTRACTION_TITLE" : "Subtraction",
	"HELP_TEXT_SUBTRACTION_BODY" : "The subtraction operator block subtracts one value from another. The values can be a constant (typed into the input and does not vary), a variable, sensing or an operator block.",
	"HELP_TEXT_SUBTRACTION_EXAMPLE_1_TITLE" : "The constant value 10 is subtracted from the constant value 200.",
	"HELP_TEXT_SUBTRACTION_EXAMPLE_2_TITLE" : "The constant value 100 is subtracted from the variable 'Counter'.",
	"HELP_TEXT_SUBTRACTION_EXAMPLE_3_TITLE" : "The constant value 10 is subtracted from the sensor input light level of sensor.",
	"HELP_TEXT_SUBTRACTION_EXAMPLE_4_TITLE" : "Example program: Light radiation counter",
	"HELP_TEXT_SUBTRACTION_EXAMPLE_4_BODY" : "In this example program, the music tempo is first set to very fast. The program then enters a forever loop. Inside the loop the program sets the variable (Delay) to 1000 minus the left light level (inverting the light level reading). The next block waits for the value in the (Delay) variable. The program then plays the note C and loops back to the start of the forever loop and repeats. This results in the Edison beeping slow when in darkness and faster when the light level is brighter.",
	"HELP_TEXT_MULTIPLICATION_TITLE" : "Multiplication",
	"HELP_TEXT_MULTIPLICATION_BODY" : "The multiplication operator block multiplies two values. The values can be a constant (typed into the input and does not vary), a variable, sensing or an operator block.",
	"HELP_TEXT_MULTIPLICATION_EXAMPLE_1_TITLE" : "The constant value 2 is multiplied by the constant value 4.",
	"HELP_TEXT_MULTIPLICATION_EXAMPLE_2_TITLE" : "The variable 'Counter' is multiplied by the constant value 2.",
	"HELP_TEXT_MULTIPLICATION_EXAMPLE_3_TITLE" : "The sensor input light level of sensor is multiplied by the constant value 4.",
	"HELP_TEXT_DIVISION_TITLE" : "Division",
	"HELP_TEXT_DIVISION_BODY_1" : "The division operator block divides one value by another value. The values can be a constant (typed into the input and does not vary), a variable, sensing or an operator block.",
	"HELP_TEXT_DIVISION_BODY_2" : "it is not possible to divide by zero, Edison will experience an error if the right most input is zero.",
	"HELP_TEXT_DIVISION_EXAMPLE_1_TITLE" : "The constant value 10 is divided by the constant value 2.",
	"HELP_TEXT_DIVISION_EXAMPLE_2_TITLE" : "The variable 'Counter' is divided by the constant value 2.",
	"HELP_TEXT_DIVISION_EXAMPLE_3_TITLE" : "The sensor input light level of sensor is divided by 10.",
	"HELP_TEXT_DIVISION_EXAMPLE_4_TITLE" : "Example program: Setting the drive distance using a variable and data from a sensor",
	"HELP_TEXT_DIVISION_EXAMPLE_4_BODY" : "In this example program, Edison sets the (Distance) variable to the light level from the left light sensor (a value from 1 to 1,000) divided by 50. The Edison then drives forward for the value in the (Distance) variable at speed 5. This results in Edison driving further in bright light, to a maximum distance of 20cm.",
	"HELP_TEXT_RANDOM_NUMBER_TITLE" : "random number",
	"HELP_TEXT_RANDOM_NUMBER_BODY" : "The random number between block generates a random number between two values. The values can be a constant (typed into the input and does not vary), a variable, sensing or an operator block.",
	"HELP_TEXT_RANDOM_NUMBER_EXAMPLE_1_TITLE" : "Generate a random number between the constant value 10 and the constant value 100.",
	"HELP_TEXT_RANDOM_NUMBER_EXAMPLE_2_TITLE" : "Generate a random number between the variable 'Counter' and the constant value 5000.",
	"HELP_TEXT_RANDOM_NUMBER_EXAMPLE_3_TITLE" : "Generate a random number between the constant value 10 and the sensor input light level of sensor.",
	"HELP_TEXT_RANDOM_NUMBER_EXAMPLE_4_TITLE" : "Example program: Crazy lights",
	"HELP_TEXT_RANDOM_NUMBER_EXAMPLE_4_BODY" : "In this example, the program begins by entering a forever loop. Inside the forever loop, the left and right LEDs are turned on and off. The wait times between turning on and off are controlled by the wait milliseconds blocks. The time in milliseconds is set by the random number blocks inside them. These are set to generate random numbers between 30 and 300 milliseconds. The result is a crazy and inconsistent flashing of the Edison robot's LED lights.",
	"HELP_TEXT_ABS_VAL_TITLE" : "abs",
	"HELP_TEXT_ABS_VAL_BODY" : "The abs (absolute value) block converts a value to an absolute value. An absolute value is a value that is always positive. The value can be a constant (typed into the input and does not vary), a variable, sensing or an operator block.",
	"HELP_TEXT_ABS_VAL_EXAMPLE_1_BODY" : "Has a result of the value 3.",
	"HELP_TEXT_ABS_VAL_EXAMPLE_2_BODY" : "Has a result of the value 3.",
	"HELP_TEXT_ABS_VAL_EXAMPLE_3_TITLE" : "Example program: report the difference between light levels",
	"HELP_TEXT_ABS_VAL_EXAMPLE_3_BODY" : "In this example, the program begins by entering a forever loop. The first block in the forever loop sets the variable 'Difference' to the absolute value of the light level from the right light sensor minus the light level from the left light sensor. The abs block ensures that the result is always positive (no negative numbers). The program then waits for one second and then sends the value in the variable 'Difference' via USB. This value is always a positive (absolute) value.",
	"HELP_TEXT_LESS_THAN_TITLE" : "Less than",
	"HELP_TEXT_LESS_THAN_BODY_1" : "The less than block compares two input values to determine if the first value is less than the second value and returns a result that is either true or false. The values can be a constant (typed into the input and does not vary), a variable, sensing or an operator block.",
	"HELP_TEXT_LESS_THAN_BODY_2" : "The less than block is a diamond shaped block so the result of the block can only be either true or false.",
	"HELP_TEXT_LESS_THAN_EXAMPLE_1_BODY" : "Result: true",
	"HELP_TEXT_LESS_THAN_EXAMPLE_2_BODY" : "Result: false",
	"HELP_TEXT_LESS_THAN_EXAMPLE_3_TITLE" : "Is the variable 'Counter' less than the constant value 120.",
	"HELP_TEXT_LESS_THAN_EXAMPLE_4_TITLE" : "Is the light level from the left sensor less than the constant value 500.",
	"HELP_TEXT_LESS_THAN_EQUAL_TITLE" : "Less than or equal to",
	"HELP_TEXT_LESS_THAN_EQUAL_BODY_1" : "The less than or equal to block compares two input values to determine if the first value is less than or equal to the second value and returns a result that is either true or false. The values can be a constant (typed into the input and does not vary), a variable, sensing or an operator block.",
	"HELP_TEXT_LESS_THAN_EQUAL_BODY_2" : "The less than or equal to block is a diamond shaped block so the result of the block can only be either true or false.",
	"HELP_TEXT_LESS_THAN_EQUAL_EXAMPLE_1_BODY" : "Result: true",
	"HELP_TEXT_LESS_THAN_EQUAL_EXAMPLE_2_BODY" : "Result: false",
	"HELP_TEXT_LESS_THAN_EQUAL_EXAMPLE_3_BODY" : "Result: true",
	"HELP_TEXT_LESS_THAN_EQUAL_EXAMPLE_4_TITLE" : "Is the variable 'Counter' less than or equal to the constant value 120.",
	"HELP_TEXT_LESS_THAN_EQUAL_EXAMPLE_5_TITLE" : "Is the light level from the left sensor less than or equal to the constant value 500.",
	"HELP_TEXT_EQUAL_TITLE" : "Equal to",
	"HELP_TEXT_EQUAL_BODY_1" : "The equal to block compares two input values to determine if the first value is equal to the second value and returns a result that is either true or false. The values can be a constant (typed into the input and does not vary), a variable, sensing or an operator block.",
	"HELP_TEXT_EQUAL_BODY_2" : "The equal to block is a diamond shaped block so the result of the block can only be either true or false.",
	"HELP_TEXT_EQUAL_EXAMPLE_1_BODY" : "Result: true",
	"HELP_TEXT_EQUAL_EXAMPLE_2_BODY" : "Result: false",
	"HELP_TEXT_EQUAL_EXAMPLE_3_TITLE" : "Is the variable 'Counter' equal to the constant value 60.",
	"HELP_TEXT_EQUAL_EXAMPLE_4_TITLE" : "Is the received remote code equal to the constant value 3.",
	"HELP_TEXT_GREATER_THAN_EQUAL_TITLE" : "Greater than or equal to",
	"HELP_TEXT_GREATER_THAN_EQUAL_BODY_1" : "The greater than or equal to block compares two input values to determine if the first value is greater than or equal to the second value and returns a result that is either true or false. The values can be a constant (typed into the input and does not vary), a variable, sensing or an operator block.",
	"HELP_TEXT_GREATER_THAN_EQUAL_BODY_2" : "The greater than or equal to block is a diamond shaped block so the result of the block can only be either true or false.",
	"HELP_TEXT_GREATER_THAN_EQUAL_EXAMPLE_1_BODY" : "Result: true",
	"HELP_TEXT_GREATER_THAN_EQUAL_EXAMPLE_2_BODY" : "Result: false",
	"HELP_TEXT_GREATER_THAN_EQUAL_EXAMPLE_3_BODY" : "Result: true",
	"HELP_TEXT_GREATER_THAN_EQUAL_EXAMPLE_4_TITLE" : "Is the variable 'Counter' greater than or equal to the constant value 120.",
	"HELP_TEXT_GREATER_THAN_EQUAL_EXAMPLE_5_TITLE" : "Is the light level from the left sensor greater than or equal to the constant value 500.",
	"HELP_TEXT_GREATER_THAN_TITLE" : "Greater than",
	"HELP_TEXT_GREATER_THAN_BODY_1" : "The greater than block compares two input values to determine if the first value is greater than the second value and returns a result that is either true or false. The values can be a constant (typed into the input and does not vary), a variable, sensing or an operator block.",
	"HELP_TEXT_GREATER_THAN_BODY_2" : "The greater than block is a diamond shaped block so the result of the block can only be either true or false",
	"HELP_TEXT_GREATER_THAN_EXAMPLE_1_BODY" : "Result: true",
	"HELP_TEXT_GREATER_THAN_EXAMPLE_2_BODY" : "Result: false",
	"HELP_TEXT_GREATER_THAN_EXAMPLE_3_TITLE" : "Is the variable 'Counter' greater than the constant value 120.",
	"HELP_TEXT_GREATER_THAN_EXAMPLE_4_TITLE" : "Is the light level from the left sensor greater than the constant value 500.",
	"HELP_TEXT_NOT_EQUAL_TITLE" : "Not equal to",
	"HELP_TEXT_NOT_EQUAL_BODY_1" : "The not equal to block compares two input values to determine if the first value is not equal to the second value and returns a result that is either true or false. The values can be a constant (typed into the input and does not vary), a variable, sensing or an operator block.",
	"HELP_TEXT_NOT_EQUAL_BODY_2" : "The not equal to block is a diamond shaped block so the result of the block can only be either true or false.",
	"HELP_TEXT_NOT_EQUAL_EXAMPLE_1_BODY" : "Result: true",
	"HELP_TEXT_NOT_EQUAL_EXAMPLE_2_BODY" : "Result: false",
	"HELP_TEXT_NOT_EQUAL_EXAMPLE_3_TITLE" : "Is the variable 'Counter' not equal to the constant value 120.",
	"HELP_TEXT_NOT_EQUAL_EXAMPLE_4_TITLE" : "Is the received remote code not equal to the constant value 3.",
	"HELP_TEXT_IS_BETWEEN_TITLE" : "Is between",
	"HELP_TEXT_IS_BETWEEN_BODY_1" : "The is between block determines if a value is within a range of two other values. The values can be a constant (typed into the input and does not vary), a variable, sensing or an operator block.",
	"HELP_TEXT_IS_BETWEEN_BODY_2" : "The is between block is a diamond shaped block so the result of the block can only be either true or false.",
	"HELP_TEXT_IS_BETWEEN_EXAMPLE_1_BODY" : "Result: true",
	"HELP_TEXT_IS_BETWEEN_EXAMPLE_2_BODY" : "Result: false",
	"HELP_TEXT_IS_BETWEENL_EXAMPLE_3_TITLE" : "Is the variable 'Counter' between the constant value 60 and the constant value 120.",
	"HELP_TEXT_IS_BETWEEN_EXAMPLE_4_TITLE" : "Is the sensor light level of left light sensor between the constant value 250 and the constant value 750.",
	"HELP_TEXT_AND_TITLE" : "And",
	"HELP_TEXT_AND_BODY_1" : "The and block determines if two inputs are both true. If both inputs are true, then the result will also be true. If one or both inputs are false, then the result is false. The inputs accept diamond shaped blocks that can be either an operator block or sensing block.",
	"HELP_TEXT_AND_BODY_2" : "The and block is a diamond shaped block so the result of the block can only be either true or false.",
	"HELP_TEXT_AND_EXAMPLE_1_BODY" : "Result: true",
	"HELP_TEXT_AND_EXAMPLE_2_BODY" : "Result: false",
	"HELP_TEXT_AND_EXAMPLE_3_TITLE" : "Is both the line tracker on reflective surface “and” drive strain detected.",
	"HELP_TEXT_AND_EXAMPLE_4_TITLE" : "Is the variable 'Counter' greater than 50 “and” received remote code is equal to the constant value 3.",
	"HELP_TEXT_OR_TITLE" : "Or",
	"HELP_TEXT_OR_BODY_1" : "The or block determines if the first input “or” the second input are true. If one or both inputs are true, then the result will be true. If both inputs are false, then the result will be false. The inputs accept diamond shaped blocks that can be either an operator block or sensing block.",
	"HELP_TEXT_OR_BODY_2" : "The or block is a diamond shaped block so the result of the block can only be either true or false.",
	"HELP_TEXT_OR_EXAMPLE_1_BODY" : "Result: true",
	"HELP_TEXT_OR_EXAMPLE_2_BODY" : "Result: true",
	"HELP_TEXT_OR_EXAMPLE_3_BODY" : "Result: false",
	"HELP_TEXT_OR_EXAMPLE_4_TITLE" : "Is either the line tracker on reflective surface “or” drive strain detected.",
	"HELP_TEXT_OR_EXAMPLE_5_TITLE" : "Is either the variable 'Counter' less than the constant value 50 “or” received remote code is equal to the constant value 3.",
	"HELP_TEXT_NOT_TITLE" : "Not",
	"HELP_TEXT_NOT_BODY_1" : "The not block determines if the input is “not” true. If the input is false, then the output will be true. If the input is true, then then the output will be false. The input accepts diamond shaped blocks that can be either an operator block or sensing block.",
	"HELP_TEXT_NOT_BODY_2" : "The not block is a diamond shaped block so the result of the block can only be either true or false.",
	"HELP_TEXT_NOT_EXAMPLE_1_BODY" : "Result: false",
	"HELP_TEXT_NOT_EXAMPLE_2_BODY" : "Result: true",
	"HELP_TEXT_NOT_EXAMPLE_3_TITLE" : "Is remote code 0 not received.",
	"HELP_TEXT_NOT_EXAMPLE_4_TITLE" : "Example program: Spin on remote control command (works best with the EdRemote)",
	"HELP_TEXT_NOT_EXAMPLE_4_BODY" : "In this example, the program begins by entering a forever loop. Inside the forever loop the if then block tests if remote code 0 has been received. If this is true, then both motors are set to spin the robot right. This continues until the wait until block condition passes. To pass, the received remote code must not be remote code 0 (the remote-control button is no longer being pressed). When this happens, the program progresses to stop both motors and then loop to the start of the forever loop. This results in Edison spinning while the remote button is held down.",
	"HELP_TEXT_COMMENT_TITLE" : "comment",
	"HELP_TEXT_COMMENT_BODY_1" : "The comment block is used to add notes to a program. The notes describe in plain language how the program is intended to work. Making comments in a program helps when someone else needs to edit your program or you need to edit your program a long time after you wrote it.",
	"HELP_TEXT_COMMENT_BODY_2" : "Comments are not programmed into Edison so do not change the behaviour of your program.",
	"HELP_TEXT_COMMENT_EXAMPLE_1_TITLE" : "Example program: Comments explain how the program works in plain language",
	"HELP_TEXT_SEND_USB_TITLE" : "send via USB",
	"HELP_TEXT_SEND_USB_BODY_1" : "The send via USB block transmits a value to a computer via the USB connection. The value can either be a constant (typed into the input and does not vary), a variable, a sensing or an operator block.",
	"HELP_TEXT_SEND_USB_BODY_2" : "To see the number on the computer, click the USB button in EdScratch and a pop-up window will appear. Click Run USB to connect to the Edison V3 robot. The data received from the Edison V3 will appear in the Data from USB window.",
	"HELP_TEXT_SEND_USB_BODY_3" : "The send to USB block can also be used to help debug a program.",
	"HELP_TEXT_SEND_USB_BODY_4" : "The Edison V3 wheels will not drive while connected to USB. This is due to international safety standards that do not allow products intended for children to be able to drive a motor while connected to a USB port.",
	"HELP_TEXT_SEND_USB_EXAMPLE_1_TITLE" : "Example program: Measure light level",
	"HELP_TEXT_SEND_USB_EXAMPLE_1_BODY" : "In this example, the program starts by entering a forever loop. The first block inside the loop sends the light level of the left light sensor via USB. The program then waits one second and repeats.",
	"HELP_TEXT_SAVE_USB_TITLE" : "wait for USB data and save to",
	"HELP_TEXT_SAVE_USB_BODY_1" : "The wait for USB data and save to block pauses the program until data is received via USB and then places the data into a variable.",
	"HELP_TEXT_SAVE_USB_BODY_2" : "The Edison V3 wheels will not drive while connected to USB. This is due to international safety standards that do not allow products intended for children to be able to drive a motor while connected to a USB port.",
	"HELP_TEXT_SAVE_USB_EXAMPLE_1_TITLE" : "Example program: Number of beeps from USB",
	"HELP_TEXT_SAVE_USB_EXAMPLE_1_BODY_1" : "In this example, the program starts by entering a forever loop. The first block inside the loop waits until data is received from USB. When data is received, the data is saved to the variable 'Count'. The program then progresses to the repeat block which repeats for the value of the 'Count' variable. Inside the repeat block the beep block and wait sec blocks run. This results in Edison beeping the number of times sent via USB.",
	"HELP_TEXT_SAVE_USB_EXAMPLE_1_BODY_2" : "To test this program, click the USB button in the EdScratch app and a pop-up window will appear. Click Run USB to connect to the Edison V3 robot. To send data to the Edison V3, type a number into the Data to USB box and click the Send to USB button.",
	"HELP_TEXT_FUNCTION_START_TITLE" : "Function start",
	"HELP_TEXT_FUNCTION_START_BODY_1" : "The function start block is where your function begins. Connect blocks to the function start block to create a custom function.",
	"HELP_TEXT_FUNCTION_START_BODY_2" : "Function blocks help to simplify a program as the code can be grouped making it easier to read. Functions also help to reduce the size of a program as the repetitive parts of a program only need to be written once.",
	"HELP_TEXT_FUNCTION_START_BODY_3" : "Function call blocks cannot be placed under function start blocks.",
	"HELP_TEXT_FUNCTION_START_EXAMPLE_1_TITLE" : "Example program 1: Drive in the shape of a square",
	"HELP_TEXT_FUNCTION_START_EXAMPLE_1_BODY" : "In this example, the program starts by entering a repeat for four times loop. Inside the repeat block is a function call named 'DriveAndTurn'. When the program gets to this block it jumps to the corresponding function start block. Under this block the robot is instructed to drive forwards 10cm, then spin right 90 degrees. This function is called four times inside the repeat loop. This results in Edison driving in a square.",
	"HELP_TEXT_FUNCTION_START_EXAMPLE_2_TITLE" : "Example program 2: Avoid lines and obstacles",
	"HELP_TEXT_FUNCTION_START_EXAMPLE_2_BODY" : "In this example, the program starts by turning on the obstacle detector and line tracker LED and then enters a forever loop. Inside the forever loop both motors are set to drive forward. Next, the if then block tests for any obstacle detected, if true, then the function call block 'TurnAround' causes the program to jump to the function start block 'TurnAround'. The program then stops the motors, turns on the LED light, beeps, drives backwards, spins 175 degrees and turns the LEDs off and exits back to the main program where it left off. The next if then block tests if the surface is non-reflective (black), if true, then the function call block 'TurnAround' causes the program to jump to the function start block 'TurnAround'. The program then stops the motors, turns on the LED light, beeps, drives backwards, spins 175 degrees and turns the LEDs off and exits back to the main program where it left off. This results in Edison driving away from lines and objects it detects.",
	"HELP_TEXT_FUNCTION_CALL_TITLE" : "Function call",
	"HELP_TEXT_FUNCTION_CALL_BODY_1" : "The function call block tells the program to jump to the function start block.",
};
Blockly.ScratchMsgs.locales['es'] ={
	"CONTROL_FOREVER" : "para siempre",
	"CONTROL_REPEAT" : "repite",
	"CONTROL_IF" : "si",
	"CONTROL_THAN" : "entonces",
	"CONTROL_ELSE" : "si no",
	"CONTROL_STOP" : "detener",
	"CONTROL_STOP_ALL" : "todo",
	"CONTROL_WAIT" : "espera",
	"CONTROL_WAIT_SEC" : "seg",
	"CONTROL_WAIT_MILLISECONDS" : "milisegundos",
	"CONTROL_WAITUNTIL" : "esperar hasta",
	"CONTROL_REPEATUNTIL" : "repetir hasta",
	"DATA_BUTTONCREATE" : "Crear una variable",
	"DATA_BUTTONMANAGE" : "Gestionar variables",
	"DATA_SET" : "establecer",
	"DATA_TO" : "a",
	"DATA_INCVARIABLE" : "incrementar",
	"DATA_DECVARIABLE" : "disminuir",
	"DATA_BITSHIFT" : "desplazamiento de bits",
	"DATA_BITSHIFTLEFT" : "izquierda por",
	"DATA_BITSHIFTRIGHT" : "derecha por",
	"EVENT_ANY_OBSTACLE" : "Cualquier obstáculo detectado",
	"EVENT_OBSTACLE_AHEAD" : "Obstáculo detectado delante",
	"EVENT_OBSTACLE_LEFT" : "Obstáculo detectado a la izquierda",
	"EVENT_OBSTACLE_RIGHT" : "Obstáculo detectado a la derecha",
	"EVENT_CLAP" : "Aplauso detectado",
	"EVENT_BUTTON_TRIANGLE" : "Botón triángulo pulsado",
	"EVENT_BUTTON_ROUND" : "Botón redondo pulsado",
	"EVENT_LINE_REFLECTIVE" : "Seguidor de línea en superficie reflectante",
	"EVENT_LINE_NON_REFLECTIVE" : "Seguidor de línea en superficie no reflectante",
	"EVENT_LINE_CHANGE" : "El seguidor de línea cambia de superficie",
	"EVENT_MESSAGE" : "Mensaje IR recibido",
	"EVENT_REMOTE" : "Código remoto recibido",
	"EVENT_DRIVE_STRAIN" : "Accionamiento forzado",
	"EVENT_START" : "Inicio",
	"OPERATORS_RANDOM" : "número aleatorio entre",
	"OPERATORS_AND" : "y",
	"OPERATORS_OR" : "o",
	"OPERATORS_NOT" : "no",
	"OPERATORS_ABS" : "abs",
	"OPERATORS_BETWEEN" : "está entre",
	"SENSING_TURN_LINE_TRACKING_LED" : "haz de seguimiento de línea de giro",
	"SENSING_TURN_OBSTACLE_BEAM" : "haz de detección de obstáculos de giro",
	"SENSING_CLEAR" : "borrar",
	"SENSING_SENSOR" : "datos del sensor",
	"SENSING_CLAP_DETECTED" : "palmada detectada",
	"SENSING_BUTTON_PRESSED" : "botón pulsado",
	"SENSING_OBSTACLE" : "obstáculo detectado",
	"SENSING_LINE_TRACKER" : "seguidor de línea en",
	"SENSING_LINE_SURFACE" : "superficie",
	"SENSING_REMOTE_NUM" : "código remoto recibido",
	"SENSING_REMOTE_BOOL" : "código remoto",
	"SENSING_REMOTE_RECEIVED" : "recibido",
	"SENSING_IR_MESSAGE_DETECTED" : "mensaje IR detectado",
	"SENSING_IR_MESSAGE" : "mensaje IR recibido",
	"SENSING_LIGHT_LEVEL" : "nivel de luz del",
	"SENSING_LIGHT_SENSOR" : "sensor",
	"SENSING_DRIVE_STRAIN" : "tensión de accionamiento detectada",
	"SENSING_DROPDOWN_ON" : "encendido",
	"SENSING_DROPDOWN_OFF" : "apagado",
	"SENSING_CLEAR_DROPDOWN_CLAP" : "detector de palmadas",
	"SENSING_CLEAR_DROPDOWN_KEY" : "teclado",
	"SENSING_CLEAR_DROPDOWN_OBS" : "detector de obstáculos",
	"SENSING_CLEAR_DROPDOWN_REMOTE" : "código remoto",
	"SENSING_CLEAR_DROPDOWN_IR" : "mensaje IR",
	"SENSING_KEY_DROPDOWN_ROUND" : "redondo",
	"SENSING_KEY_DROPDOWN_TRIANGLE" : "triángulo",
	"SENSING_OBS_DROPDOWN_ANY" : "en cualquier lugar",
	"SENSING_OBS_DROPDOWN_AHEAD" : "delante",
	"SENSING_OBS_DROPDOWN_LEFT" : "izquierda",
	"SENSING_OBS_DROPDOWN_RIGHT" : "derecha",
	"SENSING_LINE_DROPDOWN_WHITE" : "reflectante",
	"SENSING_LINE_DROPDOWN_BLACK" : "no reflectante",
	"SENSING_LIGHT_DROPDOWN_LEFT" : "luz izquierda",
	"SENSING_LIGHT_DROPDOWN_RIGHT" : "luz derecha",
	"SENSING_LIGHT_DROPDOWN_LINE" : "seguimiento de línea",
	"COMMENT_USER_COMMENT" : "comentar:",
	"ADVANCED_USB_SEND_DATA" : "envía",
	"ADVANCED_USB_SEND_VIA" : "por USB",
	"ADVANCED_USB_RECEIVED_DATA" : "datos recibidos del USB",
	"ADVANCED_USB_RECEIVED_DATA_VAR" : "esperar datos USB y guardar en",
	"SOUND_BEEP" : "pitar",
	"SOUND_PLAY_NOTE" : "reproducir un",
	"SOUND_PLAY_NOTE_DROP_DURATION_WHOLE" : "entero",
	"SOUND_PLAY_NOTE_DROP_DURATION_HALF" : "medio",
	"SOUND_PLAY_NOTE_DROP_DURATION_QUARTER" : "cuarto",
	"SOUND_PLAY_NOTE_DROP_DURATION_EIGHTH" : "octavo",
	"SOUND_PLAY_NOTE_DROP_NOTE_C" : "C",
	"SOUND_PLAY_NOTE_DROP_NOTE_B" : "B",
	"SOUND_PLAY_NOTE_DROP_NOTE_A" : "A",
	"SOUND_PLAY_NOTE_DROP_NOTE_G" : "G",
	"SOUND_PLAY_NOTE_DROP_NOTE_F" : "F",
	"SOUND_PLAY_NOTE_DROP_NOTE_E" : "E",
	"SOUND_PLAY_NOTE_DROP_NOTE_D" : "D",
	"SOUND_PLAY_NOTE_DROP_NOTE_MID_C" : "do medio",
	"SOUND_PLAY_NOTE_DROP_NOTE_LOW_B" : "Si bajo",
	"SOUND_PLAY_NOTE_DROP_NOTE_REST" : "silencio",
	"SOUND_PLAY_NOTE_DROP_MOD_SHARP" : "sostenido",
	"SOUND_PLAY_NOTE_DROP_MOD_FLAT" : "bemol",
	"SOUND_SET_TEMPO" : "poner el tempo de la música a",
	"SOUND_SET_TEMPO_DROP_VERY_SLOW" : "muy lento",
	"SOUND_SET_TEMPO_DROP_SLOW" : "lento",
	"SOUND_SET_TEMPO_DROP_MEDIUM" : "medio",
	"SOUND_SET_TEMPO_DROP_FAST" : "rápido",
	"SOUND_SET_TEMPO_DROP_VERY_FAST" : "muy rápido",
	"SOUND_PLAY_IN_BACKGROUND" : "reproducir música de fondo",
	"CATEGORY_SOUND" : "Sonido",
	"CATEGORY_EVENTS" : "Eventos",
	"CATEGORY_CONTROL" : "Controlar",
	"CATEGORY_SENSING" : "Detección",
	"CATEGORY_OPERATORS" : "Operadores",
	"CATEGORY_VARIABLES" : "Variables",
	"CATEGORY_MYBLOCKS" : "Funciones",
	"CATEGORY_DRIVE" : "Accionamiento",
	"CATEGORY_COMMENT" : "Comentario",
	"CATEGORY_LED" : "LEDs",
	"CATEGORY_ADVANCED" : "Avanzado",
	"DUPLICATE" : "Duplicar",
	"DELETE" : "Borrar",
	"DELETE_BLOCK" : "Borrar bloque",
	"CONTEXT_DELETE" : "Borrar",
	"CONTEXT_DELETE_ALL" : "Borrar todo",
	"CONTEXT_BLOCKS" : "Bloques",
	"CLEAN_UP" : "Limpiar Bloques",
	"HELP" : "Ayuda",
	"UNDO" : "Deshacer",
	"REDO" : "Rehacer",
	"CHANGE_VALUE_TITLE" : "Cambiar valor",
	"RENAME_VARIABLE" : "Renombrar variable",
	"RENAME_VARIABLE_MODAL_TITLE" : "Renombrar variable",
	"NEW_VARIABLE" : "Crear una variable",
	"NEW_VARIABLE_TITLE" : "Nuevo nombre de variable",
	"VARIABLE_MODAL_TITLE" : "Nueva variable",
	"NEW_PROCEDURE" : "Crear una función",
	"MANAGE_PROCEDURE" : "Gestionar una función",
	"PROCEDURE_DEFAULT_NAME" : "Nombre de bloque",
	"PROCEDURE_USED" : "Para eliminar una definición de bloque, elimina primero todos los usos del bloque",
	"DRIVE_FORWARDS_DISTANCE" : "hacia delante para",
	"DRIVE_BACKWARDS_DISTANCE" : "hacia atrás para",
	"DRIVE_LEFT_DISTANCE" : "izquierda por",
	"DRIVE_RIGHT_DISTANCE" : "derecha por",
	"DRIVE_DISTANCE_DROPDOWN_CM" : "cm",
	"DRIVE_DISTANCE_DROPDOWN_INCH" : "pulgada",
	"DRIVE_DISTANCE_DROPDOWN_SECONDS" : "segundos",
	"DRIVE_DISTANCE_DROPDOWN_DEGREES" : "grados",
	"DRIVE_TURN_DROPDOWN_SPIN" : "girar",
	"DRIVE_TURN_DROPDOWN_FORWARDS" : "girar hacia delante",
	"DRIVE_TURN_DROPDOWN_BACKWARDS" : "girar hacia atrás",
	"DRIVE_FORWARDS_UNTIL" : "hacia delante hasta",
	"DRIVE_BACKWARDS_UNTIL" : "hacia atrás hasta",
	"DRIVE_LEFT_UNTIL" : "hacia la izquierda hasta",
	"DRIVE_RIGHT_UNTIL" : "derecha hasta",
	"DRIVE_SET_LEFT_MOTOR" : "ajustar motor izquierdo a",
	"DRIVE_SET_RIGHT_MOTOR" : "poner el motor derecho en",
	"DRIVE_SET_MOTOR_DROPDOWN_FORWARDS" : "adelante",
	"DRIVE_SET_MOTOR_DROPDOWN_BACKWARDS" : "hacia atrás",
	"DRIVE_SET_BOTH_MOTOR" : "poner ambos motores en",
	"DRIVE_SET_BOTH_MOTOR_DROPDOWN_FORWARDS" : "hacia delante",
	"DRIVE_SET_BOTH_MOTOR_DROPDOWN_BACKWARDS" : "hacia atrás",
	"DRIVE_SET_BOTH_MOTOR_DROPDOWN_SPIN_LEFT" : "gira el robot a la izquierda",
	"DRIVE_SET_BOTH_MOTOR_DROPDOWN_SPIN_RIGHT" : "gira el robot a la derecha",
	"DRIVE_SET_BOTH_MOTOR_DROPDOWN_TURN_LEFT" : "gira el robot a la izquierda",
	"DRIVE_SET_BOTH_MOTOR_DROPDOWN_TURN_RIGHT" : "gira el robot a la derecha",
	"DRIVE_AT_SPEED" : "a velocidad",
	"DRIVE_STOP" : "detener",
	"DRIVE_STOP_DROPDOWN_BOTH" : "ambos motores",
	"DRIVE_STOP_DROPDOWN_LEFT" : "motor izquierdo",
	"DRIVE_STOP_DROPDOWN_RIGHT" : "motor derecho",
  "LED_LEFT" : "LED izquierdo",
  "LED_RIGHT" : "LED derecho",
	"LED_DROPDOWN_ON" : "encendido",
	"LED_DROPDOWN_OFF" : "apagado",
	"LED_SEND_MESSAGE" : "enviar mensaje IR",
	"DEMO_TEST_PROGRAM" : "Programa de prueba",
	"DEMO_TEST_PROGRAM_DISC" : "Prueba el motor, los LED y el altavoz",
	"DEMO_MOVE_WITH_MUSIC" : "Muévete con música",
	"DEMO_MOVE_WITH_MUSIC_DISC" : "Muévete con música",
	"DEMO_FOLLOW_A_LINE" : "Sigue una línea",
	"DEMO_FOLLOW_A_LINE_DISC" : "Utiliza el sensor de línea para seguir una línea negra",
	"DEMO_BOUNCE_IN_BORDERS" : "Rebota en los bordes",
	"DEMO_BOUNCE_IN_BORDERS_DISC" : "Utiliza el sensor de línea para permanecer dentro del borde de una línea negra",
	"DEMO_WARNINGS" : "Demostración de mensajes de advertencia",
	"DEMO_WARNINGS_DISC" : "Demuestra los mensajes de error rojos y los mensajes de advertencia amarillos",
	"DEMO_CLAP_CONTROL" : "Conducción controlada por palmadas",
	"DEMO_CLAP_CONTROL_DISC" : "Aplaude una vez para girar, aplaude dos veces para avanzar",
	"DEMO_AVOID_OBSTACLES" : "Evita los obstáculos",
	"DEMO_AVOID_OBSTACLES_DISC" : "Utiliza el sensor de obstáculos para evitar chocar contra ellos",
	"DEMO_FOLLOW_TORCH" : "Sigue una linterna",
	"DEMO_FOLLOW_TORCH_DISC" : "Utiliza los sensores de luz para seguir una linterna",
	"DEMO_FOLLOW_A_LINE_IF" : "Sigue una línea utilizando sentencias if",
	"DEMO_FOLLOW_A_LINE_IF_DISC" : "Una forma diferente de utilizar el sensor de línea para seguir una línea utilizando un bloque if",
	"MENU_DROP_MENU" : "Menú",
	"MENU_DROP_NEW" : "Nuevo",
	"MENU_DROP_LOAD_DEMO" : "Cargar demo",
	"MENU_DROP_LOAD_LOCAL" : "Cargar desde el ordenador",
	"MENU_DROP_SAVE_LOCAL" : "Guardar en el ordenador",
	"MENU_DROP_UPDATE_FIRMWARE" : "Actualizar firmware",
	"MENU_DROP_DIAGNOSTICS" : "Diagnóstico",
	"MENU_DROP_LANGUAGE_LABEL" : "Idioma",
	"MENU_DROP_ABOUT" : "Acerca de",
	"MENU_DROP_TERMS" : "Condiciones de uso",
	"MENU_USB" : "USB",
	"MENU_SAVE" : "Guardar",
	"MENU_VERSION_MAIN" : "Edison V3",
	"MENU_VERSION_SWITCH" : "Cambiar a Edison V1/V2",
	"MENU_VERSION_WHICH_VERSION" : "¿Qué versión tengo?",
	"MENU_PROGRAM" : "Programar",
	"MENU_PROGRAM_FLASH" : "Programar",
	"MODAL_CREATE_VAR" : "Crear variable",
	"MODAL_CREATE_VAR_NAME" : "Nombre de la variable",
	"MODAL_CREATE_VAR_BUTTON" : "Crear variable",
	"MODAL_CREATE_VAR_EXIT" : "Salir",
	"MODAL_CREATE_VAR_SUCCESS" : "Nueva variable creada con éxito.",
	"MODAL_MANAGE_VAR" : "Variables",
	"MODAL_MANAGE_VAR_NAME" : "Nombre de la variable",
	"MODAL_MANAGE_VAR_ACTION" : "Acción",
	"MODAL_MANAGE_VAR_BUTTON_DELETE" : "borrar",
	"MODAL_MANAGE_VAR_BUTTON_RENAME" : "renombrar",
	"MODAL_MANAGE_VAR_BUTTON_CONFIRM" : "confirmar",
	"MODAL_MANAGE_VAR_BUTTON_CANCEL" : "cancelar",
	"MODAL_MANAGE_VAR_CONFIRM_NOT_CHANGED" : "No has cambiado el nombre de la variable. Inténtalo de nuevo.",
	"MODAL_MANAGE_VAR_CONFIRM_SUCCESS" : "Se ha cambiado el nombre de la variable.",
	"MODAL_MANAGE_VAR_NAME_NONE" : "Introduce un nombre de variable.",
	"MODAL_MANAGE_VAR_NAME_IN_USE" : "Ya tienes una variable con ese nombre.",
	"MODAL_MANAGE_VAR_NAME_UNSUPPORTED" : "El nombre de la variable contiene un carácter no admitido. Los nombres de las variables sólo pueden contener letras inglesas minúsculas, letras inglesas mayúsculas, números y guiones bajos ( _ ).",
	"MODAL_MANAGE_VAR_NAME_NUMBER_START" : "Los nombres de las variables no pueden empezar por un número.",
	"MODAL_MANAGE_VAR_DELETE_IN_USE" : "Esta variable se está utilizando actualmente en tu programa. ¿Estás seguro de que quieres eliminarla?",
	"MODAL_MANAGE_VAR_DELETE_CONFIRM" : "Sí",
	"MODAL_MANAGE_VAR_DELETE_DECLINE" : "No",
	"MODAL_CREATE_FUNCT" : "Crear función",
	"MODAL_CREATE_FUNCT_NAME" : "Nombre de la función",
	"MODAL_CREATE_FUNCT_WARNING" : "Sólo caracteres alfanuméricos y debe empezar por una letra.",
	"MODAL_CREATE_FUNCT_BUTTON" : "Crear función",
	"MODAL_CREATE_FUNCT_BUTTON_EXIT" : "Salir",
	"MODAL_CREATE_FUNCT_SUCCESS" : "Nueva función creada correctamente.",
	"MODAL_MANAGE_FUNCT" : "Funciones",
	"MODAL_MANAGE_FUNCT_NAME" : "Nombre de la función",
	"MODAL_MANAGE_FUNCT_ACTION" : "Acción",
	"MODAL_MANAGE_FUNCT_BUTTON_DELETE" : "borrar",
	"MODAL_MANAGE_FUNCT_BUTTON_RENAME" : "renombrar",
	"MODAL_MANAGE_FUNCT_BUTTON_CONFIRM" : "confirmar",
	"MODAL_MANAGE_FUNCT_BUTTON_CANCEL" : "cancelar",
	"MODAL_MANAGE_FUNCT_CONFIRM_NOT_CHANGED" : "No has cambiado el nombre de la función. Inténtalo de nuevo.",
	"MODAL_MANAGE_FUNCT_CONFIRM_SUCCESS" : "¡Función renombrada con éxito!",
	"MODAL_MANAGE_FUNCT_NAME_NONE" : "Introduce un nombre de función.",
	"MODAL_MANAGE_FUNCT_NAME_IN_USE" : "Ya tienes una función con ese nombre.",
	"MODAL_MANAGE_FUNCT_NAME_START_WITH" : "Los nombres de función de usuario no pueden empezar por",
	"MODAL_MANAGE_FUNCT_NAME_UNSUPPORTED" : "El nombre de la función contiene un carácter no admitido. Los nombres de función sólo pueden contener letras inglesas minúsculas, letras inglesas mayúsculas, números y guiones bajos ( _ ).",
	"MODAL_MANAGE_FUNCT_NAME_NUMBER_START" : "Los nombres de función no pueden empezar por un número.",
	"MODAL_MANAGE_FUNCT_DELETE_IN_USE" : "Esta función se está utilizando actualmente en tu programa. ¿Estás seguro de que quieres eliminarla?",
	"MODAL_MANAGE_FUNCT_DELETE_CONFIRM" : "Sí",
	"MODAL_MANAGE_FUNCT_DELETE_DECLINE" : "No",
	"MODAL_SAVE_TITLE" : "Guardar en el ordenador",
	"MODAL_SAVE_PROG_TITLE" : "Nombre del programa",
	"MODAL_SAVE_BUTTON" : "Guardar en el ordenador",
	"MODAL_SAVE_ERROR_NO_NAME" : "Introduce un nombre para tu programa. Necesitas darle un nombre al programa para poder guardarlo.",
	"MODAL_SAVE_ERROR_LONG_NAME" : "Vaya. Hay un problema con el nombre del programa. Los nombres de los programas pueden tener un máximo de 255 caracteres.",
	"MODAL_SAVE_SAVING" : "¡OK! Tu programa se está guardando. La descarga de tu programa debería comenzar en breve.",
	"MODAL_LOAD_PC_TITLE" : "Cargar desde el ordenador",
	"MODAL_LOAD_PC_FILE_ERROR_1" : "Por favor, selecciona un archivo de guardado de EdScratch.",
	"MODAL_LOAD_PC_FILE_ERROR_2" : "Todos los archivos guardados de EdScratch son del tipo de archivo",
	"MODAL_LOAD_PC_FILE_ERROR_3" : ".edscratch",
	"MODAL_LOAD_PC_FILE_BUTTON" : "Selecciona un archivo para cargar...",
	"MODAL_LOAD_PC_BUTTON" : "Cargar programa",
	"MODAL_LOAD_PC_NO_FILE_ERROR_1" : "Aún no has seleccionado ningún archivo. Por favor, selecciona primero un archivo guardado de EdScratch de tu ordenador y, a continuación, carga el archivo. [Todos los archivos guardados de EdScratch son del tipo (.edscratch)].",
	"MODAL_LOAD_PC_FILE_DATA_ERROR_1" : "Oh-oh. Hay un problema con los datos de ese archivo.",
	"MODAL_LOAD_PC_FILE_DATA_ERROR_2" : "Por favor, carga un archivo guardar EdScratch diferente. [Todos los archivos guardados de EdScratch son del tipo (.edscratch).",
	"MODAL_LOAD_PC_FILE_TYPE_ERROR_1" : "Oh-oh. Has subido un tipo de archivo incorrecto.",
	"MODAL_LOAD_PC_FILE_TYPE_ERROR_2" : "Por favor, sube un archivo guardado EdScratch. [Todos los archivos guardados de EdScratch son del tipo (.edscratch)].",
	"MODAL_LOAD_PC_FILE_READY" : "Listo para cargar el programa:",
	"MODAL_LOAD_DEMO_TITLE" : "Cargar demo",
	"MODAL_LOAD_DEMO_BUTTON" : "Cargar programa",
  "MODAL_COOKIES_TITLE" : "Cookies",
  "MODAL_COOKIES_BODY_1" : "Utilizamos Google Analytics para medir cómo utilizan los visitantes esta aplicación web y poder mejorarla en función de las necesidades de los usuarios. Por ejemplo, qué opciones utilizan los visitantes con más frecuencia y si reciben mensajes de error de la aplicación web. Estas cookies no recogen información que identifique a un visitante.",
  "MODAL_COOKIES_BODY_2" : "No permitimos que Google utilice o comparta los datos sobre cómo utiliza este sitio y toda la información que recopilan estas cookies es agregada y, por lo tanto, anónima. Sólo se utiliza para mejorar el funcionamiento de la aplicación web. Esta cookie se almacena durante un periodo de un año.",
  "MODAL_COOKIES_ACCEPT" : "Aceptar cookies",
  "MODAL_COOKIES_BUTTON_YES" : "Sí",
  "MODAL_COOKIES_BUTTON_NO" : "No",
  "MODAL_ABOUT_TITLE" : "Acerca de EdScratch",
	"MODAL_ABOUT_COPYRIGHT" : "Copyright 2023 Microbric Pty Ltd",
	"MODAL_ABOUT_BODY_1" : "La aplicación EdScratch se desarrolló utilizando el código base de Scratch Blocks desarrollado por el MIT. Scratch Blocks se construyó sobre la base de código Blockly desarrollada por Google.",
	"MODAL_ABOUT_BODY_2" : "Contribuciones y créditos:",
	"MODAL_ABOUT_BODY_3" : "Lenguaje de programación EdScratch y compilador de bloques desarrollados por Ben Hayton, Microbric",
	"MODAL_ABOUT_BODY_4" : "Interfaz de usuario de EdScratch desarrollada por Sean Killian, Killian Web Development",
	"MODAL_ABOUT_BODY_5" : "Firmware Edison V3 desarrollado por Damien George, George Robotics (base de código MicroPython)",
	"MODAL_LANGUAGE" : "Idioma",
	"MODAL_DIAGNOSTICS" : "Diagnóstico",
	"MODAL_DIAGNOSTICS_CONNECT_ISSUES_TITLE" : "Problemas de conectividad",
	"MODAL_DIAGNOSTICS_CONNECT_ISSUES_BODY" : "Para asegurarte de que tu programa puede ser compilado y enviado al robot Edison, es una buena idea comprobar tu conexión con el compilador EdScratch.",
	"MODAL_DIAGNOSTICS_CONNECT_ISSUES_BUTTON" : "Ejecuta el comprobador de conexión",
	"MODAL_DIAGNOSTICS_FIRMWARE_TITLE" : "Corrige el firmware",
	"MODAL_DIAGNOSTICS_FIRMWARE_BODY" : "Si Edison V3 no se comporta como se espera, puede ser un problema de firmware. Haz clic en Corregir firmware para impulsar una actualización del firmware.",
	"MODAL_DIAGNOSTICS_FIRMWARE_BUTTON" : "Corrige el firmware",
	"MODAL_DIAGNOSTICS_PROGRAMMING_TITLE" : "Método de programación",
	"MODAL_DIAGNOSTICS_PROGRAMMING_BODY" : "Esta opción te permite cambiar la programación de este dispositivo entre USB y flash de pantalla.",
	"MODAL_DIAGNOSTICS_PROGRAMMING_BUTTON" : "Cambiar método de programación",
	"MODAL_DIAGNOSTICS_IR_TITLE" : "Borrar comandos aprendidos del mando a distancia por infrarrojos",
	"MODAL_DIAGNOSTICS_IR_BODY" : "Esta opción te permite borrar todos los comandos aprendidos del mando a distancia por infrarrojos de un robot Edison V3.",
	"MODAL_DIAGNOSTICS_IR_BUTTON" : "Borrar códigos remotos",
	"MODAL_DIAGNOSTICS_IR_SUCCESS" : "Se han borrado los códigos remotos.",
	"MODAL_DIAGNOSTICS_IR_ERROR" : "Se ha producido un error.",
	"MODAL_CONNECTION" : "Conexión",
	"MODAL_CONNECTION_TEST_1" : "Si la prueba anterior tiene el resultado",
	"MODAL_CONNECTION_TEST_EXAMPLE" : "NO SE HA ENCONTRADO NINGÚN SERVIDOR",
	"MODAL_CONNECTION_TEST_2" : "es posible que un cortafuegos esté bloqueando el acceso al compilador.",
	"MODAL_CONNECTION_TEST_3" : "Para solucionarlo, pide a tu administrador de red que incluya estas direcciones en una lista blanca:",
	"MODAL_CONNECTION_PORTS" : "El administrador de red también debe desbloquear los puertos 80, 8080, 443 y 8443.",
	"MODAL_CONNECTION_BACK" : "Volver al diagnóstico",
	"MODAL_CONNECTION_SERVER" : "Servidor:",
	"MODAL_CONNECTION_SERVER_SEARCHING" : "buscando en",
	"MODAL_CONNECTION_SERVER_NONE" : "NO SE HA ENCONTRADO NINGÚN SERVIDOR",
	"MODAL_CONNECTION_COMIPLE_TEST" : "Prueba de compilación:",
	"MODAL_CONNECTION_COMIPLE_TEST_WORKING" : "funcionando",
	"MODAL_CONNECTION_COMIPLE_TEST_ERROR" : "error de compilación",
	"MODAL_CONNECTION_COMIPLE_TEST_COMPLETE" : "compilar completo en",
	"MODAL_STATUS_TITLE" : "Corrige el firmware",
	"MODAL_STATUS_BUTTON" : "Conectar Edison",
	"MODAL_STATUS_STATUS_LABEL" : "estado",
	"MODAL_STATUS_STATUS_NOT_CONNECTED" : "no conectado",
	"MODAL_STATUS_STATUS_CONNECTED" : "conectado",
	"MODAL_STATUS_FIRMWARE_LABEL" : "Versión del firmware:",
	"MODAL_STATUS_FIRMWARE_BOOT_MODE" : "modo cargador de arranque",
	"MODAL_STATUS_FIRMWARE_FACTORY_MODE" : "modo aplicación de fábrica",
	"MODAL_STATUS_FIRMWARE_USER_MODE" : "modo aplicación usuario",
	"MODAL_STATUS_FIRMWARE_TAG" : "firmware",
	"MODAL_STATUS_BOOT_TAG" : "arrancar",
	"MODAL_STATUS_FIRMWARE_UPDATE" : "Una actualización del firmware",
	"MODAL_STATUS_FIRMWARE_UPDATE_AVAILABLE" : "disponible",
	"MODAL_STATUS_BOOT_UPDATE" : "Una actualización de arranque",
	"MODAL_STATUS_FIRMWARE_UPDATE_BUTTON" : "Forzar actualización de firmware",
	"MODAL_STATUS_FIRMWARE_UP_TO_DATE" : "Tu Edison está actualizada.",
	"MODAL_PROGRAMING_METHOD_TITLE" : "Método de programación",
	"MODAL_PROGRAMING_METHOD_BODY" : "La programación flash de pantalla se ha desarrollado para los iPad de Apple. Esto se debe a que Apple no permite el acceso normal al puerto de datos del iPad. Por lo tanto, la programación flash de pantalla sólo es totalmente compatible con los iPads. Sin embargo, el flash de pantalla funciona con algunos dispositivos Android. La siguiente opción activa la programación flash de pantalla en este dispositivo. Si este dispositivo no es un iPad, no se garantiza que funcione.",
	"MODAL_PROGRAMING_METHOD_CURRENT_LABEL" : "Actualmente utilizando",
	"MODAL_PROGRAMING_METHOD_CURRENT_LABEL_USB" : "USB",
	"MODAL_PROGRAMING_METHOD_CURRENT_LABEL_FLASH" : "FLASH",
	"MODAL_PROGRAMING_METHOD_CURRENT_LABEL_METHOD" : "método.",
	"MODAL_PROGRAMING_METHOD_BUTTON_USB" : "Establecer el método USB",
	"MODAL_PROGRAMING_METHOD_BUTTON_FLASH" : "Configura el método FLASH",
	"MODAL_PROGRAMING_METHOD_ACCORD_BUTTON_FLASH_GUARANTEE" : "¿Por qué no está garantizado que el flasheo de pantalla funcione con los dispositivos Android?",
	"MODAL_PROGRAMING_METHOD_ACCORD_BODY_FLASH_GUARANTEE" : "Los dispositivos Android son fabricados por muchos fabricantes diferentes y hay miles de modelos distintos. Esto significa que también hay muchas tecnologías de pantalla diferentes. No es posible probar y personalizar el flasheo de pantalla para todos los dispositivos Android.",
	"MODAL_PROGRAMING_METHOD_ACCORD_BUTTON_FLASH_SETTINGS" : "¿Existen ajustes que puedan ayudar a que mi dispositivo Android funcione con la intermitencia de pantalla?",
	"MODAL_PROGRAMING_METHOD_ACCORD_BODY_FLASH_SETTINGS" : "Sí, en la ventana emergente del parpadeo de pantalla hay un ajuste fiable/rápido que tiene cuatro posiciones. Prueba cada una de las cuatro posiciones. Además, prueba a ajustar el brillo de la pantalla. Prueba con un brillo del 50%, 75%, 90% y 100%.",
	"MODAL_PROGRAMING_METHOD_ACCORD_BUTTON_FLASH_FAIL" : "¿Qué hago si el parpadeo de pantalla no funciona en mi dispositivo Android?",
	"MODAL_PROGRAMING_METHOD_ACCORD_BODY_FLASH_FAIL" : "Para programar necesitarás conectar el cable de la Edison V3 al puerto de datos del dispositivo Android mediante un cable adaptador. Estos son comunes y baratos de conseguir en ebay, Amazon, etc.",
	"MODAL_PROGRAMING_METHOD_BACK" : "Volver al diagnóstico",
	"MODAL_PROGRAMING_TITLE" : "Programación",
	"MODAL_PROGRAMING_TITLE_COMPLETE" : "Programación completa",
	"MODAL_PROGRAMING_TITLE_ERROR" : "Error de programación",
	"MODAL_PROGRAMING_TIP_1_TITLE" : "Consejo: ¡No agrupes los robots Edison en un concentrador USB!",
	"MODAL_PROGRAMING_TIP_1_TEXT" : "Utiliza en su lugar un EdCharger.",
	"MODAL_PROGRAMING_TIP_2_TITLE" : "Consejo: ¡No dejes colgado a Edison!",
	"MODAL_PROGRAMING_TIP_2_TEXT" : "Mantén el Edison apoyado sobre una superficie sólida.",
	"MODAL_PROGRAMING_TIP_3_TITLE" : "Consejo: ¡No dejes colgado a Edison!",
	"MODAL_PROGRAMING_TIP_3_TEXT" : "Utiliza un cable alargador cuando lo cargues desde una toma de corriente.",
	"MODAL_PROGRAMING_TIP_4_TITLE" : "Consejo: ¡No tires de Edison!",
	"MODAL_PROGRAMING_TIP_4_TEXT" : "Desenchúfalo tirando del cable USB, no del robot.",
	"MODAL_PROGRAMING_ERROR_NO_BLOCK" : "No se puede descargar si no hay bloques conectados al bloque de inicio.",
	"MODAL_PROGRAMING_ERROR_RED" : "No se puede descargar con errores rojos.",
	"MODAL_PROGRAMING_UPDATE_FIRMWARE" : "Para programar tu Edison necesitarás actualizar el firmware a la última versión",
	"MODAL_PROGRAMING_UPDATE_FIRMWARE_BUTTON" : "Actualizar firmware",
	"MODAL_PROGRAMING_UPDATE_FIRMWARE_NOW" : "Es necesario actualizar el firmware. Actualizando ahora...",
	"MODAL_PROGRAMING_FIRMWARE_UPDATED" : "Firmware actualizado.",
	"MODAL_PROGRAMING_FIRMWARE_UPDATED_NOW_PROGRAMMING" : "Programando ahora Edison...",
	"MODAL_PROGRAMING_FIRMWARE_UPDATE_INCOMPLETE" : "Actualización de firmware incompleta.",
	"MODAL_PROGRAMING_DONE" : "¡OK! El programa se ha cargado en tu Edison.",
	"MODAL_PROGRAMING_ERROR_JSON" : "¡La respuesta no es JSON!",
	"MODAL_PROGRAMING_ERROR_UNKNOWN" : "¡Error desconocido!",
	"MODAL_FIRMWARE_UPDATE_TITLE" : "Actualización del firmware",
	"MODAL_FIRMWARE_UPDATE_LATEST" : "La última versión del firmware de la Edison V3 es:",
	"MODAL_FIRMWARE_UPDATE_POPUP" : "Utiliza esta ventana emergente para actualizar el firmware de tu Edison.",
	"MODAL_FIRMWARE_UPDATE_TO_UPDATE1" : "Para actualizar el firmware de la Edison V3",
	"MODAL_FIRMWARE_UPDATE_TO_UPDATE2" : "Conecta tu Edison y haz clic en el botón Actualizar firmware que aparece a continuación y sigue las instrucciones.",
	"MODAL_FIRMWARE_UPDATE_TO_UPDATE_BUTTON" : "Actualizar firmware",
	"MODAL_FIRMWARE_UPDATE_TO_RECONNECT_BUTTON" : "Vuelve a conectar Edison",
	"MODAL_FIRMWARE_UPDATE_FEEDBACK_START" : "Listo...",
	"MODAL_FIRMWARE_UPDATE_TWO_STEP_START" : "Se está iniciando una actualización del firmware en dos pasos",
	"MODAL_FIRMWARE_UPDATE_BOOT_COMPLETE" : "Actualización del cargador de arranque completada.",
	"MODAL_FIRMWARE_UPDATE_PLEASE_CLICK" : "Haz clic en",
	"MODAL_FIRMWARE_UPDATE_ISSUE_LOADING" : "Problema al cargar el firmware",
	"MODAL_FIRMWARE_UPDATE_ONE_STEP_START" : "Se está iniciando una actualización del firmware",
	"MODAL_FIRMWARE_UPDATE_ERROR_ISSUE_LOADING" : "Se ha producido un error: Problema cargando firmware.",
	"MODAL_FIRMWARE_UPDATE_ERROR_ISSUE_DOWNLOADING" : "Error: Problema descargando firmware.",
	"MODAL_FIRMWARE_UPDATE_FIRM_COMPLETE" : "Actualización de firmware completada.",
	"MODAL_FIRMWARE_UPDATE_NONE_NEEDED" : "No se requiere actualización: el firmware de tu Edison está actualizado.",
	"MODAL_FIRMWARE_UPDATE_PROBLEMS" : "¿Tienes problemas?",
	"MODAL_FIRMWARE_UPDATE_SEE_DIAG" : "Ver diagnóstico",
	"MODAL_USB_CONTROL" : "Controles USB",
	"MODAL_USB_RUN_BUTTON" : "Ejecutar USB",
	"MODAL_USB_CONNECTED_STATUS" : "CONECTADO",
	"MODAL_USB_DISCONNECTED_STATUS" : "DESCONECTADO",
	"MODAL_USB_RUNNING_STATUS" : "EN FUNCIONAMIENTO",
	"MODAL_USB_DATA_TO" : "Datos a USB",
	"MODAL_USB_DATA_TO_BUTTON" : "Enviar a USB",
	"MODAL_USB_DATA_FROM" : "Datos desde USB",
	"MODAL_USB_DATA_FROM_CLEAR" : "Borrar",
	"MODAL_USB_DATA_FROM_COPY" : "Copiar al portapapeles",
	"MODAL_USB_DATA_FROM_COPIED" : "Copiado",
	"MODAL_BAD_BROWSER_TITLE" : "Navegador no compatible",
	"MODAL_BAD_BROWSER_USING" : "Parece que estás utilizando",
	"MODAL_BAD_BROWSER_WEB_USB" : "La Edison V3 se programa directamente desde tu navegador web a través de USB. Esto requiere que tu navegador web admita conexiones USB.",
	"MODAL_BAD_BROWSER_UNFORTUNATLY" : "Lamentablemente",
	"MODAL_BAD_BROWSER_UNSUPORTED" : "no admite actualmente conexiones USB, por lo que no puede programar tu robot Edison V3.",
	"MODAL_BAD_BROWSER_USE_CHROME" : "Te recomendamos que utilices Google Chrome.",
	"MODAL_BAD_BROWSER_GET_CHROME" : "Obtener Chrome.",
	"MODAL_LOADING" : "Cargando espacio de trabajo...",
	"MODAL_FLASHER_TITLE" : "Intermitente",
	"MODAL_FLASHER_STEP_1" : "Coloca Edison sobre la imagen",
	"MODAL_FLASHER_STEP_2" : "Pulsa una vez el botón redondo de la Edison",
	"MODAL_FLASHER_STEP_3" : "Pulsa Descargar programa",
	"MODAL_FLASHER_RELIABLE" : "Fiable",
	"MODAL_FLASHER_FAST" : "Rápido",
	"MODAL_FLASHER_ADJUST_SPEED" : "Si la descarga no funciona o no es lo suficientemente rápida, prueba a ajustar la velocidad arriba indicada. La velocidad más baja suele ser la más fiable.",
	"MODAL_FLASHER_DOWNLOAD" : "Descargar programa",
	"MODAL_FLASHER_CANCEL" : "Cancelar",
	"MODAL_FLASHER_TIPS_HEADING" : "Consejos",
	"MODAL_FLASHER_TIPS_BODY_1" : "Ajusta el brillo de la pantalla entre el 80% y el 90%.",
	"MODAL_FLASHER_TIPS_BODY_2" : "Aléjate de la luz solar directa e indirecta o de luces brillantes.",
	"MODAL_FLASHER_TIPS_BODY_3" : "Asegúrate de que has actualizado la Edison V3 al firmware más reciente.",
	"MODAL_FLASHER_DOWNLOADING" : "Descarga...",
	"MODAL_FLASHER_COMPLETE" : "Completa",
	"MODAL_FLASHER_BYTES" : "bytes en",
	"MODAL_FLASHER_SECONDS" : "segundos",
	"ERROR_RED_OBS_SETTING" : "Los bloques de detección de obstáculos no funcionan a menos que el haz de detección de obstáculos esté activado utilizando el bloque de haz de detección de obstáculos de la categoría Detección.",
	"ERROR_RED_OBS_SETTING_EVENT" : "Los eventos de detección de obstáculos no funcionan a menos que el haz de detección de obstáculos esté encendido utilizando el bloque de haz de detección de obstáculos de la categoría Sensores del programa principal.",
	"ERROR_RED_LINE_SETTING" : "Los bloques de detección de líneas no funcionan a menos que el LED de detección de líneas esté encendido utilizando el bloque LED de seguimiento de líneas de la categoría Sensores.",
	"ERROR_RED_LINE_SETTING_EVENT" : "Los eventos de detección de línea no funcionan a menos que el LED de detección de línea se encienda utilizando el bloque LED de seguimiento de línea de la categoría Sensores del programa principal.",
	"ERROR_RED_DRIVE_CLAP" : "Edison no puede detectar palmadas durante la conducción porque los motores son demasiado ruidosos.",
	"ERROR_RED_EMPTY_IN_FORWARDS" : "Los bloques hacia delante hasta que necesitan una entrada de condición.",
	"ERROR_RED_EMPTY_IN_BACKWARDS" : "Hacia atrás hasta que los bloques necesiten una condición de entrada.",
	"ERROR_RED_EMPTY_IN_LEFT" : "Izquierda hasta que los bloques necesiten una condición de entrada.",
	"ERROR_RED_EMPTY_IN_RIGHT" : "Derecha hasta que los bloques necesiten una condición de entrada.",
	"ERROR_RED_EMPTY_IN_SET_VAR" : "Los bloques Establecer variable necesitan una variable.",
	"ERROR_RED_EMPTY_IN_INC_VAR" : "Los bloques de incremento de variable necesitan una variable.",
	"ERROR_RED_EMPTY_IN_DEC_VAR" : "Los bloques de variable decreciente necesitan una variable.",
	"ERROR_RED_EMPTY_IN_IF" : "Los bloques Si necesitan una condición.",
	"ERROR_RED_EMPTY_IN_IF_ELSE" : "Los bloques Si-Si necesitan una condición.",
	"ERROR_RED_EMPTY_IN_WAIT" : "Los bloques Espera hasta necesitan una condición de entrada.",
	"ERROR_RED_EMPTY_IN_WAIT_MILLI" : "Los bloques Espera milisegundos necesitan un valor de entrada.",
	"ERROR_RED_EMPTY_IN_REP" : "Repite hasta que los bloques necesiten una condición de entrada.",
	"ERROR_RED_EMPTY_IN_BS_RIGHT" : "Los bloques de desplazamiento de bits a la derecha necesitan una variable.",
	"ERROR_RED_EMPTY_IN_BS_LEFT" : "Los bloques de desplazamiento de bits a la izquierda necesitan una variable.",
	"ERROR_RED_EMPTY_IN_OPERATOR_NOT" : "Los bloques No necesitan una condición de entrada.",
	"ERROR_RED_EMPTY_IN_OPERATOR_AND" : "Y los bloques necesitan una condición de entrada.",
	"ERROR_RED_EMPTY_IN_OPERATOR_OR" : "O los bloques necesitan una condición.",
	"ERROR_RED_EMPTY_BACKGROUND_MUSIC" : "Los bloques de agrupación Reproducir música en segundo plano deben contener al menos un bloque de nota.",
	"ERROR_RED_NO_START" : "Los programas deben tener un evento de inicio para funcionar correctamente. Si ves este mensaje de error, inicia un nuevo programa yendo al menú y seleccionando nuevo.",
	"ERROR_RED_NOT_BACKGROUND_MUSIC" : "Los bloques de agrupación Reproducir música en segundo plano sólo pueden aceptar bloques de notas.",
	"ERROR_RED_NO_MAIN_BLOCKS" : "No hay bloques conectados al evento de inicio, por lo que no hay programa principal que Edison pueda ejecutar.",
	"ERROR_RED_EMPTY_IN_USB_RECEIVED" : "Los bloques de espera de datos usb necesitan una variable.",
	"ERROR_RED_DEVIDE_BY_ZERO" : "Los bloques de operador de división no pueden dividir por cero.",
	"ERROR_RED_FUNCTION_IN_FUNCTION" : "Los bloques de llamada a función no pueden colocarse bajo un bloque de inicio de función",
	"ERROR_YELLOW_RECEIVE_MESSAGE_OBS_ON" : "Edison no puede recibir mensajes mientras la detección de obstáculos está activada. Asegúrate de desactivar la detección de obstáculos en el programa antes de intentar recibir un mensaje.",
	"ERROR_YELLOW_RECEIVE_REMOTE_OBS_ON" : "Edison no puede recibir códigos de control remoto mientras la detección de obstáculos está activada. Asegúrate de desactivar la detección de obstáculos en el programa antes de intentar recibir un código remoto.",
	"ERROR_YELLOW_RECEIVE_MESSAGE_EVENT_OBS_ON" : "Edison no puede recibir mensajes mientras la detección de obstáculos está activada. Asegúrate de desactivar la detección de obstáculos en el programa principal antes de intentar recibir un mensaje.",
	"ERROR_YELLOW_RECEIVE_REMOTE_EVENT_OBS_ON" : "Edison no puede recibir códigos de control remoto mientras la detección de obstáculos está activada. Asegúrate de desactivar la detección de obstáculos en el programa principal antes de intentar recibir un código remoto.",
	"ERROR_YELLOW_READ_LIGHT_LINE_OFF" : "Considera la posibilidad de encender el LED de detección de líneas utilizando el bloque LED de seguimiento de líneas de la categoría Sensores si estás midiendo la reflectividad de la superficie de conducción.",
	"ERROR_YELLOW_OPPERATOR_WAIT_UNTIL" : "Un bloque de operador dentro de un bloque de espera hasta puede hacer que Edison espere eternamente o se salte el bloque de espera.",
	"ERROR_YELLOW_OPPERATOR_REPEAT_UNTIL" : "Un bloque de operador dentro de un bloque de repetición hasta puede hacer que Edison haga un bucle eterno o se salte el bloque de repetición.",
	"ERROR_YELLOW_OPPERATOR_WAIT" : "Un bloque operador dentro de un bloque de espera puede hacer que Edison se salte el bloque de espera.",
	"ERROR_YELLOW_OPPERATOR_REPEAT" : "Un bloque operador dentro de un bloque de repetición puede hacer que Edison se salte el bloque de repetición.",
	"ERROR_YELLOW_OPPERATOR_DRIVE_FOR_UNTIL" : "Un bloque operador dentro de un bloque conducir hacia delante hasta puede hacer que Edison conduzca para siempre o se salte el bloque conducir.",
	"ERROR_YELLOW_OPPERATOR_DRIVE_BACK_UNTIL" : "Un bloqueo del operador dentro de un bloque de conducción hacia atrás hasta que puede hacer que Edison conduzca para siempre o se salte el bloque de conducción.",
	"ERROR_YELLOW_OPPERATOR_DRIVE_LEFT_UNTIL" : "Un bloqueo del operador dentro de un bloque de conducción hacia la izquierda hasta que se bloquee puede hacer que Edison conduzca para siempre o se salte el bloque de conducción.",
	"ERROR_YELLOW_OPPERATOR_DRIVE_RIGHT_UNTIL" : "Un bloqueo de operador dentro de un bloqueo de conducir hacia la derecha hasta puede hacer que Edison conduzca para siempre o se salte el bloqueo de conducir.",
	"ERROR_YELLOW_OPPERATOR_DRIVE_FOR_DIST" : "Un bloqueo del operador dentro de un bloque de conducción hacia delante puede hacer que Edison se salte el bloque de conducción.",
	"ERROR_YELLOW_OPPERATOR_DRIVE_BACK_DIST" : "Un bloqueo del operador dentro de un bloque de conducción hacia atrás puede hacer que Edison se salte el bloque de conducción.",
	"ERROR_YELLOW_OPPERATOR_DRIVE_LEFT_DIST" : "Un bloqueo del operador dentro de un bloque de accionamiento izquierdo puede hacer que Edison se salte el bloque de accionamiento.",
	"ERROR_YELLOW_OPPERATOR_DRIVE_RIGHT_DIST" : "Un bloque de operador dentro de un bloque de accionamiento a la derecha puede hacer que Edison se salte el bloque de accionamiento.",
	"ERROR_YELLOW_DRIVE_LIGHT" : "Un bloque de nivel de luz dentro de un bloque de accionamiento puede hacer que Edison accione para siempre o se salte el bloque de accionamiento.",
	"ERROR_YELLOW_OPPERATOR_IR_MESSAGE" : "Un bloque operador dentro de un bloque enviar mensaje IR no podrá enviar un valor superior a 255",
	"ERROR_YELLOW_FOREVER_LOOP_IN" : "Un bucle eterno continuará en bucle hasta que pulses el botón cuadrado de Edison.",
	"ERROR_YELLOW_SET_MOTOR_LEFT" : "El bloque establecer motor izquierdo sólo encenderá el motor izquierdo. Asegúrate de que hay bloques adicionales en el programa para controlar la duración del motor izquierdo.",
	"ERROR_YELLOW_SET_MOTOR_RIGHT" : "El bloque fijar motor derecho sólo encenderá el motor derecho. Asegúrate de que hay bloques adicionales en el programa para controlar la duración del motor derecho.",
	"ERROR_YELLOW_SET_MOTOR_BOTH" : "El bloque fijar ambos motores sólo encenderá los motores. Asegúrate de que hay bloques adicionales en el programa para controlar la duración del motor.",
	"ERROR_YELLOW_CLAP_EVENT_DRIVE" : "El accionamiento de los motores crea ruido, lo que puede provocar que se active el evento clap. Esto puede hacer que los bloques de evento clap se disparen repetidamente mientras Edison está conduciendo.",
	"ERROR_YELLOW_FLOAT_BLOCKS" : "Los bloques que no estén conectados a un bloque de evento amarillo o a un bloque de definición de función no se programarán en Edison.",
	"ERROR_YELLOW_WAIT_TIME_LIGHT" : "El nivel de luz devolverá un valor muy alto que puede hacer que Edison espere durante mucho tiempo.",
	"ERROR_YELLOW_REPEAT_LOOP_LIGHT" : "El nivel de luz devolverá un valor muy alto que puede hacer que Edison entre en bucle durante mucho tiempo.",
	"ERROR_YELLOW_DRIVE_STRAIN" : "El bloque de tensión detectada del accionamiento sólo detectará la tensión mientras los motores estén en marcha.",
	"ERROR_YELLOW_DRIVE_STRAIN_EVENT" : "El evento de esfuerzo del accionamiento sólo puede activarse mientras los motores están en marcha.",
	"ERROR_YELLOW_COMMENT" : "Los comentarios son notas que ayudan a controlar las cosas. Los bloques de comentarios no se programarán en Edison.",
	"ERROR_YELLOW_USB_USED" : "Los bloques USB requieren que Edison esté conectado a un dispositivo para funcionar.",
	"ERROR_YELLOW_CLEAR_SENSOR" : "Algunos datos de los sensores se almacenan en la memoria de Edison. Es posible que tengas que borrar los datos de los sensores para que tu programa funcione correctamente.",
	"ERROR_YELLOW_CLEAR_LEARN_MORE" : "Más información",
	"MODAL_FIRMWARE_ERROR_TITLE" : "Error de firmware",
	"MODAL_FIRMWARE_ERROR_BODY_1" : "Se ha detectado un archivo de firmware dañado en tu robot Edison.",
	"MODAL_FIRMWARE_ERROR_BODY_2" : "Esto puede haber ocurrido durante una actualización de firmware que se interrumpió.",
	"MODAL_FIRMWARE_ERROR_BODY_3" : "¡Que no cunda el pánico! Esto se puede arreglar haciendo clic en el botón Arreglar firmware que aparece a continuación.",
	"MODAL_FIRMWARE_ERROR_CANCEL_BODY_1" : "¡Atención!",
	"MODAL_FIRMWARE_ERROR_CANCEL_BODY_2" : "Cancelar este proceso significa que tu robot Edison no se puede programar.",
	"MODAL_FIRMWARE_ERROR_CANCEL_BODY_3" : "Se recomienda que arregles el firmware ahora haciendo clic en el botón Arreglar firmware.",
	"MODAL_FIRMWARE_ERROR_CANCEL_BODY_4" : "Si decides cancelar el proceso, podrás arreglar el firmware más adelante.",
	"MODAL_FIRMWARE_ERROR_BUTTON_FIX" : "Corrige el firmware",
	"MODAL_FIRMWARE_ERROR_BUTTON_CANCEL" : "Cancelar",
	"MODAL_FIRMWARE_ERROR_BUTTON_CANCEL_CONFIRM" : "Confirmar cancelación",
	"MODAL_NEW_CONFIRM_HEADING" : "¿Estás seguro?",
	"MODAL_NEW_CONFIRM_BODY_TEXT_1" : "¿Estás seguro de que quieres iniciar un nuevo programa?",
	"MODAL_NEW_CONFIRM_BODY_TEXT_2" : "¡Cualquier cambio puede perderse!",
	"MODAL_NEW_CONFIRM_BUTTON_CANCEL" : "Cancelar",
	"MODAL_NEW_CONFIRM_BUTTON_PROCEED" : "Procede",
	"CHANGELANG" : "Cambiar idioma",
	"HELP_TEXT_ALL_TITLE" : "Bloquear la ayuda",
	"HELP_TEXT_ALL_BLOCKS_EXAMPLE_USES" : "Ejemplo de uso:",
	"HELP_TEXT_ALL_BLOCKS_EXAMPLE_LOAD" : "Abrir programa",
	"HELP_TEXT_ALL_BLOCKS_WATCH_FOR" : "Cuidado con:",
	"HELP_TEXT_DRIVE_FORWARD_FOR_TITLE" : "hacia delante para",
	"HELP_TEXT_DRIVE_FORWARD_FOR_BODY_1" : "El bloque adelante para acciona las ruedas para mover el robot en la dirección de avance.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_BODY_2" : "El bloque tiene tres parámetros:",
	"HELP_TEXT_DRIVE_FORWARD_FOR_BODY_3" : "Valor - Puede ser una constante (se teclea en la entrada y no varía), una variable, un sensor o un bloque operador.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_BODY_4" : "Unidades - Se pueden seleccionar tres opciones: cm, pulgadas y segundos.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_BODY_5" : "Velocidad - La velocidad puede seleccionarse de 1 a 10 (como valor constante), una variable, un sensor o un bloque de operador.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_BODY_6" : "El bloque hacia delante para se completará antes de que se ejecute el siguiente bloque. Por ejemplo, si utilizas el bloque adelante por, no se ejecutarán otros bloques del programa al mismo tiempo. Para ello, consulta la opción poner ambos motores en bloqueo.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_1_TITLE" : "Ejemplo 1: Emite un pitido, haz avanzar al robot Edison 15 cm a velocidad 1 y vuelve a emitir un pitido.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_1_BODY_1" : "En este programa de ejemplo, Edison emite un pitido, pero no comienza a conducir hasta que el pitido ha terminado de sonar. Además, el segundo pitido no comienza hasta que Edison ha dejado de conducir.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_2_TITLE" : "Ejemplo 2: Establecer la distancia de conducción utilizando una variable y los datos de un sensor",
	"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_2_BODY_1" : "En este programa de ejemplo, Edison establece la variable Distancia en el nivel de luz del sensor de luz izquierdo (un valor de 1 a 1.000) dividido por 50. A continuación, el Edison se desplaza hacia delante según el valor de la variable (Distancia) a la velocidad 5. El resultado es que el Edison se desplaza más lejos cuando la luz es más intensa y más corta cuando la luz es más tenue.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_3_TITLE" : "Ejemplo 3: Modificar la velocidad de avance mediante una variable.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_3_BODY_1" : "En este programa de ejemplo, la variable Velocidad se establece en 1. A continuación, el programa entra en un bucle de repetición 10 veces. En cada bucle, el Edison avanza 5 cm a la velocidad de la variable. Inicialmente, el valor de la variable Velocidad es 1, por lo que el Edison avanza 5 cm a velocidad 1. El siguiente bloque de la repetición incrementa (+1) la variable Velocidad. En la segunda repetición del bloque de avance, el valor de la variable Velocidad es 2, por lo que el Edison avanza 5 cm a velocidad 2.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_3_BODY_2" : "Este proceso se repite las 10 veces completas del bucle de repetición, haciendo que la Edison conduzca cada vez más deprisa hasta detenerse cuando finaliza el programa.",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_TITLE" : "hacia atrás para",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_BODY_1" : "El bloque hacia atrás para acciona las ruedas para mover el robot hacia atrás.",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_BODY_2" : "El bloque tiene tres parámetros:",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_BODY_3" : "Valor - Puede ser una constante (se teclea en la entrada y no varía), una variable, un sensor o un bloque operador.",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_BODY_4" : "Unidades - Se pueden seleccionar tres opciones: cm, pulgadas y segundos.",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_BODY_5" : "Velocidad - La velocidad puede seleccionarse de 1 a 10 (como valor constante), una variable, un sensor o un bloque de operador.",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_BODY_6" : "El bloque hacia atrás para se completará antes de que se ejecute el siguiente bloque. Por ejemplo, al utilizar el bloque hacia atrás para no se ejecutarán otros bloques del programa al mismo tiempo. Para ello, consulta el bloque Establecer ambos motores en bloque.",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_EXAMPLE_1_TITLE" : "Ejemplo 1: Luces LED encendidas durante la conducción",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_EXAMPLE_1_BODY_1" : "En este programa de ejemplo, el LED izquierdo se enciende y permanece encendido mientras la Edison conduce hacia atrás durante un segundo. El LED izquierdo se apaga cuando la Edison deja de avanzar. A continuación, el programa espera un segundo antes de finalizar.",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_EXAMPLE_2_TITLE" : "Ejemplo 2: Cuando hay un obstáculo, conduce hacia atrás",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_EXAMPLE_2_BODY_1" : "En este programa de ejemplo, primero se enciende el haz de detección de obstáculos. A continuación, el programa entra en un bucle eterno. Dentro del bucle, el bloque esperar hasta detiene el avance del programa hasta que se detecta un obstáculo en cualquier lugar; cuando esto ocurre, la Edison retrocede un centímetro a velocidad 10. Este comportamiento se repite eternamente en un bucle. El resultado es que la Edison retrocede ante los objetos que se le ponen delante.",
	"HELP_TEXT_DRIVE_LEFT_FOR_TITLE" : "izquierda por",
	"HELP_TEXT_DRIVE_LEFT_FOR_BODY_1" : "El bloque for izquierdo acciona las ruedas para mover el robot en la dirección izquierda.",
	"HELP_TEXT_DRIVE_LEFT_FOR_BODY_2" : "El bloque tiene cuatro parámetros:",
	"HELP_TEXT_DRIVE_LEFT_FOR_BODY_3" : "Movimiento - Hay tres opciones que se pueden seleccionar: girar, girar hacia delante y girar hacia atrás.",
	"HELP_TEXT_DRIVE_LEFT_FOR_BODY_4" : "Valor - Puede ser una constante (se teclea en la entrada y no varía), una variable, un sensor o un bloque operador.",
	"HELP_TEXT_DRIVE_LEFT_FOR_BODY_5" : "Unidades - Hay dos opciones que se pueden seleccionar: grados y segundos.",
	"HELP_TEXT_DRIVE_LEFT_FOR_BODY_6" : "Velocidad - La velocidad puede seleccionarse de 1 a 10 (como valor constante), una variable, un sensor o un bloque de operador.",
	"HELP_TEXT_DRIVE_LEFT_FOR_BODY_7" : "Girar y dar vueltas es más preciso a velocidades más bajas. Esto se debe a que las ruedas pueden perder tracción y patinar a altas velocidades. La velocidad 1 es la mejor cuando se necesita un giro preciso.",
	"HELP_TEXT_DRIVE_LEFT_FOR_BODY_8" : "La izquierda para bloque debe completarse antes de que se ejecute el siguiente bloque. Por ejemplo, al utilizar el bloque izquierdo para no se ejecutarán otros bloques del programa al mismo tiempo. Para ello, consulta el ajuste de ambos motores para bloquear.",
	"HELP_TEXT_DRIVE_LEFT_FOR_EXAMPLE_1_TITLE" : "Programa de ejemplo 1: bip, giro, bip",
	"HELP_TEXT_DRIVE_LEFT_FOR_EXAMPLE_1_BODY_1" : "En este programa de ejemplo, Edison pita, pero no empieza a girar hasta que el pitido ha terminado de sonar. Además, el segundo pitido no empieza hasta que Edison ha dejado de girar.",
	"HELP_TEXT_DRIVE_LEFT_FOR_EXAMPLE_2_TITLE" : "Programa de ejemplo 2: Conducir en un cuadrado",
	"HELP_TEXT_DRIVE_LEFT_FOR_EXAMPLE_2_BODY_1" : "En este programa de ejemplo, el bucle de repetición repite la conducción hacia delante durante 10 cm a velocidad 1 y girando hacia delante a la izquierda 90 grados cuatro veces. El resultado es que Edison conduce en cuadrado.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_TITLE" : "derecha por",
	"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_1" : "El bloque for derecho acciona las ruedas para mover el robot en la dirección izquierda.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_2" : "El bloque tiene cuatro parámetros:",
	"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_3" : "Movimiento - Hay tres opciones que se pueden seleccionar: girar, girar hacia delante y girar hacia atrás.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_4" : "Valor - Puede ser una constante (se teclea en la entrada y no varía), una variable, un sensor o un bloque operador.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_5" : "Unidades - Hay dos opciones que se pueden seleccionar: grados y segundos.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_6" : "Velocidad - La velocidad puede seleccionarse de 1 a 10 (como valor constante), una variable, un sensor o un bloque de operador.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_7" : "Girar y dar vueltas es más preciso a velocidades más bajas. Esto se debe a que las ruedas pueden perder tracción y patinar a altas velocidades. La velocidad 1 es la mejor cuando se necesita un giro preciso.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_8" : "El bloque derecho debe completarse antes de que se ejecute el siguiente bloque. Por ejemplo, al utilizar el bloque derecho para no se ejecutarán otros bloques del programa al mismo tiempo. Para ello, consulta la opción poner ambos motores en bloqueo.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_EXAMPLE_1_TITLE" : "Programa de ejemplo 1: Pitar, girar, pitar",
	"HELP_TEXT_DRIVE_RIGHT_FOR_EXAMPLE_1_BODY_1" : "En este programa de ejemplo, Edison pita, pero no empieza a girar hasta que el pitido ha terminado de sonar. Además, el segundo pitido no empieza hasta que Edison ha dejado de girar.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_EXAMPLE_2_TITLE" : "Ejemplo 2: Girar a la derecha con la velocidad controlada por el nivel de luz",
	"HELP_TEXT_DRIVE_RIGHT_FOR_EXAMPLE_2_BODY_1" : "En este programa de ejemplo Edison gira a la derecha dentro de un bucle eterno. Cada vez que se ejecuta el bloque for derecha, Edison gira 1 grado. La velocidad se establece por la lectura del nivel de luz del sensor de luz izquierdo (de 1 a 1.000) y se divide por 100 (resultado de 0 a 10). El resultado es que Edison gira más rápido bajo una luz más brillante y más lento bajo una luz más tenue.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_EXAMPLE_3_TITLE" : "Programa de ejemplo 3: Evitar obstáculos",
	"HELP_TEXT_DRIVE_RIGHT_FOR_EXAMPLE_3_BODY_1" : "En este programa de ejemplo, se enciende el haz de detección de obstáculos. A continuación, el programa entra en un bucle eterno en el que ambos motores se ponen en marcha hacia delante. A continuación, el programa espera hasta que se detecta un obstáculo en cualquier lugar. Cuando esto ocurre, el programa pasa al siguiente bloque y el robot Edison gira 180 grados a la derecha a velocidad 1. Esto hace que Edison se aleje de los obstáculos que encuentra en su camino.",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_TITLE" : "hacia delante hasta",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_BODY_1" : "El bloque hacia delante hasta hace que las ruedas muevan el robot hacia delante hasta que se cumpla la condición especificada. Una vez que se cumple la condición especificada, las ruedas se detienen y el programa pasa al siguiente bloque.",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_BODY_2" : "El bloque tiene dos parámetros:",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_BODY_3" : "Entrada condicional - La entrada condicional acepta un bloque con forma de diamante que puede ser un bloque de detección o de operador.",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_BODY_4" : "Velocidad - La velocidad puede ser seleccionada de 1 a 10 (como valor constante), una variable, un sensor o un bloque de operador.",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_BODY_5" : "El bloque avanzar hasta debe completarse antes de que se ejecute el siguiente bloque. Por ejemplo, si utilizas el bloque avanzar hasta, no se ejecutarán otros bloques del programa al mismo tiempo. Para ello, consulta la opción Bloquear ambos motores.",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_EXAMPLE_1_TITLE" : "Programa de ejemplo 1: Parada por obstáculo",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_EXAMPLE_1_BODY_1" : "En este programa de ejemplo, se enciende el haz de detección de obstáculos y el robot avanza a velocidad 5 hasta que detecta un obstáculo. Cuando esto ocurre, el robot deja de moverse y el programa finaliza.",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_EXAMPLE_2_TITLE" : "Programa de ejemplo 2: Rebote en los bordes",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_EXAMPLE_2_BODY_1" : "En este programa de ejemplo, se enciende el rayo de seguimiento de líneas y, a continuación, el programa entra en un bucle eterno. Dentro del bucle, el bloque avanzar hasta hace avanzar al robot a velocidad 1 hasta que el seguidor de línea se encuentre sobre una superficie no reflectante (es decir, negra). Cuando esto ocurre, se ejecuta el siguiente bloque, que hace girar al robot 180 grados a la izquierda a velocidad 5. A continuación, el programa vuelve al bucle hasta el bloque adelante hasta. El resultado es que Edison se aleja de las líneas negras detectadas.",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_TITLE" : "hacia atrás hasta",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_BODY_1" : "El bloque hacia atrás hasta hace que las ruedas muevan el robot hacia atrás hasta que se cumpla la condición especificada. Una vez que se cumple la condición especificada, las ruedas se detienen y el programa pasa al siguiente bloque.",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_BODY_2" : "El bloque tiene dos parámetros:",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_BODY_3" : "Entrada condicional - La entrada condicional acepta un bloque con forma de diamante que puede ser un bloque de detección o de operador.",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_BODY_4" : "Velocidad - La velocidad puede seleccionarse de 1 a 10 (como valor constante), una variable, un sensor o un bloque de operador.",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_BODY_5" : "El bloque hacia atrás hasta debe completarse antes de que se ejecute el siguiente bloque. Por ejemplo, si utilizas el bloque retroceder hasta, no se ejecutarán otros bloques del programa al mismo tiempo. Para ello, consulta el bloque Poner ambos motores en marcha.",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_EXAMPLE_1_TITLE" : "Programa de ejemplo 1: Parar cuando el accionamiento se tensa",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_EXAMPLE_1_BODY_1" : "En este programa de ejemplo, el robot se desplaza hacia atrás a velocidad 10 hasta que las ruedas se fatigan (no pueden girar o se atascan). Cuando esto ocurre, los motores se paran y el programa finaliza.",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_EXAMPLE_2_TITLE" : "Programa de ejemplo 2: Control de accionamiento con botones",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_EXAMPLE_2_BODY_1" : "En este ejemplo, el programa comienza con un bucle eterno. El primer bloque del bucle espera hasta que se pulsa el botón triangular. Cuando esto ocurre, el robot se desplaza hacia atrás a velocidad 1 hasta que se pulsa el botón redondo. Cuando esto ocurre, las ruedas del robot se detienen y el programa vuelve al bucle de espera hasta que se pulsa el botón triángulo.",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_TITLE" : "hacia la izquierda hasta",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_BODY_1" : "El bloque izquierdo hasta hace que las ruedas muevan el robot en la dirección izquierda hasta que se cumpla la condición especificada. Una vez que se cumple la condición especificada, las ruedas se detienen y el programa pasa al siguiente bloque.",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_BODY_2" : "El bloque tiene tres parámetros:",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_BODY_3" : "Movimiento - Hay tres opciones que se pueden seleccionar: girar, girar hacia delante y girar hacia atrás.",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_BODY_4" : "Entrada condicional - La entrada condicional acepta un bloque con forma de diamante que puede ser un bloque de detección o de operador.",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_BODY_5" : "Velocidad - La velocidad puede seleccionarse de 1 a 10 (como valor constante), una variable, un sensor o un bloque de operador.",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_BODY_6" : "El bloque girar a la izquierda hasta debe completarse antes de que se ejecute el siguiente bloque. Por ejemplo, si utilizas el bloque girar a la izquierda hasta, no se ejecutarán otros bloques del programa al mismo tiempo. Para ello, consulta la opción poner ambos motores en bloque.",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_EXAMPLE_1_TITLE" : "Programa de ejemplo 1: Parar cuando el accionamiento se tensa",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_EXAMPLE_1_BODY_1" : "En este programa de ejemplo, el robot avanza hacia la izquierda (rueda derecha en movimiento) a velocidad 1 hasta que la rueda se tensa (no puede girar o se atasca). Cuando esto ocurre, el motor se para y el programa finaliza.",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_EXAMPLE_2_TITLE" : "Programa de ejemplo 2: Seguir la luz",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_EXAMPLE_2_BODY_1" : "En este ejemplo, el programa comienza con un bucle eterno. El primer bloque del bucle hace girar el robot hacia la izquierda a velocidad 5 hasta que el nivel de luz izquierdo sea inferior al nivel de luz derecho. Cuando esto ocurre, el motor se para y se ejecuta el siguiente bloque. El siguiente bloque gira el robot a la derecha a velocidad 5 hasta que el nivel de luz izquierdo sea mayor que el nivel de luz derecho. El resultado es que el robot Edison se dirige hacia la luz.",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_TITLE" : "derecha hasta",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_BODY_1" : "El bloque derecha hasta acciona las ruedas para mover el robot en la dirección derecha hasta que se cumpla la condición especificada. Una vez que se cumple la condición especificada, las ruedas se detienen y el programa pasa al siguiente bloque.",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_BODY_2" : "El bloque tiene tres parámetros:",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_BODY_3" : "Movimiento - Hay tres opciones que se pueden seleccionar: girar, girar hacia delante y girar hacia atrás.",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_BODY_4" : "Entrada condicional - La entrada condicional acepta un bloque con forma de diamante que puede ser un bloque de detección o de operador.",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_BODY_5" : "Velocidad - La velocidad puede seleccionarse de 1 a 10 (como valor constante), una variable, un sensor o un bloque de operador.",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_BODY_6" : "El bloque hasta la derecha debe completarse antes de que se ejecute el siguiente bloque. Por ejemplo, si utilizas el bloque girar a la derecha hasta, no se ejecutarán otros bloques del programa al mismo tiempo. Para ello, consulta la opción Poner ambos motores en bloque.",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_EXAMPLE_1_TITLE" : "Programa de ejemplo 1: Parada en superficie negra",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_EXAMPLE_1_BODY_1" : "En este ejemplo de programa el robot gira a la derecha a velocidad 5 hasta que el seguidor de líneas detecta una superficie no reflectante (negra). Cuando esto ocurre, el motor se detiene y el programa finaliza.",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_EXAMPLE_2_TITLE" : "Programa de ejemplo 2: Seguir la luz",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_EXAMPLE_2_BODY_1" : "En este ejemplo, el programa comienza con un bucle eterno. El primer bloque del bucle hace girar el robot hacia la izquierda a velocidad 5 hasta que el nivel de luz izquierdo sea inferior al nivel de luz derecho. Cuando esto ocurre, el motor se para y se ejecuta el siguiente bloque. El siguiente bloque gira el robot a la derecha a velocidad 5 hasta que el nivel de luz izquierdo sea mayor que el nivel de luz derecho. El resultado es que el robot Edison se dirige hacia la luz.",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_TITLE" : "Pon ambos motores a",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_BODY_1" : "El bloque ajustar ambos motores a acciona las ruedas para mover el robot en la dirección y velocidad seleccionadas. Como este bloque de accionamiento ajusta los motores, el programa puede continuar directamente con el siguiente bloque. Esto es diferente de los bloques de accionamiento que tienen una distancia, tiempo o ángulo que completar antes de que el programa continúe con el siguiente bloque.",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_BODY_2" : "El bloque tiene dos parámetros:",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_BODY_3" : "Movimiento - Hay seis opciones que se pueden seleccionar: conducir hacia delante, conducir hacia atrás, girar el robot a la izquierda, girar el robot a la derecha, girar el robot a la izquierda y girar el robot a la derecha.",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_BODY_4" : "Velocidad - La velocidad puede seleccionarse de 1 a 10 (como valor constante), una variable, un sensor o un bloque de operador.",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_EXAMPLE_1_TITLE" : "Programa de ejemplo 1: Música durante la conducción",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_EXAMPLE_1_BODY" : "En este programa de ejemplo, el robot Edison está configurado para conducir hacia delante y, a continuación, se reproducen tres notas mientras el robot sigue conduciendo. Cuando termina de sonar la última nota, el programa finaliza y el robot Edison deja de conducir.",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_EXAMPLE_2_TITLE" : "Programa de ejemplo 2: Conducción hasta un obstáculo",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_EXAMPLE_2_BODY" : "En este programa de ejemplo, se enciende el haz de detección de obstáculos y, a continuación, ambos motores se ponen en marcha hacia delante a velocidad 8. El siguiente bloque espera hasta que se detecta algún obstáculo. Cuando esto ocurre, el programa finaliza y el robot detiene la marcha.",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_EXAMPLE_3_TITLE" : "Programa de ejemplo 3: Seguir una línea",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_EXAMPLE_3_BODY" : "En este programa de ejemplo, se enciende el LED de seguimiento de línea y el programa entra en un bucle eterno. Dentro del bucle, ambos motores se configuran para que el robot gire a la izquierda a velocidad 1, entonces el bloque esperar hasta mantiene el programa ahí hasta que el seguidor de línea detecta una superficie reflectante (blanca). Cuando esto ocurre, ambos motores se ajustan para que el robot gire a la derecha a velocidad 1 y el bloque esperar hasta mantiene el programa ahí hasta que el seguidor de líneas detecta una superficie no reflectante (negra). Cuando esto ocurre, el programa vuelve al principio del bucle ''para siempre'' y se repite. El resultado es que Edison sigue una línea no reflectante.",
	"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_TITLE" : "poner el motor derecho en",
	"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_BODY_1" : "El bloque fijar motor a la derecha acciona las ruedas para mover el robot en la dirección y velocidad seleccionadas. Como este bloque de accionamiento ajusta los motores, el programa puede continuar directamente hasta el siguiente bloque. Esto es diferente a los bloques de accionamiento que tienen una distancia, tiempo o ángulo que completar antes de que el programa pase al siguiente bloque.",
	"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_BODY_2" : "El bloque tiene dos parámetros:",
	"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_BODY_3" : "Movimiento - Hay dos opciones que se pueden seleccionar: hacia delante y hacia atrás.",
	"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_BODY_4" : "Velocidad - La velocidad puede seleccionarse de 1 a 10 (como valor constante), una variable, un sensor o un bloque de operador.",
	"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_EXAMPLE_1_TITLE" : "Ejemplo de programa 1: Encendido y apagado del motor pulsando un botón",
	"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_EXAMPLE_1_BODY" : "En este ejemplo, el programa entra en un bucle eterno. El primer bloque del bucle espera hasta que se pulsa el botón redondo. Cuando esto ocurre, el motor derecho se pone en marcha hacia delante a velocidad 5, el programa pasa entonces a otro bloque de espera hasta que se pulse el botón redondo. Cuando esto ocurre, el motor derecho se detiene y el programa vuelve al inicio del bucle eterno.",
	"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_TITLE" : "ajustar motor izquierdo a",
	"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_BODY_1" : "El bloque ajustar motor izquierdo a acciona las ruedas para mover el robot en la dirección y velocidad seleccionadas. Como este bloque de accionamiento fija los motores, el programa puede continuar directamente con el siguiente bloque. Esto es diferente de los bloques de accionamiento que tienen una distancia, tiempo o ángulo que completar antes de que el programa pase al siguiente bloque.",
	"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_BODY_2" : "El bloque tiene dos parámetros:",
	"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_BODY_3" : "Movimiento - Hay dos opciones que se pueden seleccionar: hacia delante y hacia atrás.",
	"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_BODY_4" : "Velocidad - La velocidad puede seleccionarse de 1 a 10 (como valor constante), una variable, un sensor o un bloque de operador.",
	"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_EXAMPLE_1_TITLE" : "Programa de ejemplo 1: Seguir la luz",
	"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_EXAMPLE_1_BODY" : "En este ejemplo, el programa entra en un bucle eterno. El primer bloque del bucle hace avanzar el motor izquierdo a una velocidad calculada. La velocidad calculada es el nivel de luz del sensor derecho menos el nivel de luz del sensor izquierdo dividido por 100, al resultado también se le añade 3 para fijar una velocidad mínima. El siguiente bloque hace que el motor derecho avance a una velocidad calculada. La velocidad calculada es el nivel de luz del sensor izquierdo menos el nivel de luz del sensor derecho dividido por 100, también se añade 3 al resultado para establecer una velocidad mínima. A continuación, el programa vuelve al inicio del bucle eterno. Los resultados calculados controlan la velocidad de modo que el lado que tiene menos luz es el que conduce más rápido. Esto hace que el robot Edison siempre intente orientarse y conducir hacia la luz más brillante.",
	"HELP_TEXT_DRIVE_STOP_TITLE" : "detener",
	"HELP_TEXT_DRIVE_STOP_BODY_1" : "El bloque de parada impide que los motores accionen las ruedas.",
	"HELP_TEXT_DRIVE_STOP_BODY_2" : "El bloque de parada sólo tiene un parámetro para seleccionar qué motor/es se paran. Las opciones son ambos motores, motor izquierdo y motor derecho.",
	"HELP_TEXT_DRIVE_STOP_EXAMPLE_1_TITLE" : "Ejemplo de programa 1: Encendido y apagado del motor pulsando un botón",
	"HELP_TEXT_DRIVE_STOP_EXAMPLE_1_BODY" : "En este ejemplo, el programa entra en un bucle eterno. El primer bloque del bucle espera hasta que se pulsa el botón redondo. Cuando esto ocurre, el motor derecho se pone en marcha hacia delante a velocidad 5, el programa pasa entonces a otro bloque de espera hasta que se pulse el botón redondo. Cuando esto ocurre, el motor derecho se detiene y el programa vuelve al inicio del bucle eterno.",
	"HELP_TEXT_LEDS_LEFT_TITLE" : "girar a la izquierda LED",
	"HELP_TEXT_LEDS_LEFT_BODY_1" : "El bloque girar LED izquierdo controla el LED izquierdo. Hay dos opciones: encendido o apagado.",
	"HELP_TEXT_LEDS_LEFT_EXAMPLE_1_TITLE" : "Programa de ejemplo 1: Parpadear una vez el LED izquierdo",
	"HELP_TEXT_LEDS_LEFT_EXAMPLE_1_BODY" : "En este ejemplo, el programa comienza encendiendo el LED izquierdo, espera un segundo y apaga el LED izquierdo.",
	"HELP_TEXT_LEDS_LEFT_EXAMPLE_2_TITLE" : "Programa de ejemplo 2: Parpadear el LED izquierdo para siempre",
	"HELP_TEXT_LEDS_LEFT_EXAMPLE_2_BODY" : "En este ejemplo, el programa comienza entrando en un bucle ''para siempre''. Dentro del bucle se enciende el LED izquierdo, luego el programa espera un segundo, luego se apaga el LED izquierdo, luego el programa espera un segundo, luego el programa salta al principio del bucle y repite para siempre.",
	"HELP_TEXT_LEDS_RIGHT_TITLE" : "gira el LED derecho",
	"HELP_TEXT_LEDS_RIGHT_BODY_1" : "El bloque girar LED derecho controla el LED derecho. Hay dos opciones: encendido o apagado.",
	"HELP_TEXT_LEDS_RIGHT_EXAMPLE_1_TITLE" : "Programa de ejemplo 1: Parpadear una vez el LED derecho",
	"HELP_TEXT_LEDS_RIGHT_EXAMPLE_1_BODY" : "En este ejemplo, el programa comienza encendiendo el LED derecho, espera un segundo y luego apaga el LED derecho.",
	"HELP_TEXT_LEDS_RIGHT_EXAMPLE_2_TITLE" : "Ejemplo de programa 2: Parpadear el LED derecho para siempre",
	"HELP_TEXT_LEDS_RIGHT_EXAMPLE_2_BODY" : "En este ejemplo, el programa comienza entrando en un bucle ''para siempre''. Dentro del bucle se enciende el LED derecho, luego el programa espera un segundo, luego se apaga el LED derecho, luego el programa espera un segundo, luego el programa salta al principio del bucle y se repite para siempre.",
	"HELP_TEXT_LEDS_SEND_MESSAGE_TITLE" : "enviar mensaje IR",
	"HELP_TEXT_LEDS_SEND_MESSAGE_BODY_1" : "El bloque de envío de mensajes IR envía datos a través de la luz infrarroja (IR). Los datos que se pueden enviar son un valor de 0 a 255. El valor puede ser una constante (se escribe en la entrada y no varía), una variable, un sensor o un bloque operador.",
	"HELP_TEXT_LEDS_SEND_MESSAGE_BODY_2" : "Los datos enviados pueden ser recibidos por cualquier otro robot Edison que esté dentro del alcance de la señal luminosa IR. El alcance máximo puede ser de hasta 10 metros/30 pies en condiciones ideales (es decir, en interiores, sin luz solar directa, techo y paredes blancas para que rebote la luz IR).",
	"HELP_TEXT_LEDS_SEND_MESSAGE_BODY_3" : "Si utilizas una variable, el número de la variable podría superar el límite de 255 (8 bits). Cuando esto ocurra, el número enviado por IR se ''enrollará'' (es decir, 256 envía 0, 257 envía 1, 258 envía 2...).",
	"HELP_TEXT_LEDS_SEND_MESSAGE_EXAMPLE_1_TITLE" : "Programa de ejemplo 1: Enviar mensaje IR 1 al pulsar el botón redondo",
	"HELP_TEXT_LEDS_SEND_MESSAGE_EXAMPLE_1_BODY" : "En este ejemplo, el programa comienza entrando en un bucle eterno. Dentro del bucle, el programa espera a que se pulse el botón redondo. Cuando esto ocurre, se envía el mensaje IR 1. A continuación, el programa vuelve al principio del bucle eterno.",
	"HELP_TEXT_LEDS_SEND_MESSAGE_EXAMPLE_2_TITLE" : "Programa de ejemplo 2: Enviar nivel de luz cada un segundo",
	"HELP_TEXT_LEDS_SEND_MESSAGE_EXAMPLE_2_BODY" : "En este ejemplo, el programa comienza entrando en un bucle eterno. Dentro del bucle, el programa envía la lectura del nivel de luz del sensor de luz izquierdo dividida por cuatro. El valor se divide por cuatro, ya que la salida del sensor de luz es de 1 a 1.000, pero el número más alto que se puede enviar con IR es 255 (1.000/4 = 250). Este cálculo adicional permite enviar todo el rango del sensor de luz. A continuación, el programa espera un segundo y vuelve al inicio del bucle eterno.",
	"HELP_TEXT_SOUND_BEEP_TITLE" : "pitar",
	"HELP_TEXT_SOUND_BEEP_BODY_1" : "El bloque bip reproduce un sonido bip de 3,5 kHz durante 125 ms (0,125 segundos).",
	"HELP_TEXT_SOUND_BEEP_EXAMPLE_1_TITLE" : "Programa de ejemplo 1: Pitido al pulsar el botón redondo",
	"HELP_TEXT_SOUND_BEEP_EXAMPLE_1_BODY" : "En este ejemplo, el programa comienza entrando en un bucle eterno. Dentro del bucle, el programa espera a que se pulse el botón redondo. Cuando esto ocurre, se reproduce el pitido. A continuación, el programa vuelve al inicio del bucle eterno y repite la operación.",
	"HELP_TEXT_SOUND_PLAY_NOTE_TITLE" : "reproducir una nota",
	"HELP_TEXT_SOUND_PLAY_NOTE_BODY_1" : "El bloque reproducir una nota reproduce una nota musical. Los parámetros del bloque permiten seleccionar la duración, la nota y el tipo de nota.",
	"HELP_TEXT_SOUND_PLAY_NOTE_BODY_2" : "El bloque tiene tres parámetros:",
	"HELP_TEXT_SOUND_PLAY_NOTE_BODY_3" : "Longitud - Hay cuatro opciones: entero, medio, cuarto y octavo.",
	"HELP_TEXT_SOUND_PLAY_NOTE_BODY_4" : "Nota - Hay diez opciones: Do, Si, La, Sol, Fa, Mi, Re, Do medio, Si grave y silencio.",
	"HELP_TEXT_SOUND_PLAY_NOTE_BODY_5" : "Modificador de nota - Hay tres opciones: - (no modificada), sostenido y bemol.",
	"HELP_TEXT_SOUND_PLAY_NOTE_BODY_6" : "El bloque tocar una nota debe completarse antes de que se ejecute el siguiente bloque. Por ejemplo, si utilizas el bloque reproducir una nota, no se ejecutarán otros bloques del programa al mismo tiempo. Para ello, consulta el bloque reproducir música en segundo plano.",
	"HELP_TEXT_SOUND_PLAY_NOTE_EXAMPLE_1_TITLE" : "Ejemplo de programa 1: María tenía un corderito",
	"HELP_TEXT_SOUND_PLAY_NOTE_EXAMPLE_1_BODY" : "En este ejemplo, el programa comienza estableciendo el tempo de las notas musicales y, a continuación, reproduce las notas de la canción infantil María tenía un corderito en orden, tocando cada nota completamente antes de pasar a la siguiente.",
	"HELP_TEXT_SOUND_SET_TEMPO_TITLE" : "poner el tempo de la música a",
	"HELP_TEXT_SOUND_SET_TEMPO_BODY_1" : "El bloque Establecer tempo de música establece el tempo al que se reproducen las notas siguientes.",
	"HELP_TEXT_SOUND_SET_TEMPO_BODY_2" : "Hay cinco opciones: muy lento, lento, medio, rápido y muy rápido.",
	"HELP_TEXT_SOUND_SET_TEMPO_EXAMPLE_1_TITLE" : "Ejemplo de programa 1: María tenía un corderito",
	"HELP_TEXT_SOUND_SET_TEMPO_EXAMPLE_1_BODY" : "En este ejemplo, el programa empieza estableciendo el tempo de las notas musicales y, a continuación, reproduce las notas de la canción infantil María tenía un corderito a esa velocidad, tocando cada nota completamente antes de pasar a la siguiente.",
	"HELP_TEXT_SOUND_PLAYINBACKGROUND_TITLE" : "Reproducir música en segundo plano",
	"HELP_TEXT_SOUND_PLAYINBACKGROUND_BODY_1" : "El bloque Reproducir música en segundo plano permite que las notas musicales colocadas dentro del bloque suenen mientras el robot Edison ejecuta otras partes del programa.",
	"HELP_TEXT_SOUND_PLAYINBACKGROUND_EXAMPLE_1_TITLE" : "Programa de ejemplo 1: María tenía un corderito mientras bailaba",
	"HELP_TEXT_SOUND_PLAYINBACKGROUND_EXAMPLE_1_BODY" : "En este programa de ejemplo, el programa comienza estableciendo el tempo de las notas musicales, después empiezan a sonar las notas dentro del bloque reproducir música de fondo, el programa entra en el bucle de repetición y los bloques girar a la izquierda y girar a la derecha se ejecutan cuatro veces con la melodía aún sonando de fondo. Esto hace que Edison baile mientras suena la música.",
	"HELP_TEXT_VARIABLE_TITLE" : "Variable",
	"HELP_TEXT_VARIABLE_BODY_1" : "Un bloque variable es un lugar donde se pueden almacenar datos y ser utilizados por un programa. Los datos de una variable pueden variar y cambiar mientras se ejecuta el programa. Por eso se llama variable.",
	"HELP_TEXT_VARIABLE_BODY_2" : "Los datos de una variable son un número que puede oscilar entre -1.073.741.824 y 1.073.741.823 (32 bits con signo).",
	"HELP_TEXT_VARIABLE_BODY_3" : "Las variables deben personalizarse dándoles un nombre que tenga sentido para el programa. Por ejemplo:",
	"HELP_TEXT_VARIABLE_BODY_4" : "Si el número de una variable supera el intervalo de -1.073.741.824 a 1.073.741.823, el programa se detendrá y Edison emitirá un tono de error.",
	"HELP_TEXT_VARIABLE_EXAMPLE_1_TITLE" : "Programa de ejemplo 1: Una velocidad de parpadeo aleatoria fijada al inicio del programa",
	"HELP_TEXT_VARIABLE_EXAMPLE_1_BODY_1" : "En este programa de ejemplo, la variable ''FlashRate'' se establece en un número aleatorio entre 10 y 100. A continuación, el programa entra en un bucle eterno. Dentro del bucle, se encienden los LED izquierdo y derecho, luego el programa espera el valor en milisegundos de ''FlashRate'', luego apaga los LED izquierdo y derecho, luego el programa vuelve a esperar el valor en milisegundos de ''FlashRate''. A continuación, el programa vuelve al principio del bucle ''para siempre'' y repite la operación. Esto hace que Edison haga parpadear sus LEDs a velocidades diferentes cada vez que se ejecuta el programa",
	"HELP_TEXT_VARIABLE_EXAMPLE_2_TITLE" : "Programa de ejemplo 2: Contar las líneas negras recorridas",
	"HELP_TEXT_VARIABLE_EXAMPLE_2_BODY_1" : "En este programa de ejemplo, primero se enciende el LED del seguidor de líneas y, a continuación, el robot Edison avanza 30 cm a velocidad 5. Mientras avanza, cualquier superficie no reflectante (negra) que detecte el seguidor de líneas hará que el programa salte al bloque de eventos Seguidor de líneas en superficie no reflectante. Cuando esto ocurre, la variable ''Recuento de líneas'' se incrementa (+1). Cuando se ha completado el recorrido de 30 cm, el programa repite los bloques de espera de 1 segundo y pitido el número de veces de la variable 'LineCount'.",
	"HELP_TEXT_VARIABLE_EXAMPLE_3_TITLE" : "Programa de ejemplo 3: Contador de radiación luminosa",
	"HELP_TEXT_VARIABLE_EXAMPLE_3_BODY_1" : "En este programa de ejemplo, primero se ajusta el tempo de la música a muy rápido. A continuación, el programa entra en un bucle eterno. Dentro del bucle, el programa establece la variable 'Retardo' en 1000 menos el nivel de luz izquierdo (invirtiendo la lectura del nivel de luz). El siguiente bloque espera el valor de la variable ''Retardo''. A continuación, el programa toca la nota C y vuelve al inicio del bucle eterno y repite. El resultado de este programa es que Edison emitirá un pitido lento cuando esté a oscuras y más rápido cuando el nivel de luz sea más brillante.",
	"HELP_TEXT_DATA_SETVARIABLETO_TITLE" : "establecer a",
	"HELP_TEXT_DATA_SETVARIABLETO_BODY_1" : "El bloque establecer en se utiliza para establecer un valor en una variable.",
	"HELP_TEXT_DATA_SETVARIABLETO_BODY_2" : "Tiene dos entradas:",
	"HELP_TEXT_DATA_SETVARIABLETO_BODY_3" : "Variable - Aquí se coloca el bloque variable.",
	"HELP_TEXT_DATA_SETVARIABLETO_BODY_4" : "Valor - Puede ser una constante (se teclea en la entrada y no varía), una variable, un sensor o un bloque operador.",
	"HELP_TEXT_DATA_SETVARIABLETO_EXAMPLE_1_TITLE" : "Programa de ejemplo 1: Establecer el número de pitidos",
	"HELP_TEXT_DATA_SETVARIABLETO_EXAMPLE_1_BODY_1" : "En este programa de ejemplo, la variable ''NúmeroDePitidos'' se establece en 5, entonces el bloque de repetición repite los pitidos para el valor 5 mantenido en la variable ''NúmeroDePitidos''.",
	"HELP_TEXT_DATA_SETVARIABLETO_EXAMPLE_2_TITLE" : "Programa de ejemplo 2: Una velocidad de parpadeo aleatoria fijada al inicio del programa",
	"HELP_TEXT_DATA_SETVARIABLETO_EXAMPLE_2_BODY_1" : "En este programa de ejemplo, la variable ''FlashRate'' se establece en un número aleatorio entre 10 y 1000. A continuación, el programa entra en un bucle eterno. Dentro del bucle, se encienden los LED izquierdo y derecho, luego el programa espera el valor en milisegundos de ''FlashRate'', luego apaga los LED izquierdo y derecho, luego el programa vuelve a esperar el valor en milisegundos de ''FlashRate''. A continuación, el programa vuelve al principio del bucle ''para siempre'' y repite la operación. Esto hace que Edison haga parpadear sus LEDs a velocidades diferentes cada vez que se ejecuta el programa",
	"HELP_TEXT_DATA_SETVARIABLETO_EXAMPLE_3_TITLE" : "Programa de ejemplo 3: Sigue la luz",
	"HELP_TEXT_DATA_SETVARIABLETO_EXAMPLE_3_BODY_1" : "En este ejemplo, el programa comienza entrando en un bucle eterno. Dentro del bucle, el programa establece la variable ''LuzIzquierdavsDerecha'' en el nivel de luz izquierdo menos el nivel de luz derecho. A continuación, el bloque if else comprueba si el valor de la variable ''LuzIzquierdavsDerecha'' es mayor que 0. Si el resultado es verdadero, el motor derecho se pone en marcha hacia delante y el motor izquierdo se para. Si el resultado es falso, el motor izquierdo se pone en marcha y el motor derecho se para. A continuación, el programa vuelve al principio del bucle ''para siempre'' y repite la operación. El resultado es que Edison se dirige hacia la fuente de luz más brillante.",
	"HELP_TEXT_DATA_INCVARIABLE_TITLE" : "incrementar",
	"HELP_TEXT_DATA_INCVARIABLE_BODY_1" : "El bloque de incremento incrementa (añade 1) a la variable colocada en el bloque.",
	"HELP_TEXT_DATA_INCVARIABLE_EXAMPLE_1_TITLE" : "Programa de ejemplo 1: Desaceleración del parpadeo",
	"HELP_TEXT_DATA_INCVARIABLE_EXAMPLE_1_BODY_1" : "En este programa de ejemplo, la variable ''Retardo'' se pone a 0 y el programa entra en un bucle eterno. Dentro del bucle, la variable 'Retardo' se incrementa (+1), luego se enciende el LED derecho y se apaga el LED izquierdo, después el programa espera el valor de la variable 'Retardo' en milisegundos, luego se apaga el LED derecho y se enciende el LED izquierdo y, de nuevo, el programa espera el valor de la variable 'Retardo' en milisegundos. A continuación, el programa vuelve al inicio del bucle para siempre y repite. A medida que el programa repite el bucle para siempre, la variable 'Retardo' se incrementa cada vez haciendo que el tiempo que los LEDs pasan encendidos y apagados sea cada vez mayor. Después de 1.000 bucles, el tiempo que los LED están encendidos es de un segundo y el tiempo que están apagados es de un segundo.",
	"HELP_TEXT_DATA_DECVARIABLE_TITLE" : "disminuir",
	"HELP_TEXT_DATA_DECVARIABLE_BODY_1" : "El bloque decremento decrementa (menos 1) a la variable colocada en el bloque.",
	"HELP_TEXT_DATA_DECVARIABLE_EXAMPLE_1_TITLE" : "Programa de ejemplo 1: Acelerar el parpadeo",
	"HELP_TEXT_DATA_DECVARIABLE_EXAMPLE_1_BODY_1" : "En este programa de ejemplo, la variable 'Retardo' se establece en 100 y el programa entra en un bucle eterno. Dentro del bucle se decrementa la variable 'Retardo' (-1), luego se enciende el LED derecho y se apaga el LED izquierdo, después el programa espera el valor de la variable 'Retardo' en milisegundos, luego se apaga el LED derecho y se enciende el LED izquierdo y, de nuevo, el programa espera el valor de la variable 'Retardo' en milisegundos. A continuación, el programa vuelve al inicio del bucle para siempre y repite. A medida que el programa se repite a través del bucle para siempre, la variable 'Retardo' se va reduciendo cada vez, haciendo que el tiempo que los LEDs pasan encendidos y apagados sea menor. Después de 100 bucles, el tiempo que los LEDs están encendidos es de un milisegundo y el tiempo que los LEDs están apagados es de un milisegundo.",
	"HELP_TEXT_BIT_SHIFT_RIGHT_TITLE" : "desplazamiento de bits a la derecha",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_1" : "El desplazamiento de bits a la derecha por bloque ajusta matemáticamente el bloque variable conectado en su forma binaria desplazando los bits a la derecha por el valor establecido.",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_2" : "El formato numérico que utilizan los ordenadores se llama binario. Es un sistema numérico que sólo se compone de los números 0 y 1. Cada número dentro de un ordenador es una cadena de 1s y 0s. Aquí tienes algunos ejemplos de números binarios de 8 bits:",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_HUMAN" : "Humano/decimal",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_COMPUTER" : "Binario de ordenador/8 bits",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_3" : "Aquí tienes algunos ejemplos de números binarios de 32 bits:",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_4" : "Edison V3 utiliza números binarios de 8 y 32 bits. Por ejemplo, los bloques de variables pueden almacenar números grandes de 32 bits (en realidad con signo de 31 bits), pero sólo se pueden enviar números de 8 bits a través del bloque de envío de mensajes IR. Además, algunos sensores, como los de luz, tienen un rango de 1 a 1000. Como el mayor número posible de 8 bits es 255, no se puede enviar todo el rango de lectura del sensor de luz a través del bloque de envío de mensajes IR. ¡Aquí es donde el bloque de desplazamiento de bits a la derecha puede ayudar!",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_5" : "La lectura del sensor de luz es binaria de 10 bits. Estos son los valores mínimo y máximo:",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_6" : "Si se enviara el número 1000 con el bloque de envío de mensajes IR, el número recibido sólo serían los últimos 8 bits. Sería 11111010 (binario) o 232 (humano/decimal). Se trata de un número muy diferente a la lectura real de luz de 1000.",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_7" : "Para enviar los datos del nivel de luz a través del bloque de envío de mensajes IR, se puede utilizar el bloque de desplazamiento de bits a la derecha para acortar el número y convertirlo en un número de 8 bits (desplazamiento a la derecha en 2) sin perder demasiados datos. Luego, en el extremo receptor, se puede utilizar el bloque de desplazamiento de bits a la izquierda para restaurar la lectura del nivel de luz a 10 bits (desplazamiento a la izquierda de 2 en 2).",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_4_LINE_1_BOX_1" : "Etapa",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_4_LINE_2_BOX_1" : "Lectura de luz",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_4_LINE_3_BOX_1" : "Desplazamiento de bits a la derecha (2)",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_4_LINE_4_BOX_1" : "Envío/recepción de datos IR",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_4_LINE_5_BOX_1" : "Desplazamiento de bits a la izquierda (2)",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_BIT" : "bit",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_8" : "En este caso, el número resultante no es perfectamente el mismo, ya que se ha perdido algo de información. Sin embargo, los bits más significativos, que contienen más del 99% de los datos originales, se han conservado mediante este proceso.",
	"HELP_TEXT_BIT_SHIFT_LEFT_TITLE" : "desplazamiento de bits a la izquierda",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_1" : "El desplazamiento de bits a la izquierda por bloque ajusta matemáticamente el bloque variable conectada en su forma binaria desplazando los bits a la izquierda por el valor establecido.",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_2" : "El formato numérico que utilizan los ordenadores se llama binario. Es un sistema numérico que sólo se compone de los números 0 y 1. Cada número dentro de un ordenador es una cadena de 1s y 0s. Aquí tienes algunos ejemplos de números binarios de 8 bits:",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_HUMAN" : "Humano/decimal",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_COMPUTER" : "Binario de ordenador/8 bits",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_3" : "Aquí tienes algunos ejemplos de números binarios de 32 bits:",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_4" : "Edison V3 utiliza números binarios de 8 y 32 bits. Por ejemplo, los bloques de variables pueden almacenar números grandes de 32 bits (en realidad con signo de 31 bits), pero sólo se pueden enviar números de 8 bits a través del bloque de envío de mensajes IR. Además, algunos sensores, como los de luz, tienen un rango de 1 a 1000. Como el mayor número posible de 8 bits es 255, no se puede enviar todo el rango de lectura del sensor de luz a través del bloque de envío de mensajes IR. ¡Aquí es donde el bloque de desplazamiento de bits a la derecha puede ayudar!",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_5" : "La lectura del sensor de luz es binaria de 10 bits. Estos son los valores mínimo y máximo:",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_6" : "Si se enviara el número 1000 con el bloque de envío de mensajes IR, el número recibido sólo serían los últimos 8 bits. Sería 11111010 (binario) o 232 (humano/decimal). Se trata de un número muy diferente a la lectura real de luz de 1000.",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_7" : "Para enviar los datos del nivel de luz a través del bloque de envío de mensajes IR, se puede utilizar el bloque de desplazamiento de bits a la derecha para acortar el número y convertirlo en un número de 8 bits (desplazamiento a la derecha en 2) sin perder demasiados datos. Luego, en el extremo receptor, se puede utilizar el bloque de desplazamiento de bits a la izquierda para restaurar la lectura del nivel de luz a 10 bits (desplazamiento a la izquierda de 2 en 2).",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_4_LINE_1_BOX_1" : "Etapa",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_4_LINE_2_BOX_1" : "Lectura de luz",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_4_LINE_3_BOX_1" : "Desplazamiento de bits a la derecha (2)",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_4_LINE_4_BOX_1" : "Envío/recepción de datos IR",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_4_LINE_5_BOX_1" : "Desplazamiento de bits a la izquierda (2)",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_BIT" : "bit",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_8" : "En este caso, el número resultante no es perfectamente el mismo, ya que se ha perdido algo de información. Sin embargo, los bits más significativos, que contienen más del 99% de los datos originales, se han conservado mediante este proceso.",
	"HELP_TEXT_EVENT_ANYOBSTACLE_TITLE" : "Cualquier obstáculo detectado",
	"HELP_TEXT_EVENT_ANYOBSTACLE_BODY_1" : "El bloque de evento Cualquier obstáculo detectado hace que el programa salte a este bloque cuando el detector de obstáculos detecta cualquier obstáculo.",
	"HELP_TEXT_EVENT_ANYOBSTACLE_BODY_2" : "Asegúrate siempre de que el haz del detector de obstáculos está encendido en el programa principal.",
	"HELP_TEXT_EVENT_ANYOBSTACLE_EXAMPLE_1_TITLE" : "Programa de ejemplo 1: Pitar cuando se detecta cualquier obstáculo.",
	"HELP_TEXT_EVENT_ANYOBSTACLE_EXAMPLE_1_BODY_1" : "En este programa de ejemplo, primero se enciende el detector de obstáculos y, a continuación, el programa entra en el bloque del bucle ''para siempre''. Cuando se detecta cualquier obstáculo, el programa salta del bucle eterno y pasa al bloque de evento Cualquier obstáculo detectado. Esto hace que se ejecute el bloque de pitido y que el robot Edison emita un pitido. A continuación, el programa vuelve al punto donde lo dejó en el programa principal.",
	"HELP_TEXT_EVENT_ANYOBSTACLE_EXAMPLE_2_TITLE" : "Programa de ejemplo 2: Detener la marcha cuando hay un obstáculo",
	"HELP_TEXT_EVENT_ANYOBSTACLE_EXAMPLE_2_BODY_1" : "En este programa de ejemplo, primero se activa el detector de obstáculos, después se ajustan ambos motores para que avancen a velocidad 5, y a continuación el programa entra en el bloque bucle para siempre. Cuando se detecta cualquier obstáculo, el programa salta del bucle eterno y pasa al bloque de evento Cualquier obstáculo detectado. Esto hace que se ejecute el bloque de parada de ambos motores y detiene la marcha de ambos motores. A continuación, el programa vuelve al punto donde lo dejó en el programa principal.",
	"HELP_TEXT_EVENT_ANYOBSTACLE_EXAMPLE_3_TITLE" : "Programa de ejemplo 3: Evitar obstáculos",
	"HELP_TEXT_EVENT_ANYOBSTACLE_EXAMPLE_3_BODY_1" : "En este programa de ejemplo, primero se activa el detector de obstáculos, luego el programa entra en un bucle infinito, dentro del bucle ambos motores están configurados para avanzar a velocidad 5. Cuando se detecta cualquier obstáculo, el programa salta del bucle infinito y va al bloque de evento Cualquier obstáculo detectado. Los bloques bajo el bloque de evento Cualquier obstáculo detectado hacen retroceder a la Edison 1 cm a velocidad 1, y luego giran a la izquierda 120 grados a velocidad 1. A continuación, el programa vuelve al punto donde lo dejó en el bucle eterno y ambos motores se configuran para avanzar a velocidad 5 de nuevo. Esto hace que Edison se aleje de los obstáculos que encuentra en su camino.",
	"HELP_TEXT_OBSTACLE_LEFT_EVENT_TITLE" : "Obstáculo detectado a la izquierda",
	"HELP_TEXT_OBSTACLE_LEFT_EVENT_BODY_1" : "El bloque de evento Obstáculo detectado a la izquierda hace que el programa salte a este bloque cuando el detector de obstáculos detecta un obstáculo a la izquierda.",
	"HELP_TEXT_OBSTACLE_LEFT_EVENT_BODY_2" : "Asegúrate siempre de que el haz del detector de obstáculos está encendido en el programa principal.",
	"HELP_TEXT_OBSTACLE_LEFT_EVENT_EXAMPLE_1_TITLE" : "Programa de ejemplo 1: Pitar cuando se detecta un obstáculo a la izquierda",
	"HELP_TEXT_OBSTACLE_LEFT_EVENT_EXAMPLE_1_BODY_1" : "En este programa de ejemplo, primero se activa el detector de obstáculos, después el programa entra en el bloque de bucle para siempre. Cuando se detecta un obstáculo a la izquierda, el programa salta del bucle eterno y pasa al bloque de eventos Obstáculo detectado a la izquierda. Esto hace que se ejecute el bloque de pitido y que el robot Edison emita un pitido. A continuación, el programa vuelve al punto donde lo dejó en el bloque de bucle eterno.",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_TITLE" : "Obstáculo detectado a la derecha",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_BODY_1" : "El bloque de evento Obstáculo detectado a la derecha hace que el programa salte a este bloque cuando el detector de obstáculos detecta un obstáculo a la derecha.",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_BODY_2" : "Asegúrate siempre de que el haz del detector de obstáculos está encendido en el programa principal.",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_1_TITLE" : "Programa de ejemplo 1: Pitar cuando se detecta un obstáculo a la derecha",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_1_BODY_1" : "En este programa de ejemplo, primero se activa el detector de obstáculos, después el programa entra en el bloque de bucle para siempre. Cuando se detecta un obstáculo a la derecha, el programa salta del bucle eterno y pasa al bloque de eventos Obstáculo detectado a la derecha. Esto hace que se ejecute el bloque de pitido y que el robot Edison emita un pitido. A continuación, el programa vuelve al punto donde lo dejó en el bloque de bucle eterno.",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_2_TITLE" : "Programa de ejemplo 2: Evasor de obstáculos",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_2_BODY_1" : "En este programa de ejemplo, primero se activa el detector de obstáculos, y después el programa entra en el bloque de bucle eterno. Cuando...",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_2_BODY_2" : "...se detecta un obstáculo delante, el programa salta al bloque de evento Obstáculo detectado delante y el robot Edison retrocede durante 0,25 segundos a velocidad 10 y luego vuelve al punto donde lo dejó en el bloque de bucle eterno.",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_2_BODY_3" : "...se detecta un obstáculo a la derecha el programa salta al bloque de eventos Obstáculo detectado a la derecha y el robot Edison gira hacia atrás a la izquierda durante 0,25 segundos a velocidad 10 y luego vuelve a donde lo dejó en el bloque de bucle eterno.",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_2_BODY_4" : "...se detecta un obstáculo a la izquierda, el programa salta al bloque de eventos Obstáculo detectado a la izquierda y el robot Edison gira a la derecha hacia atrás durante 0,25 segundos a velocidad 10 y luego vuelve al punto donde lo dejó en el bloque de bucle sin fin.",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_TITLE" : "Obstáculo detectado delante",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_BODY_1" : "El bloque de evento Obstáculo detectado delante hace que el programa salte a este bloque cuando el detector de obstáculos detecta un obstáculo delante. Esto significa que, al mismo tiempo, tanto el detector de obstáculos izquierdo como el derecho han detectado un obstáculo.",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_BODY_2" : "Asegúrate siempre de que el haz del detector de obstáculos está encendido en el programa principal.",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_1_TITLE" : "Programa de ejemplo 1: Pitido cuando se detecta un obstáculo delante",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_1_BODY_1" : "En este programa de ejemplo, primero se activa el detector de obstáculos, después el programa entra en el bloque de bucle para siempre. Cuando se detecta un obstáculo a la derecha, el programa salta del bucle eterno y pasa al bloque de eventos Obstáculo detectado a la derecha. Esto hace que se ejecute el bloque de pitido y que el robot Edison emita un pitido. A continuación, el programa vuelve al punto donde lo dejó en el bloque de bucle eterno.",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_2_TITLE" : "Programa de ejemplo 2: El evasor de obstáculos",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_2_BODY_1" : "En este programa de ejemplo, primero se activa el detector de obstáculos, y después el programa entra en el bloque de bucle eterno. Cuando...",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_2_BODY_2" : "...se detecta un obstáculo delante, el programa salta al bloque de evento Obstáculo detectado delante y el robot Edison retrocede durante 0,25 segundos a velocidad 10 y luego vuelve al punto donde lo dejó en el bloque de bucle eterno.",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_2_BODY_3" : "...se detecta un obstáculo a la derecha el programa salta al bloque de eventos Obstáculo detectado a la derecha y el robot Edison gira hacia atrás a la izquierda durante 0,25 segundos a velocidad 10 y luego vuelve a donde lo dejó en el bloque de bucle eterno.",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_2_BODY_4" : "...se detecta un obstáculo a la izquierda, el programa salta al bloque de eventos Obstáculo detectado a la izquierda y el robot Edison gira a la derecha hacia atrás durante 0,25 segundos a velocidad 10 y luego vuelve al punto donde lo dejó en el bloque de bucle sin fin.",
	"HELP_TEXT_CLAP_EVENT_TITLE" : "Aplauso detectado",
	"HELP_TEXT_CLAP_EVENT_BODY_1" : "El bloque de evento Clap detectado hace que el programa salte a este bloque cuando se detecta un clap.",
	"HELP_TEXT_CLAP_EVENT_BODY_2" : "Cuando Edison está conduciendo, el ruido del motor y los golpes hacen que se active el sensor de aplausos, por lo que es mejor no utilizar el sensor de aplausos cuando se está conduciendo. Además, si es probable que haya detecciones de ruido falsas o no deseadas, los datos del sensor de aplausos se pueden borrar con el bloque borrar datos del sensor ajustado a detector de aplausos (ver programa de ejemplo).",
	"HELP_TEXT_CLAP_EVENT_EXAMPLE_1_TITLE" : "Programa de ejemplo: Edison tiene miedo a los ruidos fuertes",
	"HELP_TEXT_CLAP_EVENT_EXAMPLE_1_BODY_1" : "En este ejemplo, el programa comienza entrando en un bucle vacío ''para siempre'' y no ocurre nada. Cuando se detecta una palmada (u otro sonido fuerte que asuste), el programa salta del bucle eterno y pasa al bloque de evento Detectado palmada. A continuación, los bloques situados por debajo del bloque de evento detectado Clap se ejecutan, retrocediendo 5 cm a velocidad 10 (salta del susto), y luego entran en un bucle de repetición configurado 25 veces en el que los bloques girar a la izquierda y girar a la derecha se ejecutan repetidamente haciendo que la Edison vibre (tiemble del susto). Por último, (cuando la Edison se recupera del susto) el bloque borrar datos del sensor borra las falsas detecciones de palmadas que se hayan podido producir durante la conducción. El programa vuelve ahora al bucle eterno.",
	"HELP_TEXT_TRIANGLEBUTTON_EVENT_TITLE" : "Botón triángulo pulsado",
	"HELP_TEXT_TRIANGLEBUTTON_EVENT_BODY_1" : "El bloque de evento Botón triángulo pulsado hace que el programa salte a este bloque cuando se pulsa el botón triángulo.",
	"HELP_TEXT_TRIANGLEBUTTON_EVENT_EXAMPLE_1_TITLE" : "Ejemplo de programa: Control de la velocidad de destello del LED mediante botones",
	"HELP_TEXT_TRIANGLEBUTTON_EVENT_EXAMPLE_1_BODY_1" : "En este ejemplo, el programa comienza estableciendo la variable llamada 'Retardo' en 100, el programa entra entonces en un bucle eterno. Dentro del bucle eterno, los LEDs izquierdo y derecho se encienden y apagan con una espera del valor de la variable 'Retardo' en milisegundos. El resultado es que los LED se encienden durante 100 milisegundos (0,1 segundos) y se apagan durante 100 milisegundos (0,1 segundos).",
	"HELP_TEXT_TRIANGLEBUTTON_EVENT_EXAMPLE_1_BODY_2" : "Cuando se pulsa el botón triángulo, el programa salta al bloque de eventos Botón triángulo pulsado. A continuación, se ejecutan los bloques situados por debajo del bloque de evento Botón triángulo pulsado, estableciendo la variable llamada ''Retardo'' en 50 y, a continuación, reproduciendo un pitido. El programa vuelve entonces al bucle eterno, pero ahora el valor de la variable llamada ''Retardo'' es 50, por lo que el tiempo entre el encendido y el apagado de los LEDs es ahora de 50 milisegundos (0,05 segundos). Esto hace que se enciendan y apaguen más rápidamente.",
	"HELP_TEXT_TRIANGLEBUTTON_EVENT_EXAMPLE_1_BODY_3" : "Cuando se pulsa el botón redondo, el programa salta al bloque de eventos Botón redondo pulsado. A continuación, se ejecutan los bloques situados debajo del bloque de evento Botón redondo pulsado, estableciendo la variable llamada ''Retraso'' en 200 y reproduciendo un pitido. A continuación, el programa vuelve al bucle eterno, pero ahora el valor de la variable llamada ''Retardo'' es 200, por lo que el tiempo entre el encendido y el apagado de los LEDs es ahora de 200 milisegundos (0,2 segundos). Esto hace que se enciendan y apaguen más lentamente.",
	"HELP_TEXT_ROUNDBUTTON_EVENT_TITLE" : "Botón redondo pulsado",
	"HELP_TEXT_ROUNDBUTTON_EVENT_BODY_1" : "El bloque de eventos Botón redondo pulsado hace que el programa salte a este bloque cuando se pulsa el botón redondo.",
	"HELP_TEXT_ROUNDBUTTON_EVENT_EXAMPLE_1_TITLE" : "Ejemplo de programa: Control de la velocidad de destello del LED mediante botones",
	"HELP_TEXT_ROUNDBUTTON_EVENT_EXAMPLE_1_BODY_1" : "En este ejemplo, el programa comienza estableciendo la variable llamada 'Retardo' en 100, el programa entra entonces en un bucle eterno. Dentro del bucle eterno, los LEDs izquierdo y derecho se encienden y apagan con una espera del valor de la variable 'Retardo' en milisegundos. El resultado es que los LED se encienden durante 100 milisegundos (0,1 segundos) y se apagan durante 100 milisegundos (0,1 segundos).",
	"HELP_TEXT_ROUNDBUTTON_EVENT_EXAMPLE_1_BODY_2" : "Cuando se pulsa el botón triángulo, el programa salta al bloque de eventos Botón triángulo pulsado. A continuación, se ejecutan los bloques situados por debajo del bloque de evento Botón triángulo pulsado, estableciendo la variable llamada ''Retardo'' en 50 y, a continuación, reproduciendo un pitido. El programa vuelve entonces al bucle eterno, pero ahora el valor de la variable llamada ''Retardo'' es 50, por lo que el tiempo entre el encendido y el apagado de los LEDs es ahora de 50 milisegundos (0,05 segundos). Esto hace que se enciendan y apaguen más rápidamente.",
	"HELP_TEXT_ROUNDBUTTON_EVENT_EXAMPLE_1_BODY_3" : "Cuando se pulsa el botón redondo, el programa salta al bloque de eventos Botón redondo pulsado. A continuación, se ejecutan los bloques situados debajo del bloque de evento Botón redondo pulsado, estableciendo la variable llamada ''Retraso'' en 200 y reproduciendo un pitido. A continuación, el programa vuelve al bucle eterno, pero ahora el valor de la variable llamada ''Retardo'' es 200, por lo que el tiempo entre el encendido y el apagado de los LEDs es ahora de 200 milisegundos (0,2 segundos). Esto hace que se enciendan y apaguen más lentamente.",
	"HELP_TEXT_LINEREFLECTIVE_EVENT_TITLE" : "Seguidor de línea en superficie reflectante",
	"HELP_TEXT_LINEREFLECTIVE_EVENT_BODY_1" : "El bloque de evento Seguidor de línea en superficie reflectante hace que el programa salte a este bloque cuando el sensor del seguidor de línea detecta un cambio de una superficie no reflectante (es decir, negra) a una superficie reflectante (es decir, blanca).",
	"HELP_TEXT_LINEREFLECTIVE_EVENT_BODY_2" : "El LED del seguidor de línea debe estar encendido para que funcione el bloque de eventos Seguidor de línea en superficie reflectante.",
	"HELP_TEXT_LINEREFLECTIVE_EVENT_EXAMPLE_1_TITLE" : "Ejemplo de programa: Seguir el borde de una línea",
	"HELP_TEXT_LINEREFLECTIVE_EVENT_EXAMPLE_1_BODY_1" : "En este ejemplo, el programa comienza encendiendo el LED de seguimiento de línea, a continuación el programa hace que el robot gire a la derecha (buscando el borde de una línea).",
	"HELP_TEXT_LINEREFLECTIVE_EVENT_EXAMPLE_1_BODY_2" : "Cuando el seguidor de línea detecta un cambio de una superficie reflectante (blanca) a una no reflectante (negra), el programa salta al bloque Seguidor de línea en superficie no reflectante y ejecuta el bloque de accionamiento para que el robot gire a la izquierda (girando de nuevo hacia la superficie reflectante (blanca)).",
	"HELP_TEXT_LINEREFLECTIVE_EVENT_EXAMPLE_1_BODY_3" : "Cuando el seguidor de líneas detecta un cambio de una superficie no reflectante a una reflectante, el programa salta al bloque de eventos Seguidor de líneas en superficie reflectante y ejecuta el bloque de accionamiento para que el robot gire a la derecha (volviendo hacia la superficie no reflectante (negra)).",
	"HELP_TEXT_LINEREFLECTIVE_EVENT_EXAMPLE_1_BODY_4" : "Cada vez que el robot gira a la izquierda o a la derecha, avanza siguiendo el borde de la línea.",
	"HELP_TEXT_LINENONREFLECTIVE_EVENT_TITLE" : "Seguidor de línea en superficie no reflectante",
	"HELP_TEXT_LINENONREFLECTIVE_EVENT_BODY_1" : "El bloque de eventos Seguimiento de línea en superficie no reflectante hace que el programa salte a este bloque cuando el sensor de seguimiento de línea detecta un cambio de una superficie reflectante (es decir, blanca) a una superficie no reflectante (es decir, negra).",
	"HELP_TEXT_LINENONREFLECTIVE_EVENT_BODY_2" : "El LED del seguidor de línea debe estar encendido para que funcione el bloque de eventos Seguidor de línea en superficie no reflectante.",
	"HELP_TEXT_LINENONREFLECTIVE_EVENT_EXAMPLE_1_TITLE" : "Ejemplo de programa: Seguir el borde de una línea",
	"HELP_TEXT_LINENONREFLECTIVE_EVENT_EXAMPLE_1_BODY_1" : "En este ejemplo, el programa comienza encendiendo el LED de seguimiento de línea, a continuación el programa hace que el robot gire a la derecha (buscando el borde de una línea).",
	"HELP_TEXT_LINENONREFLECTIVE_EVENT_EXAMPLE_1_BODY_2" : "Cuando el seguidor de línea detecta un cambio de una superficie reflectante (blanca) a una no reflectante (negra), el programa salta al bloque Seguidor de línea en superficie no reflectante y ejecuta el bloque de accionamiento para que el robot gire a la izquierda (girando de nuevo hacia la superficie reflectante (blanca)).",
	"HELP_TEXT_LINENONREFLECTIVE_EVENT_EXAMPLE_1_BODY_3" : "Cuando el seguidor de línea detecta un cambio de una superficie no reflectante a una reflectante, el programa salta al bloque Seguidor de línea en superficie reflectante y ejecuta el bloque de accionamiento para que el robot gire a la derecha (volviendo hacia la superficie no reflectante (negra)).",
	"HELP_TEXT_LINENONREFLECTIVE_EVENT_EXAMPLE_1_BODY_4" : "Cada vez que el robot gira a la izquierda o a la derecha, avanza siguiendo el borde de la línea.",
	"HELP_TEXT_LINECHANGE_EVENT_TITLE" : "El seguidor de línea cambia de superficie",
	"HELP_TEXT_LINECHANGE_EVENT_BODY_1" : "El bloque de eventos El seguidor de línea cambia de superficie hace que el programa salte a este bloque cuando el sensor del seguidor de línea detecta un cambio de una superficie no reflectante (es decir, negra) a una superficie reflectante (es decir, blanca) o un cambio de una superficie reflectante (es decir, blanca) a una superficie no reflectante (es decir, negra).",
	"HELP_TEXT_LINECHANGE_EVENT_BODY_2" : "El LED del seguidor de línea debe estar encendido para que funcione el bloque de eventos El seguidor de línea cambia de superficie.",
	"HELP_TEXT_LINECHANGE_EVENT_EXAMPLE_1_TITLE" : "Ejemplo de programa: Parada por cambio",
	"HELP_TEXT_LINECHANGE_EVENT_EXAMPLE_1_BODY_1" : "En este ejemplo, el programa comienza encendiendo el LED de seguimiento de línea, el robot avanza a velocidad 1 y entra en un bucle eterno. El robot seguirá avanzando hasta que el sensor de seguimiento de líneas detecte un cambio en la reflectividad de la superficie (de blanco a negro o de negro a blanco). Cuando esto ocurre, el programa salta al bloque El seguidor de líneas cambia la superficie. A continuación, se ejecuta el código que hay debajo del bloque El seguidor de líneas cambia de superficie, que detiene ambos motores, emite un pitido, espera 1 segundo, vuelve a emitir un pitido y, a continuación, activa ambos motores para que vuelvan a avanzar.",
	"HELP_TEXT_MESSAGE_EVENT_TITLE" : "Mensaje IR recibido",
	"HELP_TEXT_MESSAGE_EVENT_BODY_1" : "El bloque de eventos Mensaje de infrarrojos recibido hace que el programa salte a este bloque cuando se recibe un mensaje de infrarrojos (IR) de otro robot Edison.",
	"HELP_TEXT_MESSAGE_EVENT_BODY_3" : "El bloque de eventos Mensaje de infrarrojos recibido no funcionará cuando el receptor de infrarrojos se utilice para detectar obstáculos.",
	"HELP_TEXT_MESSAGE_EVENT_BODY_4" : "El programa saltará al bloque de eventos Mensaje IR recibido cuando se reciba cualquier mensaje IR de otro robot Edison. El bloque de eventos Mensaje IR recibido no descodifica los datos del mensaje IR. La descodificación del mensaje requiere que los datos del mensaje se introduzcan en una variable y luego se descodifiquen mediante un bloque if then.",
	"HELP_TEXT_MESSAGE_EVENT_EXAMPLE_1_TITLE" : "Ejemplo de programa: Recibir un mensaje IR para que suene una o dos veces",
	"HELP_TEXT_MESSAGE_EVENT_EXAMPLE_1_BODY_1" : "En este ejemplo, el programa comienza entrando en un bucle vacío ''para siempre'' y no ocurre nada. Cuando se recibe un mensaje IR, el programa salta al bloque de evento Mensaje IR recibido. A continuación, se ejecuta el código que hay debajo del bloque de eventos Mensaje IR recibido. Primero se almacenan los datos del mensaje recibido en la variable 'MensajeRecibido'. Esto es necesario porque cada vez que se leen los datos del mensaje IR recibido, también se borran. Ahora que los datos del mensaje están en una variable, se comprueba si es igual a 1; si es verdadero, se reproduce una vez el bloque de pitidos. A continuación, se comprueba si la variable es igual a 2; si es verdadero, el bloque de pitidos se reproduce dos veces. Ahora el programa vuelve al bucle ''para siempre''.",
	"HELP_TEXT_MESSAGE_EVENT_EXAMPLE_2_TITLE" : "Programa de envío de mensajes IR:",
	"HELP_TEXT_MESSAGE_EVENT_EXAMPLE_2_BODY_1" : "El programa anterior se utiliza en el robot Edison que envía el mensaje IR. El programa entra primero en un bucle eterno vacío. Cuando se pulsa el botón triángulo, el programa salta al bloque de eventos Botón triángulo pulsado y se envía un mensaje IR con el número 1. Cuando se pulsa el botón redondo, el programa salta al bloque de eventos Botón redondo pulsado y se envía un mensaje IR con el número 2.",
	"HELP_TEXT_DRIVESTRAIN_EVENT_TITLE" : "Accionamiento forzado",
	"HELP_TEXT_DRIVESTRAIN_EVENT_BODY_1" : "El bloque de eventos Accionamiento bajo tensión hace que el programa salte a este bloque cuando uno o ambos motores están siendo accionados, pero no pueden girar (bajo tensión).",
	"HELP_TEXT_DRIVESTRAIN_EVENT_EXAMPLE_1_TITLE" : "Ejemplo de programa: Alarma cuando la rueda izquierda no puede girar",
	"HELP_TEXT_DRIVESTRAIN_EVENT_EXAMPLE_1_BODY_1" : "En este ejemplo, el programa comienza ajustando el motor izquierdo para que gire hacia delante, y luego entra en un bucle eterno. Cuando la rueda no puede girar porque está sometida a tensión, el programa salta al bloque de evento Accionamiento forzado y ejecuta el código que aparece a continuación. El código que hay debajo del bloque de evento Tracción forzada es el bloque de pitido que reproduce un pitido. A continuación, el programa vuelve al bucle ''para siempre''.",
	"HELP_TEXT_REMOTE_EVENT_TITLE" : "Código remoto recibido",
	"HELP_TEXT_REMOTE_EVENT_BODY_1" : "El bloque de evento Código remoto recibido hace que el programa salte a este bloque cuando se recibe un código de control remoto.",
	"HELP_TEXT_REMOTE_EVENT_BODY_3" : "Asegúrate de pulsar el botón triángulo para iniciar el programa. Esto es fácil de olvidar, ya que el robot Edison responderá como un robot teledirigido y no hará lo que le hayas programado.",
	"HELP_TEXT_REMOTE_EVENT_BODY_4" : "Para utilizar los bloques del mando a distancia, primero hay que enseñar al robot Edison qué botones de tu mando a distancia corresponden a qué código remoto. Aprende más sobre esto aquí:",
	"HELP_TEXT_REMOTE_EVENT_BODY_5" : "Si el programa se comporta de forma inesperada, puede que tengas que utilizar el bloque borrar datos del sensor para borrar el contenido del bloque código remoto recibido. Consulta el programa de ejemplo 1 a continuación.",
	"HELP_TEXT_REMOTE_EVENT_BODY_6" : "La recepción de códigos de mando a distancia por infrarrojos funcionará con aproximadamente el 90% de los mandos a distancia de TV estándar, aunque cada marca utiliza formatos de datos ligeramente diferentes. Al descodificar los datos, esto puede provocar comportamientos inesperados de una marca de mando a distancia a otra. La descodificación avanzada de mandos a distancia funciona mejor con el EdRemote (disponible a mediados de 2025).",
	"HELP_TEXT_REMOTE_EVENT_EXAMPLE_1_TITLE" : "Ejemplo de programa: Avanzar o retroceder con el mando a distancia",
	"HELP_TEXT_REMOTE_EVENT_EXAMPLE_1_BODY" : "En este ejemplo, el programa comienza introduciendo un bucle vacío ''para siempre''. Cuando se recibe un código de control remoto, el programa salta al bloque de eventos Código remoto recibido. El código que hay debajo del bloque de eventos Código remoto recibido se ejecuta, el código remoto se comprueba para ver si es igual a 1, si es cierto, entonces ambos motores se ponen en marcha hacia delante, esto continúa hasta que el código recibido deja de ser igual a 1. A continuación, se comprueba si el código recibido es igual a 2; si es verdadero, ambos motores se ponen en marcha hacia atrás. Esto continúa hasta que el código recibido deja de ser igual a 2. Por último, una vez que se han comprobado los códigos remotos y ya no se reciben, el bloque de parada detiene ambos motores. El programa vuelve al bucle vacío para siempre.",
	"HELP_TEXT_CONTROL_WAIT_TITLE" : "Esperar seg",
	"HELP_TEXT_CONTROL_WAIT_BODY_1" : "El bloque esperar seg. detiene el programa durante una cantidad de tiempo en segundos. La cantidad de tiempo puede ser de 0,001 segundos (1 milisegundo) a 1.073.741 segundos (12,4 días).",
	"HELP_TEXT_CONTROL_WAIT_BODY_2" : "El bloque de espera sólo tiene un parámetro:",
	"HELP_TEXT_CONTROL_WAIT_BODY_3" : "Valor - Puede ser una constante (se teclea en la entrada y no varía), una variable, un sensor o un bloque operador.",
	"HELP_TEXT_CONTROL_WAIT_EXAMPLE_1_TITLE" : "Programa de ejemplo 1: Parpadeo del LED izquierdo",
	"HELP_TEXT_CONTROL_WAIT_EXAMPLE_1_BODY" : "En este ejemplo, el programa comienza entrando en un bucle eterno. Dentro del bucle se enciende el LED izquierdo, luego el programa hace una pausa y espera 0,5 segundos, luego se apaga el LED izquierdo, luego el programa vuelve a hacer una pausa y espera 0,5 segundos y luego vuelve al principio del bucle.",
	"HELP_TEXT_CONTROL_WAIT_EXAMPLE_2_TITLE" : "Programa de ejemplo 2: Grillo robot nocturno",
	"HELP_TEXT_CONTROL_WAIT_EXAMPLE_2_BODY" : "En este ejemplo, el programa comienza entrando en un bucle eterno. Dentro del bucle hay un bloque wait until que detiene la progresión del programa hasta que el nivel de luz en el sensor de luz izquierdo es inferior a 100. Cuando esto ocurre, el programa avanza para esperar un número aleatorio de segundos entre 20 y 300. Cuando termina esta espera, el altavoz toca una nota. A continuación, el programa vuelve al principio del bucle eterno. Esto provoca un comportamiento similar al de un grillo por la noche, por lo que no se puede encontrar.",
	"HELP_TEXT_CONTROL_REPEAT_TITLE" : "Repetir",
	"HELP_TEXT_CONTROL_REPEAT_BODY_1" : "El bloque repetir es un tipo de bucle que sólo repite un número determinado de veces. Todos los bloques dentro del bloque de repetición se ejecutan sólo durante este número determinado de veces.",
	"HELP_TEXT_CONTROL_REPEAT_BODY_2" : "El bloque repetir sólo tiene un parámetro:",
	"HELP_TEXT_CONTROL_REPEAT_BODY_3" : "Valor - Puede ser una constante (se teclea en la entrada y no varía), una variable, un sensor o un bloque operador.",
	"HELP_TEXT_CONTROL_REPEAT_EXAMPLE_1_TITLE" : "Programa de ejemplo 1: Conducir en un cuadrado",
	"HELP_TEXT_CONTROL_REPEAT_EXAMPLE_1_BODY" : "En este ejemplo, el programa comienza entrando en un bloque de repetición que está configurado para repetirse cuatro veces. Dentro del bloque de repetición, el robot avanza 10 cm y gira 90º a la derecha. Estos dos bloques dentro del bloque de repetición se ejecutan cuatro veces. El resultado es que el robot Edison se desplaza en forma de cuadrado.",
	"HELP_TEXT_CONTROL_FOREVER_TITLE" : "Para siempre",
	"HELP_TEXT_CONTROL_FOREVER_BODY_1" : "El bloque para siempre es un tipo de bloque de bucle que se repite incondicionalmente para siempre (a menos que se detenga el programa). Los bloques colocados dentro del bloque para siempre se ejecutan y vuelven a ejecutarse una y otra vez y...",
	"HELP_TEXT_CONTROL_FOREVER_EXAMPLE_1_TITLE" : "Programa de ejemplo: Parpadear un LED",
	"HELP_TEXT_CONTROL_FOREVER_EXAMPLE_1_BODY" : "En este ejemplo, el programa comienza entrando en un bucle forever. Dentro del bucle forever se enciende el LED izquierdo, luego el bloque wait detiene el programa durante 0,25 segundos, luego se apaga el LED izquierdo, luego el bloque wait detiene el programa durante 0,25 segundos. A continuación, el programa vuelve al bloque de encendido del LED izquierdo y la secuencia se repite para siempre.",
	"HELP_TEXT_CONTROL_IF_TITLE" : "Si entonces",
	"HELP_TEXT_CONTROL_IF_BODY_1" : "El bloque if then ejecuta los bloques si la condición de entrada es verdadera. Si la condición no es verdadera, el programa continúa con el siguiente bloque del programa.",
	"HELP_TEXT_CONTROL_IF_BODY_2" : "Este bloque tiene un parámetro de entrada:",
	"HELP_TEXT_CONTROL_IF_BODY_3" : "Entrada condicional - La entrada condicional acepta bloques en forma de diamante que pueden ser un bloque operador o un bloque sensor.",
	"HELP_TEXT_CONTROL_IF_BODY_4" : "El bloque if then se suele utilizar dentro de un bucle eterno, para que la condición if then se pueda probar varias veces. Si un programa sólo tiene un bloque if then, la prueba se ejecutará una vez y el programa saldrá.",
	"HELP_TEXT_CONTROL_IF_EXAMPLE_1_TITLE" : "Programa de ejemplo 1: Parpadeo del LED si hay una palmada",
	"HELP_TEXT_CONTROL_IF_EXAMPLE_1_BODY" : "n este ejemplo, el programa comienza entrando en un bucle eterno. El primer bloque del bucle eterno es el bloque if then, que comprueba si ha habido una palmada. Si es falso, se salta el contenido del bloque if then y el programa vuelve al inicio del bucle forever. Si se detecta una palmada (verdadero), se ejecutan los bloques del bloque if then. Primero se enciende el LED izquierdo, luego el programa hace una pausa de un segundo y después se apaga el LED izquierdo. A continuación, el programa vuelve al principio del bucle ''para siempre''. El resultado es que el robot Edison hace parpadear su LED izquierdo durante un segundo cada vez que detecta una palmada.",
	"HELP_TEXT_CONTROL_IF_EXAMPLE_2_TITLE" : "Programa de ejemplo 2: Dibujar alarma abierta",
	"HELP_TEXT_CONTROL_IF_EXAMPLE_2_BODY" : "En este ejemplo, el programa comienza entrando en un bucle forever. El primer bloque del bucle forever es el bloque if then que comprueba si el nivel de luz del sensor de luz izquierdo es mayor que 100. Si es cierto (el nivel de luz es superior a 100), se ejecuta el bloque bip y el robot Edison emite un pitido como una alarma. Si no es cierto (el nivel de luz es inferior a 100), se omite el bloque de pitido y el programa vuelve al principio del bucle ''para siempre''. El resultado es que el Edison emite un pitido rápido cada vez que detecta un nivel de luz superior a 100.",
	"HELP_TEXT_CONTROL_IF_ELSE_TITLE" : "Si entonces si no",
	"HELP_TEXT_CONTROL_IF_ELSE_BODY_1" : "El bloque if then else ejecuta el primer conjunto de bloques si la condición de entrada es verdadera. Si la condición es falsa, se ejecuta el segundo conjunto de bloques.",
	"HELP_TEXT_CONTROL_IF_ELSE_BODY_2" : "Este bloque tiene un parámetro de entrada:",
	"HELP_TEXT_CONTROL_IF_ELSE_BODY_3" : "Entrada condicional - La entrada condicional acepta bloques en forma de diamante que pueden ser un bloque operador o un bloque sensor.",
	"HELP_TEXT_CONTROL_IF_ELSE_BODY_4" : "El bloque if then else suele utilizarse dentro de un bucle eterno, para que la condición if then else pueda comprobarse varias veces. Si un programa sólo tiene un bloque if then else, la prueba se ejecutará una vez y el programa saldrá.",
	"HELP_TEXT_CONTROL_IF_ELSE_EXAMPLE_1_TITLE" : "Programa de ejemplo 1: Rebote en los bordes",
	"HELP_TEXT_CONTROL_IF_ELSE_EXAMPLE_1_BODY" : "En este ejemplo, el programa comienza encendiendo el LED del sensor de seguimiento de líneas y, a continuación, entra en un bucle eterno. El primer bloque del bucle eterno es el bloque if then else, que comprueba si el sensor de trazado de líneas está sobre una superficie no reflectante (negra). Si es cierto, el primer conjunto de bloques se ejecuta haciendo que el robot retroceda y gire 90 grados. El programa salta sobre el bloque else y vuelve a comprobar si el sensor de seguimiento de líneas está sobre una superficie no reflectante (negra); si es falso (en blanco), se ejecuta el bloque else, poniendo ambos motores en marcha hacia delante. Esto hace que el robot Edison ''rebote'' en una línea negra y se dé la vuelta. Esto hace que Edison se aleje de las líneas negras detectadas.",
	"HELP_TEXT_CONTROL_IF_ELSE_EXAMPLE_2_TITLE" : "Programa de ejemplo 2: Sigue la luz",
	"HELP_TEXT_CONTROL_IF_ELSE_EXAMPLE_2_BODY" : "En este ejemplo, el programa comienza entrando en un bucle ''para siempre''. El primer bloque del bucle eterno es el bloque if then else que comprueba si el nivel de luz en el sensor derecho es menor que el nivel de luz en el sensor izquierdo. Si el resultado es verdadero (la luz es más brillante en la izquierda), el siguiente bloque que se ejecuta es el de ajustar ambos motores para que el robot gire a la izquierda (el robot gira a la izquierda hacia la luz). Alternativamente, si el resultado es falso (la luz es más brillante a la derecha), entonces el siguiente bloque a ejecutar son los bloques else. Ahora se ejecuta el bloque establece que ambos motores giren el robot a la derecha (el robot gira hacia la luz). El resultado es que el robot Edison se dirige hacia la fuente de luz más brillante (prueba a utilizar una linterna para controlar hacia dónde se dirige Edison).",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_TITLE" : "Esperar hasta",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_BODY_1" : "El bloque esperar hasta detiene el programa hasta que se cumple la condición de entrada.",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_BODY_2" : "Este bloque tiene un parámetro de entrada:",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_BODY_3" : "Entrada condicional - La entrada condicional acepta bloques en forma de diamante que pueden ser un bloque operador o un bloque sensor.",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_BODY_4" : "El bloque esperar hasta se suele utilizar dentro de un bucle eterno, para que la condición esperar hasta se pueda probar varias veces. Si un programa sólo tiene un bloque esperar hasta, la prueba se ejecutará una vez y el programa saldrá.",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_EXAMPLE_1_TITLE" : "Programa de ejemplo 1: Parpadeo del LED si hay una palmada",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_EXAMPLE_1_BODY" : "En este ejemplo, el programa comienza entrando en un bucle forever. El primer bloque del bucle eterno es el bloque borrar datos del sensor, que borra cualquier dato falso de la claqueta. A continuación está el bloque esperar hasta con un bloque condicional de entrada de palmada detectada. El programa se detendrá aquí y esperará hasta que se detecte una palmada. Cuando se detecta una palmada, el programa enciende el LED izquierdo, espera un segundo y apaga el LED izquierdo. El programa vuelve ahora al bloque esperar hasta. Cada vez que se produce una palmada, el LED izquierdo se enciende durante un segundo. El resultado es que el robot Edison hace parpadear su LED izquierdo durante un segundo cada vez que detecta una palmada.",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_EXAMPLE_2_TITLE" : "Programa de ejemplo 2: Detector de la fuente de luz más brillante",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_EXAMPLE_2_BODY" : "En este ejemplo, el programa comienza entrando en un bucle forever. El primer bloque del bucle para siempre es el bloque esperar hasta con una entrada condicional que utiliza un operador que requiere que el nivel de luz del sensor de luz derecho sea igual al nivel de luz del sensor de luz izquierdo. Si la condición no es cierta (los niveles de luz no son iguales), el programa se detiene aquí. Cuando el nivel de luz de ambos sensores es igual, el programa pasa al bloque del pitido. Ahora el programa vuelve al bloque espera hasta y el programa se repite. El resultado es que el robot Edison emite un pitido cuando apunta hacia la fuente de luz más brillante.",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_TITLE" : "Repetir hasta",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_BODY_1" : "El bloque repetir hasta ejecuta los bloques que contiene hasta que la condición de entrada sea verdadera.",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_BODY_2" : "Este bloque tiene un parámetro de entrada:",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_BODY_3" : "Entrada condicional - La entrada condicional acepta bloques en forma de diamante que pueden ser un bloque operador o un bloque sensor.",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_BODY_4" : "El bloque repetir hasta se utiliza a menudo dentro de un bucle eterno, para que la condición repetir hasta pueda probarse varias veces. Si un programa sólo tiene un bloque repetir hasta, la prueba se ejecutará una vez y el programa saldrá.",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_EXAMPLE_1_TITLE" : "Programa de ejemplo 1: Evitar que suene la alarma",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_EXAMPLE_1_BODY" : "En este ejemplo, el programa comienza sintonizando el detector de obstáculos (activando la alarma) y luego entra en un bucle forever. El primer bloque del bucle para siempre es un bloque de espera hasta con una entrada condicional de obstáculo detectado en cualquier lugar (el detector de intrusos). El programa se detendrá y esperará aquí hasta que se detecte un obstáculo (intruso). Cuando se detecta un obstáculo, el programa pasa al bloque repetir hasta, lo que hace que se ejecute el bloque bip y se repita una y otra vez (el sonido de la alarma), ''hasta que'' se pulse el botón redondo (detener y restablecer la alarma).",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_EXAMPLE_2_TITLE" : "Ejemplo de programa 2: Edison tiembla de frío sin luz caliente",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_EXAMPLE_2_BODY" : "En este ejemplo, el programa comienza entrando en un bucle eterno. El primer bloque del bucle forever es el bloque repetir hasta con una entrada condicional mediante un operador que requiere que el nivel de luz del sensor de luz izquierdo sea superior a 980 (muy brillante/luz solar). Si esto no es cierto, entonces se ejecutan los bloques de abajo, girando rápidamente el robot Edison a izquierda y derecha (temblando). Si el nivel de luz del sensor de luz izquierdo aumenta por encima de 980 (Edison se mueve hacia una luz muy brillante), entonces la condición se convierte en verdadera y el programa se detiene (El robot Edison está caliente y feliz).",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_TITLE" : "Esperar milisegundos",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_BODY_1" : "El bloque esperar milisegundos pausa el programa durante una cantidad de tiempo en milisegundos (ms). Un milisegundo es una milésima (1/1000) de segundo o 0,001 segundos.",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_BODY_2" : "1500 milisegundos = 1,5 segundos",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_BODY_3" : "100 milisegundos = 0,1 segundos",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_BODY_4" : "25 milisegundos = 0,025 segundos",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_BODY_5" : "El bloque esperar milisegundos sólo tiene un parámetro:",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_BODY_6" : "Valor - Puede ser una variable, un sensor o un bloque operador",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_EXAMPLE_1_TITLE" : "Programa de ejemplo 1: LED que parpadea rápidamente",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_EXAMPLE_1_BODY" : "En este ejemplo, el programa comienza estableciendo la variable ''Retardo'' en 50, y luego entra en un bucle eterno. Dentro del bucle eterno se enciende el LED izquierdo, luego el bloque espera milisegundos hace una pausa para el valor en milisegundos de 'Retardo', en este caso 50 milisegundos. A continuación, se apaga el LED izquierdo y el bloque de espera de milisegundos se detiene durante 50 milisegundos. El programa vuelve ahora al inicio del bucle ''para siempre''.",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_EXAMPLE_2_TITLE" : "Programa de ejemplo 2: Luces locas",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_EXAMPLE_2_BODY" : "En este ejemplo, el programa comienza entrando en un bucle eterno. Dentro del bucle eterno, se encienden y apagan los LEDs izquierdo y derecho. Los tiempos de espera entre el encendido y el apagado se controlan mediante los bloques wait milisegundos. El tiempo en milisegundos lo establecen los bloques de números aleatorios que hay en su interior. Éstos se configuran para generar números aleatorios entre 30 y 300 milisegundos. El resultado es un parpadeo aleatorio de las luces LED del robot Edison.",
	"HELP_TEXT_SENSING_TURNLINETRACKINGLED_TITLE" : "Encender/apagar el LED de seguimiento de línea",
	"HELP_TEXT_SENSING_TURNLINETRACKINGLED_BODY_1" : "El bloque Activar/Desactivar LED de seguimiento de línea activa o desactiva el LED de seguimiento de línea.",
	"HELP_TEXT_SENSING_TURNLINETRACKINGLED_BODY_2" : "El LED de seguimiento de línea debe estar encendido para que funcione el sensor de seguimiento de línea.",
	"HELP_TEXT_SENSING_TURNLINETRACKINGLED_EXAMPLE_1_TITLE" : "Ejemplo de programa: Parada en superficie negra",
	"HELP_TEXT_SENSING_TURNLINETRACKINGLED_EXAMPLE_1_BODY" : "En este ejemplo, el programa comienza encendiendo el LED de seguimiento de línea, luego ambos motores se ponen en marcha hacia delante. A continuación, el programa espera hasta que el sensor de seguimiento de líneas detecta una superficie no reflectante (negra), cuando esto ocurre el programa finaliza y los motores se detienen.",
	"HELP_TEXT_SENSING_TURNOBSTACLEBEAM_TITLE" : "Activar/desactivar el haz de detección de obstáculos",
	"HELP_TEXT_SENSING_TURNOBSTACLEBEAM_BODY_1" : "El bloque activar/desactivar el haz de detección de obstáculos activa o desactiva el haz de detección de obstáculos.",
	"HELP_TEXT_SENSING_TURNOBSTACLEBEAM_BODY_2" : "El haz de detección de obstáculos debe estar encendido para que funcione la detección de obstáculos.",
	"HELP_TEXT_SENSING_TURNOBSTACLEBEAM_EXAMPLE_1_TITLE" : "Ejemplo de programa: Parar por un obstáculo",
	"HELP_TEXT_SENSING_TURNOBSTACLEBEAM_EXAMPLE_1_BODY" : "En este ejemplo, el programa comienza encendiendo el haz de detección de obstáculos, luego ambos motores se ponen en marcha hacia delante. A continuación, el programa espera hasta que se detecta un obstáculo en cualquier lugar, cuando esto ocurre el programa finaliza y los motores se detienen.",
	"HELP_TEXT_SENSING_CLEARSENSOR_TITLE" : "Borrar datos del sensor",
	"HELP_TEXT_SENSING_CLEARSENSOR_BODY_1" : "El bloque borrar datos del sensor borra todos los datos del sensor (detecciones) del sensor seleccionado. Este bloque se utiliza cuando puede haber detecciones falsas o no deseadas que impiden que el programa funcione de la forma que deseas. Un ejemplo es cuando un programa conduce el robot Edison al detectar una palmada. Generalmente, la conducción es bastante ruidosa y puede volver a desencadenar una detección adicional de una palmada. Esto hace que el programa detecte una segunda palmada que no se ha producido. El bloque borrar datos del sensor se utiliza para borrar los datos del sensor de cualquier detección no deseada como ésta.",
	"HELP_TEXT_SENSING_CLEARSENSOR_BODY_2" : "El bloque borrar datos del sensor tiene cinco opciones de entrada:",
	"HELP_TEXT_SENSING_CLEARSENSOR_BODY_3" : "detector de palmadas",
	"HELP_TEXT_SENSING_CLEARSENSOR_BODY_4" : "teclado",
	"HELP_TEXT_SENSING_CLEARSENSOR_BODY_5" : "detector de obstáculos",
	"HELP_TEXT_SENSING_CLEARSENSOR_BODY_6" : "código remoto",
	"HELP_TEXT_SENSING_CLEARSENSOR_BODY_7" : "mensaje IR",
	"HELP_TEXT_SENSING_CLEARSENSOR_EXAMPLE_1_TITLE" : "Programa de ejemplo 1: Aplauso y giro",
	"HELP_TEXT_SENSING_CLEARSENSOR_EXAMPLE_1_BODY" : "En este ejemplo, el programa comienza entrando en un bucle eterno. Dentro del bucle para siempre, el bloque borrar datos del sensor se configura para borrar el detector de palmadas, a continuación el programa espera hasta que se detecta una palmada, cuando esto ocurre el programa avanza y el robot gira a la izquierda durante dos segundos. Durante el giro, los motores, las ruedas y el patín hacen ruido, este ruido vuelve a activar el detector de aplausos, por lo que ahora el detector de aplausos piensa que ha habido un segundo aplauso. El programa vuelve al principio del bucle ''para siempre'' (manteniendo la detección del aplauso), pero entonces el bloque ''borrar datos del sensor'' borra la detección y el bloque ''esperar hasta'' no se activará hasta que haya realmente un aplauso.",
	"HELP_TEXT_SENSING_CLAPDETECTED_TITLE" : "Aplauso detectado",
	"HELP_TEXT_SENSING_CLAPDETECTED_BODY_1" : "El bloque de detección de palmada es un bloque de entrada de sensor que indica si se ha detectado o no una palmada. Es un bloque con forma de diamante, por lo que los datos del bloque sólo pueden ser verdaderos (se ha detectado una palmada) o falsos (no se ha detectado una palmada).",
	"HELP_TEXT_SENSING_CLAPDETECTED_BODY_2" : "Otros ruidos, como el accionamiento de los motores, pueden hacer que el bloque de detección de palmada se active en falso. Utiliza el bloque borrar datos del sensor para borrar las detecciones falsas o no deseadas de clap.",
	"HELP_TEXT_SENSING_CLAPDETECTED_EXAMPLE_1_TITLE" : "Programa de ejemplo 1: Parpadeo del LED si hay una palmada",
	"HELP_TEXT_SENSING_CLAPDETECTED_EXAMPLE_1_BODY" : "En este ejemplo, el programa comienza entrando en un bucle forever. Dentro del bucle para siempre hay un bloque if then que comprueba si se ha detectado una palmada. Cuando se detecta una palmada, el LED izquierdo se enciende, el programa espera un segundo y el LED izquierdo se apaga. A continuación, el programa vuelve al principio del bucle eterno. El resultado es que el robot Edison hace parpadear su LED izquierdo durante un segundo cada vez que detecta una palmada.",
	"HELP_TEXT_SENSING_BUTTONPRESSED_TITLE" : "Botón pulsado",
	"HELP_TEXT_SENSING_BUTTONPRESSED_BODY_1" : "El bloque botón pulsado es una entrada de sensor que indica si se ha pulsado o no un botón. Hay dos opciones de botón:",
	"HELP_TEXT_SENSING_BUTTONPRESSED_BODY_2" : "redondo",
	"HELP_TEXT_SENSING_BUTTONPRESSED_BODY_3" : "triángulo",
	"HELP_TEXT_SENSING_BUTTONPRESSED_BODY_4" : "El bloque botón pulsado es un bloque con forma de diamante, por lo que los datos del bloque sólo pueden ser verdaderos (se ha pulsado el botón) o falsos (no se ha pulsado el botón).",
	"HELP_TEXT_SENSING_BUTTONPRESSED_EXAMPLE_1_TITLE" : "Ejemplo de programa: Pitido al pulsar el botón",
	"HELP_TEXT_SENSING_BUTTONPRESSED_EXAMPLE_1_BODY" : "En este ejemplo, el programa comienza entrando en un bucle eterno. Dentro del bucle forever hay un bloque if then que comprueba si se ha pulsado el botón redondo. Cuando se pulsa el botón redondo, el programa ejecuta el bloque bip y vuelve al inicio del bucle para siempre.",
	"HELP_TEXT_SENSING_OBSTACLE_TITLE" : "Obstáculo detectado",
	"HELP_TEXT_SENSING_OBSTACLE_BODY_1" : "El bloque obstáculo detectado es un bloque de entrada de sensor que indica si se ha detectado o no un obstáculo. Hay cuatro opciones de detección:",
	"HELP_TEXT_SENSING_OBSTACLE_BODY_2" : "en cualquier lugar",
	"HELP_TEXT_SENSING_OBSTACLE_BODY_3" : "delante",
	"HELP_TEXT_SENSING_OBSTACLE_BODY_4" : "izquierda",
	"HELP_TEXT_SENSING_OBSTACLE_BODY_5" : "derecha",
	"HELP_TEXT_SENSING_OBSTACLE_BODY_6" : "El bloque de obstáculo detectado es un bloque con forma de diamante, por lo que los datos del bloque sólo pueden ser verdaderos (se ha detectado el obstáculo) o falsos (no se ha detectado el obstáculo).",
	"HELP_TEXT_SENSING_OBSTACLE_BODY_7" : "Para utilizar el bloque de detección de obstáculos, hay que utilizar el bloque de encendido/apagado del haz de detección de obstáculos para encender el haz de detección de obstáculos.",
	"HELP_TEXT_SENSING_OBSTACLE_EXAMPLE_1_TITLE" : "Ejemplo de programa: Evitar obstáculos",
	"HELP_TEXT_SENSING_OBSTACLE_EXAMPLE_1_BODY" : "En este ejemplo, el programa comienza activando el haz de detección de obstáculos y, a continuación, entra en un bucle eterno. Dentro del bucle ''para siempre'', los motores se configuran para que ambos avancen, y luego hay un bloque ''si entonces'' que comprueba si se ha detectado un obstáculo en algún lugar. Cuando esto ocurre, el robot gira 180 grados y vuelve al principio del bucle eterno. Al principio del bucle eterno, los dos motores vuelven a ponerse en marcha hacia delante. El resultado es que Edison se aleja de los obstáculos que encuentra en su camino.",
	"HELP_TEXT_SENSING_LINETRACKER_TITLE" : "Seguidor de líneas en superficie",
	"HELP_TEXT_SENSING_LINETRACKER_BODY_1" : "El bloque de seguimiento de línea en superficie es un bloque de entrada de sensor que indica si la superficie es reflectante o no. Una superficie reflectante es una superficie que refleja la luz del LED de seguimiento de líneas hacia el sensor de luz. Suele ser una superficie blanca, pero una superficie roja también reflejará la luz roja del LED rojo del seguidor de línea. Una superficie no reflectante es una superficie que no refleja la luz del LED de seguimiento de líneas hacia el sensor de luz. Suele ser negra, pero una superficie azul o verde tampoco reflejará la luz roja del LED rojo del seguidor de línea.",
	"HELP_TEXT_SENSING_LINETRACKER_BODY_2" : "Hay dos opciones de detección",
	"HELP_TEXT_SENSING_LINETRACKER_BODY_3" : "reflectante (blanco)",
	"HELP_TEXT_SENSING_LINETRACKER_BODY_4" : "no reflectante (negro)",
	"HELP_TEXT_SENSING_LINETRACKER_BODY_5" : "El bloque seguidor de línea en superficie es un bloque con forma de diamante, por lo que los datos del bloque sólo pueden ser verdaderos (se ha detectado el tipo de superficie) o falsos (no se ha detectado el tipo de superficie).",
	"HELP_TEXT_SENSING_LINETRACKER_BODY_6" : "Para utilizar el bloque de seguimiento de línea en superficie, hay que utilizar el bloque de encendido/apagado del LED de seguimiento de línea para encender el LED de seguimiento de línea.",
	"HELP_TEXT_SENSING_LINETRACKER_EXAMPLE_1_TITLE" : "Ejemplo de programa: Rebote en bordes",
	"HELP_TEXT_SENSING_LINETRACKER_EXAMPLE_1_BODY" : "En este ejemplo, el programa comienza encendiendo el LED de seguimiento de línea y, a continuación, entra en un bucle eterno. Dentro del bucle ''para siempre'', los motores se configuran para que ambos se desplacen hacia delante y, a continuación, hay un bloque if then que comprueba si la superficie no es reflectante. Si es cierto, el robot gira 180 grados y vuelve al principio del bucle eterno. Al principio del bucle ''para siempre'', ambos motores se ponen de nuevo en marcha hacia delante. Esto hace que Edison se aleje de las líneas negras detectadas.",
	"HELP_TEXT_SENSING_REMOTE_BOOL_TITLE" : "Código remoto recibido",
	"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_1" : "El bloque de código remoto recibido es un bloque de entrada de sensor que indica si se ha recibido o no un código de control remoto concreto.",
	"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_2" : "Hay ocho opciones de código remoto de 0 a 7.",
	"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_3" : "El bloque de código remoto recibido es un bloque con forma de diamante, por lo que los datos del bloque sólo pueden ser verdaderos (se ha recibido el código) o falsos (no se ha recibido el código).",
	"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_4" : "Asegúrate de pulsar el botón triángulo para iniciar el programa. Esto es fácil de olvidar, ya que el robot Edison responderá como un robot teledirigido y no hará lo que le hayas programado.",
	"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_5" : "Para utilizar el bloque de código remoto recibido, primero hay que enseñar al robot Edison qué botones de tu mando a distancia corresponden a cada código remoto. Aprende más sobre esto aquí:",
	"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_6" : "Si el programa se comporta de forma inesperada, puede que tengas que utilizar el bloque borrar datos del sensor para borrar el contenido del bloque código remoto recibido. Consulta el programa de ejemplo 1 a continuación.",
	"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_7" : "El bloque de código remoto recibido funcionará con aproximadamente el 90% de los mandos a distancia por infrarrojos (IR) de TV estándar, aunque cada marca de TV utiliza formatos de datos IR ligeramente diferentes. Cuando Edison descodifica los datos IR, estas diferencias pueden provocar comportamientos inesperados de una marca de mando a distancia a otra. La descodificación avanzada de mandos a distancia funciona mejor con el EdRemote (disponible a mediados de 2025).",
	"HELP_TEXT_SENSING_REMOTE_BOOL_EXAMPLE_1_TITLE" : "Programa de ejemplo 1: ¿Un pitido o dos?",
	"HELP_TEXT_SENSING_REMOTE_BOOL_EXAMPLE_1_BODY" : "En este ejemplo, el programa comienza entrando en un bucle ''para siempre''. Dentro del bucle forever hay dos bloques if then que comprueban el código remoto recibido. El primer if then comprueba si el código remoto recibido es el código remoto 1. Si es verdadero, el bloque bip suena una vez y los datos del sensor se borran. Si es falso, el programa pasa al siguiente bloque if then y comprueba si el código remoto recibido es el código remoto 2. Si es verdadero, se emite un pitido y se borran los datos del sensor. Si es verdadero, el bloque bip se reproduce dos veces y los datos del sensor se borran. A continuación, el programa vuelve al principio del bucle eterno.",
	"HELP_TEXT_SENSING_REMOTE_BOOL_EXAMPLE_2_TITLE" : "Programa de ejemplo 2: Gira con el mando a distancia (funciona mejor con el EdRemote)",
	"HELP_TEXT_SENSING_REMOTE_BOOL_EXAMPLE_2_BODY" : "En este ejemplo, el programa comienza entrando en un bucle eterno. Dentro del bucle forever, el bloque if then comprueba si se ha recibido el código remoto 0. Si es cierto, ambos motores se ponen en marcha para hacer girar el robot hacia la derecha. Esto continúa hasta que se supera la condición del bloque espera hasta. Para pasar, el código remoto recibido no debe ser el código remoto 0 (ya no se pulsa el botón de control remoto). Cuando esto ocurre, el programa avanza para detener ambos motores y luego vuelve al inicio del bucle ''para siempre''. Esto hace que Edison gire mientras se mantiene pulsado el botón del mando a distancia.",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_TITLE" : "mensaje IR detectado",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_BODY_1" : "El bloque Mensaje IR detectado es una entrada de sensor que indica si se ha detectado (recibido) un mensaje IR de otro robot Edison. El término ''IR'' es la abreviatura de ''infrarrojos''. Los infrarrojos se refieren a una banda de luz que no es visible para los humanos. Esto hace que sea útil como medio para comunicar datos a corta distancia.",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_BODY_2" : "El bloque de mensaje IR detectado es un bloque con forma de diamante, por lo que los datos del bloque sólo pueden ser verdaderos (se ha recibido el mensaje IR) o falsos (no se ha recibido el mensaje IR).",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_BODY_4" : "El bloque de mensaje IR detectado no conoce el contenido del mensaje IR que se ha recibido. Sólo indica al programa si se ha recibido un mensaje IR. Para leer los datos del mensaje IR, utiliza el bloque de mensaje IR recibido. Consulta el programa de ejemplo.",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_BODY_5" : "La mensajería por infrarrojos entre robots Edison funciona mejor en interiores, lejos de la luz solar directa. El alcance típico puede ser de hasta 10 metros (30 pies).",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_EXAMPLE_1_TITLE" : "Programa de ejemplo: Encendido y apagado de la luz a distancia de Edison",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_EXAMPLE_1_BODY" : "En este ejemplo, el programa comienza entrando en un bucle forever. Dentro del bucle forever, el primer bloque if then comprueba si se ha recibido un mensaje de infrarrojos; si es cierto, la variable ''IRMessage'' se establece en el valor del bloque del mensaje de infrarrojos recibido. Esto permite leer/comprobar el mensaje recibido varias veces sin que se borre o se pierda. La siguiente sentencia if then comprueba si los datos de ''IRMessage'' son iguales a 1. Si es cierto, se enciende el LED izquierdo. Si no es cierto, el programa pasa al siguiente bloque if then. Este bloque if then comprueba si los datos de ''Mensaje IR'' son iguales a 2; si es cierto, el LED izquierdo se apaga. A continuación, el programa vuelve al principio del bucle ''para siempre''.",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_EXAMPLE_2_TITLE" : "El robot Edison que envía mensajes IR ejecuta este programa.",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_EXAMPLE_2_BODY" : "Pulsando el botón triangular se envía un mensaje IR con el número 1 (encender el LED) y pulsando el botón redondo se envía un mensaje IR con el número 2 (apagar el LED)",
	"HELP_TEXT_SENSING_DRIVESTRAINED_TITLE" : "Deformación del motor detectada",
	"HELP_TEXT_SENSING_DRIVESTRAINED_BODY_1" : "El bloque de esfuerzo de tracción detectado es un bloque de entrada de sensor que indica si una o las dos ruedas han dejado de girar por estar sometidas a esfuerzo (impedidas físicamente de girar al intentar conducir).",
	"HELP_TEXT_SENSING_DRIVESTRAINED_BODY_2" : "El bloque de esfuerzo detectado es un bloque en forma de diamante, por lo que los datos del bloque sólo pueden ser verdaderos (la rueda está sometida a esfuerzo) o falsos (la rueda no está sometida a esfuerzo).",
	"HELP_TEXT_SENSING_DRIVESTRAINED_EXAMPLE_1_TITLE" : "Ejemplo de programa: Alarma de rueda tensa",
	"HELP_TEXT_SENSING_DRIVESTRAINED_EXAMPLE_1_BODY" : "En este ejemplo, el programa comienza poniendo la rueda izquierda en marcha hacia delante, a continuación el programa entra en un bucle eterno. Dentro del bucle hay un bloque if then que comprueba si se detecta tensión en la rueda. Cuando es cierto, se ejecuta el bloque bip. El bloque bip continuará ejecutándose hasta que desaparezca la tensión y la rueda pueda girar.",
	"HELP_TEXT_SENSING_REMOTE_NUM_TITLE" : "Código remoto recibido",
	"HELP_TEXT_SENSING_REMOTE_NUM_BODY_1" : "El bloque de código remoto recibido es un bloque de entrada de sensor que contiene datos recibidos de un mando a distancia. Los datos son un número del 0 al 7.",
	"HELP_TEXT_SENSING_REMOTE_NUM_BODY_2" : "Cuando un programa ejecuta este bloque, se borra su contenido. Siempre es mejor poner los datos del bloque de código remoto recibido en una variable antes de probarlos con un bloque condicional (si entonces). Ver programa de ejemplo.",
	"HELP_TEXT_SENSING_REMOTE_NUM_EXAMPLE_1_TITLE" : "Programa de ejemplo: Encendido y apagado de la luz del mando a distancia",
	"HELP_TEXT_SENSING_REMOTE_NUM_EXAMPLE_1_BODY" : "En este ejemplo, el programa comienza entrando en un bucle forever. El primer bloque dentro del bucle forever introduce los datos del bloque de código remoto recibido en la variable 'CódigoRemoto'. Ahora se puede comprobar la variable ''CódigoRemoto''. El primer bloque if then comprueba si el contenido de ''CódigoRemoto'' es igual a 1. Si es cierto, se enciende el LED izquierdo. Si es falso, el siguiente bloque if then comprueba si el contenido de ''CódigoRemoto'' es igual a 2. Si es cierto, el LED izquierdo se apaga. A continuación, el programa vuelve al principio del bucle ''para siempre''.",
	"HELP_TEXT_SENSING_IRMESSAGE_TITLE" : "Mensaje IR recibido",
	"HELP_TEXT_SENSING_IRMESSAGE_BODY_1" : "El bloque de mensaje IR recibido es un bloque de entrada de sensor que contiene datos recibidos de otro robot Edison. El término ''IR'' es la abreviatura de ''infrarrojos''. Infrarrojo se refiere a una banda de luz que no es visible para los humanos. Esto lo hace útil como medio para comunicar datos a corta distancia. Los datos se basan en un número binario de 8 bits y tienen un rango de 0 a 255.",
	"HELP_TEXT_SENSING_IRMESSAGE_BODY_2" : "Cuando un programa ejecuta este bloque, se borra su contenido. Siempre es mejor poner los datos del código remoto recibido en una variable antes de probarlo con un bloque condicional (bloque if then).",
	"HELP_TEXT_SENSING_IRMESSAGE_BODY_3" : "La mensajería por infrarrojos entre robots Edison funciona mejor en interiores, lejos de la luz solar directa. El alcance típico puede ser de hasta 10 metros (30 pies).",
	"HELP_TEXT_SENSING_IRMESSAGE_EXAMPLE_1_TITLE" : "Ejemplo de programa: Iniciar una revolución de baile",
	"HELP_TEXT_SENSING_IRMESSAGE_EXAMPLE_1_BODY" : "En este ejemplo, el programa comienza entrando en un bucle eterno. El primer bloque dentro del bucle forever borra los datos del sensor de mensajes IR, el programa espera entonces hasta que se recibe un mensaje IR igual a 3. Cuando esto ocurre, el programa entra en un bucle de repetición por cuatro veces. Dentro del bucle de repetición están las maniobras de baile del robot Edison. Cada una de estas maniobras se basa en el tiempo, no en la distancia. Esto es muy importante si hay toda una clase de robots Edison bailando sincronizados al ritmo de la música. Las maniobras de baile se repiten cuatro veces, y el programa vuelve al principio del bucle eterno.",
	"HELP_TEXT_SENSING_IRMESSAGE_EXAMPLE_2_TITLE" : "Ejemplo de programa: Enviar mensaje IR 3",
	"HELP_TEXT_SENSING_IRMESSAGE_EXAMPLE_2_BODY" : "En este ejemplo, el programa comienza entrando en un bucle forever. El primer bloque dentro del bucle eterno espera hasta que se pulsa el botón redondo, cuando esto ocurre se transmite el mensaje número 3 mediante luz infrarroja. A continuación, el programa vuelve al inicio del bucle forever.",
	"HELP_TEXT_SENSING_LIGHTLEVEL_TITLE" : "Nivel de luz del sensor",
	"HELP_TEXT_SENSING_LIGHTLEVEL_BODY_1" : "El bloque nivel de luz del sensor es un bloque de entrada de sensor que contiene datos de los sensores de luz. El nivel de luz es un número entre 1 y 1000. Los datos del bloque nivel de luz del sensor se actualizan constantemente.",
	"HELP_TEXT_SENSING_LIGHTLEVEL_BODY_2" : "Hay tres entradas de sensor de luz para seleccionar:",
	"HELP_TEXT_SENSING_LIGHTLEVEL_BODY_3" : "- luz izquierda (sensor en la parte frontal izquierda)",
	"HELP_TEXT_SENSING_LIGHTLEVEL_BODY_4" : "- luz derecha (sensor en la parte frontal derecha)",
	"HELP_TEXT_SENSING_LIGHTLEVEL_BODY_5" : "- seguimiento de líneas (sensor utilizado para detectar líneas bajo el robot)",
	"HELP_TEXT_SENSING_LIGHTLEVEL_EXAMPLE_1_TITLE" : "Programa de ejemplo: Luz nocturna",
	"HELP_TEXT_SENSING_LIGHTLEVEL_EXAMPLE_1_BODY" : "En este ejemplo, el programa comienza entrando en un bucle forever. El primer bloque dentro del bucle forever comprueba si la lectura del nivel de luz en el sensor de luz izquierdo es inferior a 50. Si es cierto, se encienden los LEDs izquierdo y derecho. Si es falso, el programa salta a else y los LED izquierdo y derecho se apagan. A continuación, el programa vuelve al principio del bucle ''para siempre'' y repite la operación. El resultado es que los LEDs de Edison se encienden mientras está en penumbra.",
	"HELP_TEXT_ADDITION_TITLE" : "Suma",
	"HELP_TEXT_ADDITION_BODY" : "El bloque operador de suma suma dos valores. Los valores pueden ser una constante (se escribe en la entrada y no varía), una variable, un sensor o un bloque operador.",
	"HELP_TEXT_ADDITION_EXAMPLE_1_TITLE" : "El valor constante 2 se suma al valor constante 2.",
	"HELP_TEXT_ADDITION_EXAMPLE_2_TITLE" : "La variable ''Contador'' se suma al valor constante 2.",
	"HELP_TEXT_ADDITION_EXAMPLE_3_TITLE" : "El nivel de luz del sensor de entrada se añade al valor constante 10.",
	"HELP_TEXT_SUBTRACTION_TITLE" : "Resta",
	"HELP_TEXT_SUBTRACTION_BODY" : "El bloque operador sustracción resta un valor de otro. Los valores pueden ser una constante (se teclea en la entrada y no varía), una variable, un sensor o un bloque operador.",
	"HELP_TEXT_SUBTRACTION_EXAMPLE_1_TITLE" : "El valor constante 10 se resta del valor constante 200.",
	"HELP_TEXT_SUBTRACTION_EXAMPLE_2_TITLE" : "El valor constante 100 se resta de la variable ''Contador''.",
	"HELP_TEXT_SUBTRACTION_EXAMPLE_3_TITLE" : "El valor constante 10 se resta del nivel de luz de entrada del sensor.",
	"HELP_TEXT_SUBTRACTION_EXAMPLE_4_TITLE" : "Programa de ejemplo: Contador de radiación luminosa",
	"HELP_TEXT_SUBTRACTION_EXAMPLE_4_BODY" : "En este programa de ejemplo, primero se ajusta el tempo de la música a muy rápido. A continuación, el programa entra en un bucle eterno. Dentro del bucle, el programa establece la variable (Retardo) en 1000 menos el nivel de luz izquierdo (invirtiendo la lectura del nivel de luz). El siguiente bloque espera el valor de la variable (Retardo). A continuación, el programa toca la nota C y vuelve al inicio del bucle eterno y repite. El resultado es que la Edison emite un pitido lento cuando está a oscuras y más rápido cuando el nivel de luz es más brillante.",
	"HELP_TEXT_MULTIPLICATION_TITLE" : "Multiplicación",
	"HELP_TEXT_MULTIPLICATION_BODY" : "El bloque operador multiplicación multiplica dos valores. Los valores pueden ser una constante (se escribe en la entrada y no varía), una variable, un sensor o un bloque operador.",
	"HELP_TEXT_MULTIPLICATION_EXAMPLE_1_TITLE" : "El valor constante 2 se multiplica por el valor constante 4.",
	"HELP_TEXT_MULTIPLICATION_EXAMPLE_2_TITLE" : "La variable ''Contador'' se multiplica por el valor constante 2.",
	"HELP_TEXT_MULTIPLICATION_EXAMPLE_3_TITLE" : "El nivel de luz del sensor de entrada se multiplica por el valor constante 4.",
	"HELP_TEXT_DIVISION_TITLE" : "División",
	"HELP_TEXT_DIVISION_BODY_1" : "El bloque operador división divide un valor por otro valor. Los valores pueden ser una constante (se teclea en la entrada y no varía), una variable, un sensor o un bloque operador.",
	"HELP_TEXT_DIVISION_BODY_2" : "No es posible dividir por cero, Edison experimentará un error si la entrada más a la derecha es cero.",
	"HELP_TEXT_DIVISION_EXAMPLE_1_TITLE" : "El valor constante 10 se divide por el valor constante 2.",
	"HELP_TEXT_DIVISION_EXAMPLE_2_TITLE" : "La variable ''Contador'' se divide por el valor constante 2.",
	"HELP_TEXT_DIVISION_EXAMPLE_3_TITLE" : "El nivel de luz de entrada del sensor se divide por 10.",
	"HELP_TEXT_DIVISION_EXAMPLE_4_TITLE" : "Programa de ejemplo: Ajustar la distancia de accionamiento utilizando una variable y los datos de un sensor",
	"HELP_TEXT_DIVISION_EXAMPLE_4_BODY" : "En este programa de ejemplo, Edison establece la variable (Distancia) en el nivel de luz del sensor de luz izquierdo (un valor de 1 a 1.000) dividido por 50. A continuación, Edison se desplaza hacia delante según el valor de la variable (Distancia) a velocidad 5. Esto hace que Edison se desplace más lejos con luz brillante, hasta una distancia máxima de 20 cm.",
	"HELP_TEXT_RANDOM_NUMBER_TITLE" : "número aleatorio",
	"HELP_TEXT_RANDOM_NUMBER_BODY" : "El bloque número aleatorio entre genera un número aleatorio entre dos valores. Los valores pueden ser una constante (se teclea en la entrada y no varía), una variable, un sensor o un bloque operador.",
	"HELP_TEXT_RANDOM_NUMBER_EXAMPLE_1_TITLE" : "Genera un número aleatorio entre el valor constante 10 y el valor constante 100.",
	"HELP_TEXT_RANDOM_NUMBER_EXAMPLE_2_TITLE" : "Genera un número aleatorio entre la variable ''Contador'' y el valor constante 5000.",
	"HELP_TEXT_RANDOM_NUMBER_EXAMPLE_3_TITLE" : "Genera un número aleatorio entre el valor constante 10 y el nivel de luz de entrada del sensor.",
	"HELP_TEXT_RANDOM_NUMBER_EXAMPLE_4_TITLE" : "Programa de ejemplo: Luces locas",
	"HELP_TEXT_RANDOM_NUMBER_EXAMPLE_4_BODY" : "En este ejemplo, el programa comienza entrando en un bucle forever. Dentro del bucle forever, se encienden y apagan los LEDs izquierdo y derecho. Los tiempos de espera entre el encendido y el apagado se controlan mediante los bloques wait milisegundos. El tiempo en milisegundos lo establecen los bloques de números aleatorios que hay en su interior. Éstos están configurados para generar números aleatorios entre 30 y 300 milisegundos. El resultado es un parpadeo loco e incoherente de las luces LED del robot Edison.",
	"HELP_TEXT_ABS_VAL_TITLE" : "abs",
	"HELP_TEXT_ABS_VAL_BODY" : "El bloque abs (valor absoluto) convierte un valor en un valor absoluto. Un valor absoluto es un valor que siempre es positivo. El valor puede ser una constante (se escribe en la entrada y no varía), una variable, un sensor o un bloque operador.",
	"HELP_TEXT_ABS_VAL_EXAMPLE_1_BODY" : "Tiene como resultado el valor 3.",
	"HELP_TEXT_ABS_VAL_EXAMPLE_2_BODY" : "Tiene como resultado el valor 3.",
	"HELP_TEXT_ABS_VAL_EXAMPLE_3_TITLE" : "Programa de ejemplo: informar de la diferencia entre los niveles de luz",
	"HELP_TEXT_ABS_VAL_EXAMPLE_3_BODY" : "En este ejemplo, el programa comienza entrando en un bucle forever. El primer bloque del bucle forever establece la variable ''Diferencia'' en el valor absoluto del nivel de luz del sensor de luz derecho menos el nivel de luz del sensor de luz izquierdo. El bloque abs garantiza que el resultado sea siempre positivo (sin números negativos). A continuación, el programa espera un segundo y envía el valor de la variable ''Diferencia'' por USB. Este valor siempre es positivo (absoluto).",
	"HELP_TEXT_LESS_THAN_TITLE" : "Menos que",
	"HELP_TEXT_LESS_THAN_BODY_1" : "El bloque menos que compara dos valores de entrada para determinar si el primer valor es menor que el segundo y devuelve un resultado que es verdadero o falso. Los valores pueden ser una constante (se escribe en la entrada y no varía), una variable, un sensor o un bloque operador.",
	"HELP_TEXT_LESS_THAN_BODY_2" : "El bloque menor que es un bloque con forma de diamante, por lo que el resultado del bloque sólo puede ser verdadero o falso.",
	"HELP_TEXT_LESS_THAN_EXAMPLE_1_BODY" : "Resultado: verdadero",
	"HELP_TEXT_LESS_THAN_EXAMPLE_2_BODY" : "Resultado: falso",
	"HELP_TEXT_LESS_THAN_EXAMPLE_3_TITLE" : "¿Es la variable ''Contador'' menor que el valor constante 120?",
	"HELP_TEXT_LESS_THAN_EXAMPLE_4_TITLE" : "¿El nivel de luz del sensor izquierdo es menor que el valor constante 500?",
	"HELP_TEXT_LESS_THAN_EQUAL_TITLE" : "Menor o igual que",
	"HELP_TEXT_LESS_THAN_EQUAL_BODY_1" : "El bloque menor o igual que compara dos valores de entrada para determinar si el primer valor es menor o igual que el segundo y devuelve un resultado que es verdadero o falso. Los valores pueden ser una constante (introducida en la entrada y que no varía), una variable, un sensor o un bloque operador.",
	"HELP_TEXT_LESS_THAN_EQUAL_BODY_2" : "El bloque menor o igual que es un bloque con forma de diamante, por lo que el resultado del bloque sólo puede ser verdadero o falso.",
	"HELP_TEXT_LESS_THAN_EQUAL_EXAMPLE_1_BODY" : "Resultado: verdadero",
	"HELP_TEXT_LESS_THAN_EQUAL_EXAMPLE_2_BODY" : "Resultado: falso",
	"HELP_TEXT_LESS_THAN_EQUAL_EXAMPLE_3_BODY" : "Resultado: verdadero",
	"HELP_TEXT_LESS_THAN_EQUAL_EXAMPLE_4_TITLE" : "¿Es la variable ''Contador'' menor o igual que el valor constante 120?",
	"HELP_TEXT_LESS_THAN_EQUAL_EXAMPLE_5_TITLE" : "¿El nivel de luz del sensor izquierdo es menor o igual que el valor constante 500?",
	"HELP_TEXT_EQUAL_TITLE" : "Igual a",
	"HELP_TEXT_EQUAL_BODY_1" : "El bloque igual a compara dos valores de entrada para determinar si el primer valor es igual al segundo y devuelve un resultado que es verdadero o falso. Los valores pueden ser una constante (se escribe en la entrada y no varía), una variable, un sensor o un bloque operador.",
	"HELP_TEXT_EQUAL_BODY_2" : "El bloque igual a es un bloque con forma de diamante, por lo que el resultado del bloque sólo puede ser verdadero o falso.",
	"HELP_TEXT_EQUAL_EXAMPLE_1_BODY" : "Resultado: verdadero",
	"HELP_TEXT_EQUAL_EXAMPLE_2_BODY" : "Resultado: falso",
	"HELP_TEXT_EQUAL_EXAMPLE_3_TITLE" : "¿Es la variable ''Contador'' igual al valor constante 60?",
	"HELP_TEXT_EQUAL_EXAMPLE_4_TITLE" : "¿El código remoto recibido es igual al valor constante 3?",
	"HELP_TEXT_GREATER_THAN_EQUAL_TITLE" : "Mayor o igual que",
	"HELP_TEXT_GREATER_THAN_EQUAL_BODY_1" : "El bloque mayor que o igual a compara dos valores de entrada para determinar si el primer valor es mayor o igual que el segundo y devuelve un resultado que es verdadero o falso. Los valores pueden ser una constante (se escribe en la entrada y no varía), una variable, un sensor o un bloque operador.",
	"HELP_TEXT_GREATER_THAN_EQUAL_BODY_2" : "El bloque mayor o igual que es un bloque con forma de diamante, por lo que el resultado del bloque sólo puede ser verdadero o falso.",
	"HELP_TEXT_GREATER_THAN_EQUAL_EXAMPLE_1_BODY" : "Resultado: verdadero",
	"HELP_TEXT_GREATER_THAN_EQUAL_EXAMPLE_2_BODY" : "Resultado: falso",
	"HELP_TEXT_GREATER_THAN_EQUAL_EXAMPLE_3_BODY" : "Resultado: verdadero",
	"HELP_TEXT_GREATER_THAN_EQUAL_EXAMPLE_4_TITLE" : "¿Es la variable ''Contador'' mayor o igual que el valor constante 120?",
	"HELP_TEXT_GREATER_THAN_EQUAL_EXAMPLE_5_TITLE" : "¿Es el nivel de luz del sensor izquierdo mayor o igual que el valor constante 500?",
	"HELP_TEXT_GREATER_THAN_TITLE" : "Mayor que",
	"HELP_TEXT_GREATER_THAN_BODY_1" : "El bloque mayor que compara dos valores de entrada para determinar si el primer valor es mayor que el segundo y devuelve un resultado que es verdadero o falso. Los valores pueden ser una constante (introducida en la entrada y que no varía), una variable, un sensor o un bloque operador.",
	"HELP_TEXT_GREATER_THAN_BODY_2" : "El bloque mayor que es un bloque con forma de diamante, por lo que el resultado del bloque sólo puede ser verdadero o falso",
	"HELP_TEXT_GREATER_THAN_EXAMPLE_1_BODY" : "Resultado: verdadero",
	"HELP_TEXT_GREATER_THAN_EXAMPLE_2_BODY" : "Resultado: falso",
	"HELP_TEXT_GREATER_THAN_EXAMPLE_3_TITLE" : "¿Es la variable ''Contador'' mayor que el valor constante 120?",
	"HELP_TEXT_GREATER_THAN_EXAMPLE_4_TITLE" : "¿Es el nivel de luz del sensor izquierdo mayor que el valor constante 500?",
	"HELP_TEXT_NOT_EQUAL_TITLE" : "No igual a",
	"HELP_TEXT_NOT_EQUAL_BODY_1" : "El bloque no igual a compara dos valores de entrada para determinar si el primer valor no es igual al segundo y devuelve un resultado que es verdadero o falso. Los valores pueden ser una constante (introducida en la entrada y que no varía), una variable, un sensor o un bloque operador.",
	"HELP_TEXT_NOT_EQUAL_BODY_2" : "El bloque no igual a es un bloque con forma de diamante, por lo que el resultado del bloque sólo puede ser verdadero o falso.",
	"HELP_TEXT_NOT_EQUAL_EXAMPLE_1_BODY" : "Resultado: verdadero",
	"HELP_TEXT_NOT_EQUAL_EXAMPLE_2_BODY" : "Resultado: falso",
	"HELP_TEXT_NOT_EQUAL_EXAMPLE_3_TITLE" : "¿La variable ''Contador'' no es igual al valor constante 120?",
	"HELP_TEXT_NOT_EQUAL_EXAMPLE_4_TITLE" : "¿El código remoto recibido no es igual al valor constante 3?",
	"HELP_TEXT_IS_BETWEEN_TITLE" : "Está entre",
	"HELP_TEXT_IS_BETWEEN_BODY_1" : "El bloque está entre determina si un valor está dentro de un intervalo de otros dos valores. Los valores pueden ser una constante (introducida en la entrada y que no varía), una variable, un sensor o un bloque operador.",
	"HELP_TEXT_IS_BETWEEN_BODY_2" : "El bloque está entre es un bloque con forma de diamante, por lo que el resultado del bloque sólo puede ser verdadero o falso.",
	"HELP_TEXT_IS_BETWEEN_EXAMPLE_1_BODY" : "Resultado: verdadero",
	"HELP_TEXT_IS_BETWEEN_EXAMPLE_2_BODY" : "Resultado: falso",
	"HELP_TEXT_IS_BETWEENL_EXAMPLE_3_TITLE" : "¿Está la variable ''Contador'' entre el valor constante 60 y el valor constante 120?",
	"HELP_TEXT_IS_BETWEEN_EXAMPLE_4_TITLE" : "¿Está el nivel de luz del sensor izquierdo entre el valor constante 250 y el valor constante 750?",
	"HELP_TEXT_AND_TITLE" : "Y",
	"HELP_TEXT_AND_BODY_1" : "El bloque y determina si dos entradas son ambas verdaderas. Si ambas entradas son verdaderas, el resultado también será verdadero. Si una o ambas entradas son falsas, entonces el resultado será falso. Las entradas aceptan bloques en forma de diamante que pueden ser un bloque operador o un bloque sensor.",
	"HELP_TEXT_AND_BODY_2" : "El bloque y es un bloque con forma de diamante, por lo que el resultado del bloque sólo puede ser verdadero o falso.",
	"HELP_TEXT_AND_EXAMPLE_1_BODY" : "Resultado: verdadero",
	"HELP_TEXT_AND_EXAMPLE_2_BODY" : "Resultado: falso",
	"HELP_TEXT_AND_EXAMPLE_3_TITLE" : "¿Está el seguidor de línea en la superficie reflectante ''y'' se ha detectado la tensión de accionamiento.",
	"HELP_TEXT_AND_EXAMPLE_4_TITLE" : "¿Es la variable 'Contador' mayor que 50 ''y'' el código remoto recibido es igual al valor constante 3.",
	"HELP_TEXT_OR_TITLE" : "O",
	"HELP_TEXT_OR_BODY_1" : "El bloque o determina si la primera entrada ''o'' la segunda son verdaderas. Si una o ambas entradas son verdaderas, entonces el resultado será verdadero. Si ambas entradas son falsas, el resultado será falso. Las entradas aceptan bloques en forma de diamante que pueden ser un bloque operador o un bloque sensor.",
	"HELP_TEXT_OR_BODY_2" : "El bloque o es un bloque con forma de diamante, por lo que el resultado del bloque sólo puede ser verdadero o falso.",
	"HELP_TEXT_OR_EXAMPLE_1_BODY" : "Resultado: verdadero",
	"HELP_TEXT_OR_EXAMPLE_2_BODY" : "Resultado: verdadero",
	"HELP_TEXT_OR_EXAMPLE_3_BODY" : "Resultado: falso",
	"HELP_TEXT_OR_EXAMPLE_4_TITLE" : "¿Está el seguidor de línea en la superficie reflectante ''o'' se ha detectado la tensión de accionamiento.",
	"HELP_TEXT_OR_EXAMPLE_5_TITLE" : "O bien la variable 'Contador' es menor que el valor constante 50 ''o'' el código remoto recibido es igual al valor constante 3.",
	"HELP_TEXT_NOT_TITLE" : "No",
	"HELP_TEXT_NOT_BODY_1" : "El bloque not determina si la entrada ''no'' es verdadera. Si la entrada es falsa, entonces la salida será verdadera. Si la entrada es verdadera, la salida será falsa. La entrada acepta bloques con forma de diamante que pueden ser un bloque operador o un bloque sensor.",
	"HELP_TEXT_NOT_BODY_2" : "El bloque no es un bloque en forma de diamante, por lo que el resultado del bloque sólo puede ser verdadero o falso.",
	"HELP_TEXT_NOT_EXAMPLE_1_BODY" : "Resultado: falso",
	"HELP_TEXT_NOT_EXAMPLE_2_BODY" : "Resultado: verdadero",
	"HELP_TEXT_NOT_EXAMPLE_3_TITLE" : "Es código remoto 0 no recibido.",
	"HELP_TEXT_NOT_EXAMPLE_4_TITLE" : "Ejemplo de programa: Gira con el mando a distancia (funciona mejor con el EdRemote)",
	"HELP_TEXT_NOT_EXAMPLE_4_BODY" : "En este ejemplo, el programa comienza entrando en un bucle para siempre. Dentro del bucle forever, el bloque if then comprueba si se ha recibido el código remoto 0. Si es cierto, ambos motores se ponen en marcha para hacer girar el robot hacia la derecha. Esto continúa hasta que se supera la condición del bloque espera hasta. Para pasar, el código remoto recibido no debe ser el código remoto 0 (ya no se pulsa el botón de control remoto). Cuando esto ocurre, el programa avanza para detener ambos motores y luego vuelve al inicio del bucle ''para siempre''. Esto hace que Edison gire mientras se mantiene pulsado el botón remoto.",
	"HELP_TEXT_COMMENT_TITLE" : "comentario",
	"HELP_TEXT_COMMENT_BODY_1" : "El bloque comentario se utiliza para añadir notas a un programa. Las notas describen en lenguaje sencillo cómo se pretende que funcione el programa. Hacer comentarios en un programa ayuda cuando otra persona necesita editar tu programa o tú necesitas editar tu programa mucho tiempo después de haberlo escrito.",
	"HELP_TEXT_COMMENT_BODY_2" : "Los comentarios no están programados en Edison, por lo que no cambian el comportamiento de tu programa.",
	"HELP_TEXT_COMMENT_EXAMPLE_1_TITLE" : "Ejemplo de programa: Los comentarios explican cómo funciona el programa en lenguaje sencillo",
	"HELP_TEXT_SEND_USB_TITLE" : "enviar por USB",
	"HELP_TEXT_SEND_USB_BODY_1" : "El bloque enviar por USB transmite un valor a un ordenador a través de la conexión USB. El valor puede ser una constante (se teclea en la entrada y no varía), una variable, una detección o un bloque operador.",
	"HELP_TEXT_SEND_USB_BODY_2" : "Para ver el número en el ordenador, haz clic en el botón USB de EdScratch y aparecerá una ventana emergente. Haz clic en Ejecutar USB para conectarte al robot Edison V3. Los datos recibidos de la Edison V3 aparecerán en la ventana Datos desde USB.",
	"HELP_TEXT_SEND_USB_BODY_3" : "El bloque Enviar a USB también puede utilizarse para ayudar a depurar un programa.",
	"HELP_TEXT_SEND_USB_BODY_4" : "Las ruedas de la Edison V3 no se moverán mientras estén conectadas al USB. Esto se debe a las normas de seguridad internacionales que no permiten que los productos destinados a los niños puedan accionar un motor mientras están conectados a un puerto USB.",
	"HELP_TEXT_SEND_USB_EXAMPLE_1_TITLE" : "Ejemplo de programa: Medir el nivel de luz",
	"HELP_TEXT_SEND_USB_EXAMPLE_1_BODY" : "En este ejemplo, el programa comienza entrando en un bucle eterno. El primer bloque dentro del bucle envía el nivel de luz del sensor de luz izquierdo por USB. A continuación, el programa espera un segundo y se repite.",
	"HELP_TEXT_SAVE_USB_TITLE" : "esperar datos USB y guardar en",
	"HELP_TEXT_SAVE_USB_BODY_1" : "El bloque esperar datos USB y guardar en pausa el programa hasta que se reciben los datos por USB y, a continuación, coloca los datos en una variable.",
	"HELP_TEXT_SAVE_USB_BODY_2" : "Las ruedas de la Edison V3 no se moverán mientras estén conectadas al USB. Esto se debe a las normas de seguridad internacionales que no permiten que los productos destinados a los niños puedan accionar un motor mientras están conectados a un puerto USB.",
	"HELP_TEXT_SAVE_USB_EXAMPLE_1_TITLE" : "Ejemplo de programa: Número de pitidos del USB",
	"HELP_TEXT_SAVE_USB_EXAMPLE_1_BODY_1" : "En este ejemplo, el programa comienza entrando en un bucle eterno. El primer bloque dentro del bucle espera hasta que se reciben los datos del USB. Cuando se reciben los datos, se guardan en la variable 'Cuenta'. A continuación, el programa pasa al bloque de repetición que se repite para el valor de la variable 'Cuenta'. Dentro del bloque de repetición se ejecutan los bloques de pitido y de espera. El resultado es que la Edison emite el número de pitidos enviados por USB.",
	"HELP_TEXT_SAVE_USB_EXAMPLE_1_BODY_2" : "Para probar este programa, haz clic en el botón USB de la aplicación EdScratch y aparecerá una ventana emergente. Haz clic en Ejecutar USB para conectarte al robot Edison V3. Para enviar datos a la Edison V3, escribe un número en la casilla Datos a USB y haz clic en el botón Enviar a USB.",
	"HELP_TEXT_FUNCTION_START_TITLE" : "Inicio de función",
	"HELP_TEXT_FUNCTION_START_BODY_1" : "El bloque de inicio de función es donde comienza tu función. Conecta bloques al bloque de inicio de función para crear una función personalizada.",
	"HELP_TEXT_FUNCTION_START_BODY_2" : "Los bloques de función ayudan a simplificar un programa, ya que el código puede agruparse facilitando su lectura. Las funciones también ayudan a reducir el tamaño de un programa, ya que las partes repetitivas de un programa sólo tienen que escribirse una vez.",
	"HELP_TEXT_FUNCTION_START_BODY_3" : "Los bloques de llamada a función no pueden colocarse bajo bloques de inicio de función.",
	"HELP_TEXT_FUNCTION_START_EXAMPLE_1_TITLE" : "Programa de ejemplo 1: Accionamiento en forma de cuadrado",
	"HELP_TEXT_FUNCTION_START_EXAMPLE_1_BODY" : "En este ejemplo, el programa comienza introduciendo un bucle de repetición cuatro veces. Dentro del bloque de repetición hay una llamada a función llamada ''ConducirYGirar''. Cuando el programa llega a este bloque, salta al bloque de inicio de función correspondiente. Dentro de este bloque se ordena al robot que conduzca hacia delante 10 cm, y luego gire a la derecha 90 grados. Esta función se llama cuatro veces dentro del bucle de repetición. El resultado es que Edison se desplaza en cuadrado.",
	"HELP_TEXT_FUNCTION_START_EXAMPLE_2_TITLE" : "Programa de ejemplo 2: Evitar líneas y obstáculos",
	"HELP_TEXT_FUNCTION_START_EXAMPLE_2_BODY" : "En este ejemplo, el programa comienza encendiendo el detector de obstáculos y el LED de seguimiento de líneas y, a continuación, entra en un bucle eterno. Dentro del bucle eterno, ambos motores se configuran para avanzar. A continuación, el bloque if then comprueba si se ha detectado algún obstáculo; si es verdadero, el bloque de llamada a la función ''Dar la vuelta'' hace que el programa salte al bloque de inicio de la función ''Dar la vuelta''. A continuación, el programa detiene los motores, enciende la luz LED, emite un pitido, se desplaza hacia atrás, gira 175 grados y apaga los LED y sale de nuevo al programa principal donde lo dejó. El siguiente bloque if then comprueba si la superficie es antirreflectante (negra), si es cierto, entonces el bloque de llamada a la función ''Dar la vuelta'' hace que el programa salte al bloque de inicio de la función ''Dar la vuelta''. A continuación, el programa detiene los motores, enciende la luz LED, emite un pitido, conduce hacia atrás, gira 175 grados y apaga los LED y sale de nuevo al programa principal donde lo dejó. Esto hace que Edison se aleje de las líneas y objetos que detecta.",
	"HELP_TEXT_FUNCTION_CALL_TITLE" : "Llamada a función",
	"HELP_TEXT_FUNCTION_CALL_BODY_1" : "El bloque de llamada a función indica al programa que salte al bloque de inicio de función.",
};
Blockly.ScratchMsgs.locales['de'] ={
	"CONTROL_FOREVER" : "für immer",
	"CONTROL_REPEAT" : "wiederholen",
	"CONTROL_IF" : "wenn",
	"CONTROL_THAN" : "dann",
	"CONTROL_ELSE" : "sonst",
	"CONTROL_STOP" : "stoppen",
	"CONTROL_STOP_ALL" : "alle",
	"CONTROL_WAIT" : "warten",
	"CONTROL_WAIT_SEC" : "sec",
	"CONTROL_WAIT_MILLISECONDS" : "Millisekunden",
	"CONTROL_WAITUNTIL" : "warten bis",
	"CONTROL_REPEATUNTIL" : "wiederholen bis",
	"DATA_BUTTONCREATE" : "Eine Variable erstellen",
	"DATA_BUTTONMANAGE" : "Variablen verwalten",
	"DATA_SET" : "setzen",
	"DATA_TO" : "auf",
	"DATA_INCVARIABLE" : "inkrementieren",
	"DATA_DECVARIABLE" : "dekrementieren",
	"DATA_BITSHIFT" : "Bitverschiebung",
	"DATA_BITSHIFTLEFT" : "links um",
	"DATA_BITSHIFTRIGHT" : "rechts um",
	"EVENT_ANY_OBSTACLE" : "Jedes Hindernis erkannt",
	"EVENT_OBSTACLE_AHEAD" : "Hindernis voraus erkannt",
	"EVENT_OBSTACLE_LEFT" : "Hindernis links erkannt",
	"EVENT_OBSTACLE_RIGHT" : "Hindernis rechts erkannt",
	"EVENT_CLAP" : "Klatschen erkannt",
	"EVENT_BUTTON_TRIANGLE" : "Dreieckige Taste gedrückt",
	"EVENT_BUTTON_ROUND" : "Runde Taste gedrückt",
	"EVENT_LINE_REFLECTIVE" : "Linientracker auf reflektierender Oberfläche",
	"EVENT_LINE_NON_REFLECTIVE" : "Linientracker auf nicht reflektierender Oberfläche",
	"EVENT_LINE_CHANGE" : "Linienverfolger wechselt Oberfläche",
	"EVENT_MESSAGE" : "IR-Nachricht empfangen",
	"EVENT_REMOTE" : "Fernbedienungscode empfangen",
	"EVENT_DRIVE_STRAIN" : "Antrieb angespannt",
	"EVENT_START" : "Start",
	"OPERATORS_RANDOM" : "Zufallszahl zwischen",
	"OPERATORS_AND" : "und",
	"OPERATORS_OR" : "oder",
	"OPERATORS_NOT" : "nicht",
	"OPERATORS_ABS" : "abs",
	"OPERATORS_BETWEEN" : "ist zwischen",
	"SENSING_TURN_LINE_TRACKING_LED" : "Abbiegelinienverfolgung LED",
	"SENSING_TURN_OBSTACLE_BEAM" : "Abbiegen Hinderniserkennung Strahl",
	"SENSING_CLEAR" : "klar",
	"SENSING_SENSOR" : "Sensordaten",
	"SENSING_CLAP_DETECTED" : "Klatschen erkannt",
	"SENSING_BUTTON_PRESSED" : "Taste gedrückt",
	"SENSING_OBSTACLE" : "Hindernis erkannt",
	"SENSING_LINE_TRACKER" : "Linienverfolger an",
	"SENSING_LINE_SURFACE" : "Oberfläche",
	"SENSING_REMOTE_NUM" : "Fernbedienungscode empfangen",
	"SENSING_REMOTE_BOOL" : "Fernbedienungscode",
	"SENSING_REMOTE_RECEIVED" : "empfangen",
	"SENSING_IR_MESSAGE_DETECTED" : "IR-Nachricht erkannt",
	"SENSING_IR_MESSAGE" : "Empfangene IR-Nachricht",
	"SENSING_LIGHT_LEVEL" : "Lichtstärke des",
	"SENSING_LIGHT_SENSOR" : "Sensor",
	"SENSING_DRIVE_STRAIN" : "Antriebsbelastung erkannt",
	"SENSING_DROPDOWN_ON" : "ein",
	"SENSING_DROPDOWN_OFF" : "aus",
	"SENSING_CLEAR_DROPDOWN_CLAP" : "Klatschdetektor",
	"SENSING_CLEAR_DROPDOWN_KEY" : "Tastenfeld",
	"SENSING_CLEAR_DROPDOWN_OBS" : "Hindernisdetektor",
	"SENSING_CLEAR_DROPDOWN_REMOTE" : "Fernbedienungscode",
	"SENSING_CLEAR_DROPDOWN_IR" : "IR-Nachricht",
	"SENSING_KEY_DROPDOWN_ROUND" : "rund",
	"SENSING_KEY_DROPDOWN_TRIANGLE" : "Dreieck",
	"SENSING_OBS_DROPDOWN_ANY" : "überall",
	"SENSING_OBS_DROPDOWN_AHEAD" : "voraus",
	"SENSING_OBS_DROPDOWN_LEFT" : "links",
	"SENSING_OBS_DROPDOWN_RIGHT" : "rechts",
	"SENSING_LINE_DROPDOWN_WHITE" : "reflektierend",
	"SENSING_LINE_DROPDOWN_BLACK" : "nicht-reflektierend",
	"SENSING_LIGHT_DROPDOWN_LEFT" : "linkes Licht",
	"SENSING_LIGHT_DROPDOWN_RIGHT" : "rechtes Licht",
	"SENSING_LIGHT_DROPDOWN_LINE" : "Linienverfolgung",
	"COMMENT_USER_COMMENT" : "Kommentar:",
	"ADVANCED_USB_SEND_DATA" : "senden",
	"ADVANCED_USB_SEND_VIA" : "über USB",
	"ADVANCED_USB_RECEIVED_DATA" : "Daten von USB empfangen",
	"ADVANCED_USB_RECEIVED_DATA_VAR" : "Warte auf USB-Daten und speichere in",
	"SOUND_BEEP" : "piepsen",
	"SOUND_PLAY_NOTE" : "Abspielen einer",
	"SOUND_PLAY_NOTE_DROP_DURATION_WHOLE" : "ganzes",
	"SOUND_PLAY_NOTE_DROP_DURATION_HALF" : "halb",
	"SOUND_PLAY_NOTE_DROP_DURATION_QUARTER" : "Viertel",
	"SOUND_PLAY_NOTE_DROP_DURATION_EIGHTH" : "Achtel",
	"SOUND_PLAY_NOTE_DROP_NOTE_C" : "C",
	"SOUND_PLAY_NOTE_DROP_NOTE_B" : "B",
	"SOUND_PLAY_NOTE_DROP_NOTE_A" : "A",
	"SOUND_PLAY_NOTE_DROP_NOTE_G" : "G",
	"SOUND_PLAY_NOTE_DROP_NOTE_F" : "F",
	"SOUND_PLAY_NOTE_DROP_NOTE_E" : "E",
	"SOUND_PLAY_NOTE_DROP_NOTE_D" : "D",
	"SOUND_PLAY_NOTE_DROP_NOTE_MID_C" : "mittleres C",
	"SOUND_PLAY_NOTE_DROP_NOTE_LOW_B" : "tiefes B",
	"SOUND_PLAY_NOTE_DROP_NOTE_REST" : "Rest",
	"SOUND_PLAY_NOTE_DROP_MOD_SHARP" : "scharf",
	"SOUND_PLAY_NOTE_DROP_MOD_FLAT" : "flach",
	"SOUND_SET_TEMPO" : "Musiktempo einstellen auf",
	"SOUND_SET_TEMPO_DROP_VERY_SLOW" : "sehr langsam",
	"SOUND_SET_TEMPO_DROP_SLOW" : "langsam",
	"SOUND_SET_TEMPO_DROP_MEDIUM" : "mittel",
	"SOUND_SET_TEMPO_DROP_FAST" : "schnell",
	"SOUND_SET_TEMPO_DROP_VERY_FAST" : "sehr schnell",
	"SOUND_PLAY_IN_BACKGROUND" : "Musik im Hintergrund abspielen",
	"CATEGORY_SOUND" : "Sound",
	"CATEGORY_EVENTS" : "Ereignisse",
	"CATEGORY_CONTROL" : "Steuerung",
	"CATEGORY_SENSING" : "Sensing",
	"CATEGORY_OPERATORS" : "Operatoren",
	"CATEGORY_VARIABLES" : "Variablen",
	"CATEGORY_MYBLOCKS" : "Funktionen",
	"CATEGORY_DRIVE" : "Antrieb",
	"CATEGORY_COMMENT" : "Kommentar",
	"CATEGORY_LED" : "LEDs",
	"CATEGORY_ADVANCED" : "Erweitert",
	"DUPLICATE" : "Duplizieren",
	"DELETE" : "Löschen",
	"DELETE_BLOCK" : "Block löschen",
	"CONTEXT_DELETE" : "Löschen",
	"CONTEXT_DELETE_ALL" : "Alle löschen",
	"CONTEXT_BLOCKS" : "Blöcke",
	"CLEAN_UP" : "Blöcke bereinigen",
	"HELP" : "Hilfe",
	"UNDO" : "Rückgängig machen",
	"REDO" : "Wiederholen",
	"CHANGE_VALUE_TITLE" : "Wert ändern:",
	"RENAME_VARIABLE" : "Variable umbenennen",
	"RENAME_VARIABLE_MODAL_TITLE" : "Variable umbenennen",
	"NEW_VARIABLE" : "Eine Variable erstellen",
	"NEW_VARIABLE_TITLE" : "Neuer Variablenname:",
	"VARIABLE_MODAL_TITLE" : "Neue Variable",
	"NEW_PROCEDURE" : "Eine Funktion erstellen",
	"MANAGE_PROCEDURE" : "Verwalten einer Funktion",
	"PROCEDURE_DEFAULT_NAME" : "Blockname",
	"PROCEDURE_USED" : "Um eine Blockdefinition zu löschen, entferne zunächst alle Verwendungen des Blocks",
	"DRIVE_FORWARDS_DISTANCE" : "vorwärts für",
	"DRIVE_BACKWARDS_DISTANCE" : "rückwärts für",
	"DRIVE_LEFT_DISTANCE" : "links für",
	"DRIVE_RIGHT_DISTANCE" : "rechts für",
	"DRIVE_DISTANCE_DROPDOWN_CM" : "cm",
	"DRIVE_DISTANCE_DROPDOWN_INCH" : "Zoll",
	"DRIVE_DISTANCE_DROPDOWN_SECONDS" : "Sekunden",
	"DRIVE_DISTANCE_DROPDOWN_DEGREES" : "Grad",
	"DRIVE_TURN_DROPDOWN_SPIN" : "drehen",
	"DRIVE_TURN_DROPDOWN_FORWARDS" : "vorwärts drehen",
	"DRIVE_TURN_DROPDOWN_BACKWARDS" : "rückwärts drehen",
	"DRIVE_FORWARDS_UNTIL" : "vorwärts bis",
	"DRIVE_BACKWARDS_UNTIL" : "rückwärts bis",
	"DRIVE_LEFT_UNTIL" : "links bis",
	"DRIVE_RIGHT_UNTIL" : "rechts bis",
	"DRIVE_SET_LEFT_MOTOR" : "Linken Motor einstellen auf",
	"DRIVE_SET_RIGHT_MOTOR" : "rechten Motor einstellen auf",
	"DRIVE_SET_MOTOR_DROPDOWN_FORWARDS" : "vorwärts",
	"DRIVE_SET_MOTOR_DROPDOWN_BACKWARDS" : "rückwärts",
	"DRIVE_SET_BOTH_MOTOR" : "beide Motoren einstellen auf",
	"DRIVE_SET_BOTH_MOTOR_DROPDOWN_FORWARDS" : "vorwärts fahren",
	"DRIVE_SET_BOTH_MOTOR_DROPDOWN_BACKWARDS" : "rückwärts fahren",
	"DRIVE_SET_BOTH_MOTOR_DROPDOWN_SPIN_LEFT" : "Roboter links drehen",
	"DRIVE_SET_BOTH_MOTOR_DROPDOWN_SPIN_RIGHT" : "Roboter rechts drehen",
	"DRIVE_SET_BOTH_MOTOR_DROPDOWN_TURN_LEFT" : "Roboter links drehen",
	"DRIVE_SET_BOTH_MOTOR_DROPDOWN_TURN_RIGHT" : "Roboter rechts drehen",
	"DRIVE_AT_SPEED" : "mit Geschwindigkeit",
	"DRIVE_STOP" : "stoppen",
	"DRIVE_STOP_DROPDOWN_BOTH" : "beide Motoren",
	"DRIVE_STOP_DROPDOWN_LEFT" : "linker Motor",
	"DRIVE_STOP_DROPDOWN_RIGHT" : "rechter Motor",
  "LED_LEFT" : "linke LED",
  "LED_RIGHT" : "rechte LED",
	"LED_DROPDOWN_ON" : "ein",
	"LED_DROPDOWN_OFF" : "aus",
	"LED_SEND_MESSAGE" : "IR-Nachricht senden",
	"DEMO_TEST_PROGRAM" : "Testprogramm",
	"DEMO_TEST_PROGRAM_DISC" : "Testet Antrieb, LEDs und Lautsprecher",
	"DEMO_MOVE_WITH_MUSIC" : "Fahren mit Musik",
	"DEMO_MOVE_WITH_MUSIC_DISC" : "Fahren während Musik gespielt wird",
	"DEMO_FOLLOW_A_LINE" : "Einer Linie folgen",
	"DEMO_FOLLOW_A_LINE_DISC" : "Benutze den Zeilensensor, um einer schwarzen Linie zu folgen",
	"DEMO_BOUNCE_IN_BORDERS" : "In Grenzen hüpfen",
	"DEMO_BOUNCE_IN_BORDERS_DISC" : "Verwende den Zeilensensor, um innerhalb einer schwarzen Linie zu bleiben",
	"DEMO_WARNINGS" : "Warnmeldungen Demo",
	"DEMO_WARNINGS_DISC" : "Zeigt rote Fehlermeldungen und gelbe Warnmeldungen",
	"DEMO_CLAP_CONTROL" : "Klatschgesteuertes Fahren",
	"DEMO_CLAP_CONTROL_DISC" : "Klatsche einmal, um zu wenden, klatsche zweimal, um vorwärts zu fahren",
	"DEMO_AVOID_OBSTACLES" : "Hindernisse meiden",
	"DEMO_AVOID_OBSTACLES_DISC" : "Benutze den Hindernissensor, um zu vermeiden, in Hindernisse zu fahren",
	"DEMO_FOLLOW_TORCH" : "Folge einer Taschenlampe",
	"DEMO_FOLLOW_TORCH_DISC" : "Verwende die Lichtsensoren, um einer Taschenlampe zu folgen",
	"DEMO_FOLLOW_A_LINE_IF" : "Folge einer Linie mit if-Anweisungen",
	"DEMO_FOLLOW_A_LINE_IF_DISC" : "Eine andere Möglichkeit, den Zeilensensor zu verwenden, um einer Linie mit Hilfe eines if-Blocks zu folgen",
	"MENU_DROP_MENU" : "Menü",
	"MENU_DROP_NEW" : "Neu",
	"MENU_DROP_LOAD_DEMO" : "Demo laden",
	"MENU_DROP_LOAD_LOCAL" : "Vom Computer laden",
	"MENU_DROP_SAVE_LOCAL" : "Auf dem Computer speichern",
	"MENU_DROP_UPDATE_FIRMWARE" : "Firmware aktualisieren",
	"MENU_DROP_DIAGNOSTICS" : "Diagnose",
	"MENU_DROP_LANGUAGE_LABEL" : "Sprache",
	"MENU_DROP_ABOUT" : "Über",
	"MENU_DROP_TERMS" : "Nutzungsbedingungen",
	"MENU_USB" : "USB",
	"MENU_SAVE" : "Speichern",
	"MENU_VERSION_MAIN" : "Edison V3",
	"MENU_VERSION_SWITCH" : "Zu Edison V1/V2 wechseln",
	"MENU_VERSION_WHICH_VERSION" : "Welche Version habe ich?",
	"MENU_PROGRAM" : "Programmieren",
	"MENU_PROGRAM_FLASH" : "Programmieren",
	"MODAL_CREATE_VAR" : "Variable erstellen",
	"MODAL_CREATE_VAR_NAME" : "Variablenname",
	"MODAL_CREATE_VAR_BUTTON" : "Variable erstellen",
	"MODAL_CREATE_VAR_EXIT" : "Beenden",
	"MODAL_CREATE_VAR_SUCCESS" : "Neue Variable erfolgreich erstellt.",
	"MODAL_MANAGE_VAR" : "Variablen",
	"MODAL_MANAGE_VAR_NAME" : "Variablenname",
	"MODAL_MANAGE_VAR_ACTION" : "Aktion",
	"MODAL_MANAGE_VAR_BUTTON_DELETE" : "löschen",
	"MODAL_MANAGE_VAR_BUTTON_RENAME" : "umbenennen",
	"MODAL_MANAGE_VAR_BUTTON_CONFIRM" : "bestätigen",
	"MODAL_MANAGE_VAR_BUTTON_CANCEL" : "Abbrechen",
	"MODAL_MANAGE_VAR_CONFIRM_NOT_CHANGED" : "Du hast den Variablennamen nicht geändert. Bitte versuche es erneut.",
	"MODAL_MANAGE_VAR_CONFIRM_SUCCESS" : "Variable erfolgreich umbenannt!",
	"MODAL_MANAGE_VAR_NAME_NONE" : "Bitte gib einen Variablennamen ein.",
	"MODAL_MANAGE_VAR_NAME_IN_USE" : "Du hast bereits eine Variable mit diesem Namen.",
	"MODAL_MANAGE_VAR_NAME_UNSUPPORTED" : "Der Variablenname enthält ein nicht unterstütztes Zeichen. Variablennamen dürfen nur englische Kleinbuchstaben, englische Großbuchstaben, Zahlen und Unterstriche ( _ ) enthalten.",
	"MODAL_MANAGE_VAR_NAME_NUMBER_START" : "Variablennamen können nicht mit einer Zahl beginnen.",
	"MODAL_MANAGE_VAR_DELETE_IN_USE" : "Diese Variable wird zurzeit in deinem Programm verwendet. Bist du sicher, dass du sie löschen möchtest?",
	"MODAL_MANAGE_VAR_DELETE_CONFIRM" : "Ja",
	"MODAL_MANAGE_VAR_DELETE_DECLINE" : "Nein",
	"MODAL_CREATE_FUNCT" : "Funktion erstellen",
	"MODAL_CREATE_FUNCT_NAME" : "Funktionsname",
	"MODAL_CREATE_FUNCT_WARNING" : "Nur alphanumerische Zeichen und muss mit einem Buchstaben beginnen.",
	"MODAL_CREATE_FUNCT_BUTTON" : "Funktion erstellen",
	"MODAL_CREATE_FUNCT_BUTTON_EXIT" : "Beenden",
	"MODAL_CREATE_FUNCT_SUCCESS" : "Neue Funktion erfolgreich erstellt.",
	"MODAL_MANAGE_FUNCT" : "Funktionen",
	"MODAL_MANAGE_FUNCT_NAME" : "Funktionsname",
	"MODAL_MANAGE_FUNCT_ACTION" : "Aktion",
	"MODAL_MANAGE_FUNCT_BUTTON_DELETE" : "löschen",
	"MODAL_MANAGE_FUNCT_BUTTON_RENAME" : "umbenennen",
	"MODAL_MANAGE_FUNCT_BUTTON_CONFIRM" : "bestätigen",
	"MODAL_MANAGE_FUNCT_BUTTON_CANCEL" : "Abbrechen",
	"MODAL_MANAGE_FUNCT_CONFIRM_NOT_CHANGED" : "Du hast den Funktionsnamen nicht geändert. Bitte versuche es erneut.",
	"MODAL_MANAGE_FUNCT_CONFIRM_SUCCESS" : "Funktion erfolgreich umbenannt!",
	"MODAL_MANAGE_FUNCT_NAME_NONE" : "Bitte gib einen Funktionsnamen ein.",
	"MODAL_MANAGE_FUNCT_NAME_IN_USE" : "Du hast bereits eine Funktion mit diesem Namen.",
	"MODAL_MANAGE_FUNCT_NAME_START_WITH" : "Benutzerfunktionsnamen können nicht mit",
	"MODAL_MANAGE_FUNCT_NAME_UNSUPPORTED" : "Der Funktionsname enthält ein nicht unterstütztes Zeichen. Funktionsnamen dürfen nur englische Kleinbuchstaben, englische Großbuchstaben, Zahlen und Unterstriche ( _ ) enthalten.",
	"MODAL_MANAGE_FUNCT_NAME_NUMBER_START" : "Funktionsnamen können nicht mit einer Zahl beginnen.",
	"MODAL_MANAGE_FUNCT_DELETE_IN_USE" : "Diese Funktion wird zurzeit in deinem Programm verwendet. Bist du sicher, dass du sie löschen willst?",
	"MODAL_MANAGE_FUNCT_DELETE_CONFIRM" : "Ja",
	"MODAL_MANAGE_FUNCT_DELETE_DECLINE" : "Nein",
	"MODAL_SAVE_TITLE" : "Auf dem Computer speichern",
	"MODAL_SAVE_PROG_TITLE" : "Programmname",
	"MODAL_SAVE_BUTTON" : "Auf dem Computer speichern",
	"MODAL_SAVE_ERROR_NO_NAME" : "Bitte gib einen Namen für dein Programm ein. Du musst das Programm benennen, um es speichern zu können.",
	"MODAL_SAVE_ERROR_LONG_NAME" : "Hoppla. Es gibt ein Problem mit dem Programmnamen. Programmnamen dürfen maximal 255 Zeichen lang sein.",
	"MODAL_SAVE_SAVING" : "OK! Dein Programm wird jetzt gespeichert. Der Download deines Programms sollte bald beginnen.",
	"MODAL_LOAD_PC_TITLE" : "Vom Computer laden",
	"MODAL_LOAD_PC_FILE_ERROR_1" : "Bitte wähle eine EdScratch-Speicherdatei aus.",
	"MODAL_LOAD_PC_FILE_ERROR_2" : "Alle EdScratch-Speicherdateien haben den Dateityp",
	"MODAL_LOAD_PC_FILE_ERROR_3" : ".edscratch",
	"MODAL_LOAD_PC_FILE_BUTTON" : "Wähle eine Datei zum Hochladen...",
	"MODAL_LOAD_PC_BUTTON" : "Programm laden",
	"MODAL_LOAD_PC_NO_FILE_ERROR_1" : "Du hast noch keine Datei ausgewählt. Bitte wähle zuerst eine EdScratch-Speicherdatei von deinem Computer aus und lade dann die Datei. [Alle EdScratch-Speicherdateien sind vom Dateityp (.edscratch)].",
	"MODAL_LOAD_PC_FILE_DATA_ERROR_1" : "Oh-oh. Es gibt ein Problem mit den Daten in dieser Datei.",
	"MODAL_LOAD_PC_FILE_DATA_ERROR_2" : "Bitte lade eine andere EdScratch-Speicherdatei hoch. [Alle EdScratch-Speicherdateien haben den Dateityp (.edscratch).",
	"MODAL_LOAD_PC_FILE_TYPE_ERROR_1" : "Oh-oh. Du hast einen falschen Dateityp hochgeladen.",
	"MODAL_LOAD_PC_FILE_TYPE_ERROR_2" : "Bitte lade eine EdScratch-Speicherdatei hoch. [Alle EdScratch-Speicherdateien haben den Dateityp (.edscratch)].",
	"MODAL_LOAD_PC_FILE_READY" : "Bereit zum Laden des Programms:",
	"MODAL_LOAD_DEMO_TITLE" : "Demo laden",
	"MODAL_LOAD_DEMO_BUTTON" : "Programm laden",
  "MODAL_COOKIES_TITLE" : "Cookies",
  "MODAL_COOKIES_BODY_1" : "Wir verwenden Google Analytics, um zu messen, wie Besucher diese Webanwendung nutzen, damit wir sie entsprechend den Bedürfnissen der Nutzer verbessern können. Zum Beispiel, welche Optionen Besucher am häufigsten verwenden und ob sie Fehlermeldungen von der Web-App erhalten. Diese Cookies sammeln keine Informationen, die einen Besucher identifizieren.",
  "MODAL_COOKIES_BODY_2" : "Wir gestatten Google nicht, die Daten darüber, wie Sie diese Website nutzen, zu verwenden oder weiterzugeben, und alle Informationen, die diese Cookies sammeln, sind aggregiert und daher anonym. Sie werden nur verwendet, um die Funktionsweise der Webanwendung zu verbessern. Dieses Cookie wird für einen Zeitraum von einem Jahr gespeichert.",
  "MODAL_COOKIES_ACCEPT" : "Cookies akzeptieren",
  "MODAL_COOKIES_BUTTON_YES" : "Ja",
  "MODAL_COOKIES_BUTTON_NO" : "Nein",
  "MODAL_ABOUT_TITLE" : "Über EdScratch",
	"MODAL_ABOUT_COPYRIGHT" : "Copyright 2023 Microbric Pty Ltd",
	"MODAL_ABOUT_BODY_1" : "Die EdScratch-App wurde mit der vom MIT entwickelten Codebasis Scratch Blocks entwickelt. Scratch Blocks wurde auf der von Google entwickelten Blockly-Codebasis aufgebaut.",
	"MODAL_ABOUT_BODY_2" : "Beiträge und Credits:",
	"MODAL_ABOUT_BODY_3" : "EdScratch Programmiersprache und Block-Compiler entwickelt von Ben Hayton, Microbric",
	"MODAL_ABOUT_BODY_4" : "Die EdScratch-Benutzeroberfläche wurde von Sean Killian, Killian Web Development, entwickelt.",
	"MODAL_ABOUT_BODY_5" : "Die Edison V3-Firmware wurde von Damien George, George Robotics, entwickelt (MicroPython-Codebasis)",
	"MODAL_LANGUAGE" : "Sprache",
	"MODAL_DIAGNOSTICS" : "Diagnose",
	"MODAL_DIAGNOSTICS_CONNECT_ISSUES_TITLE" : "Konnektivitätsprobleme",
	"MODAL_DIAGNOSTICS_CONNECT_ISSUES_BODY" : "Um sicherzustellen, dass dein Programm kompiliert und an den Edison-Roboter gesendet werden kann, solltest du deine Verbindung mit dem EdScratch-Compiler überprüfen.",
	"MODAL_DIAGNOSTICS_CONNECT_ISSUES_BUTTON" : "Führe den Verbindungschecker aus",
	"MODAL_DIAGNOSTICS_FIRMWARE_TITLE" : "Firmware reparieren",
	"MODAL_DIAGNOSTICS_FIRMWARE_BODY" : "Wenn sich Edison V3 nicht wie erwartet verhält, könnte es ein Problem mit der Firmware sein. Klicke auf Firmware reparieren, um ein Firmware-Update durchzuführen.",
	"MODAL_DIAGNOSTICS_FIRMWARE_BUTTON" : "Firmware reparieren",
	"MODAL_DIAGNOSTICS_PROGRAMMING_TITLE" : "Programmiermethode",
	"MODAL_DIAGNOSTICS_PROGRAMMING_BODY" : "Mit dieser Option kannst du bei diesem Gerät zwischen USB- und Bildschirm-Flash-Programmierung umschalten.",
	"MODAL_DIAGNOSTICS_PROGRAMMING_BUTTON" : "Programmiermethode ändern",
	"MODAL_DIAGNOSTICS_IR_TITLE" : "Gelernte IR-Fernbedienungsbefehle löschen",
	"MODAL_DIAGNOSTICS_IR_BODY" : "Mit dieser Option kannst du alle gelernten IR-Fernbedienungsbefehle von einem Edison V3 Roboter löschen.",
	"MODAL_DIAGNOSTICS_IR_BUTTON" : "Fernbedienungscodes löschen",
	"MODAL_DIAGNOSTICS_IR_SUCCESS" : "Die Fernbedienungscodes wurden gelöscht.",
	"MODAL_DIAGNOSTICS_IR_ERROR" : "Es ist ein Fehler aufgetreten.",
	"MODAL_CONNECTION" : "Verbindung",
	"MODAL_CONNECTION_TEST_1" : "Wenn der obige Test das Ergebnis hat",
	"MODAL_CONNECTION_TEST_EXAMPLE" : "KEIN SERVER GEFUNDEN",
	"MODAL_CONNECTION_TEST_2" : "dann blockiert möglicherweise eine Firewall den Zugriff auf den Compiler.",
	"MODAL_CONNECTION_TEST_3" : "Bitten Sie Ihren Netzwerkadministrator, diese Adressen auf eine Whitelist zu setzen, um dies zu beheben:",
	"MODAL_CONNECTION_PORTS" : "Der Netzwerkadministrator muss auch die Ports 80, 8080, 443 und 8443 freischalten.",
	"MODAL_CONNECTION_BACK" : "Zurück zur Diagnose",
	"MODAL_CONNECTION_SERVER" : "Server:",
	"MODAL_CONNECTION_SERVER_SEARCHING" : "Suche",
	"MODAL_CONNECTION_SERVER_NONE" : "KEIN SERVER GEFUNDEN",
	"MODAL_CONNECTION_COMIPLE_TEST" : "Kompiliertest:",
	"MODAL_CONNECTION_COMIPLE_TEST_WORKING" : "funktioniert",
	"MODAL_CONNECTION_COMIPLE_TEST_ERROR" : "Fehler beim Kompilieren",
	"MODAL_CONNECTION_COMIPLE_TEST_COMPLETE" : "Kompilieren abgeschlossen in",
	"MODAL_STATUS_TITLE" : "Firmware reparieren",
	"MODAL_STATUS_BUTTON" : "Edison verbinden",
	"MODAL_STATUS_STATUS_LABEL" : "Status:",
	"MODAL_STATUS_STATUS_NOT_CONNECTED" : "nicht verbunden",
	"MODAL_STATUS_STATUS_CONNECTED" : "verbunden",
	"MODAL_STATUS_FIRMWARE_LABEL" : "Firmware Version:",
	"MODAL_STATUS_FIRMWARE_BOOT_MODE" : "Bootloader-Modus",
	"MODAL_STATUS_FIRMWARE_FACTORY_MODE" : "Werksanwendungsmodus",
	"MODAL_STATUS_FIRMWARE_USER_MODE" : "Benutzeranwendungsmodus",
	"MODAL_STATUS_FIRMWARE_TAG" : "firmware",
	"MODAL_STATUS_BOOT_TAG" : "boot",
	"MODAL_STATUS_FIRMWARE_UPDATE" : "Ein Firmware-Update",
	"MODAL_STATUS_FIRMWARE_UPDATE_AVAILABLE" : "ist verfügbar",
	"MODAL_STATUS_BOOT_UPDATE" : "Ein Boot-Update",
	"MODAL_STATUS_FIRMWARE_UPDATE_BUTTON" : "Firmware-Update erzwingen",
	"MODAL_STATUS_FIRMWARE_UP_TO_DATE" : "Dein Edison ist auf dem neuesten Stand.",
	"MODAL_PROGRAMING_METHOD_TITLE" : "Programmiermethode",
	"MODAL_PROGRAMING_METHOD_BODY" : "Die Bildschirm-Flash-Programmierung wurde für Apple iPads entwickelt. Das liegt daran, dass Apple keinen normalen Zugriff auf den Datenport des iPads zulässt. Daher wird die Bildschirmflash-Programmierung nur für iPads vollständig unterstützt. Der Screen-Flash funktioniert jedoch auch mit einigen Android-Geräten. Die unten stehende Option aktiviert die Bildschirmflash-Programmierung auf diesem Gerät. Wenn es sich bei dem Gerät nicht um ein iPad handelt, funktioniert es nicht garantiert.",
	"MODAL_PROGRAMING_METHOD_CURRENT_LABEL" : "Derzeit verwendet",
	"MODAL_PROGRAMING_METHOD_CURRENT_LABEL_USB" : "USB",
	"MODAL_PROGRAMING_METHOD_CURRENT_LABEL_FLASH" : "FLASH",
	"MODAL_PROGRAMING_METHOD_CURRENT_LABEL_METHOD" : "Methode.",
	"MODAL_PROGRAMING_METHOD_BUTTON_USB" : "Auf USB-Methode einstellen",
	"MODAL_PROGRAMING_METHOD_BUTTON_FLASH" : "Auf FLASH-Methode umstellen",
	"MODAL_PROGRAMING_METHOD_ACCORD_BUTTON_FLASH_GUARANTEE" : "Warum funktioniert das Bildschirmflashen bei Android-Geräten nicht garantiert?",
	"MODAL_PROGRAMING_METHOD_ACCORD_BODY_FLASH_GUARANTEE" : "Android-Geräte werden von vielen verschiedenen Herstellern produziert und es gibt Tausende von verschiedenen Modellen. Das bedeutet, dass es auch eine Menge verschiedener Bildschirmtechnologien gibt. Es ist nicht möglich, das Bildschirmflashen für alle Android-Geräte zu testen und anzupassen.",
	"MODAL_PROGRAMING_METHOD_ACCORD_BUTTON_FLASH_SETTINGS" : "Gibt es Einstellungen, die helfen, dass mein Android-Gerät mit dem Bildschirmflashen funktioniert?",
	"MODAL_PROGRAMING_METHOD_ACCORD_BODY_FLASH_SETTINGS" : "Ja, im Popup-Fenster für das Bildschirmflashen gibt es eine Einstellung für zuverlässig/schnell, die vier Positionen hat. Probiere jede der vier Positionen aus. Versuche auch, die Bildschirmhelligkeit einzustellen. Teste mit 50%, 75%, 90% und 100% Helligkeit.",
	"MODAL_PROGRAMING_METHOD_ACCORD_BUTTON_FLASH_FAIL" : "Was mache ich, wenn das Blinken des Bildschirms auf meinem Android-Gerät nicht funktioniert?",
	"MODAL_PROGRAMING_METHOD_ACCORD_BODY_FLASH_FAIL" : "Um zu programmieren, musst du das Edison V3-Kabel über ein Adapterkabel an den Datenanschluss deines Android-Geräts anschließen. Diese sind häufig und günstig bei ebay, Amazon usw. erhältlich.",
	"MODAL_PROGRAMING_METHOD_BACK" : "Zurück zur Diagnose",
	"MODAL_PROGRAMING_TITLE" : "Programmierung",
	"MODAL_PROGRAMING_TITLE_COMPLETE" : "Programmierung abgeschlossen",
	"MODAL_PROGRAMING_TITLE_ERROR" : "Fehler beim Programmieren",
	"MODAL_PROGRAMING_TIP_1_TITLE" : "Tipp: Häufe Edison-Roboter nicht an einem USB-Hub an!",
	"MODAL_PROGRAMING_TIP_1_TEXT" : "Verwende stattdessen einen EdCharger.",
	"MODAL_PROGRAMING_TIP_2_TITLE" : "Tipp: Lass Edison nicht hängen!",
	"MODAL_PROGRAMING_TIP_2_TEXT" : "Stütze Edison auf einer festen Oberfläche ab.",
	"MODAL_PROGRAMING_TIP_3_TITLE" : "Tipp: Lass Edison nicht hängen!",
	"MODAL_PROGRAMING_TIP_3_TEXT" : "Verwende ein Verlängerungskabel, wenn du ihn über eine Steckdose auflädst.",
	"MODAL_PROGRAMING_TIP_4_TITLE" : "Tipp: Zieh nicht an Edison!",
	"MODAL_PROGRAMING_TIP_4_TEXT" : "Ziehe beim Ausstecken am USB-Kabel, nicht am Roboter.",
	"MODAL_PROGRAMING_ERROR_NO_BLOCK" : "Der Download kann nicht durchgeführt werden, wenn keine Blöcke mit dem Startblock verbunden sind.",
	"MODAL_PROGRAMING_ERROR_RED" : "Kann bei roten Fehlern nicht herunterladen.",
	"MODAL_PROGRAMING_UPDATE_FIRMWARE" : "Um deinen Edison zu programmieren, musst du die Firmware auf die neueste Version aktualisieren",
	"MODAL_PROGRAMING_UPDATE_FIRMWARE_BUTTON" : "Firmware aktualisieren",
	"MODAL_PROGRAMING_UPDATE_FIRMWARE_NOW" : "Firmware-Update erforderlich. Aktualisiere jetzt...",
	"MODAL_PROGRAMING_FIRMWARE_UPDATED" : "Firmware aktualisiert.",
	"MODAL_PROGRAMING_FIRMWARE_UPDATED_NOW_PROGRAMMING" : "Edison wird jetzt programmiert...",
	"MODAL_PROGRAMING_FIRMWARE_UPDATE_INCOMPLETE" : "Unvollständiges Firmware-Update.",
	"MODAL_PROGRAMING_DONE" : "OK! Das Programm wurde auf dein Edison geladen.",
	"MODAL_PROGRAMING_ERROR_JSON" : "Die Antwort ist nicht JSON!",
	"MODAL_PROGRAMING_ERROR_UNKNOWN" : "Unbekannter Fehler!",
	"MODAL_FIRMWARE_UPDATE_TITLE" : "Firmware-Update",
	"MODAL_FIRMWARE_UPDATE_LATEST" : "Die neueste Edison V3-Firmware-Version ist:",
	"MODAL_FIRMWARE_UPDATE_POPUP" : "Benutze dieses Pop-up, um die Firmware in deinem Edison zu aktualisieren.",
	"MODAL_FIRMWARE_UPDATE_TO_UPDATE1" : "So aktualisierst du die Edison V3-Firmware:",
	"MODAL_FIRMWARE_UPDATE_TO_UPDATE2" : "Schließe dein Edison an, klicke auf die Schaltfläche Firmware aktualisieren und folge den Anweisungen.",
	"MODAL_FIRMWARE_UPDATE_TO_UPDATE_BUTTON" : "Firmware aktualisieren",
	"MODAL_FIRMWARE_UPDATE_TO_RECONNECT_BUTTON" : "Edison wieder einstecken",
	"MODAL_FIRMWARE_UPDATE_FEEDBACK_START" : "Fertig...",
	"MODAL_FIRMWARE_UPDATE_TWO_STEP_START" : "Ein zweistufiges Firmware-Update wird gestartet",
	"MODAL_FIRMWARE_UPDATE_BOOT_COMPLETE" : "Bootloader-Update abgeschlossen.",
	"MODAL_FIRMWARE_UPDATE_PLEASE_CLICK" : "Bitte klicken",
	"MODAL_FIRMWARE_UPDATE_ISSUE_LOADING" : "Problem beim Laden der Firmware",
	"MODAL_FIRMWARE_UPDATE_ONE_STEP_START" : "Ein Firmware-Update wird gestartet",
	"MODAL_FIRMWARE_UPDATE_ERROR_ISSUE_LOADING" : "Fehler: Problem beim Laden der Firmware.",
	"MODAL_FIRMWARE_UPDATE_ERROR_ISSUE_DOWNLOADING" : "Fehler: Problem beim Herunterladen der Firmware.",
	"MODAL_FIRMWARE_UPDATE_FIRM_COMPLETE" : "Firmware-Update abgeschlossen.",
	"MODAL_FIRMWARE_UPDATE_NONE_NEEDED" : "Keine Aktualisierung erforderlich: Die Firmware deines Edison ist auf dem neuesten Stand.",
	"MODAL_FIRMWARE_UPDATE_PROBLEMS" : "Du hast Probleme?",
	"MODAL_FIRMWARE_UPDATE_SEE_DIAG" : "Siehe Diagnose",
	"MODAL_USB_CONTROL" : "USB-Bedienelemente",
	"MODAL_USB_RUN_BUTTON" : "USB ausführen",
	"MODAL_USB_CONNECTED_STATUS" : "ANGESCHLOSSEN",
	"MODAL_USB_DISCONNECTED_STATUS" : "ABGETRENNT",
	"MODAL_USB_RUNNING_STATUS" : "LÄUFT",
	"MODAL_USB_DATA_TO" : "Daten an USB",
	"MODAL_USB_DATA_TO_BUTTON" : "Senden an USB",
	"MODAL_USB_DATA_FROM" : "Daten von USB",
	"MODAL_USB_DATA_FROM_CLEAR" : "löschen",
	"MODAL_USB_DATA_FROM_COPY" : "In die Zwischenablage kopieren",
	"MODAL_USB_DATA_FROM_COPIED" : "Kopiert!",
	"MODAL_BAD_BROWSER_TITLE" : "Nicht unterstützter Browser",
	"MODAL_BAD_BROWSER_USING" : "Du scheinst ihn zu benutzen:",
	"MODAL_BAD_BROWSER_WEB_USB" : "Der Edison V3 wird direkt von deinem Webbrowser über USB programmiert. Dies setzt voraus, dass dein Webbrowser USB-Verbindungen unterstützt.",
	"MODAL_BAD_BROWSER_UNFORTUNATLY" : "Leider unterstützt",
	"MODAL_BAD_BROWSER_UNSUPORTED" : "derzeit keine USB-Verbindungen und kann daher deinen Edison V3 Roboter nicht programmieren.",
	"MODAL_BAD_BROWSER_USE_CHROME" : "Wir empfehlen die Verwendung von Google Chrome.",
	"MODAL_BAD_BROWSER_GET_CHROME" : "Chrome holen.",
	"MODAL_LOADING" : "Arbeitsbereich laden...",
	"MODAL_FLASHER_TITLE" : "Blinker",
	"MODAL_FLASHER_STEP_1" : "Platziere Edison über dem Bild",
	"MODAL_FLASHER_STEP_2" : "Drücke einmal auf den runden Knopf von Edison",
	"MODAL_FLASHER_STEP_3" : "Drücke Programm herunterladen",
	"MODAL_FLASHER_RELIABLE" : "Zuverlässig",
	"MODAL_FLASHER_FAST" : "Schnell",
	"MODAL_FLASHER_ADJUST_SPEED" : "Wenn der Download nicht funktioniert oder nicht schnell genug ist, versuche, die Geschwindigkeit oben einzustellen. Die niedrigste Geschwindigkeit ist normalerweise die zuverlässigste.",
	"MODAL_FLASHER_DOWNLOAD" : "Programm herunterladen",
	"MODAL_FLASHER_CANCEL" : "Abbrechen",
	"MODAL_FLASHER_TIPS_HEADING" : "Tipps",
	"MODAL_FLASHER_TIPS_BODY_1" : "Stelle die Bildschirmhelligkeit zwischen 80% und 90% ein.",
	"MODAL_FLASHER_TIPS_BODY_2" : "Halte dich von direktem und indirektem Sonnenlicht oder hellen Lichtern fern.",
	"MODAL_FLASHER_TIPS_BODY_3" : "Stelle sicher, dass du Edison V3 auf die neueste Firmware aktualisiert hast.",
	"MODAL_FLASHER_DOWNLOADING" : "Herunterladen...",
	"MODAL_FLASHER_COMPLETE" : "Vollständige",
	"MODAL_FLASHER_BYTES" : "Bytes in",
	"MODAL_FLASHER_SECONDS" : "Sekunden",
	"ERROR_RED_OBS_SETTING" : "Die Hinderniserkennungsblöcke funktionieren nur, wenn der Hinderniserkennungsstrahl mit dem Hinderniserkennungsstrahl-Block aus der Kategorie Erkennung eingeschaltet ist.",
	"ERROR_RED_OBS_SETTING_EVENT" : "Hinderniserkennungsereignisse funktionieren nur, wenn der Hinderniserkennungsstrahl mit dem Hinderniserkennungsstrahl-Block aus der Kategorie Sensing im Hauptprogramm eingeschaltet wird.",
	"ERROR_RED_LINE_SETTING" : "Linienerkennungsblöcke funktionieren nur, wenn die LED für die Linienerkennung mit dem Linienverfolgungs-LED-Block aus der Kategorie ''Sensoren'' eingeschaltet wurde.",
	"ERROR_RED_LINE_SETTING_EVENT" : "Linienerkennungsereignisse funktionieren nur, wenn die Linienerkennungs-LED mit dem Linienverfolgungs-LED-Block aus der Kategorie ''Sensing'' im Hauptprogramm eingeschaltet wird.",
	"ERROR_RED_DRIVE_CLAP" : "Edison kann Klatschen während der Fahrt nicht erkennen, weil die Motoren zu laut sind.",
	"ERROR_RED_EMPTY_IN_FORWARDS" : "Vorwärts bis-Blöcke brauchen einen Bedingungseingang.",
	"ERROR_RED_EMPTY_IN_BACKWARDS" : "Rückwärts, bis die Blöcke einen Bedingungseingang benötigen.",
	"ERROR_RED_EMPTY_IN_LEFT" : "Links, bis Blöcke einen Bedingungseingang brauchen.",
	"ERROR_RED_EMPTY_IN_RIGHT" : "Rechts, bis Blöcke einen Bedingungseingang brauchen.",
	"ERROR_RED_EMPTY_IN_SET_VAR" : "Variable setzen Blöcke brauchen eine Variable.",
	"ERROR_RED_EMPTY_IN_INC_VAR" : "Inkrement-Variablenblöcke brauchen eine Variable.",
	"ERROR_RED_EMPTY_IN_DEC_VAR" : "Variable dekrementieren Blöcke brauchen eine Variable.",
	"ERROR_RED_EMPTY_IN_IF" : "If-Blöcke benötigen eine Bedingungseingabe.",
	"ERROR_RED_EMPTY_IN_IF_ELSE" : "If-else-Blöcke brauchen eine Bedingungseingabe.",
	"ERROR_RED_EMPTY_IN_WAIT" : "Warte bis Blöcke benötigen eine Bedingungseingabe.",
	"ERROR_RED_EMPTY_IN_WAIT_MILLI" : "Warte Millisekunden Blöcke brauchen einen Eingabewert.",
	"ERROR_RED_EMPTY_IN_REP" : "Wiederhole bis Blöcke brauchen eine Bedingungseingabe.",
	"ERROR_RED_EMPTY_IN_BS_RIGHT" : "Bit shift right Blöcke brauchen eine Variable.",
	"ERROR_RED_EMPTY_IN_BS_LEFT" : "Bit Shift Left Blöcke brauchen eine Variable.",
	"ERROR_RED_EMPTY_IN_OPERATOR_NOT" : "Nicht-Blöcke brauchen einen Bedingungseingang.",
	"ERROR_RED_EMPTY_IN_OPERATOR_AND" : "Und Blöcke brauchen einen Bedingungseingang.",
	"ERROR_RED_EMPTY_IN_OPERATOR_OR" : "Oder Blöcke brauchen eine Bedingungseingabe.",
	"ERROR_RED_EMPTY_BACKGROUND_MUSIC" : "Musik im Hintergrund abspielen Gruppierungsblöcke müssen mindestens einen Notenblock enthalten.",
	"ERROR_RED_NO_START" : "Programme müssen ein Startereignis haben, damit sie richtig funktionieren. Wenn du diese Fehlermeldung siehst, starte ein neues Programm, indem du im Menü ''Neu'' wählst.",
	"ERROR_RED_NOT_BACKGROUND_MUSIC" : "Musik im Hintergrund abspielen Gruppierungsblöcke können nur Notenblöcke akzeptieren.",
	"ERROR_RED_NO_MAIN_BLOCKS" : "Es gibt keine Blöcke, die mit dem Startereignis verbunden sind, also gibt es kein Hauptprogramm, das Edison ausführen kann.",
	"ERROR_RED_EMPTY_IN_USB_RECEIVED" : "warten auf usb-Datenblöcke brauchen eine Variable.",
	"ERROR_RED_DEVIDE_BY_ZERO" : "Devide-Operator-Blöcke können nicht durch Null dividieren.",
	"ERROR_RED_FUNCTION_IN_FUNCTION" : "Funktionsaufrufblöcke können nicht unter einem Funktionsstartblock platziert werden",
	"ERROR_YELLOW_RECEIVE_MESSAGE_OBS_ON" : "Edison kann keine Nachrichten empfangen, wenn die Hinderniserkennung eingeschaltet ist. Stelle sicher, dass du die Hinderniserkennung im Programm ausschaltest, bevor du versuchst, eine Nachricht zu empfangen.",
	"ERROR_YELLOW_RECEIVE_REMOTE_OBS_ON" : "Edison kann keine Fernbedienungscodes empfangen, wenn die Hinderniserkennung eingeschaltet ist. Stelle sicher, dass du die Hinderniserkennung im Programm ausschaltest, bevor du versuchst, einen Fernbedienungscode zu empfangen.",
	"ERROR_YELLOW_RECEIVE_MESSAGE_EVENT_OBS_ON" : "Edison kann keine Nachrichten empfangen, wenn die Hinderniserkennung eingeschaltet ist. Stelle sicher, dass du die Hinderniserkennung im Hauptprogramm ausschaltest, bevor du versuchst, eine Nachricht zu empfangen.",
	"ERROR_YELLOW_RECEIVE_REMOTE_EVENT_OBS_ON" : "Edison kann keine Fernbedienungscodes empfangen, wenn die Hinderniserkennung eingeschaltet ist. Stelle sicher, dass du die Hinderniserkennung im Hauptprogramm ausschaltest, bevor du versuchst, einen Fernbedienungscode zu empfangen.",
	"ERROR_YELLOW_READ_LIGHT_LINE_OFF" : "Erwäge, die LED für die Linienerkennung mit dem LED-Block für die Linienverfolgung aus der Kategorie Sensing einzuschalten, wenn du die Reflektivität der Fahrfläche messen willst.",
	"ERROR_YELLOW_OPPERATOR_WAIT_UNTIL" : "Ein Bedienerblock innerhalb eines Warte-Bis-Blocks kann dazu führen, dass Edison ewig wartet oder den Warteblock überspringt.",
	"ERROR_YELLOW_OPPERATOR_REPEAT_UNTIL" : "Ein Operator-Block innerhalb eines repeat until-Blocks kann dazu führen, dass Edison eine Endlosschleife fährt oder den repeat-Block überspringt.",
	"ERROR_YELLOW_OPPERATOR_WAIT" : "Ein Operator-Block innerhalb eines Wait-Blocks kann Edison dazu veranlassen, den Wait-Block zu überspringen.",
	"ERROR_YELLOW_OPPERATOR_REPEAT" : "Ein Operator-Block innerhalb eines Repeat-Blocks kann Edison dazu veranlassen, den Repeat-Block zu überspringen.",
	"ERROR_YELLOW_OPPERATOR_DRIVE_FOR_UNTIL" : "Ein Operator-Block innerhalb eines Vorwärtsfahr-Blocks kann dazu führen, dass Edison für immer fährt oder den Fahr-Block überspringt.",
	"ERROR_YELLOW_OPPERATOR_DRIVE_BACK_UNTIL" : "Ein Operator-Block innerhalb eines Rückwärtsfahr-Blocks kann dazu führen, dass Edison für immer fährt oder den Fahr-Block überspringt.",
	"ERROR_YELLOW_OPPERATOR_DRIVE_LEFT_UNTIL" : "Eine Bedienersperre innerhalb einer Fahrt nach links bis zum Block kann dazu führen, dass Edison für immer fährt oder den Fahrblock überspringt.",
	"ERROR_YELLOW_OPPERATOR_DRIVE_RIGHT_UNTIL" : "Eine Bedienersperre innerhalb einer Rechts-vor-links-Blockade kann dazu führen, dass Edison für immer fährt oder die Blockade überspringt.",
	"ERROR_YELLOW_OPPERATOR_DRIVE_FOR_DIST" : "Eine Bedienersperre innerhalb eines Vorwärtsfahr-Blocks kann dazu führen, dass Edison den Fahr-Block überspringt.",
	"ERROR_YELLOW_OPPERATOR_DRIVE_BACK_DIST" : "Eine Bedienersperre innerhalb eines Rückwärtsfahr-Blocks kann dazu führen, dass Edison den Fahr-Block überspringt.",
	"ERROR_YELLOW_OPPERATOR_DRIVE_LEFT_DIST" : "Eine Bedienersperre innerhalb eines linken Fahrblocks kann dazu führen, dass Edison den Fahrblock überspringt.",
	"ERROR_YELLOW_OPPERATOR_DRIVE_RIGHT_DIST" : "Eine Bedienersperre in einem Rechtsfahrerblock kann dazu führen, dass Edison den Fahrerblock überspringt.",
	"ERROR_YELLOW_DRIVE_LIGHT" : "Ein Lichtpegel-Block innerhalb eines Antriebsblocks kann dazu führen, dass Edison für immer fährt oder den Antriebsblock überspringt.",
	"ERROR_YELLOW_OPPERATOR_IR_MESSAGE" : "Ein Operator-Block innerhalb eines Sende-IR-Blocks kann keinen Wert größer als 255 senden.",
	"ERROR_YELLOW_FOREVER_LOOP_IN" : "Eine Endlosschleife läuft so lange, bis du den quadratischen Knopf am Edison drückst.",
	"ERROR_YELLOW_SET_MOTOR_LEFT" : "Der Block ''Setze linken Motor'' schaltet nur den linken Motor ein. Vergewissere dich, dass in deinem Programm zusätzliche Blöcke verwendet werden, um die Dauer des linken Motors zu steuern.",
	"ERROR_YELLOW_SET_MOTOR_RIGHT" : "Der Block ''Set right motor'' schaltet nur den rechten Motor ein. Vergewissere dich, dass im Programm zusätzliche Blöcke verwendet werden, um die Dauer des rechten Motors zu steuern.",
	"ERROR_YELLOW_SET_MOTOR_BOTH" : "Der Satz ''Setze beide Motoren'' schaltet nur die Motoren ein. Vergewissere dich, dass im Programm zusätzliche Blöcke verwendet werden, um die Dauer des Motors zu steuern.",
	"ERROR_YELLOW_CLAP_EVENT_DRIVE" : "Das Antreiben der Motoren erzeugt Geräusche, die das Klatschen auslösen können. Dies kann dazu führen, dass die Klatsch-Ereignisblöcke wiederholt ausgelöst werden, während Edison fährt.",
	"ERROR_YELLOW_FLOAT_BLOCKS" : "Blöcke, die nicht mit einem gelben Ereignisblock oder Funktionsdefinitionsblock verbunden sind, werden nicht in Edison programmiert.",
	"ERROR_YELLOW_WAIT_TIME_LIGHT" : "Der Lichtpegel gibt einen sehr hohen Wert zurück, was dazu führen kann, dass Edison sehr lange wartet.",
	"ERROR_YELLOW_REPEAT_LOOP_LIGHT" : "Der Lichtpegel gibt einen sehr hohen Wert zurück, was dazu führen kann, dass Edison eine lange Schleife fährt.",
	"ERROR_YELLOW_DRIVE_STRAIN" : "Der Block ''Antriebsbelastung erkannt'' erkennt die Belastung nur, wenn die Motoren laufen.",
	"ERROR_YELLOW_DRIVE_STRAIN_EVENT" : "Das Ereignis ''Antrieb belastet'' kann nur ausgelöst werden, wenn die Motoren in Betrieb sind.",
	"ERROR_YELLOW_COMMENT" : "Kommentare sind Notizen, die helfen, den Überblick zu behalten. Kommentarblöcke werden nicht in Edison programmiert.",
	"ERROR_YELLOW_USB_USED" : "USB-Blöcke erfordern, dass Edison an ein Gerät angeschlossen ist, um zu funktionieren.",
	"ERROR_YELLOW_CLEAR_SENSOR" : "Einige Sensordaten werden im Speicher von Edison gespeichert. Möglicherweise musst du die Sensordaten löschen, damit dein Programm richtig funktioniert.",
	"ERROR_YELLOW_CLEAR_LEARN_MORE" : "Mehr erfahren",
	"MODAL_FIRMWARE_ERROR_TITLE" : "Firmware-Fehler",
	"MODAL_FIRMWARE_ERROR_BODY_1" : "In deinem Edison-Roboter wurde eine beschädigte Firmware-Datei entdeckt.",
	"MODAL_FIRMWARE_ERROR_BODY_2" : "Das kann während eines Firmware-Updates passiert sein, das unterbrochen wurde.",
	"MODAL_FIRMWARE_ERROR_BODY_3" : "Kein Grund zur Panik! Du kannst das Problem beheben, indem du unten auf die Schaltfläche Firmware reparieren klickst.",
	"MODAL_FIRMWARE_ERROR_CANCEL_BODY_1" : "Achtung!",
	"MODAL_FIRMWARE_ERROR_CANCEL_BODY_2" : "Wenn du diesen Vorgang abbrichst, kann dein Edison-Roboter nicht mehr programmiert werden.",
	"MODAL_FIRMWARE_ERROR_CANCEL_BODY_3" : "Es wird empfohlen, dass du die Firmware jetzt reparierst, indem du auf die Schaltfläche Firmware reparieren klickst.",
	"MODAL_FIRMWARE_ERROR_CANCEL_BODY_4" : "Wenn du den Vorgang abbrichst, kannst du die Firmware zu einem späteren Zeitpunkt reparieren.",
	"MODAL_FIRMWARE_ERROR_BUTTON_FIX" : "Firmware reparieren",
	"MODAL_FIRMWARE_ERROR_BUTTON_CANCEL" : "Abbrechen",
	"MODAL_FIRMWARE_ERROR_BUTTON_CANCEL_CONFIRM" : "Bestätige Abbrechen",
	"MODAL_NEW_CONFIRM_HEADING" : "Bist du sicher?",
	"MODAL_NEW_CONFIRM_BODY_TEXT_1" : "Bist du sicher, dass du ein neues Programm starten willst?",
	"MODAL_NEW_CONFIRM_BODY_TEXT_2" : "Alle Änderungen können verloren gehen!",
	"MODAL_NEW_CONFIRM_BUTTON_CANCEL" : "Abbrechen",
	"MODAL_NEW_CONFIRM_BUTTON_PROCEED" : "Fortfahren",
	"CHANGELANG" : "Sprache ändern",
	"HELP_TEXT_ALL_TITLE" : "Hilfe blockieren",
	"HELP_TEXT_ALL_BLOCKS_EXAMPLE_USES" : "Beispielanwendungen:",
	"HELP_TEXT_ALL_BLOCKS_EXAMPLE_LOAD" : "Programm öffnen",
	"HELP_TEXT_ALL_BLOCKS_WATCH_FOR" : "Achte auf:",
	"HELP_TEXT_DRIVE_FORWARD_FOR_TITLE" : "vorwärts für",
	"HELP_TEXT_DRIVE_FORWARD_FOR_BODY_1" : "Der Block vorwärts für treibt die Räder an, um den Roboter in Vorwärtsrichtung zu bewegen.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_BODY_2" : "Der Block hat drei Parameter:",
	"HELP_TEXT_DRIVE_FORWARD_FOR_BODY_3" : "Wert - Kann eine Konstante sein (wird in den Eingang eingegeben und ändert sich nicht), eine Variable, ein Fühler oder ein Operator-Block.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_BODY_4" : "Einheiten - Es gibt drei Optionen, die ausgewählt werden können: cm, Zoll und Sekunden.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_BODY_5" : "Geschwindigkeit - Die Geschwindigkeit kann entweder von 1 bis 10 (als konstanter Wert), als Variable, als Sensing oder als Operator-Block ausgewählt werden.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_BODY_6" : "Der Vorwärts-Block wird abgeschlossen, bevor der nächste Block ausgeführt wird. Wenn du z. B. den Vorwärts-Satz verwendest, werden andere Sätze im Programm nicht gleichzeitig ausgeführt. Siehe dazu den Abschnitt Beide Motoren auf Block setzen.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_1_TITLE" : "Beispiel 1: Piepse, dann fahre den Edison-Roboter 15 cm mit Geschwindigkeit 1 vorwärts, dann piepse wieder.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_1_BODY_1" : "In diesem Beispielprogramm piepst Edison, fährt aber erst los, wenn der Piepton zu Ende ist. Auch der zweite Piepton ertönt erst, wenn Edison aufgehört hat zu fahren.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_2_TITLE" : "Beispiel 2: Einstellen der Fahrstrecke mit einer Variablen und Daten von einem Sensor",
	"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_2_BODY_1" : "In diesem Beispielprogramm setzt Edison die Variable Abstand auf die Lichtstärke des linken Lichtsensors (ein Wert von 1 bis 1.000) geteilt durch 50. Der Edison fährt dann mit der Geschwindigkeit 5 um den Wert in der Variable (Distance) vorwärts. Das Ergebnis ist, dass der Edison bei hellerem Licht weiter und bei schwächerem Licht kürzer fährt.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_3_TITLE" : "Beispiel 3: Ändern der Fahrgeschwindigkeit über eine Variable.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_3_BODY_1" : "In diesem Beispielprogramm wird die Variable Geschwindigkeit auf 1 gesetzt. Das Programm beginnt dann mit einer Wiederholungsschleife, die 10 Mal durchlaufen wird. In jeder Schleife fährt der Edison mit der in der Variable Speed eingestellten Geschwindigkeit 5 cm vorwärts. Zu Beginn ist der Wert in der Variable Geschwindigkeit 1, also fährt der Edison 5 cm mit der Geschwindigkeit 1 vorwärts. Der nächste Block in der Wiederholung erhöht (+1) die Variable Geschwindigkeit. In der zweiten Wiederholung des Vorwärtsblocks ist der Wert in der Variable Geschwindigkeit 2, also fährt der Edison 5 cm mit Geschwindigkeit 2 vorwärts.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_3_BODY_2" : "Dieser Vorgang wird in der Wiederholungsschleife 10 Mal wiederholt, so dass Edison immer schneller fährt, bis er anhält, wenn das Programm endet.",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_TITLE" : "rückwärts für",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_BODY_1" : "Der Backwards for-Block treibt die Räder an, um den Roboter in die Rückwärtsrichtung zu bewegen.",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_BODY_2" : "Der Block hat drei Parameter:",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_BODY_3" : "Wert - Kann eine Konstante sein (wird in den Eingang eingegeben und ändert sich nicht), eine Variable, ein Fühler oder ein Operator-Block.",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_BODY_4" : "Einheiten - Es gibt drei Optionen, die ausgewählt werden können: cm, Zoll und Sekunden.",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_BODY_5" : "Geschwindigkeit - Die Geschwindigkeit kann entweder von 1 bis 10 (als konstanter Wert), als Variable, als Sensing oder als Operator-Block ausgewählt werden.",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_BODY_6" : "Der Rückwärts-für-Block wird abgeschlossen, bevor der nächste Block ausgeführt wird. Wenn du zum Beispiel den Block ''Rückwärts für'' verwendest, werden andere Blöcke im Programm nicht gleichzeitig ausgeführt. Siehe dazu die Funktion Beide Motoren auf Block setzen.",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_EXAMPLE_1_TITLE" : "Beispiel 1: LED leuchtet während der Fahrt",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_EXAMPLE_1_BODY_1" : "In diesem Beispielprogramm leuchtet die linke LED auf und bleibt an, während der Edison eine Sekunde lang rückwärts fährt. Die linke LED schaltet sich aus, nachdem der Edison aufgehört hat zu fahren. Das Programm wartet dann eine Sekunde lang, bevor es beendet wird.",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_EXAMPLE_2_TITLE" : "Beispiel 2: Wenn es ein Hindernis gibt, fahre rückwärts",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_EXAMPLE_2_BODY_1" : "In diesem Beispielprogramm wird zunächst der Hinderniserkennungsstrahl eingeschaltet. Dann tritt das Programm in eine Endlosschleife ein. Innerhalb der Schleife hält der wait until-Block das Programm an, bis irgendwo ein Hindernis erkannt wird. Wenn das passiert, fährt der Edison mit der Geschwindigkeit 10 einen Zoll rückwärts. Dieses Verhalten wiederholt sich für immer in einer Schleife. Das führt dazu, dass Edison vor Objekten zurückweicht, die sich vor ihm befinden.",
	"HELP_TEXT_DRIVE_LEFT_FOR_TITLE" : "links für",
	"HELP_TEXT_DRIVE_LEFT_FOR_BODY_1" : "Der linke for-Block treibt die Räder an, um den Roboter in die linke Richtung zu bewegen.",
	"HELP_TEXT_DRIVE_LEFT_FOR_BODY_2" : "Der Block hat vier Parameter:",
	"HELP_TEXT_DRIVE_LEFT_FOR_BODY_3" : "Bewegung - Es gibt drei Optionen, die ausgewählt werden können: Drehen, vorwärts drehen und rückwärts drehen.",
	"HELP_TEXT_DRIVE_LEFT_FOR_BODY_4" : "Wert - Kann eine Konstante sein (wird in den Eingang eingegeben und ändert sich nicht), eine Variable, ein Fühler oder ein Operator-Block.",
	"HELP_TEXT_DRIVE_LEFT_FOR_BODY_5" : "Einheiten - Es gibt zwei Optionen, die ausgewählt werden können: Grad und Sekunden.",
	"HELP_TEXT_DRIVE_LEFT_FOR_BODY_6" : "Geschwindigkeit - Die Geschwindigkeit kann entweder von 1 bis 10 (als konstanter Wert), als Variable, als Sensing oder als Operator-Block ausgewählt werden.",
	"HELP_TEXT_DRIVE_LEFT_FOR_BODY_7" : "Das Drehen und Schleudern ist bei niedrigeren Geschwindigkeiten genauer. Das liegt daran, dass die Räder bei hohen Geschwindigkeiten die Bodenhaftung verlieren und durchdrehen können. Geschwindigkeit 1 ist am besten geeignet, wenn genaues Drehen gefragt ist.",
	"HELP_TEXT_DRIVE_LEFT_FOR_BODY_8" : "Der ''Links für''-Block muss abgeschlossen sein, bevor der nächste Block ausgeführt wird. Wenn du z. B. den ''Left for''-Block verwendest, werden andere Blöcke im Programm nicht gleichzeitig ausgeführt. Siehe dazu den Abschnitt Beide Motoren auf Block setzen.",
	"HELP_TEXT_DRIVE_LEFT_FOR_EXAMPLE_1_TITLE" : "Beispielprogramm 1: Piepsen, Drehen, Piepsen",
	"HELP_TEXT_DRIVE_LEFT_FOR_EXAMPLE_1_BODY_1" : "In diesem Beispielprogramm piepst Edison, beginnt aber erst zu drehen, wenn der Piepton zu Ende ist. Auch der zweite Piepton ertönt erst, wenn Edison aufgehört hat, sich zu drehen.",
	"HELP_TEXT_DRIVE_LEFT_FOR_EXAMPLE_2_TITLE" : "Beispielprogramm 2: In einem Quadrat fahren",
	"HELP_TEXT_DRIVE_LEFT_FOR_EXAMPLE_2_BODY_1" : "In diesem Beispielprogramm wiederholt die Wiederholungsschleife, dass Edison mit Geschwindigkeit 1 10 cm vorwärts fährt und sich dann viermal um 90 Grad nach links dreht. Das führt dazu, dass Edison in einem Quadrat fährt.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_TITLE" : "rechts für",
	"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_1" : "Der rechte for-Block treibt die Räder an, um den Roboter in die linke Richtung zu bewegen.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_2" : "Der Block hat vier Parameter:",
	"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_3" : "Bewegung - Es gibt drei Optionen, die ausgewählt werden können: Drehen, vorwärts drehen und rückwärts drehen.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_4" : "Wert - Kann eine Konstante sein (wird in den Eingang eingegeben und ändert sich nicht), eine Variable, ein Fühler oder ein Operator-Block.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_5" : "Einheiten - Es gibt zwei Optionen, die ausgewählt werden können: Grad und Sekunden.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_6" : "Geschwindigkeit - Die Geschwindigkeit kann entweder von 1 bis 10 (als konstanter Wert), als Variable, als Sensing oder als Operator-Block ausgewählt werden.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_7" : "Das Drehen und Schleudern ist bei niedrigeren Geschwindigkeiten genauer. Das liegt daran, dass die Räder bei hohen Geschwindigkeiten die Bodenhaftung verlieren und durchdrehen können. Geschwindigkeit 1 ist am besten geeignet, wenn genaues Drehen gefragt ist.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_8" : "Der rechte Block muss abgeschlossen werden, bevor der nächste Block ausgeführt wird. Wenn du zum Beispiel den Block ''Rechts für'' verwendest, können andere Blöcke im Programm nicht gleichzeitig ausgeführt werden. Siehe dazu den Abschnitt Beide Motoren auf Block setzen.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_EXAMPLE_1_TITLE" : "Beispielprogramm 1: Piepsen, drehen, piepsen",
	"HELP_TEXT_DRIVE_RIGHT_FOR_EXAMPLE_1_BODY_1" : "In diesem Beispielprogramm piept Edison, beginnt aber erst zu drehen, wenn der Piepton zu Ende ist. Auch der zweite Piepton ertönt erst, wenn Edison aufgehört hat, sich zu drehen.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_EXAMPLE_2_TITLE" : "Beispiel 2: Drehen nach rechts, wobei die Geschwindigkeit durch die Lichtstärke gesteuert wird",
	"HELP_TEXT_DRIVE_RIGHT_FOR_EXAMPLE_2_BODY_1" : "In diesem Beispielprogramm dreht sich Edison innerhalb einer Endlosschleife nach rechts. Jedes Mal, wenn der rechte for-Block läuft, dreht sich Edison um 1 Grad. Die Geschwindigkeit wird durch den Lichtpegel des linken Lichtsensors bestimmt (1 bis 1.000) und durch 100 geteilt (Ergebnis 0 bis 10). Das Ergebnis ist, dass Edison sich bei hellerem Licht schneller und bei schwächerem Licht langsamer dreht.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_EXAMPLE_3_TITLE" : "Beispielprogramm 3: Hindernissen ausweichen",
	"HELP_TEXT_DRIVE_RIGHT_FOR_EXAMPLE_3_BODY_1" : "In diesem Beispielprogramm wird der Hinderniserkennungsstrahl eingeschaltet. Dann tritt das Programm in eine Endlosschleife ein, in der beide Motoren auf Vorwärtsfahrt eingestellt sind. Das Programm wartet dann, bis irgendwo ein Hindernis erkannt wird. Wenn das passiert, geht das Programm zum nächsten Block über und der Edison-Roboter dreht sich mit der Geschwindigkeit 1 um 180 Grad nach rechts. Das führt dazu, dass Edison von Hindernissen in seinem Weg wegfährt.",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_TITLE" : "vorwärts bis",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_BODY_1" : "Der Vorwärts-Block treibt die Räder an, um den Roboter in die Vorwärtsrichtung zu bewegen, bis die angegebene Bedingung erfüllt ist. Sobald die angegebene Bedingung erfüllt ist, halten die Räder an und das Programm geht zum nächsten Block über.",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_BODY_2" : "Der Block hat zwei Parameter:",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_BODY_3" : "Bedingungseingang - Der Bedingungseingang akzeptiert einen rautenförmigen Block, der entweder ein Sensorblock oder ein Bedienerblock sein kann.",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_BODY_4" : "Geschwindigkeit - Die Geschwindigkeit kann entweder von 1 bis 10 (als konstanter Wert), als Variable, als Sensing- oder als Operator-Block gewählt werden.",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_BODY_5" : "Der Vorwärts-Bis-Block muss abgeschlossen sein, bevor der nächste Block ausgeführt wird. Wenn du zum Beispiel den Vorwärts-Bis-Satz verwendest, können andere Sätze im Programm nicht gleichzeitig ausgeführt werden. Siehe dazu den Abschnitt Beide Motoren auf Block setzen.",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_EXAMPLE_1_TITLE" : "Beispielprogramm 1: Anhalten wegen eines Hindernisses",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_EXAMPLE_1_BODY_1" : "In diesem Beispielprogramm wird der Hinderniserkennungsstrahl eingeschaltet, dann fährt der Roboter mit Geschwindigkeit 5 vorwärts, bis ein Hindernis erkannt wird. Wenn das passiert, hält der Roboter an und das Programm endet.",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_EXAMPLE_2_TITLE" : "Beispielprogramm 2: Bounce in Grenzen",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_EXAMPLE_2_BODY_1" : "In diesem Beispielprogramm wird die LED des Linienverfolgers eingeschaltet, dann geht das Programm in eine Endlosschleife über. Innerhalb der Schleife fährt der Vorwärts-Block den Roboter mit der Geschwindigkeit 1 vorwärts, bis der Line Tracker auf einer nicht reflektierenden Oberfläche (d.h. schwarz) steht. Wenn das passiert, wird der nächste Block ausgeführt, der den Roboter mit der Geschwindigkeit 5 um 180 Grad nach links dreht. Das Programm kehrt dann zum Vorwärts-Bis-Block zurück. Dies führt dazu, dass Edison von den erkannten schwarzen Linien wegfährt.",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_TITLE" : "rückwärts bis",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_BODY_1" : "Der Rückwärts-Bis-Block treibt die Räder an, um den Roboter rückwärts zu bewegen, bis die angegebene Bedingung erfüllt ist. Sobald die angegebene Bedingung erfüllt ist, halten die Räder an und das Programm geht zum nächsten Block über.",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_BODY_2" : "Der Block hat zwei Parameter:",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_BODY_3" : "Bedingungseingang - Der Bedingungseingang akzeptiert einen rautenförmigen Block, der entweder ein Sensorblock oder ein Bedienerblock sein kann.",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_BODY_4" : "Geschwindigkeit - Die Geschwindigkeit kann entweder von 1 bis 10 (als konstanter Wert), als Variable, als Sensing oder als Operator-Block ausgewählt werden.",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_BODY_5" : "Der Rückwärts-Bis-Block muss abgeschlossen sein, bevor der nächste Block ausgeführt wird. Wenn du zum Beispiel den Rückwärts-Bis-Block verwendest, werden andere Blöcke im Programm nicht gleichzeitig ausgeführt. Siehe dazu den Satz Beide Motoren auf Block setzen.",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_EXAMPLE_1_TITLE" : "Beispielprogramm 1: Anhalten, wenn der Antrieb beansprucht wird",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_EXAMPLE_1_BODY_1" : "In diesem Beispielprogramm fährt der Roboter mit der Geschwindigkeit 10 rückwärts, bis die Räder überlastet sind (sich nicht mehr drehen können oder stecken bleiben). Wenn das passiert, halten die Motoren an und das Programm endet.",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_EXAMPLE_2_TITLE" : "Beispielprogramm 2: Antriebssteuerung mit Tasten",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_EXAMPLE_2_BODY_1" : "In diesem Beispiel beginnt das Programm mit einer Endlosschleife. Der erste Block in der Schleife wartet, bis der Dreiecksknopf gedrückt wird. Dann fährt der Roboter mit Geschwindigkeit 1 rückwärts, bis der runde Knopf gedrückt wird. Wenn dies geschehen ist, halten die Räder des Roboters an und das Programm beginnt wieder mit einer Schleife, in der auf das Drücken der Dreieckstaste gewartet wird.",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_TITLE" : "links bis",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_BODY_1" : "Der linke Until-Block treibt die Räder an und bewegt den Roboter in die linke Richtung, bis die angegebene Bedingung erfüllt ist. Sobald die angegebene Bedingung erfüllt ist, halten die Räder an und das Programm geht zum nächsten Block über.",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_BODY_2" : "Der Block hat drei Parameter:",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_BODY_3" : "Bewegung - Es gibt drei Optionen, die ausgewählt werden können: Drehen, vorwärts drehen und rückwärts drehen.",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_BODY_4" : "Bedingungseingang - Der Bedingungseingang akzeptiert einen rautenförmigen Block, der entweder ein Sensorblock oder ein Bedienerblock sein kann.",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_BODY_5" : "Geschwindigkeit - Die Geschwindigkeit kann entweder von 1 bis 10 (als konstanter Wert), als Variable, als Sensing oder als Operator-Block ausgewählt werden.",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_BODY_6" : "Der spin left until-Block muss abgeschlossen sein, bevor der nächste Block ausgeführt wird. Wenn du zum Beispiel den Satz ''Links drehen bis'' verwendest, werden andere Sätze im Programm nicht gleichzeitig ausgeführt. Siehe dazu den Abschnitt Beide Motoren auf Block setzen.",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_EXAMPLE_1_TITLE" : "Beispielprogramm 1: Anhalten, wenn der Antrieb beansprucht wird",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_EXAMPLE_1_BODY_1" : "In diesem Beispielprogramm fährt der Roboter mit Geschwindigkeit 1 nach links (das rechte Rad bewegt sich), bis das Rad verspannt wird (sich nicht mehr drehen kann oder feststeckt). Wenn das passiert, hält der Motor an und das Programm endet.",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_EXAMPLE_2_TITLE" : "Beispielprogramm 2: Licht folgen",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_EXAMPLE_2_BODY_1" : "In diesem Beispiel beginnt das Programm mit einer Endlosschleife. Der erste Satz in der Schleife dreht den Roboter mit Geschwindigkeit 5 nach links, bis der linke Lichtpegel geringer ist als der rechte Lichtpegel. Wenn das passiert, hält der Motor an und der nächste Block läuft. Der nächste Block dreht den Roboter mit Geschwindigkeit 5 nach rechts, bis der linke Lichtpegel größer als der rechte Lichtpegel ist. Das Ergebnis ist, dass der Edison-Roboter in Richtung Licht fährt.",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_TITLE" : "rechts bis",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_BODY_1" : "Der Block rechts bis treibt die Räder an, um den Roboter in die richtige Richtung zu bewegen, bis die angegebene Bedingung erfüllt ist. Sobald die angegebene Bedingung erfüllt ist, bleiben die Räder stehen und das Programm geht zum nächsten Block über.",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_BODY_2" : "Der Block hat drei Parameter:",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_BODY_3" : "Bewegung - Es gibt drei Optionen, die ausgewählt werden können: Drehen, vorwärts drehen und rückwärts drehen.",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_BODY_4" : "Bedingungseingang - Der Bedingungseingang akzeptiert einen rautenförmigen Block, der entweder ein Sensorblock oder ein Bedienerblock sein kann.",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_BODY_5" : "Geschwindigkeit - Die Geschwindigkeit kann entweder von 1 bis 10 (als konstanter Wert), als Variable, als Sensing oder als Operator-Block ausgewählt werden.",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_BODY_6" : "Der right until-Block muss abgeschlossen werden, bevor der nächste Block ausgeführt wird. Wenn du z. B. den ''Spin Right Until''-Block verwendest, können andere Blöcke im Programm nicht gleichzeitig ausgeführt werden. Siehe dazu den Abschnitt Beide Motoren auf Block setzen.",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_EXAMPLE_1_TITLE" : "Beispielprogramm 1: Anhalten auf schwarzer Fläche",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_EXAMPLE_1_BODY_1" : "In diesem Beispielprogramm dreht sich der Roboter mit Geschwindigkeit 5 nach rechts, bis der Linienverfolger eine nicht reflektierende Oberfläche (schwarz) erkennt. Wenn das passiert, hält der Motor an und das Programm endet.",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_EXAMPLE_2_TITLE" : "Beispielprogramm 2: Licht folgen",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_EXAMPLE_2_BODY_1" : "In diesem Beispiel beginnt das Programm mit einer Endlosschleife. Der erste Satz in der Schleife dreht den Roboter mit Geschwindigkeit 5 nach links, bis der linke Lichtpegel geringer ist als der rechte Lichtpegel. Wenn das passiert, hält der Motor an und der nächste Block läuft. Der nächste Block dreht den Roboter mit Geschwindigkeit 5 nach rechts, bis der linke Lichtpegel größer als der rechte Lichtpegel ist. Das Ergebnis ist, dass der Edison-Roboter in Richtung Licht fährt.",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_TITLE" : "Setze beide Motoren auf",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_BODY_1" : "Der Block ''Beide Motoren einstellen'' treibt die Räder an, um den Roboter in die gewählte Richtung und Geschwindigkeit zu bewegen. Da dieser Antriebsblock die Motoren einstellt, kann das Programm direkt mit dem nächsten Block fortfahren. Dies unterscheidet sich von den Antriebsblöcken, die eine Strecke, eine Zeit oder einen Winkel vorgeben, bevor das Programm mit dem nächsten Block fortfährt.",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_BODY_2" : "Der Block hat zwei Parameter:",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_BODY_3" : "Bewegung - Es gibt sechs Optionen, die ausgewählt werden können: vorwärts fahren, rückwärts fahren, Roboter links drehen, Roboter rechts drehen, Roboter links drehen und Roboter rechts drehen.",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_BODY_4" : "Geschwindigkeit - Die Geschwindigkeit kann entweder von 1 bis 10 (als konstanter Wert), als Variable, als Sensing oder als Operator-Block ausgewählt werden.",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_EXAMPLE_1_TITLE" : "Beispielprogramm 1: Musik beim Fahren",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_EXAMPLE_1_BODY" : "In diesem Beispielprogramm wird der Edison-Roboter so eingestellt, dass er vorwärts fährt, dann werden drei Noten gespielt, während der Roboter noch fährt. Nachdem die letzte Note zu Ende gespielt wurde, endet das Programm und der Edison-Roboter hört auf zu fahren.",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_EXAMPLE_2_TITLE" : "Beispielprogramm 2: Fahrt bis zu einem Hindernis",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_EXAMPLE_2_BODY" : "In diesem Beispielprogramm wird der Hinderniserkennungsstrahl eingeschaltet, dann werden beide Motoren auf Vorwärtsfahrt mit Geschwindigkeit 8 eingestellt. Der nächste Block wartet, bis ein Hindernis erkannt wird. Wenn das passiert, endet das Programm und der Roboter hört auf zu fahren.",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_EXAMPLE_3_TITLE" : "Beispielprogramm 3: Einer Linie folgen",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_EXAMPLE_3_BODY" : "In diesem Beispielprogramm wird die LED des Linienverfolgers eingeschaltet und das Programm tritt in eine Endlosschleife ein. Innerhalb der Schleife werden beide Motoren so eingestellt, dass der Roboter mit der Geschwindigkeit 1 nach links fährt. Dann hält der ''wait until''-Block das Programm an, bis der Linienverfolger eine reflektierende Oberfläche (weiß) erkennt. Wenn das passiert, werden beide Motoren so eingestellt, dass der Roboter mit Geschwindigkeit 1 nach rechts fährt, und der wait until-Block hält das Programm dort, bis der Line Tracker eine nicht reflektierende Oberfläche (schwarz) erkennt. Wenn das passiert, kehrt das Programm an den Anfang der Endlosschleife zurück und wiederholt den Vorgang. Das Ergebnis ist, dass Edison einer nicht reflektierenden Linie folgt.",
	"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_TITLE" : "rechten Motor einstellen auf",
	"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_BODY_1" : "Der Block set right motor to treibt die Räder an, um den Roboter in die gewählte Richtung und Geschwindigkeit zu bewegen. Da dieser Antriebsblock die Motoren einstellt, kann das Programm direkt mit dem nächsten Block fortfahren. Das ist anders als bei den Antriebsblöcken, die eine Strecke, eine Zeit oder einen Winkel vorgeben, bevor das Programm zum nächsten Block weitergeht.",
	"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_BODY_2" : "Der Block hat zwei Parameter:",
	"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_BODY_3" : "Bewegung - Es gibt zwei Optionen, die ausgewählt werden können: vorwärts und rückwärts.",
	"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_BODY_4" : "Geschwindigkeit - Die Geschwindigkeit kann entweder von 1 bis 10 (als konstanter Wert), als Variable, als Sensing oder als Operator-Block ausgewählt werden.",
	"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_EXAMPLE_1_TITLE" : "Beispielprogramm 1: Motor ein- und ausschalten mit einem Tastendruck",
	"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_EXAMPLE_1_BODY" : "In diesem Beispiel beginnt das Programm mit einer Endlosschleife. Der erste Block in der Schleife wartet, bis der runde Knopf gedrückt wird. Wenn das passiert, wird der rechte Motor auf Vorwärtsfahrt mit Geschwindigkeit 5 gestellt. Das Programm geht dann zu einem weiteren Block ''Warten, bis der runde Knopf gedrückt wird'' über. Dann wird der rechte Motor angehalten und das Programm kehrt zum Anfang der Endlosschleife zurück.",
	"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_TITLE" : "Linken Motor einstellen auf",
	"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_BODY_1" : "Der ''Setze linken Motor auf''-Block treibt die Räder an, um den Roboter in die gewählte Richtung und Geschwindigkeit zu bewegen. Da dieser Antriebsblock die Motoren einstellt, kann das Programm direkt mit dem nächsten Block fortfahren. Das ist anders als bei den Antriebsblöcken, die eine Strecke, eine Zeit oder einen Winkel vorgeben, bevor das Programm zum nächsten Block übergeht.",
	"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_BODY_2" : "Der Block hat zwei Parameter:",
	"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_BODY_3" : "Bewegung - Es gibt zwei Optionen, die ausgewählt werden können: vorwärts und rückwärts.",
	"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_BODY_4" : "Geschwindigkeit - Die Geschwindigkeit kann entweder von 1 bis 10 (als konstanter Wert), als Variable, als Sensing oder als Operator-Block ausgewählt werden.",
	"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_EXAMPLE_1_TITLE" : "Beispielprogramm 1: Licht folgen",
	"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_EXAMPLE_1_BODY" : "In diesem Beispiel tritt das Programm in eine Endlosschleife ein. Der erste Satz in der Schleife lässt den linken Motor mit einer berechneten Geschwindigkeit vorwärts laufen. Die berechnete Geschwindigkeit ergibt sich aus der Lichtstärke des rechten Sensors minus der Lichtstärke des linken Sensors geteilt durch 100, wobei zu dem Ergebnis noch 3 addiert wird, um eine Mindestgeschwindigkeit festzulegen. Der nächste Block stellt den rechten Motor mit einer berechneten Geschwindigkeit auf vorwärts. Die berechnete Geschwindigkeit ergibt sich aus der Lichtstärke des linken Sensors minus der Lichtstärke des rechten Sensors geteilt durch 100; zu dem Ergebnis wird ebenfalls 3 addiert, um eine Mindestgeschwindigkeit festzulegen. Das Programm kehrt dann in einer Schleife zum Anfang der Endlosschleife zurück. Die berechneten Ergebnisse steuern die Geschwindigkeit so, dass die Seite, die am wenigsten Licht hat, am schnellsten fährt. Das führt dazu, dass der Edison-Roboter immer versucht, sich dem hellsten Licht zuzuwenden und dorthin zu fahren.",
	"HELP_TEXT_DRIVE_STOP_TITLE" : "stoppen",
	"HELP_TEXT_DRIVE_STOP_BODY_1" : "Der Stopp-Block hält die Motoren davon ab, die Räder anzutreiben.",
	"HELP_TEXT_DRIVE_STOP_BODY_2" : "Der Stopp-Block hat nur einen Parameter, mit dem du auswählen kannst, welche Motoren angehalten werden sollen. Die Optionen sind beide Motoren, der linke Motor und der rechte Motor.",
	"HELP_TEXT_DRIVE_STOP_EXAMPLE_1_TITLE" : "Beispielprogramm 1: Motor ein- und ausschalten mit einem Tastendruck",
	"HELP_TEXT_DRIVE_STOP_EXAMPLE_1_BODY" : "In diesem Beispiel beginnt das Programm mit einer Endlosschleife. Der erste Block in der Schleife wartet, bis der runde Knopf gedrückt wird. Wenn das passiert, wird der rechte Motor auf Vorwärtsfahrt mit Geschwindigkeit 5 gestellt. Das Programm geht dann zu einem weiteren Block ''Warten, bis der runde Knopf gedrückt wird'' über. Dann wird der rechte Motor angehalten und das Programm kehrt zum Anfang der Endlosschleife zurück.",
	"HELP_TEXT_LEDS_LEFT_TITLE" : "LED links drehen",
	"HELP_TEXT_LEDS_LEFT_BODY_1" : "Der Block LED links drehen steuert die linke LED. Es gibt zwei Optionen: an oder aus.",
	"HELP_TEXT_LEDS_LEFT_EXAMPLE_1_TITLE" : "Beispielprogramm 1: Linke LED einmal blinken",
	"HELP_TEXT_LEDS_LEFT_EXAMPLE_1_BODY" : "In diesem Beispiel beginnt das Programm mit dem Einschalten der linken LED, wartet dann eine Sekunde und schaltet die linke LED dann wieder aus.",
	"HELP_TEXT_LEDS_LEFT_EXAMPLE_2_TITLE" : "Beispielprogramm 2: Linke LED für immer blinken",
	"HELP_TEXT_LEDS_LEFT_EXAMPLE_2_BODY" : "In diesem Beispiel beginnt das Programm mit dem Eintritt in eine Endlosschleife. Innerhalb der Schleife wird die linke LED eingeschaltet, dann wartet das Programm eine Sekunde lang, dann wird die linke LED ausgeschaltet, dann wartet das Programm eine Sekunde lang, dann springt das Programm an den Anfang der Schleife und wiederholt dies für immer.",
	"HELP_TEXT_LEDS_RIGHT_TITLE" : "LED rechts drehen",
	"HELP_TEXT_LEDS_RIGHT_BODY_1" : "Der Block turn right LED steuert die rechte LED. Es gibt zwei Optionen: an oder aus.",
	"HELP_TEXT_LEDS_RIGHT_EXAMPLE_1_TITLE" : "Beispielprogramm 1: Rechte LED einmal blinken",
	"HELP_TEXT_LEDS_RIGHT_EXAMPLE_1_BODY" : "In diesem Beispiel beginnt das Programm damit, die rechte LED einzuschalten, wartet dann eine Sekunde und schaltet die rechte LED dann wieder aus.",
	"HELP_TEXT_LEDS_RIGHT_EXAMPLE_2_TITLE" : "Beispielprogramm 2: Rechte LED blinkt immer",
	"HELP_TEXT_LEDS_RIGHT_EXAMPLE_2_BODY" : "In diesem Beispiel beginnt das Programm mit dem Eintritt in eine Endlosschleife. Innerhalb der Schleife wird die rechte LED eingeschaltet, dann wartet das Programm eine Sekunde lang, dann wird die rechte LED ausgeschaltet, dann wartet das Programm eine Sekunde lang, dann springt das Programm an den Anfang der Schleife und wiederholt dies für immer.",
	"HELP_TEXT_LEDS_SEND_MESSAGE_TITLE" : "IR-Nachricht senden",
	"HELP_TEXT_LEDS_SEND_MESSAGE_BODY_1" : "Der Block IR-Nachricht senden sendet Daten über Infrarot (IR) Licht. Die Daten, die gesendet werden können, sind ein Wert zwischen 0 und 255. Der Wert kann eine Konstante (die in den Eingang eingegeben wird und sich nicht ändert), eine Variable, ein Sensor oder ein Operatorblock sein.",
	"HELP_TEXT_LEDS_SEND_MESSAGE_BODY_2" : "Die gesendeten Daten können von jedem anderen Edison-Roboter empfangen werden, der sich in Reichweite des IR-Lichtsignals befindet. Die maximale Reichweite kann unter idealen Bedingungen bis zu 10 Meter betragen (d.h. in Innenräumen, kein direktes Sonnenlicht, weiße Decken und Wände, an denen das IR-Licht abprallen kann).",
	"HELP_TEXT_LEDS_SEND_MESSAGE_BODY_3" : "Wenn du eine Variable verwendest, kann die Zahl in der Variable die Grenze von 255 (8 Bits) überschreiten. In diesem Fall wird die per IR gesendete Zahl ''umgeschlagen'' (d.h. 256 sendet 0, 257 sendet 1, 258 sendet 2 ...).",
	"HELP_TEXT_LEDS_SEND_MESSAGE_EXAMPLE_1_TITLE" : "Beispielprogramm 1: IR-Nachricht 1 senden, wenn runder Knopf gedrückt wird",
	"HELP_TEXT_LEDS_SEND_MESSAGE_EXAMPLE_1_BODY" : "In diesem Beispiel beginnt das Programm mit einer Endlosschleife. Innerhalb der Schleife wartet das Programm darauf, dass der runde Knopf gedrückt wird. Wenn dies geschieht, wird die IR-Nachricht 1 gesendet. Dann kehrt das Programm zum Anfang der Endlosschleife zurück.",
	"HELP_TEXT_LEDS_SEND_MESSAGE_EXAMPLE_2_TITLE" : "Beispielprogramm 2: Lichtpegel alle eine Sekunde senden",
	"HELP_TEXT_LEDS_SEND_MESSAGE_EXAMPLE_2_BODY" : "In diesem Beispiel beginnt das Programm mit dem Eintritt in eine Endlosschleife. Innerhalb der Schleife sendet das Programm den vom linken Lichtsensor gemessenen Lichtwert geteilt durch vier. Der Wert wird durch vier geteilt, da die Ausgabe des Lichtsensors 1 bis 1.000 beträgt, aber die höchste Zahl, die mit IR gesendet werden kann, ist 255 (1.000/4 = 250). Durch diese zusätzliche Berechnung kann der gesamte Bereich des Lichtsensors gesendet werden. Das Programm wartet dann eine Sekunde lang und kehrt dann zum Anfang der Endlosschleife zurück.",
	"HELP_TEXT_SOUND_BEEP_TITLE" : "piepsen",
	"HELP_TEXT_SOUND_BEEP_BODY_1" : "Der Beep-Block spielt einen 3,5kHz-Piepton für 125mS (0,125 Sekunden) ab.",
	"HELP_TEXT_SOUND_BEEP_EXAMPLE_1_TITLE" : "Beispielprogramm 1: Piepton, wenn runder Knopf gedrückt wird",
	"HELP_TEXT_SOUND_BEEP_EXAMPLE_1_BODY" : "In diesem Beispiel beginnt das Programm mit dem Eintritt in eine Endlosschleife. Innerhalb der Schleife wartet das Programm darauf, dass der runde Knopf gedrückt wird. Wenn dies geschieht, wird der Piepton abgespielt. Dann kehrt das Programm zum Anfang der Endlosschleife zurück und wiederholt den Vorgang.",
	"HELP_TEXT_SOUND_PLAY_NOTE_TITLE" : "Eine Note abspielen",
	"HELP_TEXT_SOUND_PLAY_NOTE_BODY_1" : "Der Block play a note spielt eine Musiknote ab. Mit den Blockparametern kannst du die Länge, die Note und die Art der Note auswählen.",
	"HELP_TEXT_SOUND_PLAY_NOTE_BODY_2" : "Der Block hat drei Parameter:",
	"HELP_TEXT_SOUND_PLAY_NOTE_BODY_3" : "Länge - Es gibt vier Optionen: ganz, halb, viertel und achtel.",
	"HELP_TEXT_SOUND_PLAY_NOTE_BODY_4" : "Note - Es gibt zehn Optionen: C, B, A, G, F, E, D, mittleres C, tiefes B und Pause.",
	"HELP_TEXT_SOUND_PLAY_NOTE_BODY_5" : "Notenmodifikator - Es gibt drei Optionen: - (nicht modifiziert), sharp und flat.",
	"HELP_TEXT_SOUND_PLAY_NOTE_BODY_6" : "Der Block ''Spiel eine Note'' muss abgeschlossen sein, bevor der nächste Block ausgeführt wird. Wenn du z. B. den Block ''Eine Note abspielen'' verwendest, werden andere Blöcke im Programm nicht zur gleichen Zeit ausgeführt. Siehe dazu den Block Musik im Hintergrund abspielen.",
	"HELP_TEXT_SOUND_PLAY_NOTE_EXAMPLE_1_TITLE" : "Beispielprogramm 1: Mary had a little lamb",
	"HELP_TEXT_SOUND_PLAY_NOTE_EXAMPLE_1_BODY" : "In diesem Beispiel beginnt das Programm mit dem Einstellen des Tempos für die Musiknoten und spielt dann die Noten des Kinderlieds Mary had a little lamb der Reihe nach ab, wobei jede Note vollständig gespielt wird, bevor es weitergeht.",
	"HELP_TEXT_SOUND_SET_TEMPO_TITLE" : "Musiktempo einstellen auf",
	"HELP_TEXT_SOUND_SET_TEMPO_BODY_1" : "Der Block set music temp to legt das Tempo fest, mit dem die folgenden Noten gespielt werden.",
	"HELP_TEXT_SOUND_SET_TEMPO_BODY_2" : "Es gibt fünf Optionen: sehr langsam, langsam, mittel, schnell und sehr schnell.",
	"HELP_TEXT_SOUND_SET_TEMPO_EXAMPLE_1_TITLE" : "Beispielprogramm 1: Mary had a little lamb",
	"HELP_TEXT_SOUND_SET_TEMPO_EXAMPLE_1_BODY" : "In diesem Beispiel legt das Programm zunächst das Tempo für die Musiknoten fest und spielt dann die Noten des Kinderlieds Mary had a little lamb in diesem Tempo ab, wobei jede Note vollständig gespielt wird, bevor es weitergeht.",
	"HELP_TEXT_SOUND_PLAYINBACKGROUND_TITLE" : "Musik im Hintergrund abspielen",
	"HELP_TEXT_SOUND_PLAYINBACKGROUND_BODY_1" : "Der Block ''Musik im Hintergrund abspielen'' ermöglicht das Abspielen von Musiknoten innerhalb des Blocks, während der Edison-Roboter andere Teile des Programms ausführt.",
	"HELP_TEXT_SOUND_PLAYINBACKGROUND_EXAMPLE_1_TITLE" : "Beispielprogramm 1: Mary had a little lamb beim Tanzen",
	"HELP_TEXT_SOUND_PLAYINBACKGROUND_EXAMPLE_1_BODY" : "In diesem Beispielprogramm beginnt das Programm mit der Einstellung des Tempos für die Musiknoten. Dann beginnen die Noten im Block ''Musik im Hintergrund abspielen'' zu spielen, das Programm geht in die Wiederholungsschleife und die Blöcke ''Spin links'' und ''Spin rechts'' laufen viermal, während die Melodie im Hintergrund weiterläuft. Das Ergebnis ist, dass Edison tanzt, während er Musik spielt.",
	"HELP_TEXT_VARIABLE_TITLE" : "Variable",
	"HELP_TEXT_VARIABLE_BODY_1" : "Ein variabler Block ist ein Ort, an dem Daten gespeichert und von einem Programm verwendet werden können. Die Daten in einer Variable können variieren und sich ändern, während das Programm läuft. Deshalb nennt man sie auch Variablen.",
	"HELP_TEXT_VARIABLE_BODY_2" : "Die Daten in einer Variablen sind eine Zahl, die zwischen -1.073.741.824 und 1.073.741.823 (vorzeichenbehaftet, 32-Bit) liegen kann.",
	"HELP_TEXT_VARIABLE_BODY_3" : "Variablen sollten angepasst werden, indem du ihnen einen Namen gibst, der für das Programm sinnvoll ist. Ein Beispiel:",
	"HELP_TEXT_VARIABLE_BODY_4" : "Wenn die Zahl in einer Variable den Bereich von -1.073.741.824 bis 1.073.741.823 überschreitet, wird das Programm angehalten und Edison gibt einen Fehlerton aus.",
	"HELP_TEXT_VARIABLE_EXAMPLE_1_TITLE" : "Beispielprogramm 1: Eine zufällige Blitzrate, die beim Programmstart festgelegt wird",
	"HELP_TEXT_VARIABLE_EXAMPLE_1_BODY_1" : "In diesem Beispielprogramm wird die Variable ''FlashRate'' auf eine Zufallszahl zwischen 10 und 100 gesetzt. Das Programm beginnt dann mit einer Endlosschleife. Innerhalb der Schleife werden die linke und die rechte LED eingeschaltet, dann wartet das Programm auf den Millisekundenwert in 'FlashRate', schaltet dann die linke und die rechte LED aus und wartet erneut auf den Millisekundenwert in 'FlashRate'. Dann wartet das Programm wieder auf den Millisekundenwert in ''FlashRate'' und kehrt an den Anfang der Endlosschleife zurück. Das führt dazu, dass die LEDs von Edison bei jedem Programmdurchlauf mit unterschiedlicher Geschwindigkeit blinken",
	"HELP_TEXT_VARIABLE_EXAMPLE_2_TITLE" : "Beispielprogramm 2: Überfahrene schwarze Linien zählen",
	"HELP_TEXT_VARIABLE_EXAMPLE_2_BODY_1" : "In diesem Beispielprogramm wird zuerst die LED des Linienverfolgers eingeschaltet, dann fährt der Edison-Roboter mit Geschwindigkeit 5 30 cm vorwärts. Während der Vorwärtsfahrt löst jede vom Linienverfolger erkannte nicht reflektierende (schwarze) Fläche einen Sprung zum Ereignisblock Linienverfolger auf nicht reflektierender Fläche aus. Wenn dies geschieht, wird die Variable ''LineCount'' erhöht (+1). Wenn die Fahrt über 30 cm beendet ist, wiederholt das Programm die Wartezeit von 1 Sekunde und die Piep-Blöcke für die in der Variablen 'LineCount' angegebene Anzahl.",
	"HELP_TEXT_VARIABLE_EXAMPLE_3_TITLE" : "Beispielprogramm 3: Lichtstrahlungszähler",
	"HELP_TEXT_VARIABLE_EXAMPLE_3_BODY_1" : "In diesem Beispielprogramm wird das Musiktempo zunächst auf sehr schnell eingestellt. Dann tritt das Programm in eine Endlosschleife ein. Innerhalb der Schleife setzt das Programm die Variable 'Delay' auf 1000 minus den linken Lichtpegel (und invertiert damit den Lichtpegelwert). Der nächste Block wartet auf den Wert in der Variablen ''Delay''. Dann spielt das Programm die Note C und kehrt zum Anfang der Endlosschleife zurück und wiederholt den Vorgang. Das Ergebnis dieses Programms ist, dass Edison langsam piept, wenn es dunkel ist, und schneller, wenn das Licht heller ist.",
	"HELP_TEXT_DATA_SETVARIABLETO_TITLE" : "set to",
	"HELP_TEXT_DATA_SETVARIABLETO_BODY_1" : "Der set to-Block wird verwendet, um einen Wert in einer Variablen zu setzen.",
	"HELP_TEXT_DATA_SETVARIABLETO_BODY_2" : "Es gibt zwei Eingänge:",
	"HELP_TEXT_DATA_SETVARIABLETO_BODY_3" : "Variable - Hier wird der Variablenblock platziert.",
	"HELP_TEXT_DATA_SETVARIABLETO_BODY_4" : "Wert - Kann eine Konstante sein (wird in den Eingang eingegeben und ändert sich nicht), eine Variable, ein Fühler oder ein Operator-Block.",
	"HELP_TEXT_DATA_SETVARIABLETO_EXAMPLE_1_TITLE" : "Beispielprogramm 1: Die Anzahl der Pieptöne einstellen",
	"HELP_TEXT_DATA_SETVARIABLETO_EXAMPLE_1_BODY_1" : "In diesem Beispielprogramm wird die Variable ''NumberOfBeeps'' auf 5 gesetzt, dann wiederholt der Wiederholungsblock das Piepen für den Wert 5, der in der Variable ''NumberOfBeeps'' steht.",
	"HELP_TEXT_DATA_SETVARIABLETO_EXAMPLE_2_TITLE" : "Beispielprogramm 2: Eine zufällige Blitzrate, die beim Programmstart festgelegt wird",
	"HELP_TEXT_DATA_SETVARIABLETO_EXAMPLE_2_BODY_1" : "In diesem Beispielprogramm wird die Variable ''FlashRate'' auf eine Zufallszahl zwischen 10 und 1000 gesetzt. Das Programm beginnt dann mit einer Endlosschleife. Innerhalb der Schleife werden die linke und die rechte LED eingeschaltet, dann wartet das Programm auf den Millisekundenwert in 'FlashRate', schaltet dann die linke und die rechte LED aus und wartet erneut auf den Millisekundenwert in 'FlashRate'. Dann wartet das Programm wieder auf den Millisekundenwert in ''FlashRate'' und kehrt an den Anfang der Endlosschleife zurück. Das führt dazu, dass die LEDs von Edison bei jedem Programmdurchlauf mit unterschiedlicher Geschwindigkeit blinken",
	"HELP_TEXT_DATA_SETVARIABLETO_EXAMPLE_3_TITLE" : "Beispielprogramm 3: Folge dem Licht",
	"HELP_TEXT_DATA_SETVARIABLETO_EXAMPLE_3_BODY_1" : "In diesem Beispiel beginnt das Programm mit einer Endlosschleife. Innerhalb der Schleife setzt das Programm die Variable 'LightLeftvsRight' auf den linken Lichtpegel minus den rechten Lichtpegel. Der if else-Block prüft dann, ob der Wert in der Variablen 'LightLeftvsRight' größer als 0 ist. Wenn das Ergebnis wahr ist, wird der rechte Motor auf Vorwärtsfahrt gestellt und der linke Motor wird angehalten. Wenn das Ergebnis falsch ist, wird der linke Motor auf Vorwärtsfahrt gestellt und der rechte Motor wird angehalten. Das Programm kehrt dann an den Anfang der Endlosschleife zurück und wiederholt den Vorgang. Das Ergebnis ist, dass Edison auf die hellste Lichtquelle zufährt.",
	"HELP_TEXT_DATA_INCVARIABLE_TITLE" : "inkrementieren",
	"HELP_TEXT_DATA_INCVARIABLE_BODY_1" : "Der Inkrement-Block inkrementiert (addiert 1) die Variable, die in dem Block steht.",
	"HELP_TEXT_DATA_INCVARIABLE_EXAMPLE_1_TITLE" : "Beispielprogramm 1: Verlangsamtes Blinken",
	"HELP_TEXT_DATA_INCVARIABLE_EXAMPLE_1_BODY_1" : "In diesem Beispielprogramm wird die Variable ''Verzögerung'' auf 0 gesetzt und das Programm beginnt mit einer Endlosschleife. Innerhalb der Schleife wird die Variable 'Delay' inkrementiert (+1), dann wird die rechte LED eingeschaltet und die linke LED ausgeschaltet, dann wartet das Programm auf den Wert in der Variable 'Delay' in Millisekunden, dann wird die rechte LED ausgeschaltet und die linke LED eingeschaltet und dann wartet das Programm wieder auf den Wert in der Variable 'Delay' in Millisekunden. Dann kehrt das Programm zum Anfang der Endlosschleife zurück und wiederholt den Vorgang. Während das Programm die Endlosschleife durchläuft, wird die Variable ''Verzögerung'' jedes Mal erhöht, so dass die Zeit, die die LEDs ein- und ausgeschaltet werden, immer länger wird. Nach 1.000 Schleifen ist die Zeit, in der die LEDs an sind, eine Sekunde und die Zeit, in der die LEDs aus sind, eine Sekunde.",
	"HELP_TEXT_DATA_DECVARIABLE_TITLE" : "dekrementieren",
	"HELP_TEXT_DATA_DECVARIABLE_BODY_1" : "Der Dekrement-Block dekrementiert (minus 1) die im Block platzierte Variable.",
	"HELP_TEXT_DATA_DECVARIABLE_EXAMPLE_1_TITLE" : "Beispielprogramm 1: Beschleunigung des Blinkens",
	"HELP_TEXT_DATA_DECVARIABLE_EXAMPLE_1_BODY_1" : "In diesem Beispielprogramm wird die Variable ''Verzögerung'' auf 100 gesetzt und das Programm beginnt mit einer Endlosschleife. Innerhalb der Schleife wird die Variable 'Delay' dekrementiert (-1), dann wird die rechte LED eingeschaltet und die linke LED ausgeschaltet, dann wartet das Programm auf den Wert in der Variable 'Delay' in Millisekunden, dann wird die rechte LED ausgeschaltet und die linke LED eingeschaltet und dann wartet das Programm wieder auf den Wert in der Variable 'Delay' in Millisekunden. Dann kehrt das Programm zum Anfang der Endlosschleife zurück und wiederholt den Vorgang. Während das Programm die Endlosschleife durchläuft, wird die Variable ''Verzögerung'' jedes Mal dekrementiert, sodass die Zeit, die die LEDs ein- und ausgeschaltet werden, kürzer wird. Nach 100 Schleifen ist die Zeit, in der die LEDs an sind, eine Millisekunde und die Zeit, in der die LEDs aus sind, eine Millisekunde.",
	"HELP_TEXT_BIT_SHIFT_RIGHT_TITLE" : "Bitverschiebung nach rechts",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_1" : "Die Bitverschiebung nach rechts durch Block passt den angeschlossenen Variablenblock in seiner binären Form mathematisch an, indem die Bits um den eingestellten Wert nach rechts verschoben werden.",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_2" : "Das Zahlenformat, das Computer verwenden, heißt Binär. Es ist ein Zahlensystem, das nur aus den Zahlen 0 und 1 besteht. Jede Zahl in einem Computer ist eine Folge von 1en und 0en. Hier sind einige Beispiele für Binärzahlen, die 8 Bits lang sind:",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_HUMAN" : "Menschlich/dezimal",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_COMPUTER" : "Computer/8-Bit-Binär",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_3" : "Hier sind einige Beispiele für Binärzahlen, die 32 Bits lang sind:",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_4" : "Edison V3 verwendet sowohl 8-Bit- als auch 32-Bit-Binärzahlen. In den Variablenblöcken können zum Beispiel große 32-Bit-Zahlen (eigentlich 31-Bit mit Vorzeichen) gespeichert werden, aber über den IR-Nachrichtenblock können nur 8-Bit-Zahlen gesendet werden. Außerdem haben einige Sensoren, z. B. die Lichtsensoren, einen Bereich von 1 bis 1000. Da die höchstmögliche 8-Bit-Zahl 255 ist, kann der gesamte Bereich des Lichtsensors nicht über den IR-Meldungsblock gesendet werden. Hier kann der Bit Shift Right Block helfen!",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_5" : "Der Messwert des Lichtsensors ist ein 10-Bit-Binärwert. Hier sind die Mindest- und Höchstwerte:",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_6" : "Wenn die Zahl 1000 mit dem Sende-IR-Meldungsblock gesendet würde, wären die empfangene Zahl nur die letzten 8 Bits. Das wäre dann 11111010 (binär) oder 232 (menschlich/dezimal). Das ist eine ganz andere Zahl als der tatsächliche Lichtwert von 1000.",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_7" : "Um die Lichtmessdaten über den IR-Meldungsblock zu senden, kann der Bit Shift Right-Block verwendet werden, um die Zahl in eine 8-Bit-Zahl zu kürzen (Verschiebung um 2 nach rechts), ohne dass zu viele Daten verloren gehen. Auf der Empfängerseite kann der Bit-Shift-Links-Block verwendet werden, um den Lichtpegelwert wieder auf 10-Bit zu verkürzen (Verschiebung um 2 nach links).",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_4_LINE_1_BOX_1" : "Stufe",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_4_LINE_2_BOX_1" : "Lichtmessung",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_4_LINE_3_BOX_1" : "Bitverschiebung nach rechts (2)",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_4_LINE_4_BOX_1" : "IR-Daten senden/empfangen",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_4_LINE_5_BOX_1" : "Bitverschiebung links (2)",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_BIT" : "Bit",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_8" : "In diesem Szenario ist die resultierende Zahl nicht vollkommen identisch, da einige Informationen verloren gegangen sind. Die höchstwertigen Bits, die mehr als 99 % der ursprünglichen Daten enthalten, wurden jedoch durch diesen Prozess beibehalten.",
	"HELP_TEXT_BIT_SHIFT_LEFT_TITLE" : "Bitverschiebung nach links",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_1" : "Die Bitverschiebung nach links durch den Block passt den verbundenen Variablenblock in seiner binären Form mathematisch an, indem die Bits um den eingestellten Wert nach links verschoben werden.",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_2" : "Das Zahlenformat, das Computer verwenden, heißt Binär. Es ist ein Zahlensystem, das nur aus den Zahlen 0 und 1 besteht. Jede Zahl in einem Computer ist eine Folge von 1en und 0en. Hier sind einige Beispiele für Binärzahlen, die 8 Bits lang sind:",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_HUMAN" : "Menschlich/dezimal",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_COMPUTER" : "Computer/8-Bit-Binär",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_3" : "Hier sind einige Beispiele für Binärzahlen, die 32 Bits lang sind:",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_4" : "Edison V3 verwendet sowohl 8-Bit- als auch 32-Bit-Binärzahlen. In den Variablenblöcken können zum Beispiel große 32-Bit-Zahlen (eigentlich 31-Bit mit Vorzeichen) gespeichert werden, aber über den IR-Nachrichtenblock können nur 8-Bit-Zahlen gesendet werden. Außerdem haben einige Sensoren, z. B. die Lichtsensoren, einen Bereich von 1 bis 1000. Da die höchstmögliche 8-Bit-Zahl 255 ist, kann der gesamte Bereich des Lichtsensors nicht über den IR-Meldungsblock gesendet werden. Hier kann der Bit Shift Right Block helfen!",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_5" : "Der Messwert des Lichtsensors ist ein 10-Bit-Binärwert. Hier sind die Mindest- und Höchstwerte:",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_6" : "Wenn die Zahl 1000 mit dem Sende-IR-Meldungsblock gesendet würde, wären die empfangene Zahl nur die letzten 8 Bits. Das wäre dann 11111010 (binär) oder 232 (menschlich/dezimal). Das ist eine ganz andere Zahl als der tatsächliche Lichtwert von 1000.",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_7" : "Um die Lichtmessdaten über den IR-Meldungsblock zu senden, kann der Bit Shift Right-Block verwendet werden, um die Zahl in eine 8-Bit-Zahl zu kürzen (Verschiebung um 2 nach rechts), ohne dass zu viele Daten verloren gehen. Auf der Empfängerseite kann der Bit-Shift-Links-Block verwendet werden, um den Lichtpegelwert wieder auf 10-Bit zu verkürzen (Verschiebung um 2 nach links).",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_4_LINE_1_BOX_1" : "Stufe",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_4_LINE_2_BOX_1" : "Lichtmessung",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_4_LINE_3_BOX_1" : "Bitverschiebung nach rechts (2)",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_4_LINE_4_BOX_1" : "IR-Daten senden/empfangen",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_4_LINE_5_BOX_1" : "Bitverschiebung links (2)",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_BIT" : "Bit",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_8" : "In diesem Szenario ist die resultierende Zahl nicht vollkommen identisch, da einige Informationen verloren gegangen sind. Die höchstwertigen Bits, die mehr als 99 % der ursprünglichen Daten enthalten, wurden jedoch durch diesen Prozess beibehalten.",
	"HELP_TEXT_EVENT_ANYOBSTACLE_TITLE" : "Jedes Hindernis erkannt",
	"HELP_TEXT_EVENT_ANYOBSTACLE_BODY_1" : "Der Ereignisblock Jedes Hindernis erkannt bewirkt, dass das Programm zu diesem Block springt, wenn ein Hindernis vom Hinderniswächter erkannt wird.",
	"HELP_TEXT_EVENT_ANYOBSTACLE_BODY_2" : "Vergewissere dich immer, dass der Strahl des Hinderniswächters im Hauptprogramm eingeschaltet ist.",
	"HELP_TEXT_EVENT_ANYOBSTACLE_EXAMPLE_1_TITLE" : "Beispielprogramm 1: Piepton, wenn ein Hindernis erkannt wird.",
	"HELP_TEXT_EVENT_ANYOBSTACLE_EXAMPLE_1_BODY_1" : "In diesem Beispielprogramm wird zuerst der Hinderniswächter eingeschaltet, dann geht das Programm in den Ewigkeitsschleifenblock. Wenn ein Hindernis erkannt wird, springt das Programm aus der Endlosschleife heraus und geht zum Ereignisblock Jedes Hindernis erkannt. Dadurch wird der Beep-Block ausgeführt und der Edison-Roboter piept. Danach kehrt das Programm an die Stelle zurück, an der es im Hauptprogramm aufgehört hat.",
	"HELP_TEXT_EVENT_ANYOBSTACLE_EXAMPLE_2_TITLE" : "Beispielprogramm 2: Anhalten der Fahrt, wenn ein Hindernis vorhanden ist",
	"HELP_TEXT_EVENT_ANYOBSTACLE_EXAMPLE_2_BODY_1" : "In diesem Beispielprogramm wird zuerst der Hindernisdetektor eingeschaltet, dann werden beide Motoren so eingestellt, dass sie mit der Geschwindigkeit 5 vorwärts fahren, und dann geht das Programm in den Ewigkeitsschleifenblock. Wenn ein Hindernis erkannt wird, springt das Programm aus der Endlosschleife heraus und geht zum Ereignisblock ''Hindernis erkannt''. Dadurch wird der Block ''Beide Motoren stoppen'' ausgelöst und beide Motoren werden gestoppt. Das Programm kehrt dann an die Stelle zurück, an der es im Hauptprogramm aufgehört hat.",
	"HELP_TEXT_EVENT_ANYOBSTACLE_EXAMPLE_3_TITLE" : "Beispielprogramm 3: Hindernissen ausweichen",
	"HELP_TEXT_EVENT_ANYOBSTACLE_EXAMPLE_3_BODY_1" : "In diesem Beispielprogramm wird zuerst der Hindernisdetektor eingeschaltet, dann tritt das Programm in eine Endlosschleife ein, in der beide Motoren mit der Geschwindigkeit 5 vorwärts fahren. Wenn ein Hindernis erkannt wird, springt das Programm aus der Endlosschleife heraus und geht zum Ereignisblock Any obstacle detected. Die Blöcke unter dem Ereignisblock Any obstacle detected fahren den Edison 1 cm rückwärts mit Geschwindigkeit 1 und drehen sich dann 120 Grad nach links mit Geschwindigkeit 1. Dann kehrt das Programm an die Stelle zurück, an der es in der Endlosschleife aufgehört hat, und beide Motoren werden wieder auf Vorwärtsfahrt mit Geschwindigkeit 5 eingestellt. Das führt dazu, dass Edison von Hindernissen in seinem Weg wegfährt.",
	"HELP_TEXT_OBSTACLE_LEFT_EVENT_TITLE" : "Hindernis links erkannt",
	"HELP_TEXT_OBSTACLE_LEFT_EVENT_BODY_1" : "Der Ereignisblock Hindernis links erkannt bewirkt, dass das Programm zu diesem Block springt, wenn der Hindernisdetektor links ein Hindernis erkennt.",
	"HELP_TEXT_OBSTACLE_LEFT_EVENT_BODY_2" : "Vergewissere dich immer, dass der Strahl des Hinderniswächters im Hauptprogramm eingeschaltet ist.",
	"HELP_TEXT_OBSTACLE_LEFT_EVENT_EXAMPLE_1_TITLE" : "Beispielprogramm 1: Piepton, wenn ein Hindernis links erkannt wird",
	"HELP_TEXT_OBSTACLE_LEFT_EVENT_EXAMPLE_1_BODY_1" : "In diesem Beispielprogramm wird zuerst der Hindernisdetektor eingeschaltet, dann springt das Programm in den Endlosschleifenblock. Wenn ein Hindernis auf der linken Seite erkannt wird, springt das Programm aus der Endlosschleife und geht zum Ereignisblock Hindernis links erkannt. Dadurch wird der Beep-Block ausgelöst und der Edison-Roboter piept. Das Programm kehrt dann an die Stelle zurück, an der es im Endlosschleifenblock aufgehört hat.",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_TITLE" : "Hindernis rechts erkannt",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_BODY_1" : "Der Ereignisblock Hindernis erkannt rechts bewirkt, dass das Programm zu diesem Block springt, wenn der Hindernisdetektor rechts ein Hindernis erkennt.",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_BODY_2" : "Vergewissere dich immer, dass der Strahl des Hinderniswächters im Hauptprogramm eingeschaltet ist.",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_1_TITLE" : "Beispielprogramm 1: Piepton, wenn ein Hindernis rechts erkannt wird",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_1_BODY_1" : "In diesem Beispielprogramm wird zuerst der Hindernisdetektor eingeschaltet, dann springt das Programm in den Endlosschleifenblock. Wenn ein Hindernis rechts erkannt wird, springt das Programm aus der Endlosschleife heraus und geht zum Ereignisblock Hindernis rechts erkannt. Dadurch wird der Beep-Block ausgelöst und der Edison-Roboter piept. Anschließend kehrt das Programm an die Stelle zurück, an der es in der Endlosschleife aufgehört hat.",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_2_TITLE" : "Beispielprogramm 2: Hindernisumgehung",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_2_BODY_1" : "In diesem Beispielprogramm wird zunächst der Hindernisdetektor eingeschaltet und das Programm kehrt dann in den Endlosschleifenblock zurück. Wenn ...",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_2_BODY_2" : "...ein Hindernis voraus erkannt wird, springt das Programm zum Ereignisblock Hindernis voraus erkannt und der Edison-Roboter fährt 0,25 Sekunden lang mit der Geschwindigkeit 10 rückwärts und kehrt dann an die Stelle zurück, an der er im Endlosschleifenblock aufgehört hat.",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_2_BODY_3" : "...ein Hindernis rechts erkannt wird, springt das Programm zum Ereignisblock Hindernis rechts erkannt und der Edison-Roboter fährt 0,25 Sekunden lang mit Geschwindigkeit 10 rückwärts und kehrt dann zu der Stelle zurück, an der er im Endlosschleifenblock aufgehört hat.",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_2_BODY_4" : "...ein Hindernis links erkannt wird, springt das Programm zum Ereignisblock Hindernis links erkannt und der Edison-Roboter dreht sich 0,25 Sekunden lang mit Geschwindigkeit 10 nach rechts und kehrt dann an die Stelle zurück, an der er im Endlosschleifenblock aufgehört hat.",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_TITLE" : "Hindernis voraus erkannt",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_BODY_1" : "Der Ereignisblock Hindernis voraus erkannt veranlasst das Programm, zu diesem Block zu springen, wenn der Hindernisdetektor ein Hindernis voraus erkennt. Das bedeutet, dass sowohl der linke als auch der rechte Hindernisdetektor gleichzeitig ein Hindernis erkannt haben.",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_BODY_2" : "Vergewissere dich immer, dass der Strahl des Hinderniswächters im Hauptprogramm eingeschaltet ist.",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_1_TITLE" : "Beispielprogramm 1: Piepton, wenn ein Hindernis voraus erkannt wird",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_1_BODY_1" : "In diesem Beispielprogramm wird zuerst der Hindernisdetektor eingeschaltet, dann springt das Programm in den Endlosschleifenblock. Wenn ein Hindernis rechts erkannt wird, springt das Programm aus der Endlosschleife heraus und geht zum Ereignisblock Hindernis rechts erkannt. Dadurch wird der Beep-Block ausgelöst und der Edison-Roboter piept. Anschließend kehrt das Programm an die Stelle zurück, an der es in der Endlosschleife aufgehört hat.",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_2_TITLE" : "Beispielprogramm 2: Der Hindernisvermeider",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_2_BODY_1" : "In diesem Beispielprogramm wird zunächst der Hindernisdetektor eingeschaltet und das Programm kehrt dann in den Endlosschleifenblock zurück. Wenn ...",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_2_BODY_2" : "...ein Hindernis voraus erkannt wird, springt das Programm zum Ereignisblock Hindernis voraus erkannt und der Edison-Roboter fährt 0,25 Sekunden lang mit der Geschwindigkeit 10 rückwärts und kehrt dann an die Stelle zurück, an der er im Endlosschleifenblock aufgehört hat.",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_2_BODY_3" : "...ein Hindernis rechts erkannt wird, springt das Programm zum Ereignisblock Hindernis rechts erkannt und der Edison-Roboter fährt 0,25 Sekunden lang mit Geschwindigkeit 10 rückwärts und kehrt dann zu der Stelle zurück, an der er im Endlosschleifenblock aufgehört hat.",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_2_BODY_4" : "...ein Hindernis links erkannt wird, springt das Programm zum Ereignisblock Hindernis links erkannt und der Edison-Roboter dreht sich 0,25 Sekunden lang mit Geschwindigkeit 10 nach rechts und kehrt dann an die Stelle zurück, an der er im Endlosschleifenblock aufgehört hat.",
	"HELP_TEXT_CLAP_EVENT_TITLE" : "Klatschen erkannt",
	"HELP_TEXT_CLAP_EVENT_BODY_1" : "Der Ereignisblock Klatschen erkannt bewirkt, dass das Programm zu diesem Block springt, wenn ein Klatschen erkannt wird.",
	"HELP_TEXT_CLAP_EVENT_BODY_2" : "Wenn Edison fährt, lösen Motorgeräusche und Stöße den Klatschsensor aus. Wenn die Wahrscheinlichkeit besteht, dass falsche oder unerwünschte Geräusche erkannt werden, können die Daten des Klatschsensors mit dem Block Sensordaten löschen, der auf Klatschdetektor eingestellt ist, gelöscht werden (siehe Beispielprogramm).",
	"HELP_TEXT_CLAP_EVENT_EXAMPLE_1_TITLE" : "Beispielprogramm: Edison hat Angst vor lauten Geräuschen",
	"HELP_TEXT_CLAP_EVENT_EXAMPLE_1_BODY_1" : "In diesem Beispiel beginnt das Programm mit einer leeren Endlosschleife und es passiert nichts. Wenn ein Klatschen (oder ein anderes lautes, beängstigendes Geräusch) erkannt wird, springt das Programm aus der Endlosschleife heraus und geht zum Ereignisblock ''Klatschen erkannt''. Die Blöcke unterhalb des Ereignisblocks ''Klatschen erkannt'' laufen dann, wobei sie mit Geschwindigkeit 10 5 cm rückwärts fahren (vor Schreck springen) und dann in eine auf 25 Mal eingestellte Wiederholungsschleife eintreten, in der die Blöcke ''Spin links'' und ''Spin rechts'' wiederholt laufen und Edison zum Zittern bringen (vor Schreck zittern). Zum Schluss (wenn Edison sich von seinem Schreck erholt hat) löscht der Block Sensordaten löschen alle falschen Klatscherfassungen, die während der Fahrt aufgetreten sein könnten. Das Programm kehrt nun zur Endlosschleife zurück.",
	"HELP_TEXT_TRIANGLEBUTTON_EVENT_TITLE" : "Dreieckige Taste gedrückt",
	"HELP_TEXT_TRIANGLEBUTTON_EVENT_BODY_1" : "Der Ereignisblock Dreieckstaste gedrückt bewirkt, dass das Programm zu diesem Block springt, wenn die Dreieckstaste gedrückt wird.",
	"HELP_TEXT_TRIANGLEBUTTON_EVENT_EXAMPLE_1_TITLE" : "Beispielprogramm: LED-Blitzgeschwindigkeitseinstellung mit Tasten steuern",
	"HELP_TEXT_TRIANGLEBUTTON_EVENT_EXAMPLE_1_BODY_1" : "In diesem Beispiel beginnt das Programm, indem es die Variable ''Verzögerung'' auf 100 setzt und dann in eine Endlosschleife geht. Innerhalb der Endlosschleife werden die linke und die rechte LED ein- und ausgeschaltet, wobei auf den Wert der Variable ''Verzögerung'' in Millisekunden gewartet wird. Dies führt dazu, dass die LEDs für 100 Millisekunden (0,1 Sekunden) an und für 100 Millisekunden (0,1 Sekunden) aus sind.",
	"HELP_TEXT_TRIANGLEBUTTON_EVENT_EXAMPLE_1_BODY_2" : "Wenn die Dreieckstaste gedrückt wird, springt das Programm zum Ereignisblock ''Dreieckstaste gedrückt''. Die Blöcke unterhalb des Ereignisblocks ''Dreieckstaste gedrückt'' laufen dann ab, setzen die Variable ''Verzögerung'' auf 50 und geben dann einen Piepton aus. Das Programm kehrt dann zur Endlosschleife zurück, aber jetzt ist der Wert in der Variablen ''Verzögerung'' 50, so dass die Zeit zwischen dem Ein- und Ausschalten der LEDs jetzt 50 Millisekunden (0,05 Sekunden) beträgt. Dadurch blinken sie schneller ein und aus.",
	"HELP_TEXT_TRIANGLEBUTTON_EVENT_EXAMPLE_1_BODY_3" : "Wenn die runde Taste gedrückt wird, springt das Programm zum Ereignisblock Runde Taste gedrückt. Die Blöcke unterhalb des Ereignisblocks ''Runde Taste gedrückt'' laufen dann ab, setzen die Variable ''Verzögerung'' auf 200 und geben dann einen Piepton aus. Das Programm kehrt dann zur Endlosschleife zurück, aber jetzt ist der Wert der Variable ''Verzögerung'' 200, so dass die Zeit zwischen dem Ein- und Ausschalten der LEDs jetzt 200 Millisekunden (0,2 Sekunden) beträgt. Dadurch blinken sie langsamer auf und ab.",
	"HELP_TEXT_ROUNDBUTTON_EVENT_TITLE" : "Runde Taste gedrückt",
	"HELP_TEXT_ROUNDBUTTON_EVENT_BODY_1" : "Der Ereignisblock Runde Taste gedrückt bewirkt, dass das Programm zu diesem Block springt, wenn die runde Taste gedrückt wird.",
	"HELP_TEXT_ROUNDBUTTON_EVENT_EXAMPLE_1_TITLE" : "Beispielprogramm: LED-Blitzgeschwindigkeitseinstellung mit Tasten steuern",
	"HELP_TEXT_ROUNDBUTTON_EVENT_EXAMPLE_1_BODY_1" : "In diesem Beispiel beginnt das Programm, indem es die Variable ''Verzögerung'' auf 100 setzt und dann in eine Endlosschleife geht. Innerhalb der Endlosschleife werden die linke und die rechte LED ein- und ausgeschaltet, wobei auf den Wert der Variable ''Verzögerung'' in Millisekunden gewartet wird. Dies führt dazu, dass die LEDs für 100 Millisekunden (0,1 Sekunden) an und für 100 Millisekunden (0,1 Sekunden) aus sind.",
	"HELP_TEXT_ROUNDBUTTON_EVENT_EXAMPLE_1_BODY_2" : "Wenn die Dreieckstaste gedrückt wird, springt das Programm zum Ereignisblock ''Dreieckstaste gedrückt''. Die Blöcke unterhalb des Ereignisblocks ''Dreieckstaste gedrückt'' laufen dann ab, setzen die Variable ''Verzögerung'' auf 50 und geben dann einen Piepton aus. Das Programm kehrt dann zur Endlosschleife zurück, aber jetzt ist der Wert in der Variablen ''Verzögerung'' 50, so dass die Zeit zwischen dem Ein- und Ausschalten der LEDs jetzt 50 Millisekunden (0,05 Sekunden) beträgt. Dadurch blinken sie schneller ein und aus.",
	"HELP_TEXT_ROUNDBUTTON_EVENT_EXAMPLE_1_BODY_3" : "Wenn die runde Taste gedrückt wird, springt das Programm zum Ereignisblock Runde Taste gedrückt. Die Blöcke unterhalb des Ereignisblocks ''Runde Taste gedrückt'' laufen dann ab, setzen die Variable ''Verzögerung'' auf 200 und geben dann einen Piepton aus. Das Programm kehrt dann zur Endlosschleife zurück, aber jetzt ist der Wert der Variable ''Verzögerung'' 200, so dass die Zeit zwischen dem Ein- und Ausschalten der LEDs jetzt 200 Millisekunden (0,2 Sekunden) beträgt. Dadurch blinken sie langsamer auf und ab.",
	"HELP_TEXT_LINEREFLECTIVE_EVENT_TITLE" : "Linientracker auf reflektierender Oberfläche",
	"HELP_TEXT_LINEREFLECTIVE_EVENT_BODY_1" : "Der Ereignisblock Linientracker auf reflektierender Oberfläche bewirkt, dass das Programm zu diesem Block springt, wenn der Linientracker-Sensor einen Wechsel von einer nicht reflektierenden Oberfläche (z. B. schwarz) zu einer reflektierenden Oberfläche (z. B. weiß) feststellt.",
	"HELP_TEXT_LINEREFLECTIVE_EVENT_BODY_2" : "Die LED des Linetrackers muss eingeschaltet sein, damit der Ereignisblock Linetracker auf reflektierender Oberfläche funktioniert.",
	"HELP_TEXT_LINEREFLECTIVE_EVENT_EXAMPLE_1_TITLE" : "Beispielprogramm: Dem Rand einer Linie folgen",
	"HELP_TEXT_LINEREFLECTIVE_EVENT_EXAMPLE_1_BODY_1" : "In diesem Beispiel beginnt das Programm damit, dass die LED des Linienverfolgers eingeschaltet wird und der Roboter nach rechts abbiegt (und nach der Kante einer Linie sucht).",
	"HELP_TEXT_LINEREFLECTIVE_EVENT_EXAMPLE_1_BODY_2" : "Wenn der Linienverfolger einen Wechsel von einer reflektierenden (weißen) zu einer nicht reflektierenden (schwarzen) Oberfläche feststellt, springt das Programm zum Block Linienverfolger auf nicht reflektierender Oberfläche und lässt den Antriebsblock laufen, damit der Roboter nach links abbiegt (zurück zur reflektierenden (weißen) Oberfläche).",
	"HELP_TEXT_LINEREFLECTIVE_EVENT_EXAMPLE_1_BODY_3" : "Wenn der Linienverfolger einen Wechsel von einer nicht reflektierenden zu einer reflektierenden Oberfläche feststellt, springt das Programm zum Ereignisblock Linienverfolger auf reflektierender Oberfläche und lässt den Antriebsblock laufen, um den Roboter nach rechts drehen zu lassen (zurück zur nicht reflektierenden (schwarzen) Oberfläche).",
	"HELP_TEXT_LINEREFLECTIVE_EVENT_EXAMPLE_1_BODY_4" : "Jedes Mal, wenn der Roboter nach links oder rechts abbiegt, bewegt er sich vorwärts und folgt der Kante der Linie.",
	"HELP_TEXT_LINENONREFLECTIVE_EVENT_TITLE" : "Linientracker auf nicht reflektierender Oberfläche",
	"HELP_TEXT_LINENONREFLECTIVE_EVENT_BODY_1" : "Der Ereignisblock Linienverfolger auf nicht reflektierender Oberfläche veranlasst das Programm, zu diesem Block zu springen, wenn der Sensor des Linienverfolgers einen Wechsel von einer reflektierenden Oberfläche (z. B. weiß) zu einer nicht reflektierenden Oberfläche (z. B. schwarz) feststellt.",
	"HELP_TEXT_LINENONREFLECTIVE_EVENT_BODY_2" : "Die LED des Linienverfolgers muss eingeschaltet sein, damit der Ereignisblock Linienverfolger auf nicht reflektierender Oberfläche funktioniert.",
	"HELP_TEXT_LINENONREFLECTIVE_EVENT_EXAMPLE_1_TITLE" : "Beispielprogramm: Dem Rand einer Linie folgen",
	"HELP_TEXT_LINENONREFLECTIVE_EVENT_EXAMPLE_1_BODY_1" : "In diesem Beispiel beginnt das Programm damit, dass die LED des Linienverfolgers eingeschaltet wird und der Roboter nach rechts abbiegt (und nach der Kante einer Linie sucht).",
	"HELP_TEXT_LINENONREFLECTIVE_EVENT_EXAMPLE_1_BODY_2" : "Wenn der Linienverfolger einen Wechsel von einer reflektierenden (weißen) zu einer nicht reflektierenden (schwarzen) Oberfläche feststellt, springt das Programm zum Block Linienverfolger auf nicht reflektierender Oberfläche und lässt den Antriebsblock laufen, damit der Roboter nach links abbiegt (zurück zur reflektierenden (weißen) Oberfläche).",
	"HELP_TEXT_LINENONREFLECTIVE_EVENT_EXAMPLE_1_BODY_3" : "Wenn der Linienverfolger einen Wechsel von einer nicht reflektierenden zu einer reflektierenden Oberfläche feststellt, springt das Programm zum Ereignisblock Linienverfolger auf reflektierender Oberfläche und führt den Antriebsblock aus, um den Roboter nach rechts abbiegen zu lassen (zurück zur nicht reflektierenden (schwarzen) Oberfläche).",
	"HELP_TEXT_LINENONREFLECTIVE_EVENT_EXAMPLE_1_BODY_4" : "Jedes Mal, wenn der Roboter nach links oder rechts abbiegt, bewegt er sich vorwärts und folgt der Kante der Linie.",
	"HELP_TEXT_LINECHANGE_EVENT_TITLE" : "Linienverfolger wechselt Oberfläche",
	"HELP_TEXT_LINECHANGE_EVENT_BODY_1" : "Der Ereignisblock Linienverfolger ändert Oberfläche bewirkt, dass das Programm zu diesem Block springt, wenn der Sensor des Linienverfolgers entweder einen Wechsel von einer nicht reflektierenden (d.h. schwarzen) Oberfläche zu einer reflektierenden (d.h. weißen) Oberfläche oder von einer reflektierenden (d.h. weißen) Oberfläche zu einer nicht reflektierenden (d.h. schwarzen) Oberfläche feststellt.",
	"HELP_TEXT_LINECHANGE_EVENT_BODY_2" : "Die LED des Linienverfolgers muss eingeschaltet sein, damit der Ereignisblock ''Linienverfolger ändert Oberfläche'' funktioniert.",
	"HELP_TEXT_LINECHANGE_EVENT_EXAMPLE_1_TITLE" : "Beispielprogramm: Anhalten für Veränderung",
	"HELP_TEXT_LINECHANGE_EVENT_EXAMPLE_1_BODY_1" : "In diesem Beispiel beginnt das Programm mit dem Einschalten der LED des Linienverfolgers. Der Roboter fährt dann mit Geschwindigkeit 1 vorwärts und tritt in eine Endlosschleife ein. Der Roboter fährt dann so lange vorwärts, bis der Sensor des Linienverfolgers eine Änderung des Reflexionsgrads der Oberfläche feststellt (weiß zu schwarz oder schwarz zu weiß). Wenn das passiert, springt das Programm zum Block Linienverfolger ändert Oberfläche. Der Code unterhalb des Blocks ''Linienverfolger ändert Oberfläche'' hält beide Motoren an, piepst, wartet 1 Sekunde, piepst erneut und setzt dann beide Motoren wieder auf Vorwärtsfahrt.",
	"HELP_TEXT_MESSAGE_EVENT_TITLE" : "IR-Nachricht empfangen",
	"HELP_TEXT_MESSAGE_EVENT_BODY_1" : "Der Ereignisblock ''IR-Nachricht empfangen'' bewirkt, dass das Programm zu diesem Block springt, wenn eine Infrarot-Nachricht (IR) von einem anderen Edison-Roboter empfangen wird.",
	"HELP_TEXT_MESSAGE_EVENT_BODY_3" : "Der Ereignisblock für den Empfang einer IR-Nachricht funktioniert nicht, wenn der IR-Empfänger zum Erkennen von Hindernissen verwendet wird.",
	"HELP_TEXT_MESSAGE_EVENT_BODY_4" : "Das Programm springt zum Ereignisblock ''IR-Nachricht empfangen'', wenn eine IR-Nachricht von einem anderen Edison-Roboter empfangen wird. Der Ereignisblock für den Empfang einer IR-Nachricht dekodiert die Daten in der IR-Nachricht nicht. Um die Nachricht zu dekodieren, müssen die Daten in eine Variable geschrieben und dann mit einem if then-Block dekodiert werden.",
	"HELP_TEXT_MESSAGE_EVENT_EXAMPLE_1_TITLE" : "Beispielprogramm: IR-Nachricht empfangen, um ein- oder zweimal zu piepen",
	"HELP_TEXT_MESSAGE_EVENT_EXAMPLE_1_BODY_1" : "In diesem Beispiel beginnt das Programm mit einer leeren Endlosschleife und es passiert nichts. Wenn eine IR-Nachricht empfangen wird, springt das Programm zum Ereignisblock IR-Nachricht empfangen. Dann wird der Code unterhalb des Ereignisblocks ''IR-Nachricht empfangen'' ausgeführt. Zuerst werden die Daten der empfangenen Nachricht in der Variablen ''ReceivedMessage'' gespeichert. Das ist notwendig, da die Daten der empfangenen IR-Nachricht jedes Mal, wenn sie gelesen werden, auch wieder gelöscht werden. Jetzt, da die Nachrichtendaten in einer Variablen gespeichert sind, wird geprüft, ob sie gleich 1 ist. Wenn dies der Fall ist, wird der Beep-Block einmal abgespielt. Als Nächstes wird geprüft, ob die Variable gleich 2 ist; wenn ja, wird der Piep-Block zweimal abgespielt. Das Programm kehrt nun zur Endlosschleife zurück.",
	"HELP_TEXT_MESSAGE_EVENT_EXAMPLE_2_TITLE" : "Programm zum Senden von IR-Nachrichten:",
	"HELP_TEXT_MESSAGE_EVENT_EXAMPLE_2_BODY_1" : "Das obige Programm wird in dem Edison-Roboter verwendet, der die IR-Nachricht sendet. Das Programm geht zunächst in eine leere Endlosschleife. Wenn die Dreieckstaste gedrückt wird, springt das Programm zum Ereignisblock Dreieckstaste gedrückt und eine IR-Nachricht mit der Nummer 1 wird gesendet. Wenn die runde Taste gedrückt wird, springt das Programm zum Ereignisblock Runde Taste gedrückt und sendet eine IR-Nachricht mit der Nummer 2.",
	"HELP_TEXT_DRIVESTRAIN_EVENT_TITLE" : "Antrieb angespannt",
	"HELP_TEXT_DRIVESTRAIN_EVENT_BODY_1" : "Der Ereignisblock Antrieb belastet bewirkt, dass das Programm zu diesem Block springt, wenn ein oder beide Motoren angetrieben werden, sich aber nicht mehr drehen können (unter Belastung).",
	"HELP_TEXT_DRIVESTRAIN_EVENT_EXAMPLE_1_TITLE" : "Beispielprogramm: Alarm, wenn sich das linke Rad nicht drehen kann",
	"HELP_TEXT_DRIVESTRAIN_EVENT_EXAMPLE_1_BODY_1" : "In diesem Beispiel beginnt das Programm, indem es den linken Motor auf Vorwärtsfahrt stellt und dann in eine Endlosschleife geht. Wenn sich das Rad nicht mehr drehen kann, weil es unter Spannung steht, springt das Programm zum Ereignisblock Antrieb gespannt und führt den folgenden Code aus. Der Code unter dem Ereignisblock Antrieb belastet ist der Beep-Block, der einen Signalton abspielt. Danach kehrt das Programm zur Endlosschleife zurück.",
	"HELP_TEXT_REMOTE_EVENT_TITLE" : "Fernbedienungscode empfangen",
	"HELP_TEXT_REMOTE_EVENT_BODY_1" : "Der Ereignisblock Fernsteuerungscode empfangen bewirkt, dass das Programm zu diesem Block springt, wenn ein Fernsteuerungscode empfangen wird.",
	"HELP_TEXT_REMOTE_EVENT_BODY_3" : "Achte darauf, dass du die Dreieckstaste drückst, um dein Programm zu starten. Das kann leicht vergessen werden, da der Edison-Roboter dann wie ein ferngesteuerter Roboter reagiert und nicht das tut, was du ihm einprogrammiert hast.",
	"HELP_TEXT_REMOTE_EVENT_BODY_4" : "Um die Fernbedienungsblöcke zu benutzen, muss dem Edison-Roboter zuerst beigebracht werden, welche Tasten deiner Fernbedienung welchem Fernbedienungscode entsprechen. Mehr dazu erfährst du hier:",
	"HELP_TEXT_REMOTE_EVENT_BODY_5" : "Wenn sich das Programm unerwartet verhält, musst du eventuell den Block ''Sensordaten löschen'' verwenden, um den Inhalt des Blocks ''Empfangener Fernbedienungscode'' zu löschen. Siehe Beispielprogramm 1 unten.",
	"HELP_TEXT_REMOTE_EVENT_BODY_6" : "Der Empfang von Infrarot-Fernbedienungscodes funktioniert mit etwa 90 % aller handelsüblichen TV-Fernbedienungen, allerdings verwendet jede Marke ein etwas anderes Datenformat. Bei der Dekodierung der Daten kann dies zu unerwartetem Verhalten von einer Fernbedienungsmarke zur anderen führen. Die erweiterte Dekodierung von Fernbedienungen funktioniert am besten mit der EdRemote (erhältlich ab Mitte 2025).",
	"HELP_TEXT_REMOTE_EVENT_EXAMPLE_1_TITLE" : "Beispielprogramm: Fernsteuerung vorwärts oder rückwärts fahren",
	"HELP_TEXT_REMOTE_EVENT_EXAMPLE_1_BODY" : "In diesem Beispiel beginnt das Programm mit der Eingabe einer leeren Endlosschleife. Wenn ein Fernsteuerungscode empfangen wird, springt das Programm zum Ereignisblock Fernsteuerungscode empfangen. Der Code unterhalb des Ereignisblocks ''Fernsteuerungscode empfangen'' wird ausgeführt. Der Fernsteuerungscode wird daraufhin geprüft, ob er gleich 1 ist; wenn dies der Fall ist, werden beide Motoren auf Vorwärtsfahrt eingestellt. Als Nächstes wird geprüft, ob der empfangene Code gleich 2 ist. Ist dies der Fall, werden beide Motoren auf Rückwärtsfahrt eingestellt. Dies geschieht so lange, bis der empfangene Code nicht mehr gleich 2 ist. Nachdem die Fernbedienungscodes getestet wurden und nicht mehr empfangen werden, stoppt der Stopp-Block beide Motoren. Das Programm kehrt zur leeren Endlosschleife zurück.",
	"HELP_TEXT_CONTROL_WAIT_TITLE" : "Wait sec",
	"HELP_TEXT_CONTROL_WAIT_BODY_1" : "Der wait sec-Block unterbricht das Programm für eine bestimmte Zeit in Sekunden. Die Zeitspanne kann zwischen 0,001 Sekunden (1 Millisekunde) und 1.073.741 Sekunden (12,4 Tage) liegen.",
	"HELP_TEXT_CONTROL_WAIT_BODY_2" : "Der Warteblock hat nur einen Parameter:",
	"HELP_TEXT_CONTROL_WAIT_BODY_3" : "Wert - Kann eine Konstante sein (wird in den Eingang eingegeben und ändert sich nicht), eine Variable, ein Fühler oder ein Operator-Block.",
	"HELP_TEXT_CONTROL_WAIT_EXAMPLE_1_TITLE" : "Beispielprogramm 1: Blinken der linken LED",
	"HELP_TEXT_CONTROL_WAIT_EXAMPLE_1_BODY" : "In diesem Beispiel beginnt das Programm mit einer Endlosschleife. Innerhalb der Schleife wird die linke LED eingeschaltet, dann macht das Programm eine Pause und wartet 0,5 Sekunden, dann wird die linke LED ausgeschaltet, dann macht das Programm wieder eine Pause und wartet 0,5 Sekunden und macht dann eine Schleife zum Start.",
	"HELP_TEXT_CONTROL_WAIT_EXAMPLE_2_TITLE" : "Beispielprogramm 2: Nächtliche Robotergrille",
	"HELP_TEXT_CONTROL_WAIT_EXAMPLE_2_BODY" : "In diesem Beispiel beginnt das Programm mit einer Endlosschleife. Innerhalb der Schleife gibt es einen ''wait until''-Block, der den Programmablauf unterbricht, bis die Lichtstärke am linken Lichtsensor unter 100 liegt. Wenn das passiert, wartet das Programm eine zufällige Anzahl von Sekunden zwischen 20 und 300. Wenn diese Wartezeit endet, spielt der Lautsprecher einen Ton. Dann kehrt das Programm zum Anfang der Endlosschleife zurück. Das führt zu einem Verhalten, das dem einer Grille in der Nacht ähnelt, so dass sie nicht gefunden werden kann.",
	"HELP_TEXT_CONTROL_REPEAT_TITLE" : "Wiederholen",
	"HELP_TEXT_CONTROL_REPEAT_BODY_1" : "Der Repeat-Block ist eine Art von Schleife, die nur eine bestimmte Anzahl von Schleifen durchläuft. Alle Blöcke innerhalb des Repeat-Blocks werden nur diese bestimmte Anzahl von Malen ausgeführt.",
	"HELP_TEXT_CONTROL_REPEAT_BODY_2" : "Der Wiederholungsblock hat nur einen Parameter:",
	"HELP_TEXT_CONTROL_REPEAT_BODY_3" : "Wert - Kann eine Konstante sein (wird in den Eingang eingegeben und ändert sich nicht), eine Variable, ein Fühler oder ein Operator-Block.",
	"HELP_TEXT_CONTROL_REPEAT_EXAMPLE_1_TITLE" : "Beispielprogramm 1: In einem Quadrat fahren",
	"HELP_TEXT_CONTROL_REPEAT_EXAMPLE_1_BODY" : "In diesem Beispiel beginnt das Programm mit der Eingabe eines Wiederholungsblocks, der so eingestellt ist, dass er viermal wiederholt wird. Innerhalb des Wiederholungsblocks fährt der Roboter 10 cm vorwärts und dreht sich dann um 90 Grad nach rechts. Diese beiden Blöcke innerhalb des Wiederholungsblocks laufen viermal ab. Das Ergebnis ist, dass der Edison-Roboter in der Form eines Quadrats fährt.",
	"HELP_TEXT_CONTROL_FOREVER_TITLE" : "Für immer",
	"HELP_TEXT_CONTROL_FOREVER_BODY_1" : "Der Forever-Block ist eine Art Schleifenblock, der bedingungslos ewig läuft (es sei denn, das Programm wird angehalten). Die Blöcke, die sich innerhalb des Forever-Blocks befinden, laufen und laufen wieder und wieder und...",
	"HELP_TEXT_CONTROL_FOREVER_EXAMPLE_1_TITLE" : "Beispielprogramm: Blinken einer LED",
	"HELP_TEXT_CONTROL_FOREVER_EXAMPLE_1_BODY" : "In diesem Beispiel beginnt das Programm mit dem Eintritt in eine Endlosschleife. Innerhalb der Endlosschleife wird die linke LED eingeschaltet, dann pausiert der Warteblock das Programm für 0,25 Sekunden, dann wird die linke LED ausgeschaltet, dann pausiert der Warteblock das Programm für 0,25 Sekunden. Dann kehrt das Programm zum Block ''Linke LED einschalten'' zurück und die Sequenz wird für immer wiederholt.",
	"HELP_TEXT_CONTROL_IF_TITLE" : "Wenn dann",
	"HELP_TEXT_CONTROL_IF_BODY_1" : "Der if then-Block führt die Blöcke aus, wenn die Eingangsbedingung erfüllt ist. Wenn die Bedingung nicht erfüllt ist, fährt das Programm mit dem nächsten Block fort.",
	"HELP_TEXT_CONTROL_IF_BODY_2" : "Dieser Block hat einen Eingangsparameter:",
	"HELP_TEXT_CONTROL_IF_BODY_3" : "Bedingter Eingang - Der bedingte Eingang akzeptiert rautenförmige Blöcke, die entweder ein Operator-Block oder ein Sensing-Block sein können.",
	"HELP_TEXT_CONTROL_IF_BODY_4" : "Der if then-Block wird normalerweise innerhalb einer Endlosschleife verwendet, damit die if then-Bedingung mehrfach getestet werden kann. Wenn ein Programm nur einen if then-Block hat, wird der Test einmal ausgeführt und das Programm beendet.",
	"HELP_TEXT_CONTROL_IF_EXAMPLE_1_TITLE" : "Beispielprogramm 1: LED blinkt, wenn geklatscht wird",
	"HELP_TEXT_CONTROL_IF_EXAMPLE_1_BODY" : "n diesem Beispiel beginnt das Programm mit einer Endlosschleife. Der erste Block in der Endlosschleife ist der if then-Block, der prüft, ob es ein Klatschen gegeben hat. Ist dies nicht der Fall, wird der Inhalt des if then-Blocks übersprungen und das Programm kehrt zum Anfang der Endlosschleife zurück. Wenn ein Klatschen festgestellt wurde (true), werden die Blöcke innerhalb des if then-Blocks ausgeführt. Zuerst wird die linke LED eingeschaltet, dann pausiert das Programm für eine Sekunde und dann wird die linke LED ausgeschaltet. Das Programm kehrt nun in einer Schleife zum Anfang der Endlosschleife zurück. Das Ergebnis ist, dass der Edison-Roboter seine linke LED eine Sekunde lang blinkt, wenn er ein Klatschen erkennt.",
	"HELP_TEXT_CONTROL_IF_EXAMPLE_2_TITLE" : "Beispielprogramm 2: Zeichne einen offenen Alarm",
	"HELP_TEXT_CONTROL_IF_EXAMPLE_2_BODY" : "In diesem Beispiel beginnt das Programm mit dem Eintritt in eine Endlosschleife. Der erste Block in der Endlosschleife ist der if then-Block, der prüft, ob die Lichtstärke am linken Lichtsensor größer als 100 ist. Wenn dies der Fall ist (die Lichtstärke ist größer als 100), wird der Beep-Block ausgeführt und der Edison-Roboter piept wie ein Alarm. Wenn dies nicht der Fall ist (die Lichtstärke ist kleiner als 100), wird der Piep-Block übersprungen und das Programm kehrt zum Anfang der Endlosschleife zurück. Das Ergebnis ist, dass der Edison-Roboter immer dann schnell piept, wenn er eine Lichtstärke über 100 feststellt.",
	"HELP_TEXT_CONTROL_IF_ELSE_TITLE" : "If then else",
	"HELP_TEXT_CONTROL_IF_ELSE_BODY_1" : "Der if then else-Block führt den ersten Satz von Blöcken aus, wenn die Eingangsbedingung wahr ist. Wenn die Bedingung falsch ist, wird die zweite Gruppe von Blöcken ausgeführt.",
	"HELP_TEXT_CONTROL_IF_ELSE_BODY_2" : "Dieser Block hat einen Eingangsparameter:",
	"HELP_TEXT_CONTROL_IF_ELSE_BODY_3" : "Bedingter Eingang - Der bedingte Eingang akzeptiert rautenförmige Blöcke, die entweder ein Operator-Block oder ein Sensing-Block sein können.",
	"HELP_TEXT_CONTROL_IF_ELSE_BODY_4" : "Der if then else-Block wird normalerweise innerhalb einer Endlosschleife verwendet, damit die if then else-Bedingung mehrfach getestet werden kann. Wenn ein Programm nur einen if then else-Block hat, wird der Test einmal ausgeführt und das Programm wird beendet.",
	"HELP_TEXT_CONTROL_IF_ELSE_EXAMPLE_1_TITLE" : "Beispielprogramm 1: Hüpfen in Grenzen",
	"HELP_TEXT_CONTROL_IF_ELSE_EXAMPLE_1_BODY" : "In diesem Beispiel beginnt das Programm mit dem Einschalten der LED des Zeilensensors und beginnt dann mit einer Endlosschleife. Der erste Block in der Endlosschleife ist der if then else-Block, der prüft, ob sich der Linetracker-Sensor auf einer nicht reflektierenden Oberfläche (schwarz) befindet. Wenn dies der Fall ist, fährt der erste Satz von Blöcken den Roboter rückwärts und dreht sich dann um 90 Grad. Das Programm überspringt den else-Block und kehrt dann in einer Schleife zurück, um erneut zu prüfen, ob der Sensor des Zeilensuchers auf einer nicht reflektierenden Oberfläche (schwarz) liegt. Wenn dies nicht der Fall ist (auf weiß), wird der else-Block ausgeführt und beide Motoren werden auf Vorwärtsfahrt gestellt. Das führt dazu, dass der Edison-Roboter an einer schwarzen Linie ''abprallt'' und sich umdreht. Dies führt dazu, dass Edison von erkannten schwarzen Linien wegfährt.",
	"HELP_TEXT_CONTROL_IF_ELSE_EXAMPLE_2_TITLE" : "Beispielprogramm 2: Folge dem Licht",
	"HELP_TEXT_CONTROL_IF_ELSE_EXAMPLE_2_BODY" : "In diesem Beispiel beginnt das Programm mit einer Endlosschleife. Der erste Block in der Endlosschleife ist der if then else-Block, der prüft, ob die Lichtstärke am rechten Sensor geringer ist als die Lichtstärke am linken Sensor. Wenn dies der Fall ist (das Licht ist links heller), werden im nächsten Block beide Motoren so eingestellt, dass sie den Roboter nach links drehen (der Roboter dreht sich nach links in Richtung des Lichts). Wenn das Ergebnis falsch ist (das Licht ist rechts heller), werden als nächstes die else-Blöcke ausgeführt. Jetzt läuft der Block, der beide Motoren so einstellt, dass sie den Roboter nach rechts drehen (der Roboter dreht sich in Richtung des Lichts). Das Ergebnis ist, dass der Edison-Roboter in Richtung der hellsten Lichtquelle fährt (versuche mit einer Taschenlampe zu kontrollieren, wohin Edison fährt).",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_TITLE" : "Warten bis",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_BODY_1" : "Der wait until-Block hält das Programm an, bis die Eingabebedingung erfüllt ist.",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_BODY_2" : "Dieser Block hat einen Eingangsparameter:",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_BODY_3" : "Bedingter Eingang - Der bedingte Eingang akzeptiert rautenförmige Blöcke, die entweder ein Operator-Block oder ein Sensing-Block sein können.",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_BODY_4" : "Der wait until-Block wird normalerweise innerhalb einer Endlosschleife verwendet, so dass die wait until-Bedingung mehrmals getestet werden kann. Wenn ein Programm nur einen wait until-Block hat, wird der Test einmal ausgeführt und das Programm wird beendet.",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_EXAMPLE_1_TITLE" : "Beispielprogramm 1: LED blinkt, wenn geklatscht wird",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_EXAMPLE_1_BODY" : "In diesem Beispiel beginnt das Programm mit dem Eintritt in eine Endlosschleife. Der erste Block in der Endlosschleife ist der Block Sensordaten löschen, der alle falschen Klatschdaten löscht. Es folgt der Block wait until mit einem bedingten Block für die Eingabe von Klatschdaten. Hier hält das Programm an und wartet, bis ein Klatschen erkannt wird. Wenn ein Klatschen erkannt wird, schaltet das Programm die linke LED ein, wartet eine Sekunde und schaltet dann die linke LED aus. Das Programm kehrt nun in einer Schleife zum wait until-Block zurück. Bei jedem Klatschen geht die linke LED eine Sekunde lang an. Das Ergebnis ist, dass die linke LED des Edison-Roboters immer dann eine Sekunde lang blinkt, wenn er ein Klatschen wahrnimmt.",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_EXAMPLE_2_TITLE" : "Beispielprogramm 2: Quelle des hellsten Lichtdetektors",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_EXAMPLE_2_BODY" : "In diesem Beispiel beginnt das Programm mit der Eingabe einer Endlosschleife. Der erste Block in der Endlosschleife ist der ''wait until''-Block mit einer Bedingung, die verlangt, dass der Lichtpegel am rechten Lichtsensor gleich dem Lichtpegel am linken Lichtsensor ist. Wenn die Bedingung nicht erfüllt ist (die Lichtwerte sind nicht gleich), hält das Programm hier an. Wenn die Lichtstärke an beiden Lichtsensoren gleich ist, geht das Programm zum Signaltonblock über. Das Programm kehrt nun in einer Schleife zum Warte-Bis-Block zurück und das Programm wird wiederholt. Dies führt dazu, dass der Edison-Roboter piept, wenn er auf die hellste Lichtquelle zeigt",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_TITLE" : "Wiederholen bis",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_BODY_1" : "Der repeat until-Block führt die darin enthaltenen Blöcke aus, bis die Eingabebedingung erfüllt ist.",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_BODY_2" : "Dieser Block hat einen Eingangsparameter:",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_BODY_3" : "Bedingter Eingang - Der bedingte Eingang akzeptiert rautenförmige Blöcke, die entweder ein Operator-Block oder ein Sensing-Block sein können.",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_BODY_4" : "Der repeat until-Block wird oft innerhalb einer Endlosschleife verwendet, damit die repeat until-Bedingung mehrfach getestet werden kann. Wenn ein Programm nur einen repeat until-Block hat, wird der Test nur einmal ausgeführt und das Programm wird beendet.",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_EXAMPLE_1_TITLE" : "Beispielprogramm 1: Den Alarm abstellen",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_EXAMPLE_1_BODY" : "In diesem Beispiel beginnt das Programm mit dem Einschalten des Hinderniswächters (wodurch der Alarm ausgelöst wird) und geht dann in eine Endlosschleife über. Der erste Block in der Endlosschleife ist ein Warte-Bis-Block mit der Bedingung, dass irgendwo ein Hindernis entdeckt wurde (der Eindringlingsdetektor). Das Programm hält hier an und wartet, bis ein Hindernis (Eindringling) entdeckt wird. Wenn ein Hindernis erkannt wird, geht das Programm zum Block repeat until über. Dieser bewirkt, dass der Beep-Block ausgeführt und immer wieder wiederholt wird (der Alarmton), ''bis'' der runde Knopf gedrückt wird (um den Alarm zu stoppen und zurückzusetzen).",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_EXAMPLE_2_TITLE" : "Beispielprogramm 2: Edison fröstelt kalt ohne warmes Licht",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_EXAMPLE_2_BODY" : "In diesem Beispiel beginnt das Programm mit dem Eintritt in eine Endlosschleife. Der erste Block in der Endlosschleife ist der Block repeat until mit einer bedingten Eingabe, die einen Operator verwendet, der verlangt, dass die Lichtstärke des linken Lichtsensors größer als 980 (sehr helles/Sonnenlicht) sein muss. Wenn dies nicht der Fall ist, laufen die folgenden Blöcke ab und der Edison-Roboter dreht sich schnell nach links und rechts (er zittert). Wenn die Helligkeit des linken Lichtsensors über 980 steigt (Edison bewegt sich in sehr helles Licht), wird die Bedingung wahr und das Programm pausiert (Der Edison-Roboter ist warm und glücklich).",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_TITLE" : "Millisekunden warten",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_BODY_1" : "Der Block wait milliseconds hält das Programm für eine bestimmte Zeit in Millisekunden (ms) an. Eine Millisekunde ist ein Tausendstel (1/1000) einer Sekunde oder 0,001 Sekunden.",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_BODY_2" : "1500 Millisekunden = 1,5 Sekunden",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_BODY_3" : "100 Millisekunden = 0,1 Sekunden",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_BODY_4" : "25 Millisekunden = 0,025 Sekunden",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_BODY_5" : "Der Block wait milliseconds hat nur einen Parameter:",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_BODY_6" : "Wert - Kann eine Variable, ein Sensor oder ein Operator-Block sein",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_EXAMPLE_1_TITLE" : "Beispielprogramm 1: Schnell blinkende LED",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_EXAMPLE_1_BODY" : "In diesem Beispiel beginnt das Programm, indem es die Variable ''Verzögerung'' auf 50 setzt und dann in eine Endlosschleife eintritt. Innerhalb der Endlosschleife wird die linke LED eingeschaltet, dann hält der Block ''Warte Millisekunden'' für den Wert in ''Verzögerung'' Millisekunden an, in diesem Fall 50 Millisekunden. Dann wird die linke LED ausgeschaltet, und der Block wait milliseconds hält für 50 Millisekunden an. Das Programm kehrt nun in einer Schleife zum Anfang der Endlosschleife zurück.",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_EXAMPLE_2_TITLE" : "Beispielprogramm 2: Verrückte Lichter",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_EXAMPLE_2_BODY" : "In diesem Beispiel beginnt das Programm mit einer Endlosschleife. Innerhalb der Endlosschleife werden die linken und rechten LEDs ein- und ausgeschaltet. Die Wartezeiten zwischen dem Ein- und Ausschalten werden durch die wait milliseconds Blöcke gesteuert. Die Zeit in Millisekunden wird von den Zufallszahlenblöcken in den Blöcken bestimmt. Diese sind so eingestellt, dass sie Zufallszahlen zwischen 30 und 300 Millisekunden erzeugen. Das Ergebnis ist ein zufälliges Blinken der LED-Leuchten des Edison-Roboters.",
	"HELP_TEXT_SENSING_TURNLINETRACKINGLED_TITLE" : "Linienverfolgungs-LED ein-/ausschalten",
	"HELP_TEXT_SENSING_TURNLINETRACKINGLED_BODY_1" : "Der Block turn line tracker LED on/off schaltet die LED des Line Trackers entweder ein oder aus.",
	"HELP_TEXT_SENSING_TURNLINETRACKINGLED_BODY_2" : "Die Linientracker-LED muss eingeschaltet sein, damit der Linientrackingsensor funktioniert.",
	"HELP_TEXT_SENSING_TURNLINETRACKINGLED_EXAMPLE_1_TITLE" : "Beispielprogramm: Anhalten auf schwarzer Fläche",
	"HELP_TEXT_SENSING_TURNLINETRACKINGLED_EXAMPLE_1_BODY" : "In diesem Beispiel beginnt das Programm mit dem Einschalten der Linienverfolgungs-LED, dann werden beide Motoren auf Vorwärtsfahrt eingestellt. Das Programm wartet dann, bis der Linienverfolgungssensor eine nicht reflektierende Oberfläche (schwarz) erkennt.",
	"HELP_TEXT_SENSING_TURNOBSTACLEBEAM_TITLE" : "Hinderniserkennungsstrahl ein-/ausschalten",
	"HELP_TEXT_SENSING_TURNOBSTACLEBEAM_BODY_1" : "Der Block Hinderniserkennungsstrahl ein-/ausschalten schaltet den Hinderniserkennungsstrahl entweder ein oder aus.",
	"HELP_TEXT_SENSING_TURNOBSTACLEBEAM_BODY_2" : "Der Hinderniserkennungsstrahl muss eingeschaltet sein, damit die Hinderniserkennung funktioniert.",
	"HELP_TEXT_SENSING_TURNOBSTACLEBEAM_EXAMPLE_1_TITLE" : "Beispielprogramm: Für ein Hindernis anhalten",
	"HELP_TEXT_SENSING_TURNOBSTACLEBEAM_EXAMPLE_1_BODY" : "In diesem Beispiel beginnt das Programm mit dem Einschalten des Hinderniserkennungsstrahls, dann werden beide Motoren auf Vorwärtsfahrt eingestellt. Dann werden beide Motoren auf Vorwärtsfahrt gestellt. Das Programm wartet dann, bis irgendwo ein Hindernis erkannt wird, dann endet das Programm und die Motoren halten an.",
	"HELP_TEXT_SENSING_CLEARSENSOR_TITLE" : "Sensordaten löschen",
	"HELP_TEXT_SENSING_CLEARSENSOR_BODY_1" : "Der Block ''Sensordaten löschen'' löscht alle Sensordaten (Erkennungen) des ausgewählten Sensors. Dieser Block wird verwendet, wenn es falsche oder unerwünschte Erkennungen gibt, die das Programm daran hindern, so zu arbeiten, wie du es willst. Ein Beispiel dafür ist, wenn ein Programm den Edison-Roboter antreibt, weil es ein Klatschen erkannt hat. Das Fahren ist in der Regel ziemlich laut und kann eine weitere Erkennung eines Klatschens auslösen. Dies führt dazu, dass das Programm ein zweites Klatschen erkennt, das nicht stattgefunden hat. Der Block Sensordaten löschen wird verwendet, um die Sensordaten von solchen unerwünschten Erkennungen zu befreien.",
	"HELP_TEXT_SENSING_CLEARSENSOR_BODY_2" : "Der Block ''Sensordaten löschen'' hat fünf Eingabeoptionen:",
	"HELP_TEXT_SENSING_CLEARSENSOR_BODY_3" : "Klatschdetektor",
	"HELP_TEXT_SENSING_CLEARSENSOR_BODY_4" : "Tastenfeld",
	"HELP_TEXT_SENSING_CLEARSENSOR_BODY_5" : "Hindernisdetektor",
	"HELP_TEXT_SENSING_CLEARSENSOR_BODY_6" : "Fernbedienungscode",
	"HELP_TEXT_SENSING_CLEARSENSOR_BODY_7" : "IR-Nachricht",
	"HELP_TEXT_SENSING_CLEARSENSOR_EXAMPLE_1_TITLE" : "Beispielprogramm 1: Klatschen und Drehen",
	"HELP_TEXT_SENSING_CLEARSENSOR_EXAMPLE_1_BODY" : "In diesem Beispiel beginnt das Programm mit einer Endlosschleife. Innerhalb der Endlosschleife wird der Sensordatenblock so eingestellt, dass er den Klatschdetektor löscht. Als Nächstes wartet das Programm, bis ein Klatschen erkannt wird, dann wird das Programm fortgesetzt und der Roboter dreht sich zwei Sekunden lang nach links. Während des Drehens machen die Motoren, die Räder und die Kufe Geräusche, die den Klatschdetektor erneut auslösen, so dass der Klatschdetektor nun denkt, dass es ein zweites Klatschen gab. Das Programm kehrt zum Anfang der Endlosschleife zurück (und hält immer noch an der Klatscherfassung fest), aber dann löscht der Block ''Sensordaten löschen'' die Erfassung und der Block ''Warten bis'' wird erst ausgelöst, wenn es tatsächlich einen Klatscher gibt.",
	"HELP_TEXT_SENSING_CLAPDETECTED_TITLE" : "Klatschen erkannt",
	"HELP_TEXT_SENSING_CLAPDETECTED_BODY_1" : "Der Block ''Klatschen erkannt'' ist ein Sensoreingangsblock, der anzeigt, ob ein Klatschen erkannt wurde oder nicht. Es handelt sich um einen rautenförmigen Block, so dass die Daten in diesem Block nur entweder wahr (Klatschen wurde erkannt) oder falsch (Klatschen wurde nicht erkannt) sein können.",
	"HELP_TEXT_SENSING_CLAPDETECTED_BODY_2" : "Andere Geräusche, wie z. B. das Fahren der Motoren, können dazu führen, dass der Block ''Klatschen erkannt'' falsch ausgelöst wird. Verwende den Block Sensordaten löschen, um falsche oder unerwünschte Klatscherkennungen zu löschen.",
	"HELP_TEXT_SENSING_CLAPDETECTED_EXAMPLE_1_TITLE" : "Beispielprogramm 1: LED blinkt, wenn geklatscht wird",
	"HELP_TEXT_SENSING_CLAPDETECTED_EXAMPLE_1_BODY" : "In diesem Beispiel beginnt das Programm mit einer Endlosschleife. Innerhalb der Endlosschleife gibt es einen if then-Block, der prüft, ob ein Klatschen erkannt wurde. Wenn ein Klatschen erkannt wird, leuchtet die linke LED auf, dann wartet das Programm eine Sekunde und schaltet die linke LED wieder aus. Anschließend kehrt das Programm zum Anfang der Endlosschleife zurück. Das Ergebnis ist, dass die linke LED des Edison-Roboters immer dann eine Sekunde lang blinkt, wenn er ein Klatschen feststellt.",
	"HELP_TEXT_SENSING_BUTTONPRESSED_TITLE" : "Gedrückte Taste",
	"HELP_TEXT_SENSING_BUTTONPRESSED_BODY_1" : "Der Button Pressed Block ist ein Sensoreingang, der anzeigt, ob eine Taste gedrückt wurde oder nicht. Es gibt zwei Tastenoptionen:",
	"HELP_TEXT_SENSING_BUTTONPRESSED_BODY_2" : "rund",
	"HELP_TEXT_SENSING_BUTTONPRESSED_BODY_3" : "Dreieck",
	"HELP_TEXT_SENSING_BUTTONPRESSED_BODY_4" : "Der Block ''Taste gedrückt'' ist ein rautenförmiger Block, so dass die Daten in diesem Block nur entweder wahr (Taste wurde gedrückt) oder falsch (Taste wurde nicht gedrückt) sein können.",
	"HELP_TEXT_SENSING_BUTTONPRESSED_EXAMPLE_1_TITLE" : "Beispielprogramm: Signalton bei Tastendruck",
	"HELP_TEXT_SENSING_BUTTONPRESSED_EXAMPLE_1_BODY" : "In diesem Beispiel beginnt das Programm mit einer Endlosschleife. Innerhalb der Endlosschleife gibt es einen if then-Block, der prüft, ob der runde Knopf gedrückt wurde. Wenn der runde Knopf gedrückt wird, führt das Programm den Piep-Block aus und kehrt dann zum Anfang der Endlosschleife zurück.",
	"HELP_TEXT_SENSING_OBSTACLE_TITLE" : "Hindernis erkannt",
	"HELP_TEXT_SENSING_OBSTACLE_BODY_1" : "Der Block Hindernis erkannt ist ein Sensoreingangsblock, der anzeigt, ob ein Hindernis erkannt wurde oder nicht. Es gibt vier Erkennungsoptionen:",
	"HELP_TEXT_SENSING_OBSTACLE_BODY_2" : "überall",
	"HELP_TEXT_SENSING_OBSTACLE_BODY_3" : "voraus",
	"HELP_TEXT_SENSING_OBSTACLE_BODY_4" : "links",
	"HELP_TEXT_SENSING_OBSTACLE_BODY_5" : "rechts",
	"HELP_TEXT_SENSING_OBSTACLE_BODY_6" : "Der Hinderniserkennungsblock ist ein rautenförmiger Block, so dass die Daten in diesem Block nur entweder wahr (Hindernis erkannt) oder falsch (Hindernis nicht erkannt) sein können.",
	"HELP_TEXT_SENSING_OBSTACLE_BODY_7" : "Um den Hinderniserkennungsblock zu verwenden, muss der Block Hinderniserkennungsstrahl ein-/ausschalten verwendet werden, um den Hinderniserkennungsstrahl einzuschalten.",
	"HELP_TEXT_SENSING_OBSTACLE_EXAMPLE_1_TITLE" : "Beispielprogramm: Hindernissen ausweichen",
	"HELP_TEXT_SENSING_OBSTACLE_EXAMPLE_1_BODY" : "In diesem Beispiel beginnt das Programm mit dem Einschalten des Hinderniserkennungsstrahls und beginnt dann mit einer Endlosschleife. Innerhalb der Endlosschleife werden die Motoren so eingestellt, dass sie beide vorwärts fahren, dann gibt es einen if then-Block, der prüft, ob irgendwo ein Hindernis erkannt wurde. Wenn dies der Fall ist, dreht sich der Roboter um 180 Grad und kehrt zum Anfang der Endlosschleife zurück. Am Anfang der Endlosschleife werden beide Motoren wieder auf Vorwärtsfahrt eingestellt. Das führt dazu, dass Edison von Hindernissen auf seinem Weg wegfährt.",
	"HELP_TEXT_SENSING_LINETRACKER_TITLE" : "Line Tracker auf der Oberfläche",
	"HELP_TEXT_SENSING_LINETRACKER_BODY_1" : "Der Block Line Tracker on Surface ist ein Sensoreingangsblock, der anzeigt, ob die Oberfläche reflektierend ist oder nicht. Eine reflektierende Oberfläche ist eine Oberfläche, die das Licht der LED des Linienverfolgers zurück zum Lichtsensor reflektiert. In der Regel ist das eine weiße Oberfläche, aber auch eine rote Oberfläche reflektiert das rote Licht der roten LED des Linetrackers. Eine nicht reflektierende Oberfläche ist eine Oberfläche, die das Licht der Line-Tracker-LED nicht zum Lichtsensor zurückwirft. In der Regel ist dies schwarz, aber auch eine blaue oder grüne Oberfläche reflektiert das rote Licht der roten LED des Linetrackers nicht.",
	"HELP_TEXT_SENSING_LINETRACKER_BODY_2" : "Es gibt zwei Erkennungsoptionen:",
	"HELP_TEXT_SENSING_LINETRACKER_BODY_3" : "reflektierend (weiß)",
	"HELP_TEXT_SENSING_LINETRACKER_BODY_4" : "nicht-reflektierend (schwarz)",
	"HELP_TEXT_SENSING_LINETRACKER_BODY_5" : "Der Block ''Linienverfolgung auf Oberfläche'' ist ein rautenförmiger Block, so dass die Daten in diesem Block nur entweder wahr (Oberflächenart wurde erkannt) oder falsch (Oberflächenart wurde nicht erkannt) sein können.",
	"HELP_TEXT_SENSING_LINETRACKER_BODY_6" : "Um den Block Linienverfolgung auf der Oberfläche zu verwenden, muss der Block Linienverfolgung LED ein/aus verwendet werden, um die LED für die Linienverfolgung einzuschalten.",
	"HELP_TEXT_SENSING_LINETRACKER_EXAMPLE_1_TITLE" : "Beispielprogramm: Bounce in Grenzen",
	"HELP_TEXT_SENSING_LINETRACKER_EXAMPLE_1_BODY" : "In diesem Beispiel beginnt das Programm mit dem Einschalten der Linientracking-LED und geht dann in eine Endlosschleife über. Innerhalb der Endlosschleife werden die Motoren so eingestellt, dass sie beide vorwärts fahren, dann gibt es einen if then-Block, der prüft, ob die Oberfläche nicht reflektierend ist. Wenn dies der Fall ist, dreht sich der Roboter um 180 Grad und kehrt zum Anfang der Endlosschleife zurück. Am Anfang der Endlosschleife werden beide Motoren wieder auf Vorwärtsfahrt eingestellt. Das führt dazu, dass Edison von den erkannten schwarzen Linien wegfährt.",
	"HELP_TEXT_SENSING_REMOTE_BOOL_TITLE" : "Fernbedienungscode empfangen",
	"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_1" : "Der Block ''Fernbedienungscode empfangen'' ist ein Sensoreingangsblock, der anzeigt, ob ein bestimmter Fernbedienungscode empfangen wurde oder nicht.",
	"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_2" : "Es gibt acht Fernsteuerungscodes von 0 bis 7.",
	"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_3" : "Der Block für den empfangenen Fernbedienungscode ist ein rautenförmiger Block, so dass die Daten in diesem Block nur entweder wahr (Code wurde empfangen) oder falsch (Code wurde nicht empfangen) sein können.",
	"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_4" : "Achte darauf, dass du die Dreieckstaste drückst, um dein Programm zu starten. Das kann leicht vergessen werden, da der Edison-Roboter dann wie ein ferngesteuerter Roboter reagiert und nicht das tut, was du ihm einprogrammiert hast.",
	"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_5" : "Um den Block für den empfangenen Fernbedienungscode zu verwenden, muss dem Edison-Roboter zuerst beigebracht werden, welche Tasten deiner Fernbedienung welchem Fernbedienungscode entsprechen. Mehr dazu erfährst du hier:",
	"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_6" : "Wenn sich das Programm unerwartet verhält, musst du eventuell den Sensordatenblock löschen, um den Inhalt des Fernbedienungscode-Empfangsblocks zu löschen. Siehe Beispielprogramm 1 unten.",
	"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_7" : "Der Fernbedienungscode-Empfangsblock funktioniert mit ungefähr 90 % der Standard-Fernbedienungen für Fernsehgeräte, allerdings verwendet jede Fernsehmarke ein etwas anderes IR-Datenformat. Bei der Dekodierung von IR-Daten durch Edison können diese Unterschiede zu einem unerwarteten Verhalten der verschiedenen Fernbedienungsmarken führen. Die erweiterte Dekodierung von Fernbedienungen funktioniert am besten mit der EdRemote (erhältlich ab Mitte 2025).",
	"HELP_TEXT_SENSING_REMOTE_BOOL_EXAMPLE_1_TITLE" : "Beispielprogramm 1: Ein Piepton oder zwei?",
	"HELP_TEXT_SENSING_REMOTE_BOOL_EXAMPLE_1_BODY" : "In diesem Beispiel beginnt das Programm mit einer Endlosschleife. Innerhalb der Endlosschleife gibt es zwei if then Blöcke, die den empfangenen Fernbedienungscode testen. Der erste if then-Block prüft, ob der empfangene Fernmeldecode der Fernmeldecode 1 ist. Wenn dies der Fall ist, ertönt der Signalton einmal und die Sensordaten werden dann gelöscht. Wenn dies nicht der Fall ist, geht das Programm zum nächsten if then-Block über und prüft, ob der empfangene Fernbedienungscode Fernbedienungscode 2 ist. Wenn dies der Fall ist, ertönt der Signalton zweimal und die Sensordaten werden gelöscht. Dann kehrt das Programm zum Anfang der Endlosschleife zurück.",
	"HELP_TEXT_SENSING_REMOTE_BOOL_EXAMPLE_2_TITLE" : "Beispielprogramm 2: Drehen auf Fernbedienungsbefehl (funktioniert am besten mit der EdRemote)",
	"HELP_TEXT_SENSING_REMOTE_BOOL_EXAMPLE_2_BODY" : "In diesem Beispiel beginnt das Programm mit einer Endlosschleife. Innerhalb der Endlosschleife prüft der if then-Block, ob der Fernsteuerungscode 0 empfangen wurde. Wenn dies der Fall ist, werden beide Motoren so eingestellt, dass sie den Roboter nach rechts drehen. Dies geschieht so lange, bis die Bedingung des wait until-Blocks erfüllt ist. Um zu bestehen, darf der empfangene Fernbedienungscode nicht Fernbedienungscode 0 sein (der Fernbedienungsknopf wird nicht mehr gedrückt). Wenn das passiert, stoppt das Programm beide Motoren und kehrt dann zum Anfang der Endlosschleife zurück. Das führt dazu, dass sich Edison dreht, während die Fernsteuerungstaste gedrückt gehalten wird.",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_TITLE" : "IR-Nachricht erkannt",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_BODY_1" : "Der Block IR-Nachricht erkannt ist ein Sensoreingang, der anzeigt, ob eine IR-Nachricht von einem anderen Edison-Roboter erkannt (empfangen) wurde oder nicht. Der Begriff ''IR'' ist die Abkürzung für ''Infrarot''. Infrarot bezieht sich auf ein Lichtband, das für Menschen nicht sichtbar ist. Das macht es zu einem nützlichen Mittel, um Daten über kurze Distanzen zu übermitteln.",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_BODY_2" : "Der Block ''IR-Nachricht erkannt'' ist ein rautenförmiger Block, so dass die Daten in diesem Block entweder wahr (IR-Nachricht wurde empfangen) oder falsch (IR-Nachricht wurde nicht empfangen) sein können.",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_BODY_4" : "Der Block ''IR-Nachricht erkannt'' kennt den Inhalt der empfangenen IR-Nachricht nicht. Er teilt dem Programm nur mit, ob eine IR-Nachricht empfangen wurde. Um die Daten in der IR-Nachricht zu lesen, verwende den Block für die empfangene IR-Nachricht. Siehe das Beispielprogramm.",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_BODY_5" : "Infrarot-Nachrichten zwischen Edison-Robotern funktionieren am besten in geschlossenen Räumen und ohne direkte Sonneneinstrahlung. Die typische Reichweite beträgt bis zu 10 Meter (30 Fuß).",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_EXAMPLE_1_TITLE" : "Beispielprogramm: Edison-Fernlicht an und aus",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_EXAMPLE_1_BODY" : "In diesem Beispiel beginnt das Programm mit einer Endlosschleife. Innerhalb der Endlosschleife prüft der erste if then-Block, ob eine IR-Nachricht empfangen wurde. Ist dies der Fall, wird die Variable ''IRMessage'' auf den Wert des empfangenen IR-Nachrichtenblocks gesetzt. Auf diese Weise kann die empfangene Nachricht mehrmals gelesen/getestet werden, ohne dass sie gelöscht wird oder verloren geht. Die nächste if then-Anweisung prüft, ob die Daten in 'IRMessage' gleich 1 sind. Wenn dies der Fall ist, wird die linke LED eingeschaltet. Wenn dies nicht der Fall ist, geht das Programm zum nächsten if then-Block über. Dieser if then-Block prüft, ob die Daten in ''IR-Meldung'' gleich 2 sind. Wenn das der Fall ist, wird die linke LED ausgeschaltet. Das Programm kehrt dann in einer Schleife zum Anfang der Endlosschleife zurück.",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_EXAMPLE_2_TITLE" : "Der Edison-Roboter, der IR-Nachrichten sendet, führt dieses Programm aus.",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_EXAMPLE_2_BODY" : "Wenn du die dreieckige Taste drückst, wird eine IR-Nachricht mit der Nummer 1 gesendet (die LED wird eingeschaltet) und wenn du die runde Taste drückst, wird eine IR-Nachricht mit der Nummer 2 gesendet (die LED wird ausgeschaltet)",
	"HELP_TEXT_SENSING_DRIVESTRAINED_TITLE" : "Antriebsdehnung erkannt",
	"HELP_TEXT_SENSING_DRIVESTRAINED_BODY_1" : "Der Block ''Antriebsbelastung erkannt'' ist ein Sensoreingangsblock, der anzeigt, ob sich eines oder beide Räder nicht mehr drehen, weil sie unter Belastung stehen (physisch daran gehindert werden, sich beim Fahren zu drehen).",
	"HELP_TEXT_SENSING_DRIVESTRAINED_BODY_2" : "Der Block ''Antriebsbelastung erkannt'' ist ein rautenförmiger Block, so dass die Daten in diesem Block entweder wahr (das Rad ist belastet) oder falsch (das Rad ist nicht belastet) sein können.",
	"HELP_TEXT_SENSING_DRIVESTRAINED_EXAMPLE_1_TITLE" : "Beispielprogramm: Alarm bei belastetem Rad",
	"HELP_TEXT_SENSING_DRIVESTRAINED_EXAMPLE_1_BODY" : "In diesem Beispiel beginnt das Programm damit, dass das linke Rad auf Vorwärtsfahrt eingestellt wird, dann geht das Programm in eine Endlosschleife. Innerhalb der Schleife gibt es einen if then-Block, der prüft, ob die Belastung des Antriebs erkannt wurde. Wenn dies der Fall ist, wird der Piep-Block ausgeführt. Der Piep-Block wird so lange ausgeführt, bis die Belastung beseitigt ist und sich das Rad drehen kann.",
	"HELP_TEXT_SENSING_REMOTE_NUM_TITLE" : "Empfangener Fernbedienungscode",
	"HELP_TEXT_SENSING_REMOTE_NUM_BODY_1" : "Der Block für den empfangenen Fernbedienungscode ist ein Sensoreingangsblock, der Daten enthält, die von einer Fernsteuerung empfangen wurden. Bei den Daten handelt es sich um eine Zahl von 0 bis 7.",
	"HELP_TEXT_SENSING_REMOTE_NUM_BODY_2" : "Wenn ein Programm diesen Block ausführt, wird sein Inhalt gelöscht. Es ist immer am besten, die Daten aus dem Block für den empfangenen Fernbedienungscode in eine Variable zu schreiben, bevor du sie mit einem bedingten (if then) Block testest. Siehe Beispielprogramm.",
	"HELP_TEXT_SENSING_REMOTE_NUM_EXAMPLE_1_TITLE" : "Beispielprogramm: Fernsteuerung Licht an und aus",
	"HELP_TEXT_SENSING_REMOTE_NUM_EXAMPLE_1_BODY" : "In diesem Beispiel beginnt das Programm mit einer Endlosschleife. Der erste Block innerhalb der Endlosschleife speichert die Daten aus dem empfangenen Fernbedienungscode-Block in der Variablen ''RemoteCode''. Die Variable ''RemoteCode'' kann nun getestet werden. Der erste if then-Block prüft, ob der Inhalt von 'RemoteCode' gleich 1 ist. Wenn dies der Fall ist, wird die linke LED eingeschaltet. Wenn dies falsch ist, prüft der nächste if then-Block, ob der Inhalt von ''RemoteCode'' gleich 2 ist. Wenn dies wahr ist, wird die linke LED ausgeschaltet. Das Programm kehrt dann zum Anfang der Endlosschleife zurück.",
	"HELP_TEXT_SENSING_IRMESSAGE_TITLE" : "Empfangene IR-Nachricht",
	"HELP_TEXT_SENSING_IRMESSAGE_BODY_1" : "Der Block ''Empfangene IR-Nachricht'' ist ein Sensoreingangsblock, der Daten enthält, die von einem anderen Edison-Roboter empfangen wurden. Der Begriff ''IR'' ist die Abkürzung für ''Infrarot''. Infrarot bezieht sich auf ein Lichtband, das für Menschen nicht sichtbar ist. Das macht es zu einem nützlichen Mittel, um Daten über kurze Distanzen zu übermitteln. Die Daten basieren auf einer 8-Bit-Binärzahl und haben einen Bereich von 0 bis 255.",
	"HELP_TEXT_SENSING_IRMESSAGE_BODY_2" : "Wenn ein Programm diesen Block ausführt, wird sein Inhalt gelöscht. Es ist immer am besten, die Daten aus dem empfangenen Remote-Code in eine Variable zu schreiben, bevor du sie mit einem bedingten Block (if then block) testest.",
	"HELP_TEXT_SENSING_IRMESSAGE_BODY_3" : "Infrarot-Nachrichten zwischen Edison-Robotern funktionieren am besten in geschlossenen Räumen und ohne direkte Sonneneinstrahlung. Die typische Reichweite beträgt bis zu 10 Meter (30 Fuß).",
	"HELP_TEXT_SENSING_IRMESSAGE_EXAMPLE_1_TITLE" : "Beispielprogramm: Eine Tanzrevolution starten",
	"HELP_TEXT_SENSING_IRMESSAGE_EXAMPLE_1_BODY" : "In diesem Beispiel beginnt das Programm mit dem Eintritt in eine Endlosschleife. Der erste Block innerhalb der Endlosschleife löscht die Sensordaten der IR-Nachricht. Dann wartet das Programm, bis eine IR-Nachricht empfangen wird, die gleich 3 ist. Wenn das passiert, tritt das Programm viermal in eine Wiederholungsschleife ein. Innerhalb der Wiederholungsschleife werden die Tanzmanöver des Edison-Roboters ausgeführt. Jede dieser Bewegungen basiert auf der Zeit und nicht auf der Entfernung. Das ist besonders wichtig, wenn eine ganze Klasse von Edison-Robotern im Takt zur Musik tanzt. Die Tanzmanöver werden viermal wiederholt, dann kehrt das Programm an den Anfang der Endlosschleife zurück.",
	"HELP_TEXT_SENSING_IRMESSAGE_EXAMPLE_2_TITLE" : "Beispielprogramm: IR-Nachricht 3 senden",
	"HELP_TEXT_SENSING_IRMESSAGE_EXAMPLE_2_BODY" : "In diesem Beispiel beginnt das Programm mit einer Endlosschleife. Der erste Block innerhalb der Endlosschleife wartet, bis die runde Taste gedrückt wird. Wenn dies geschieht, wird die Nachricht Nummer 3 per Infrarotlicht gesendet. Dann kehrt das Programm zum Anfang der Endlosschleife zurück.",
	"HELP_TEXT_SENSING_LIGHTLEVEL_TITLE" : "Lichtpegel des Sensors",
	"HELP_TEXT_SENSING_LIGHTLEVEL_BODY_1" : "Der Block Lichtniveau des Sensors ist ein Sensoreingangsblock, der Daten von den Lichtsensoren enthält. Die Lichtstärke ist eine Zahl zwischen 1 und 1000. Die Daten des Lichtpegels des Sensorblocks werden ständig aktualisiert.",
	"HELP_TEXT_SENSING_LIGHTLEVEL_BODY_2" : "Es gibt drei Lichtsensoreingänge, aus denen du wählen kannst:",
	"HELP_TEXT_SENSING_LIGHTLEVEL_BODY_3" : "- linkes Licht (Sensor an der linken Vorderseite)",
	"HELP_TEXT_SENSING_LIGHTLEVEL_BODY_4" : "- rechtes Licht (Sensor an der vorderen rechten Seite)",
	"HELP_TEXT_SENSING_LIGHTLEVEL_BODY_5" : "- Linienverfolgung (Sensor zur Erkennung von Linien unter dem Roboter)",
	"HELP_TEXT_SENSING_LIGHTLEVEL_EXAMPLE_1_TITLE" : "Beispielprogramm: Nachtlicht",
	"HELP_TEXT_SENSING_LIGHTLEVEL_EXAMPLE_1_BODY" : "In diesem Beispiel beginnt das Programm mit einer Endlosschleife. Der erste Block innerhalb der Endlosschleife prüft, ob die Lichtstärke am linken Lichtsensor weniger als 50 beträgt. Wenn dies der Fall ist, leuchten die linke und die rechte LED. Wenn dies nicht der Fall ist, springt das Programm zu else und die linken und rechten LEDs werden ausgeschaltet. Das Programm springt dann an den Anfang der Endlosschleife und wiederholt diese. Das Ergebnis ist, dass Edisons LEDs leuchten, während er sich in einem schummrigen Licht befindet.",
	"HELP_TEXT_ADDITION_TITLE" : "Addition",
	"HELP_TEXT_ADDITION_BODY" : "Der Additionsoperatorblock addiert zwei Werte zusammen. Bei den Werten kann es sich um eine Konstante (die in den Eingang eingegeben wird und sich nicht ändert), eine Variable, eine Abtastung oder einen Operatorblock handeln.",
	"HELP_TEXT_ADDITION_EXAMPLE_1_TITLE" : "Der konstante Wert 2 wird zu dem konstanten Wert 2 addiert.",
	"HELP_TEXT_ADDITION_EXAMPLE_2_TITLE" : "Die Variable ''Zähler'' wird zu dem konstanten Wert 2 addiert.",
	"HELP_TEXT_ADDITION_EXAMPLE_3_TITLE" : "Der Sensoreingang Lichtstärke des Sensors wird zum konstanten Wert 10 addiert.",
	"HELP_TEXT_SUBTRACTION_TITLE" : "Subtraktion",
	"HELP_TEXT_SUBTRACTION_BODY" : "Der Subtraktionsoperatorblock subtrahiert einen Wert von einem anderen. Bei den Werten kann es sich um eine Konstante (die in den Eingang eingegeben wird und nicht variiert), eine Variable, einen Sensor oder einen Operatorblock handeln.",
	"HELP_TEXT_SUBTRACTION_EXAMPLE_1_TITLE" : "Der konstante Wert 10 wird von dem konstanten Wert 200 subtrahiert.",
	"HELP_TEXT_SUBTRACTION_EXAMPLE_2_TITLE" : "Der konstante Wert 100 wird von der Variablen ''Zähler'' subtrahiert.",
	"HELP_TEXT_SUBTRACTION_EXAMPLE_3_TITLE" : "Der konstante Wert 10 wird vom Lichteingang des Sensors subtrahiert.",
	"HELP_TEXT_SUBTRACTION_EXAMPLE_4_TITLE" : "Beispielprogramm: Lichtstrahlungszähler",
	"HELP_TEXT_SUBTRACTION_EXAMPLE_4_BODY" : "In diesem Beispielprogramm wird das Musiktempo zunächst auf sehr schnell eingestellt. Dann tritt das Programm in eine Endlosschleife ein. Innerhalb der Schleife setzt das Programm die Variable (Delay) auf 1000 minus den linken Lichtpegel (und invertiert so den Lichtpegelwert). Der nächste Block wartet auf den Wert in der Variablen (Delay). Dann spielt das Programm die Note C und kehrt zum Anfang der Endlosschleife zurück und wiederholt diese. Das Ergebnis ist, dass der Edison bei Dunkelheit langsam piept und schneller, wenn es heller ist.",
	"HELP_TEXT_MULTIPLICATION_TITLE" : "Multiplikation",
	"HELP_TEXT_MULTIPLICATION_BODY" : "Der Multiplikations-Operatorblock multipliziert zwei Werte. Bei den Werten kann es sich um eine Konstante (die in den Eingang eingegeben wird und sich nicht ändert), eine Variable, einen Fühler oder einen Operatorblock handeln.",
	"HELP_TEXT_MULTIPLICATION_EXAMPLE_1_TITLE" : "Der konstante Wert 2 wird mit dem konstanten Wert 4 multipliziert.",
	"HELP_TEXT_MULTIPLICATION_EXAMPLE_2_TITLE" : "Die Variable ''Zähler'' wird mit dem konstanten Wert 2 multipliziert.",
	"HELP_TEXT_MULTIPLICATION_EXAMPLE_3_TITLE" : "Der Sensoreingang Lichtstärke des Sensors wird mit dem konstanten Wert 4 multipliziert.",
	"HELP_TEXT_DIVISION_TITLE" : "Division",
	"HELP_TEXT_DIVISION_BODY_1" : "Der Divisionsoperatorblock teilt einen Wert durch einen anderen Wert. Die Werte können eine Konstante (die in den Eingang eingegeben wird und sich nicht ändert), eine Variable, ein Sensor oder ein Operatorblock sein.",
	"HELP_TEXT_DIVISION_BODY_2" : "Es ist nicht möglich, durch Null zu dividieren. Edison gibt einen Fehler aus, wenn der rechte Eingang Null ist.",
	"HELP_TEXT_DIVISION_EXAMPLE_1_TITLE" : "Der konstante Wert 10 wird durch den konstanten Wert 2 geteilt.",
	"HELP_TEXT_DIVISION_EXAMPLE_2_TITLE" : "Die Variable ''Zähler'' wird durch den konstanten Wert 2 geteilt.",
	"HELP_TEXT_DIVISION_EXAMPLE_3_TITLE" : "Der Lichteingang des Sensors wird durch 10 geteilt.",
	"HELP_TEXT_DIVISION_EXAMPLE_4_TITLE" : "Beispielprogramm: Einstellen der Fahrstrecke mithilfe einer Variablen und Daten von einem Sensor",
	"HELP_TEXT_DIVISION_EXAMPLE_4_BODY" : "In diesem Beispielprogramm setzt Edison die Variable (Abstand) auf den Lichtpegel des linken Lichtsensors (ein Wert von 1 bis 1.000) geteilt durch 50. Der Edison fährt dann für den Wert in der Variable (Entfernung) mit der Geschwindigkeit 5 vorwärts. Das führt dazu, dass der Edison bei hellem Licht weiter fährt, bis zu einer maximalen Entfernung von 20 cm.",
	"HELP_TEXT_RANDOM_NUMBER_TITLE" : "Zufallszahl",
	"HELP_TEXT_RANDOM_NUMBER_BODY" : "Der Block Zufallszahl zwischen erzeugt eine Zufallszahl zwischen zwei Werten. Bei den Werten kann es sich um eine Konstante (die in die Eingabe eingegeben wird und nicht variiert), eine Variable, einen Sensor oder einen Operatorblock handeln.",
	"HELP_TEXT_RANDOM_NUMBER_EXAMPLE_1_TITLE" : "Erzeuge eine Zufallszahl zwischen dem konstanten Wert 10 und dem konstanten Wert 100.",
	"HELP_TEXT_RANDOM_NUMBER_EXAMPLE_2_TITLE" : "Erstelle eine Zufallszahl zwischen der Variablen ''Zähler'' und dem konstanten Wert 5000.",
	"HELP_TEXT_RANDOM_NUMBER_EXAMPLE_3_TITLE" : "Erzeuge eine Zufallszahl zwischen dem konstanten Wert 10 und dem Sensoreingang Lichtstärke des Sensors.",
	"HELP_TEXT_RANDOM_NUMBER_EXAMPLE_4_TITLE" : "Beispielprogramm: Verrückte Lichter",
	"HELP_TEXT_RANDOM_NUMBER_EXAMPLE_4_BODY" : "In diesem Beispiel beginnt das Programm mit dem Eintritt in eine Endlosschleife. Innerhalb der Endlosschleife werden die linken und rechten LEDs ein- und ausgeschaltet. Die Wartezeiten zwischen dem Ein- und Ausschalten werden durch die wait milliseconds Blöcke gesteuert. Die Zeit in Millisekunden wird von den Zufallszahlenblöcken in den Blöcken bestimmt. Diese sind so eingestellt, dass sie Zufallszahlen zwischen 30 und 300 Millisekunden erzeugen. Das Ergebnis ist ein verrücktes und ungleichmäßiges Blinken der LED-Lichter des Edison-Roboters.",
	"HELP_TEXT_ABS_VAL_TITLE" : "abs",
	"HELP_TEXT_ABS_VAL_BODY" : "Der abs (absolute value) Block wandelt einen Wert in einen absoluten Wert um. Ein absoluter Wert ist ein Wert, der immer positiv ist. Der Wert kann eine Konstante (die in den Eingang eingegeben wird und sich nicht ändert), eine Variable, ein Sensor oder ein Operatorblock sein.",
	"HELP_TEXT_ABS_VAL_EXAMPLE_1_BODY" : "Hat ein Ergebnis mit dem Wert 3.",
	"HELP_TEXT_ABS_VAL_EXAMPLE_2_BODY" : "Hat ein Ergebnis mit dem Wert 3.",
	"HELP_TEXT_ABS_VAL_EXAMPLE_3_TITLE" : "Beispielprogramm: Den Unterschied zwischen den Lichtwerten melden",
	"HELP_TEXT_ABS_VAL_EXAMPLE_3_BODY" : "In diesem Beispiel beginnt das Programm mit der Eingabe einer Endlosschleife. Der erste Block in der Endlosschleife setzt die Variable ''Differenz'' auf den absoluten Wert des Lichtpegels des rechten Lichtsensors minus des Lichtpegels des linken Lichtsensors. Der abs-Block stellt sicher, dass das Ergebnis immer positiv ist (keine negativen Zahlen). Das Programm wartet dann eine Sekunde und sendet dann den Wert in der Variablen 'Difference' über USB. Dieser Wert ist immer ein positiver (absoluter) Wert.",
	"HELP_TEXT_LESS_THAN_TITLE" : "Kleiner als",
	"HELP_TEXT_LESS_THAN_BODY_1" : "Der Less than-Block vergleicht zwei Eingabewerte, um festzustellen, ob der erste Wert kleiner ist als der zweite und liefert ein Ergebnis, das entweder wahr oder falsch ist. Bei den Werten kann es sich um eine Konstante (die in die Eingabe eingegeben wird und sich nicht ändert), eine Variable, eine Abtastung oder einen Operatorblock handeln.",
	"HELP_TEXT_LESS_THAN_BODY_2" : "Der Weniger-als-Block ist ein rautenförmiger Block, so dass das Ergebnis des Blocks nur entweder wahr oder falsch sein kann.",
	"HELP_TEXT_LESS_THAN_EXAMPLE_1_BODY" : "Ergebnis: wahr",
	"HELP_TEXT_LESS_THAN_EXAMPLE_2_BODY" : "Ergebnis: falsch",
	"HELP_TEXT_LESS_THAN_EXAMPLE_3_TITLE" : "Ist die Variable ''Zähler'' kleiner als der konstante Wert 120.",
	"HELP_TEXT_LESS_THAN_EXAMPLE_4_TITLE" : "Ist der Lichtpegel des linken Sensors kleiner als der konstante Wert 500.",
	"HELP_TEXT_LESS_THAN_EQUAL_TITLE" : "Kleiner als oder gleich",
	"HELP_TEXT_LESS_THAN_EQUAL_BODY_1" : "Der Block ''Kleiner als oder gleich'' vergleicht zwei Eingangswerte, um festzustellen, ob der erste Wert kleiner oder gleich dem zweiten Wert ist, und gibt ein Ergebnis zurück, das entweder wahr oder falsch ist. Bei den Werten kann es sich um eine Konstante (die in den Eingang eingegeben wird und sich nicht ändert), eine Variable, eine Abtastung oder einen Operatorblock handeln.",
	"HELP_TEXT_LESS_THAN_EQUAL_BODY_2" : "Der Kleiner-als-oder-Gleich-Block ist ein rautenförmiger Block, so dass das Ergebnis des Blocks nur entweder wahr oder falsch sein kann.",
	"HELP_TEXT_LESS_THAN_EQUAL_EXAMPLE_1_BODY" : "Ergebnis: wahr",
	"HELP_TEXT_LESS_THAN_EQUAL_EXAMPLE_2_BODY" : "Ergebnis: falsch",
	"HELP_TEXT_LESS_THAN_EQUAL_EXAMPLE_3_BODY" : "Ergebnis: wahr",
	"HELP_TEXT_LESS_THAN_EQUAL_EXAMPLE_4_TITLE" : "Ist die Variable ''Zähler'' kleiner oder gleich dem konstanten Wert 120.",
	"HELP_TEXT_LESS_THAN_EQUAL_EXAMPLE_5_TITLE" : "Ist der Lichtpegel des linken Sensors kleiner oder gleich dem konstanten Wert 500.",
	"HELP_TEXT_EQUAL_TITLE" : "Gleichwertig mit",
	"HELP_TEXT_EQUAL_BODY_1" : "Der Gleichheits-Block vergleicht zwei Eingangswerte, um festzustellen, ob der erste Wert gleich dem zweiten Wert ist, und gibt ein Ergebnis zurück, das entweder wahr oder falsch ist. Bei den Werten kann es sich um eine Konstante (die in die Eingabe eingegeben wird und sich nicht ändert), eine Variable, eine Abtastung oder einen Operatorblock handeln.",
	"HELP_TEXT_EQUAL_BODY_2" : "Der Gleichheits-Block ist ein rautenförmiger Block, so dass das Ergebnis des Blocks nur entweder wahr oder falsch sein kann.",
	"HELP_TEXT_EQUAL_EXAMPLE_1_BODY" : "Ergebnis: wahr",
	"HELP_TEXT_EQUAL_EXAMPLE_2_BODY" : "Ergebnis: falsch",
	"HELP_TEXT_EQUAL_EXAMPLE_3_TITLE" : "Ist die Variable ''Zähler'' gleich dem konstanten Wert 60.",
	"HELP_TEXT_EQUAL_EXAMPLE_4_TITLE" : "Ist der empfangene Fernbedienungscode gleich dem konstanten Wert 3.",
	"HELP_TEXT_GREATER_THAN_EQUAL_TITLE" : "Größer als oder gleich",
	"HELP_TEXT_GREATER_THAN_EQUAL_BODY_1" : "Der Größer-als-Gleich-Block vergleicht zwei Eingabewerte, um festzustellen, ob der erste Wert größer oder gleich dem zweiten Wert ist, und liefert ein Ergebnis, das entweder wahr oder falsch ist. Bei den Werten kann es sich um eine Konstante (die in den Eingang eingegeben wird und sich nicht ändert), eine Variable, eine Abtastung oder einen Operatorblock handeln.",
	"HELP_TEXT_GREATER_THAN_EQUAL_BODY_2" : "Der Größer-als-gleich-Block ist ein rautenförmiger Block, sodass das Ergebnis des Blocks nur entweder wahr oder falsch sein kann.",
	"HELP_TEXT_GREATER_THAN_EQUAL_EXAMPLE_1_BODY" : "Ergebnis: wahr",
	"HELP_TEXT_GREATER_THAN_EQUAL_EXAMPLE_2_BODY" : "Ergebnis: falsch",
	"HELP_TEXT_GREATER_THAN_EQUAL_EXAMPLE_3_BODY" : "Ergebnis: wahr",
	"HELP_TEXT_GREATER_THAN_EQUAL_EXAMPLE_4_TITLE" : "Ist die Variable ''Zähler'' größer oder gleich dem konstanten Wert 120.",
	"HELP_TEXT_GREATER_THAN_EQUAL_EXAMPLE_5_TITLE" : "Ist die Lichtstärke des linken Sensors größer oder gleich dem konstanten Wert 500.",
	"HELP_TEXT_GREATER_THAN_TITLE" : "Größer als",
	"HELP_TEXT_GREATER_THAN_BODY_1" : "Der Größer-als-Block vergleicht zwei Eingangswerte, um festzustellen, ob der erste Wert größer als der zweite Wert ist, und gibt ein Ergebnis zurück, das entweder wahr oder falsch ist. Bei den Werten kann es sich um eine Konstante (die in die Eingabe eingegeben wird und nicht variiert), eine Variable, eine Abtastung oder einen Operatorblock handeln.",
	"HELP_TEXT_GREATER_THAN_BODY_2" : "Der Größer-als-Block ist ein rautenförmiger Block, so dass das Ergebnis des Blocks nur entweder wahr oder falsch sein kann",
	"HELP_TEXT_GREATER_THAN_EXAMPLE_1_BODY" : "Ergebnis: wahr",
	"HELP_TEXT_GREATER_THAN_EXAMPLE_2_BODY" : "Ergebnis: falsch",
	"HELP_TEXT_GREATER_THAN_EXAMPLE_3_TITLE" : "Ist die Variable ''Zähler'' größer als der konstante Wert 120.",
	"HELP_TEXT_GREATER_THAN_EXAMPLE_4_TITLE" : "Ist der Lichtpegel des linken Sensors größer als der konstante Wert 500.",
	"HELP_TEXT_NOT_EQUAL_TITLE" : "Nicht gleich",
	"HELP_TEXT_NOT_EQUAL_BODY_1" : "Der not equal to-Block vergleicht zwei Eingangswerte, um festzustellen, ob der erste Wert ungleich dem zweiten Wert ist, und gibt ein Ergebnis zurück, das entweder wahr oder falsch ist. Bei den Werten kann es sich um eine Konstante (die in die Eingabe eingegeben wird und sich nicht ändert), eine Variable, eine Abtastung oder einen Operatorblock handeln.",
	"HELP_TEXT_NOT_EQUAL_BODY_2" : "Der ungleiche Block ist ein rautenförmiger Block, so dass das Ergebnis des Blocks nur entweder wahr oder falsch sein kann.",
	"HELP_TEXT_NOT_EQUAL_EXAMPLE_1_BODY" : "Ergebnis: wahr",
	"HELP_TEXT_NOT_EQUAL_EXAMPLE_2_BODY" : "Ergebnis: falsch",
	"HELP_TEXT_NOT_EQUAL_EXAMPLE_3_TITLE" : "Ist die Variable ''Zähler'' nicht gleich dem konstanten Wert 120.",
	"HELP_TEXT_NOT_EQUAL_EXAMPLE_4_TITLE" : "Ist der empfangene Fernbedienungscode nicht gleich dem konstanten Wert 3.",
	"HELP_TEXT_IS_BETWEEN_TITLE" : "Ist zwischen",
	"HELP_TEXT_IS_BETWEEN_BODY_1" : "Der is between-Block bestimmt, ob ein Wert innerhalb eines Bereichs von zwei anderen Werten liegt. Bei den Werten kann es sich um eine Konstante (die in den Eingang eingegeben wird und nicht variiert), eine Variable, einen Messwert oder einen Operatorblock handeln.",
	"HELP_TEXT_IS_BETWEEN_BODY_2" : "Der is between-Block ist ein rautenförmiger Block, so dass das Ergebnis des Blocks nur entweder wahr oder falsch sein kann.",
	"HELP_TEXT_IS_BETWEEN_EXAMPLE_1_BODY" : "Ergebnis: wahr",
	"HELP_TEXT_IS_BETWEEN_EXAMPLE_2_BODY" : "Ergebnis: falsch",
	"HELP_TEXT_IS_BETWEENL_EXAMPLE_3_TITLE" : "Liegt die Variable ''Zähler'' zwischen dem konstanten Wert 60 und dem konstanten Wert 120.",
	"HELP_TEXT_IS_BETWEEN_EXAMPLE_4_TITLE" : "Liegt die Lichtstärke des linken Lichtsensors zwischen dem konstanten Wert 250 und dem konstanten Wert 750.",
	"HELP_TEXT_AND_TITLE" : "Und",
	"HELP_TEXT_AND_BODY_1" : "Der Und-Block bestimmt, ob zwei Eingänge beide wahr sind. Wenn beide Eingänge wahr sind, dann ist auch das Ergebnis wahr. Wenn einer oder beide Eingänge falsch sind, dann ist das Ergebnis falsch. Die Eingänge akzeptieren rautenförmige Blöcke, die entweder ein Operator-Block oder ein Sensing-Block sein können.",
	"HELP_TEXT_AND_BODY_2" : "Der und-Block ist ein rautenförmiger Block, also kann das Ergebnis des Blocks nur entweder wahr oder falsch sein.",
	"HELP_TEXT_AND_EXAMPLE_1_BODY" : "Ergebnis: wahr",
	"HELP_TEXT_AND_EXAMPLE_2_BODY" : "Ergebnis: falsch",
	"HELP_TEXT_AND_EXAMPLE_3_TITLE" : "Ist sowohl der Line Tracker auf der reflektierenden Oberfläche ''und'' die Antriebsbelastung erkannt.",
	"HELP_TEXT_AND_EXAMPLE_4_TITLE" : "Ist die Variable ''Zähler'' größer als 50 ''und'' der empfangene Fernbedienungscode ist gleich dem konstanten Wert 3.",
	"HELP_TEXT_OR_TITLE" : "Oder",
	"HELP_TEXT_OR_BODY_1" : "Der Oder-Block bestimmt, ob der erste Eingang ''oder'' der zweite Eingang wahr ist. Wenn einer oder beide Eingänge wahr sind, dann ist das Ergebnis wahr. Wenn beide Eingänge falsch sind, ist das Ergebnis falsch. Die Eingänge akzeptieren rautenförmige Blöcke, die entweder ein Operator-Block oder ein Sensing-Block sein können.",
	"HELP_TEXT_OR_BODY_2" : "Der oder-Block ist ein rautenförmiger Block, so dass das Ergebnis des Blocks nur entweder wahr oder falsch sein kann.",
	"HELP_TEXT_OR_EXAMPLE_1_BODY" : "Ergebnis: wahr",
	"HELP_TEXT_OR_EXAMPLE_2_BODY" : "Ergebnis: wahr",
	"HELP_TEXT_OR_EXAMPLE_3_BODY" : "Ergebnis: falsch",
	"HELP_TEXT_OR_EXAMPLE_4_TITLE" : "Ist entweder der Line Tracker auf der reflektierenden Oberfläche ''oder'' die Antriebsdehnung erkannt.",
	"HELP_TEXT_OR_EXAMPLE_5_TITLE" : "Ist entweder die Variable ''Zähler'' kleiner als der konstante Wert 50 ''oder'' ist der empfangene Ferncode gleich dem konstanten Wert 3.",
	"HELP_TEXT_NOT_TITLE" : "Nicht",
	"HELP_TEXT_NOT_BODY_1" : "Der Not-Block bestimmt, ob die Eingabe ''nicht'' wahr ist. Wenn die Eingabe falsch ist, ist die Ausgabe wahr. Wenn die Eingabe wahr ist, ist die Ausgabe falsch. Die Eingabe akzeptiert rautenförmige Blöcke, die entweder ein Operator-Block oder ein Sensing-Block sein können.",
	"HELP_TEXT_NOT_BODY_2" : "Der Nicht-Block ist ein rautenförmiger Block, so dass das Ergebnis des Blocks nur entweder wahr oder falsch sein kann.",
	"HELP_TEXT_NOT_EXAMPLE_1_BODY" : "Ergebnis: falsch",
	"HELP_TEXT_NOT_EXAMPLE_2_BODY" : "Ergebnis: wahr",
	"HELP_TEXT_NOT_EXAMPLE_3_TITLE" : "Wird der Fernbedienungscode 0 nicht empfangen.",
	"HELP_TEXT_NOT_EXAMPLE_4_TITLE" : "Beispielprogramm: Spin on remote control command (funktioniert am besten mit der EdRemote)",
	"HELP_TEXT_NOT_EXAMPLE_4_BODY" : "In diesem Beispiel beginnt das Programm mit einer Endlosschleife. Innerhalb der Endlosschleife prüft der if then-Block, ob der Fernbedienungscode 0 empfangen wurde. Wenn dies der Fall ist, werden beide Motoren so eingestellt, dass sie den Roboter nach rechts drehen. Dies geschieht so lange, bis die Bedingung des wait until-Blocks erfüllt ist. Um zu bestehen, darf der empfangene Fernbedienungscode nicht Fernbedienungscode 0 sein (der Fernbedienungsknopf wird nicht mehr gedrückt). Wenn das passiert, stoppt das Programm beide Motoren und kehrt dann zum Anfang der Endlosschleife zurück. Das führt dazu, dass sich Edison dreht, während der Fernbedienungsknopf gedrückt gehalten wird.",
	"HELP_TEXT_COMMENT_TITLE" : "Kommentar",
	"HELP_TEXT_COMMENT_BODY_1" : "Der Kommentarblock wird verwendet, um einem Programm Notizen hinzuzufügen. Die Anmerkungen beschreiben im Klartext, wie das Programm funktionieren soll. Kommentare in einem Programm sind hilfreich, wenn jemand anderes dein Programm bearbeiten muss oder du dein Programm lange Zeit nach dem Schreiben bearbeiten musst.",
	"HELP_TEXT_COMMENT_BODY_2" : "Kommentare sind nicht in Edison einprogrammiert und ändern daher nicht das Verhalten deines Programms.",
	"HELP_TEXT_COMMENT_EXAMPLE_1_TITLE" : "Beispielprogramm: Die Kommentare erklären in einfacher Sprache, wie das Programm funktioniert",
	"HELP_TEXT_SEND_USB_TITLE" : "Senden über USB",
	"HELP_TEXT_SEND_USB_BODY_1" : "Der send via USB-Block überträgt einen Wert über die USB-Verbindung an einen Computer. Der Wert kann entweder eine Konstante (die in den Eingang eingegeben wird und sich nicht ändert), eine Variable, ein Messwert oder ein Operatorblock sein.",
	"HELP_TEXT_SEND_USB_BODY_2" : "Um die Zahl auf dem Computer zu sehen, klicke auf die USB-Schaltfläche in EdScratch und ein Pop-up-Fenster wird angezeigt. Klicke auf USB ausführen, um eine Verbindung mit dem Edison V3 Roboter herzustellen. Die vom Edison V3 empfangenen Daten werden im Fenster Daten vom USB angezeigt.",
	"HELP_TEXT_SEND_USB_BODY_3" : "Der Block An USB senden kann auch zum Debuggen eines Programms verwendet werden.",
	"HELP_TEXT_SEND_USB_BODY_4" : "Die Räder des Edison V3 fahren nicht, wenn sie mit dem USB verbunden sind. Das liegt an den internationalen Sicherheitsstandards, die es nicht zulassen, dass Produkte, die für Kinder bestimmt sind, einen Motor antreiben, während sie an einen USB-Anschluss angeschlossen sind.",
	"HELP_TEXT_SEND_USB_EXAMPLE_1_TITLE" : "Beispielprogramm: Lichtpegel messen",
	"HELP_TEXT_SEND_USB_EXAMPLE_1_BODY" : "In diesem Beispiel beginnt das Programm mit einer Endlosschleife. Der erste Block innerhalb der Schleife sendet den Lichtpegel des linken Lichtsensors über USB. Dann wartet das Programm eine Sekunde und wiederholt den Vorgang.",
	"HELP_TEXT_SAVE_USB_TITLE" : "Warte auf USB-Daten und speichere in",
	"HELP_TEXT_SAVE_USB_BODY_1" : "Der Block Warten auf USB-Daten und Speichern in hält das Programm an, bis Daten über USB empfangen werden, und speichert die Daten dann in einer Variablen.",
	"HELP_TEXT_SAVE_USB_BODY_2" : "Die Räder des Edison V3 fahren nicht, wenn sie mit dem USB verbunden sind. Das liegt an den internationalen Sicherheitsstandards, die es nicht zulassen, dass Produkte, die für Kinder bestimmt sind, einen Motor antreiben, während sie an einen USB-Anschluss angeschlossen sind.",
	"HELP_TEXT_SAVE_USB_EXAMPLE_1_TITLE" : "Beispielprogramm: Anzahl der Pieptöne vom USB",
	"HELP_TEXT_SAVE_USB_EXAMPLE_1_BODY_1" : "In diesem Beispiel beginnt das Programm mit einer Endlosschleife. Der erste Block innerhalb der Schleife wartet, bis Daten vom USB empfangen werden. Wenn die Daten empfangen werden, werden sie in der Variablen ''Count'' gespeichert. Das Programm geht dann zum Wiederholungsblock über, der den Wert der Variablen ''Count'' wiederholt. Innerhalb des Wiederholungsblocks laufen der Beep-Block und der Wait-Sec-Block. Das Ergebnis ist, dass Edison die Anzahl der über USB gesendeten Signale piept.",
	"HELP_TEXT_SAVE_USB_EXAMPLE_1_BODY_2" : "Um dieses Programm zu testen, klicke auf die USB-Schaltfläche in der EdScratch-App und ein Pop-up-Fenster wird angezeigt. Klicke auf USB ausführen, um dich mit dem Edison V3 Roboter zu verbinden. Um Daten an den Edison V3 zu senden, gib eine Zahl in das Feld Daten an USB ein und klicke auf die Schaltfläche An USB senden.",
	"HELP_TEXT_FUNCTION_START_TITLE" : "Funktionsstart",
	"HELP_TEXT_FUNCTION_START_BODY_1" : "Der Funktionsstartblock ist der Ort, an dem deine Funktion beginnt. Verbinde Blöcke mit dem Funktionsstartblock, um eine eigene Funktion zu erstellen.",
	"HELP_TEXT_FUNCTION_START_BODY_2" : "Funktionsblöcke helfen dabei, ein Programm zu vereinfachen, da der Code gruppiert werden kann und somit leichter zu lesen ist. Funktionen tragen auch dazu bei, den Umfang eines Programms zu verringern, da die sich wiederholenden Teile eines Programms nur einmal geschrieben werden müssen.",
	"HELP_TEXT_FUNCTION_START_BODY_3" : "Funktionsaufrufblöcke können nicht unter Funktionsstartblöcken platziert werden.",
	"HELP_TEXT_FUNCTION_START_EXAMPLE_1_TITLE" : "Beispielprogramm 1: Antrieb in Form eines Quadrats",
	"HELP_TEXT_FUNCTION_START_EXAMPLE_1_BODY" : "In diesem Beispiel beginnt das Programm mit einer viermaligen Wiederholungsschleife. Innerhalb des Wiederholungsblocks befindet sich ein Funktionsaufruf namens ''DriveAndTurn''. Wenn das Programm bei diesem Block ankommt, springt es zum entsprechenden Funktionsstartblock. In diesem Block wird der Roboter angewiesen, 10 cm vorwärts zu fahren und sich dann um 90 Grad nach rechts zu drehen. Diese Funktion wird viermal innerhalb der Wiederholungsschleife aufgerufen. Das Ergebnis ist, dass Edison in einem Quadrat fährt.",
	"HELP_TEXT_FUNCTION_START_EXAMPLE_2_TITLE" : "Beispielprogramm 2: Linien und Hindernissen ausweichen",
	"HELP_TEXT_FUNCTION_START_EXAMPLE_2_BODY" : "In diesem Beispiel beginnt das Programm mit dem Einschalten des Hindernisdetektors und der LED des Linienverfolgers und geht dann in eine Endlosschleife über. Innerhalb der Endlosschleife werden beide Motoren auf Vorwärtsfahrt eingestellt. Als Nächstes prüft der if then-Block, ob ein Hindernis erkannt wurde. Wenn dies der Fall ist, springt das Programm zum Funktionsaufrufblock ''TurnAround''. Das Programm hält dann die Motoren an, schaltet das LED-Licht ein, piept, fährt rückwärts, dreht sich um 175 Grad, schaltet die LEDs aus und kehrt zum Hauptprogramm zurück, wo es aufgehört hat. Der nächste if then-Block prüft, ob die Oberfläche nicht reflektierend (schwarz) ist. Wenn das der Fall ist, springt das Programm mit dem Funktionsaufrufblock ''TurnAround'' zum Funktionsstartblock ''TurnAround''. Das Programm hält dann die Motoren an, schaltet das LED-Licht ein, piept, fährt rückwärts, dreht sich um 175 Grad, schaltet die LEDs aus und kehrt zum Hauptprogramm zurück, wo es aufgehört hat. Das führt dazu, dass Edison von Linien und Objekten, die er erkennt, wegfährt.",
	"HELP_TEXT_FUNCTION_CALL_TITLE" : "Funktionsaufruf",
	"HELP_TEXT_FUNCTION_CALL_BODY_1" : "Der Funktionsaufrufblock weist das Programm an, zum Funktionsstartblock zu springen.",
};
Blockly.ScratchMsgs.locales['pt-br'] ={
	"CONTROL_FOREVER" : "para sempre",
	"CONTROL_REPEAT" : "repetir",
	"CONTROL_IF" : "se",
	"CONTROL_THAN" : "então",
	"CONTROL_ELSE" : "else",
	"CONTROL_STOP" : "parar",
	"CONTROL_STOP_ALL" : "todos",
	"CONTROL_WAIT" : "esperar",
	"CONTROL_WAIT_SEC" : "sec",
	"CONTROL_WAIT_MILLISECONDS" : "milissegundos",
	"CONTROL_WAITUNTIL" : "esperar até",
	"CONTROL_REPEATUNTIL" : "repetir até",
	"DATA_BUTTONCREATE" : "Criar uma variável",
	"DATA_BUTTONMANAGE" : "Gerenciar variáveis",
	"DATA_SET" : "definir",
	"DATA_TO" : "para",
	"DATA_INCVARIABLE" : "incrementar",
	"DATA_DECVARIABLE" : "decremento",
	"DATA_BITSHIFT" : "deslocamento de bit",
	"DATA_BITSHIFTLEFT" : "esquerda por",
	"DATA_BITSHIFTRIGHT" : "para a direita",
	"EVENT_ANY_OBSTACLE" : "Qualquer obstáculo detectado",
	"EVENT_OBSTACLE_AHEAD" : "Obstáculo detectado à frente",
	"EVENT_OBSTACLE_LEFT" : "Obstáculo detectado à esquerda",
	"EVENT_OBSTACLE_RIGHT" : "Obstáculo detectado à direita",
	"EVENT_CLAP" : "Palmas detectadas",
	"EVENT_BUTTON_TRIANGLE" : "Botão triangular pressionado",
	"EVENT_BUTTON_ROUND" : "Botão redondo pressionado",
	"EVENT_LINE_REFLECTIVE" : "Rastreador de linha em superfície refletiva",
	"EVENT_LINE_NON_REFLECTIVE" : "Rastreador de linha em superfície não reflexiva",
	"EVENT_LINE_CHANGE" : "O rastreador de linha muda de superfície",
	"EVENT_MESSAGE" : "Mensagem IR recebida",
	"EVENT_REMOTE" : "Código remoto recebido",
	"EVENT_DRIVE_STRAIN" : "Acionamento tensionado",
	"EVENT_START" : "Início",
	"OPERATORS_RANDOM" : "número aleatório entre",
	"OPERATORS_AND" : "e",
	"OPERATORS_OR" : "ou",
	"OPERATORS_NOT" : "não",
	"OPERATORS_ABS" : "abs",
	"OPERATORS_BETWEEN" : "está entre",
	"SENSING_TURN_LINE_TRACKING_LED" : "LED de rastreamento de linha de giro",
	"SENSING_TURN_OBSTACLE_BEAM" : "feixe de detecção de obstáculos na curva",
	"SENSING_CLEAR" : "Limpar",
	"SENSING_SENSOR" : "dados do sensor",
	"SENSING_CLAP_DETECTED" : "palmas detectadas",
	"SENSING_BUTTON_PRESSED" : "botão pressionado",
	"SENSING_OBSTACLE" : "obstáculo detectado",
	"SENSING_LINE_TRACKER" : "rastreador de linha em",
	"SENSING_LINE_SURFACE" : "superfície",
	"SENSING_REMOTE_NUM" : "código remoto recebido",
	"SENSING_REMOTE_BOOL" : "código remoto",
	"SENSING_REMOTE_RECEIVED" : "recebido",
	"SENSING_IR_MESSAGE_DETECTED" : "Mensagem IR detectada",
	"SENSING_IR_MESSAGE" : "mensagem de IR recebida",
	"SENSING_LIGHT_LEVEL" : "nível de luz do",
	"SENSING_LIGHT_SENSOR" : "sensor",
	"SENSING_DRIVE_STRAIN" : "tensão de acionamento detectada",
	"SENSING_DROPDOWN_ON" : "ligado",
	"SENSING_DROPDOWN_OFF" : "desligado",
	"SENSING_CLEAR_DROPDOWN_CLAP" : "detector de palmas",
	"SENSING_CLEAR_DROPDOWN_KEY" : "teclado",
	"SENSING_CLEAR_DROPDOWN_OBS" : "detector de obstáculos",
	"SENSING_CLEAR_DROPDOWN_REMOTE" : "código remoto",
	"SENSING_CLEAR_DROPDOWN_IR" : "Mensagem IR",
	"SENSING_KEY_DROPDOWN_ROUND" : "redondo",
	"SENSING_KEY_DROPDOWN_TRIANGLE" : "triângulo",
	"SENSING_OBS_DROPDOWN_ANY" : "em qualquer lugar",
	"SENSING_OBS_DROPDOWN_AHEAD" : "à frente",
	"SENSING_OBS_DROPDOWN_LEFT" : "esquerda",
	"SENSING_OBS_DROPDOWN_RIGHT" : "direita",
	"SENSING_LINE_DROPDOWN_WHITE" : "refletivo",
	"SENSING_LINE_DROPDOWN_BLACK" : "não refletivo",
	"SENSING_LIGHT_DROPDOWN_LEFT" : "luz esquerda",
	"SENSING_LIGHT_DROPDOWN_RIGHT" : "luz direita",
	"SENSING_LIGHT_DROPDOWN_LINE" : "rastreamento de linha",
	"COMMENT_USER_COMMENT" : "comentário:",
	"ADVANCED_USB_SEND_DATA" : "enviar",
	"ADVANCED_USB_SEND_VIA" : "via USB",
	"ADVANCED_USB_RECEIVED_DATA" : "dados recebidos do USB",
	"ADVANCED_USB_RECEIVED_DATA_VAR" : "aguarde os dados do USB e salve-os em",
	"SOUND_BEEP" : "bip",
	"SOUND_PLAY_NOTE" : "reproduzir um",
	"SOUND_PLAY_NOTE_DROP_DURATION_WHOLE" : "inteira",
	"SOUND_PLAY_NOTE_DROP_DURATION_HALF" : "metade",
	"SOUND_PLAY_NOTE_DROP_DURATION_QUARTER" : "quarto",
	"SOUND_PLAY_NOTE_DROP_DURATION_EIGHTH" : "oitavo",
	"SOUND_PLAY_NOTE_DROP_NOTE_C" : "C",
	"SOUND_PLAY_NOTE_DROP_NOTE_B" : "B",
	"SOUND_PLAY_NOTE_DROP_NOTE_A" : "A",
	"SOUND_PLAY_NOTE_DROP_NOTE_G" : "G",
	"SOUND_PLAY_NOTE_DROP_NOTE_F" : "F",
	"SOUND_PLAY_NOTE_DROP_NOTE_E" : "E",
	"SOUND_PLAY_NOTE_DROP_NOTE_D" : "D",
	"SOUND_PLAY_NOTE_DROP_NOTE_MID_C" : "C médio",
	"SOUND_PLAY_NOTE_DROP_NOTE_LOW_B" : "B baixo",
	"SOUND_PLAY_NOTE_DROP_NOTE_REST" : "resto",
	"SOUND_PLAY_NOTE_DROP_MOD_SHARP" : "sustenido",
	"SOUND_PLAY_NOTE_DROP_MOD_FLAT" : "bemol",
	"SOUND_SET_TEMPO" : "ajustar o andamento da música para",
	"SOUND_SET_TEMPO_DROP_VERY_SLOW" : "muito lento",
	"SOUND_SET_TEMPO_DROP_SLOW" : "lento",
	"SOUND_SET_TEMPO_DROP_MEDIUM" : "médio",
	"SOUND_SET_TEMPO_DROP_FAST" : "rápido",
	"SOUND_SET_TEMPO_DROP_VERY_FAST" : "muito rápido",
	"SOUND_PLAY_IN_BACKGROUND" : "reproduzir música em segundo plano",
	"CATEGORY_SOUND" : "Som",
	"CATEGORY_EVENTS" : "Eventos",
	"CATEGORY_CONTROL" : "Controle",
	"CATEGORY_SENSING" : "Sensoriamento",
	"CATEGORY_OPERATORS" : "Operadores",
	"CATEGORY_VARIABLES" : "Variáveis",
	"CATEGORY_MYBLOCKS" : "Funções",
	"CATEGORY_DRIVE" : "Acionamento",
	"CATEGORY_COMMENT" : "Comentários",
	"CATEGORY_LED" : "LEDs",
	"CATEGORY_ADVANCED" : "Avançado",
	"DUPLICATE" : "Duplicar",
	"DELETE" : "Excluir",
	"DELETE_BLOCK" : "Excluir bloco",
	"CONTEXT_DELETE" : "Excluir",
	"CONTEXT_DELETE_ALL" : "Excluir todos os",
	"CONTEXT_BLOCKS" : "Blocos",
	"CLEAN_UP" : "Limpar blocos",
	"HELP" : "Ajuda",
	"UNDO" : "Desfazer",
	"REDO" : "Refazer",
	"CHANGE_VALUE_TITLE" : "Alterar valor:",
	"RENAME_VARIABLE" : "Renomear variável",
	"RENAME_VARIABLE_MODAL_TITLE" : "Renomear variável",
	"NEW_VARIABLE" : "Criar uma variável",
	"NEW_VARIABLE_TITLE" : "Novo nome de variável:",
	"VARIABLE_MODAL_TITLE" : "New Variable (Nova variável)",
	"NEW_PROCEDURE" : "Criar uma função",
	"MANAGE_PROCEDURE" : "Gerenciar uma função",
	"PROCEDURE_DEFAULT_NAME" : "Nome do bloco",
	"PROCEDURE_USED" : "Para excluir uma definição de bloco, primeiro remova todos os usos do bloco",
	"DRIVE_FORWARDS_DISTANCE" : "para frente para",
	"DRIVE_BACKWARDS_DISTANCE" : "para trás para",
	"DRIVE_LEFT_DISTANCE" : "esquerda para",
	"DRIVE_RIGHT_DISTANCE" : "direita para",
	"DRIVE_DISTANCE_DROPDOWN_CM" : "cm",
	"DRIVE_DISTANCE_DROPDOWN_INCH" : "polegada",
	"DRIVE_DISTANCE_DROPDOWN_SECONDS" : "segundos",
	"DRIVE_DISTANCE_DROPDOWN_DEGREES" : "graus",
	"DRIVE_TURN_DROPDOWN_SPIN" : "girar",
	"DRIVE_TURN_DROPDOWN_FORWARDS" : "girar para frente",
	"DRIVE_TURN_DROPDOWN_BACKWARDS" : "girar para trás",
	"DRIVE_FORWARDS_UNTIL" : "para frente até",
	"DRIVE_BACKWARDS_UNTIL" : "para trás até",
	"DRIVE_LEFT_UNTIL" : "esquerda até",
	"DRIVE_RIGHT_UNTIL" : "direita até",
	"DRIVE_SET_LEFT_MOTOR" : "ajustar o motor esquerdo para",
	"DRIVE_SET_RIGHT_MOTOR" : "ajustar o motor direito para",
	"DRIVE_SET_MOTOR_DROPDOWN_FORWARDS" : "para frente",
	"DRIVE_SET_MOTOR_DROPDOWN_BACKWARDS" : "para trás",
	"DRIVE_SET_BOTH_MOTOR" : "ajustar ambos os motores para",
	"DRIVE_SET_BOTH_MOTOR_DROPDOWN_FORWARDS" : "dirigir para a frente",
	"DRIVE_SET_BOTH_MOTOR_DROPDOWN_BACKWARDS" : "dirigir para trás",
	"DRIVE_SET_BOTH_MOTOR_DROPDOWN_SPIN_LEFT" : "girar o robô para a esquerda",
	"DRIVE_SET_BOTH_MOTOR_DROPDOWN_SPIN_RIGHT" : "girar o robô para a direita",
	"DRIVE_SET_BOTH_MOTOR_DROPDOWN_TURN_LEFT" : "girar o robô para a esquerda",
	"DRIVE_SET_BOTH_MOTOR_DROPDOWN_TURN_RIGHT" : "girar o robô para a direita",
	"DRIVE_AT_SPEED" : "em velocidade",
	"DRIVE_STOP" : "parar",
	"DRIVE_STOP_DROPDOWN_BOTH" : "ambos os motores",
	"DRIVE_STOP_DROPDOWN_LEFT" : "motor esquerdo",
	"DRIVE_STOP_DROPDOWN_RIGHT" : "motor direito",
  "LED_LEFT" : "LED esquerdo",
  "LED_RIGHT" : "LED direito",
	"LED_DROPDOWN_ON" : "ligado",
	"LED_DROPDOWN_OFF" : "desligado",
	"LED_SEND_MESSAGE" : "enviar mensagem IR",
	"DEMO_TEST_PROGRAM" : "Programa de teste",
	"DEMO_TEST_PROGRAM_DISC" : "Testa a unidade, os LEDs e o alto-falante",
	"DEMO_MOVE_WITH_MUSIC" : "Movimentação com música",
	"DEMO_MOVE_WITH_MUSIC_DISC" : "Dirigir durante a reprodução de música",
	"DEMO_FOLLOW_A_LINE" : "Seguir uma linha",
	"DEMO_FOLLOW_A_LINE_DISC" : "Use o sensor de linha para seguir uma linha preta",
	"DEMO_BOUNCE_IN_BORDERS" : "Saltar nas bordas",
	"DEMO_BOUNCE_IN_BORDERS_DISC" : "Use o sensor de linha para ficar dentro de uma borda de linha preta",
	"DEMO_WARNINGS" : "Demonstração de mensagens de aviso",
	"DEMO_WARNINGS_DISC" : "Demonstra mensagens de erro vermelhas e mensagens de aviso amarelas",
	"DEMO_CLAP_CONTROL" : "Direção controlada por palmas",
	"DEMO_CLAP_CONTROL_DISC" : "Bata palmas uma vez para virar, bata palmas duas vezes para dirigir para frente",
	"DEMO_AVOID_OBSTACLES" : "Evitar obstáculos",
	"DEMO_AVOID_OBSTACLES_DISC" : "Use o sensor de obstáculos para evitar bater em obstáculos",
	"DEMO_FOLLOW_TORCH" : "Siga uma lanterna",
	"DEMO_FOLLOW_TORCH_DISC" : "Use os sensores de luz para seguir uma lanterna",
	"DEMO_FOLLOW_A_LINE_IF" : "Seguir uma linha usando instruções if",
	"DEMO_FOLLOW_A_LINE_IF_DISC" : "Uma maneira diferente de usar o sensor de linha para seguir uma linha usando um bloco if",
	"MENU_DROP_MENU" : "Menu",
	"MENU_DROP_NEW" : "Novo",
	"MENU_DROP_LOAD_DEMO" : "Carregar demonstração",
	"MENU_DROP_LOAD_LOCAL" : "Carregar do computador",
	"MENU_DROP_SAVE_LOCAL" : "Salvar no computador",
	"MENU_DROP_UPDATE_FIRMWARE" : "Atualizar firmware",
	"MENU_DROP_DIAGNOSTICS" : "Diagnóstico",
	"MENU_DROP_LANGUAGE_LABEL" : "Idioma",
	"MENU_DROP_ABOUT" : "Sobre o computador",
	"MENU_DROP_TERMS" : "Termos de uso",
	"MENU_USB" : "USB",
	"MENU_SAVE" : "Salvar",
	"MENU_VERSION_MAIN" : "Edison V3",
	"MENU_VERSION_SWITCH" : "Mudar para Edison V1/V2",
	"MENU_VERSION_WHICH_VERSION" : "Qual versão eu tenho?",
	"MENU_PROGRAM" : "Programa",
	"MENU_PROGRAM_FLASH" : "Programa",
	"MODAL_CREATE_VAR" : "Criar variável",
	"MODAL_CREATE_VAR_NAME" : "Nome da variável",
	"MODAL_CREATE_VAR_BUTTON" : "Criar variável",
	"MODAL_CREATE_VAR_EXIT" : "Sair",
	"MODAL_CREATE_VAR_SUCCESS" : "Nova variável criada com sucesso.",
	"MODAL_MANAGE_VAR" : "Variáveis",
	"MODAL_MANAGE_VAR_NAME" : "Nome da variável",
	"MODAL_MANAGE_VAR_ACTION" : "Ação",
	"MODAL_MANAGE_VAR_BUTTON_DELETE" : "excluir",
	"MODAL_MANAGE_VAR_BUTTON_RENAME" : "renomear",
	"MODAL_MANAGE_VAR_BUTTON_CONFIRM" : "confirmar",
	"MODAL_MANAGE_VAR_BUTTON_CANCEL" : "cancelar",
	"MODAL_MANAGE_VAR_CONFIRM_NOT_CHANGED" : "Você não alterou o nome da variável. Tente novamente.",
	"MODAL_MANAGE_VAR_CONFIRM_SUCCESS" : "A variável foi renomeada com sucesso!",
	"MODAL_MANAGE_VAR_NAME_NONE" : "Digite um nome de variável.",
	"MODAL_MANAGE_VAR_NAME_IN_USE" : "Você já tem uma variável com esse nome.",
	"MODAL_MANAGE_VAR_NAME_UNSUPPORTED" : "O nome da variável contém um caractere não suportado. Os nomes de variáveis só podem conter letras inglesas minúsculas, letras inglesas maiúsculas, números e sublinhados ( _ ).",
	"MODAL_MANAGE_VAR_NAME_NUMBER_START" : "Os nomes das variáveis não podem começar com um número.",
	"MODAL_MANAGE_VAR_DELETE_IN_USE" : "Essa variável está sendo usada atualmente no seu programa. Tem certeza de que deseja excluí-la?",
	"MODAL_MANAGE_VAR_DELETE_CONFIRM" : "Sim",
	"MODAL_MANAGE_VAR_DELETE_DECLINE" : "Não",
	"MODAL_CREATE_FUNCT" : "Criar função",
	"MODAL_CREATE_FUNCT_NAME" : "Nome da função",
	"MODAL_CREATE_FUNCT_WARNING" : "Somente caracteres alfanuméricos e deve começar com uma letra.",
	"MODAL_CREATE_FUNCT_BUTTON" : "Criar função",
	"MODAL_CREATE_FUNCT_BUTTON_EXIT" : "Sair",
	"MODAL_CREATE_FUNCT_SUCCESS" : "Nova função criada com êxito.",
	"MODAL_MANAGE_FUNCT" : "Funções",
	"MODAL_MANAGE_FUNCT_NAME" : "Nome da função",
	"MODAL_MANAGE_FUNCT_ACTION" : "Ação",
	"MODAL_MANAGE_FUNCT_BUTTON_DELETE" : "excluir",
	"MODAL_MANAGE_FUNCT_BUTTON_RENAME" : "renomear",
	"MODAL_MANAGE_FUNCT_BUTTON_CONFIRM" : "confirmar",
	"MODAL_MANAGE_FUNCT_BUTTON_CANCEL" : "cancelar",
	"MODAL_MANAGE_FUNCT_CONFIRM_NOT_CHANGED" : "Você não alterou o nome da função. Tente novamente.",
	"MODAL_MANAGE_FUNCT_CONFIRM_SUCCESS" : "Função renomeada com sucesso!",
	"MODAL_MANAGE_FUNCT_NAME_NONE" : "Digite um nome de função.",
	"MODAL_MANAGE_FUNCT_NAME_IN_USE" : "Você já tem uma função com esse nome.",
	"MODAL_MANAGE_FUNCT_NAME_START_WITH" : "Os nomes de funções de usuário não podem começar com",
	"MODAL_MANAGE_FUNCT_NAME_UNSUPPORTED" : "O nome da função contém um caractere não suportado. Os nomes de funções só podem conter letras inglesas minúsculas, letras inglesas maiúsculas, números e sublinhados ( _ ).",
	"MODAL_MANAGE_FUNCT_NAME_NUMBER_START" : "Os nomes das funções não podem começar com um número.",
	"MODAL_MANAGE_FUNCT_DELETE_IN_USE" : "Essa função está sendo usada atualmente no seu programa. Tem certeza de que deseja excluí-la?",
	"MODAL_MANAGE_FUNCT_DELETE_CONFIRM" : "Sim",
	"MODAL_MANAGE_FUNCT_DELETE_DECLINE" : "Não",
	"MODAL_SAVE_TITLE" : "Salvar no computador",
	"MODAL_SAVE_PROG_TITLE" : "Nome do programa",
	"MODAL_SAVE_BUTTON" : "Salvar no computador",
	"MODAL_SAVE_ERROR_NO_NAME" : "Digite um nome para o seu programa. Você precisa nomear o programa para salvá-lo.",
	"MODAL_SAVE_ERROR_LONG_NAME" : "Opa. Há um problema com esse nome de programa. Os nomes de programas podem ter no máximo 255 caracteres.",
	"MODAL_SAVE_SAVING" : "OK! Seu programa está sendo salvo. O download do seu programa deve começar em breve.",
	"MODAL_LOAD_PC_TITLE" : "Carregar do computador",
	"MODAL_LOAD_PC_FILE_ERROR_1" : "Selecione um arquivo de salvamento do EdScratch.",
	"MODAL_LOAD_PC_FILE_ERROR_2" : "Todos os arquivos salvos do EdScratch são do tipo",
	"MODAL_LOAD_PC_FILE_ERROR_3" : ".edscratch",
	"MODAL_LOAD_PC_FILE_BUTTON" : "Selecione um arquivo para carregar...",
	"MODAL_LOAD_PC_BUTTON" : "Carregar programa",
	"MODAL_LOAD_PC_NO_FILE_ERROR_1" : "Você ainda não selecionou um arquivo. Primeiro, selecione um arquivo salvo do EdScratch em seu computador e, em seguida, carregue o arquivo. [Todos os arquivos salvos do EdScratch são do tipo (.edscratch).",
	"MODAL_LOAD_PC_FILE_DATA_ERROR_1" : "Uh-oh. Há um problema com os dados desse arquivo.",
	"MODAL_LOAD_PC_FILE_DATA_ERROR_2" : "Carregue um arquivo salvo do EdScratch diferente. [Todos os arquivos salvos do EdScratch são do tipo de arquivo (.edscratch).",
	"MODAL_LOAD_PC_FILE_TYPE_ERROR_1" : "Uh-oh. Você fez upload de um tipo de arquivo incorreto.",
	"MODAL_LOAD_PC_FILE_TYPE_ERROR_2" : "Carregue um arquivo salvo do EdScratch. [Todos os arquivos salvos do EdScratch são do tipo de arquivo (.edscratch).",
	"MODAL_LOAD_PC_FILE_READY" : "Pronto para carregar o programa:",
	"MODAL_LOAD_DEMO_TITLE" : "Carregar demonstração",
	"MODAL_LOAD_DEMO_BUTTON" : "Carregar programa",
  "MODAL_COOKIES_TITLE" : "Cookies",
  "MODAL_COOKIES_BODY_1" : "Usamos o Google Analytics para medir como os visitantes usam este aplicativo Web para que possamos aprimorá-lo com base nas necessidades dos usuários. Por exemplo, quais opções os visitantes usam com mais frequência e se eles recebem mensagens de erro do aplicativo Web. Esses cookies não coletam informações que identifiquem um visitante.",
  "MODAL_COOKIES_BODY_2" : "Não permitimos que o Google use ou compartilhe os dados sobre como você usa este site e todas as informações que esses cookies coletam são agregadas e, portanto, anônimas. Elas são usadas apenas para melhorar o funcionamento do aplicativo da Web. Esse cookie é armazenado por um período de um ano.",
  "MODAL_COOKIES_ACCEPT" : "Aceitar cookies",
  "MODAL_COOKIES_BUTTON_YES" : "Sim",
  "MODAL_COOKIES_BUTTON_NO" : "Não",
  "MODAL_ABOUT_TITLE" : "Sobre o EdScratch",
	"MODAL_ABOUT_COPYRIGHT" : "Direitos autorais 2023 Microbric Pty Ltd",
	"MODAL_ABOUT_BODY_1" : "O aplicativo EdScratch foi desenvolvido usando a base de código Scratch Blocks desenvolvida pelo MIT. O Scratch Blocks foi criado com base no código Blockly desenvolvido pelo Google.",
	"MODAL_ABOUT_BODY_2" : "Contribuições e créditos:",
	"MODAL_ABOUT_BODY_3" : "Linguagem de programação EdScratch e compilador de blocos desenvolvidos por Ben Hayton, Microbric",
	"MODAL_ABOUT_BODY_4" : "Interface de usuário do EdScratch desenvolvida por Sean Killian, Killian Web Development",
	"MODAL_ABOUT_BODY_5" : "Firmware do Edison V3 desenvolvido por Damien George, George Robotics (base de código MicroPython)",
	"MODAL_LANGUAGE" : "Idioma",
	"MODAL_DIAGNOSTICS" : "Diagnóstico",
	"MODAL_DIAGNOSTICS_CONNECT_ISSUES_TITLE" : "Problemas de conectividade",
	"MODAL_DIAGNOSTICS_CONNECT_ISSUES_BODY" : "Para garantir que seu programa possa ser compilado e enviado para o robô Edison, é uma boa ideia verificar sua conexão com o compilador EdScratch.",
	"MODAL_DIAGNOSTICS_CONNECT_ISSUES_BUTTON" : "Execute o verificador de conexão",
	"MODAL_DIAGNOSTICS_FIRMWARE_TITLE" : "Corrigir o firmware",
	"MODAL_DIAGNOSTICS_FIRMWARE_BODY" : "Se o Edison V3 não estiver se comportando como esperado, pode ser um problema de firmware. Clique em Fix firmware para enviar uma atualização de firmware.",
	"MODAL_DIAGNOSTICS_FIRMWARE_BUTTON" : "Corrigir o firmware",
	"MODAL_DIAGNOSTICS_PROGRAMMING_TITLE" : "Método de programação",
	"MODAL_DIAGNOSTICS_PROGRAMMING_BODY" : "Essa opção permite alternar entre a programação flash USB e de tela neste dispositivo.",
	"MODAL_DIAGNOSTICS_PROGRAMMING_BUTTON" : "Alterar método de programação",
	"MODAL_DIAGNOSTICS_IR_TITLE" : "Limpar comandos remotos IR aprendidos",
	"MODAL_DIAGNOSTICS_IR_BODY" : "Esta opção permite limpar todos os comandos de controle remoto IR aprendidos de um robô Edison V3.",
	"MODAL_DIAGNOSTICS_IR_BUTTON" : "Limpar códigos remotos",
	"MODAL_DIAGNOSTICS_IR_SUCCESS" : "Os códigos remotos foram apagados.",
	"MODAL_DIAGNOSTICS_IR_ERROR" : "Ocorreu um erro.",
	"MODAL_CONNECTION" : "Conexão",
	"MODAL_CONNECTION_TEST_1" : "Se o teste acima tiver o resultado",
	"MODAL_CONNECTION_TEST_EXAMPLE" : "NENHUM SERVIDOR ENCONTRADO",
	"MODAL_CONNECTION_TEST_2" : "é possível que um firewall esteja bloqueando o acesso ao compilador.",
	"MODAL_CONNECTION_TEST_3" : "Para corrigir isso, peça ao administrador da rede para colocar esses endereços na lista de permissões:",
	"MODAL_CONNECTION_PORTS" : "O administrador da rede também precisa desbloquear as portas 80, 8080, 443 e 8443.",
	"MODAL_CONNECTION_BACK" : "Voltar ao diagnóstico",
	"MODAL_CONNECTION_SERVER" : "Servidor:",
	"MODAL_CONNECTION_SERVER_SEARCHING" : "pesquisando",
	"MODAL_CONNECTION_SERVER_NONE" : "NENHUM SERVIDOR ENCONTRADO",
	"MODAL_CONNECTION_COMIPLE_TEST" : "Teste de compilação:",
	"MODAL_CONNECTION_COMIPLE_TEST_WORKING" : "funcionando",
	"MODAL_CONNECTION_COMIPLE_TEST_ERROR" : "erro de compilação",
	"MODAL_CONNECTION_COMIPLE_TEST_COMPLETE" : "Compilação completa em",
	"MODAL_STATUS_TITLE" : "Corrigir o firmware",
	"MODAL_STATUS_BUTTON" : "Conectar Edison",
	"MODAL_STATUS_STATUS_LABEL" : "Status:",
	"MODAL_STATUS_STATUS_NOT_CONNECTED" : "não conectado",
	"MODAL_STATUS_STATUS_CONNECTED" : "conectado",
	"MODAL_STATUS_FIRMWARE_LABEL" : "Versão do firmware:",
	"MODAL_STATUS_FIRMWARE_BOOT_MODE" : "modo bootloader",
	"MODAL_STATUS_FIRMWARE_FACTORY_MODE" : "modo de aplicativo de fábrica",
	"MODAL_STATUS_FIRMWARE_USER_MODE" : "modo de aplicativo do usuário",
	"MODAL_STATUS_FIRMWARE_TAG" : "firmware",
	"MODAL_STATUS_BOOT_TAG" : "inicialização",
	"MODAL_STATUS_FIRMWARE_UPDATE" : "Uma atualização de firmware",
	"MODAL_STATUS_FIRMWARE_UPDATE_AVAILABLE" : "está disponível",
	"MODAL_STATUS_BOOT_UPDATE" : "Uma atualização de inicialização",
	"MODAL_STATUS_FIRMWARE_UPDATE_BUTTON" : "Forçar atualização do firmware",
	"MODAL_STATUS_FIRMWARE_UP_TO_DATE" : "Seu Edison está atualizado.",
	"MODAL_PROGRAMING_METHOD_TITLE" : "Método de programação",
	"MODAL_PROGRAMING_METHOD_BODY" : "A programação flash da tela foi desenvolvida para iPads da Apple. Isso ocorre porque a Apple não permite o acesso normal à porta de dados do iPad. Portanto, a programação do flash de tela só é totalmente compatível com os iPads. No entanto, o flash de tela funciona com alguns dispositivos Android. A opção abaixo ativa a programação do flash de tela nesse dispositivo. Se esse dispositivo não for um iPad, não há garantia de funcionamento.",
	"MODAL_PROGRAMING_METHOD_CURRENT_LABEL" : "Atualmente usando",
	"MODAL_PROGRAMING_METHOD_CURRENT_LABEL_USB" : "USB",
	"MODAL_PROGRAMING_METHOD_CURRENT_LABEL_FLASH" : "FLASH",
	"MODAL_PROGRAMING_METHOD_CURRENT_LABEL_METHOD" : "method.",
	"MODAL_PROGRAMING_METHOD_BUTTON_USB" : "Definir para o método USB",
	"MODAL_PROGRAMING_METHOD_BUTTON_FLASH" : "Configurar para o método FLASH",
	"MODAL_PROGRAMING_METHOD_ACCORD_BUTTON_FLASH_GUARANTEE" : "Por que não é garantido que o flash de tela funcione com dispositivos Android?",
	"MODAL_PROGRAMING_METHOD_ACCORD_BODY_FLASH_GUARANTEE" : "Os dispositivos Android são fabricados por muitos fabricantes diferentes e há milhares de modelos diferentes. Isso significa que também há muitas tecnologias de tela diferentes. Não é possível testar e personalizar a intermitência de tela para todos os dispositivos Android.",
	"MODAL_PROGRAMING_METHOD_ACCORD_BUTTON_FLASH_SETTINGS" : "Existem configurações que podem ajudar meu dispositivo Android a funcionar com o flash de tela?",
	"MODAL_PROGRAMING_METHOD_ACCORD_BODY_FLASH_SETTINGS" : "Sim, na janela pop-up do flash de tela há uma configuração confiável/rápida que tem quatro posições. Experimente cada uma das quatro posições. Além disso, tente ajustar o brilho da tela. Teste com 50%, 75%, 90% e 100% de brilho.",
	"MODAL_PROGRAMING_METHOD_ACCORD_BUTTON_FLASH_FAIL" : "O que devo fazer se a intermitência da tela não funcionar no meu dispositivo Android?",
	"MODAL_PROGRAMING_METHOD_ACCORD_BODY_FLASH_FAIL" : "Para programar, você precisará conectar o cabo do Edison V3 à porta de dados do dispositivo Android por meio de um cabo adaptador. Esses cabos são comuns e baratos e estão disponíveis no ebay, Amazon etc.",
	"MODAL_PROGRAMING_METHOD_BACK" : "Voltar ao diagnóstico",
	"MODAL_PROGRAMING_TITLE" : "Programação",
	"MODAL_PROGRAMING_TITLE_COMPLETE" : "Programação concluída",
	"MODAL_PROGRAMING_TITLE_ERROR" : "Erro de programação",
	"MODAL_PROGRAMING_TIP_1_TITLE" : "Dica: Não agrupe os robôs Edison em um hub USB!",
	"MODAL_PROGRAMING_TIP_1_TEXT" : "Em vez disso, use um EdCharger.",
	"MODAL_PROGRAMING_TIP_2_TITLE" : "Dica: Não deixe o Edison pendurado!",
	"MODAL_PROGRAMING_TIP_2_TEXT" : "Mantenha o Edison apoiado em uma superfície sólida.",
	"MODAL_PROGRAMING_TIP_3_TITLE" : "Dica: Não deixe o Edison pendurado!",
	"MODAL_PROGRAMING_TIP_3_TEXT" : "Use um cabo de extensão ao carregar em uma tomada elétrica.",
	"MODAL_PROGRAMING_TIP_4_TITLE" : "Dica: Não puxe o Edison!",
	"MODAL_PROGRAMING_TIP_4_TEXT" : "Desconecte-o puxando o cabo USB, não o robô.",
	"MODAL_PROGRAMING_ERROR_NO_BLOCK" : "Não é possível fazer download sem blocos conectados ao bloco inicial.",
	"MODAL_PROGRAMING_ERROR_RED" : "Não é possível fazer download com erros vermelhos.",
	"MODAL_PROGRAMING_UPDATE_FIRMWARE" : "Para programar o Edison, será necessário atualizar o firmware para a versão mais recente",
	"MODAL_PROGRAMING_UPDATE_FIRMWARE_BUTTON" : "Atualizar firmware",
	"MODAL_PROGRAMING_UPDATE_FIRMWARE_NOW" : "É necessária a atualização do firmware. Atualizando agora...",
	"MODAL_PROGRAMING_FIRMWARE_UPDATED" : "Firmware atualizado.",
	"MODAL_PROGRAMING_FIRMWARE_UPDATED_NOW_PROGRAMMING" : "Agora programando o Edison...",
	"MODAL_PROGRAMING_FIRMWARE_UPDATE_INCOMPLETE" : "Atualização incompleta do firmware.",
	"MODAL_PROGRAMING_DONE" : "OK! O programa foi carregado em seu Edison.",
	"MODAL_PROGRAMING_ERROR_JSON" : "A resposta não é JSON!",
	"MODAL_PROGRAMING_ERROR_UNKNOWN" : "Erro desconhecido!",
	"MODAL_FIRMWARE_UPDATE_TITLE" : "Atualização do firmware",
	"MODAL_FIRMWARE_UPDATE_LATEST" : "A versão mais recente do firmware do Edison V3 é:",
	"MODAL_FIRMWARE_UPDATE_POPUP" : "Use essa janela pop-up para atualizar o firmware em seu Edison.",
	"MODAL_FIRMWARE_UPDATE_TO_UPDATE1" : "Para atualizar o firmware do Edison V3:",
	"MODAL_FIRMWARE_UPDATE_TO_UPDATE2" : "Conecte seu Edison e clique no botão Update firmware (Atualizar firmware) abaixo e siga as instruções.",
	"MODAL_FIRMWARE_UPDATE_TO_UPDATE_BUTTON" : "Atualizar firmware",
	"MODAL_FIRMWARE_UPDATE_TO_RECONNECT_BUTTON" : "Reconectar o Edison",
	"MODAL_FIRMWARE_UPDATE_FEEDBACK_START" : "Pronto...",
	"MODAL_FIRMWARE_UPDATE_TWO_STEP_START" : "Uma atualização de firmware em duas etapas está sendo iniciada",
	"MODAL_FIRMWARE_UPDATE_BOOT_COMPLETE" : "Atualização do carregador de inicialização concluída.",
	"MODAL_FIRMWARE_UPDATE_PLEASE_CLICK" : "Clique em",
	"MODAL_FIRMWARE_UPDATE_ISSUE_LOADING" : "Problema ao carregar o firmware",
	"MODAL_FIRMWARE_UPDATE_ONE_STEP_START" : "A atualização do firmware está sendo iniciada",
	"MODAL_FIRMWARE_UPDATE_ERROR_ISSUE_LOADING" : "Erro: Problema ao carregar o firmware.",
	"MODAL_FIRMWARE_UPDATE_ERROR_ISSUE_DOWNLOADING" : "Erro: Problema ao fazer o download do firmware.",
	"MODAL_FIRMWARE_UPDATE_FIRM_COMPLETE" : "Atualização do firmware concluída.",
	"MODAL_FIRMWARE_UPDATE_NONE_NEEDED" : "Nenhuma atualização necessária: o firmware do seu Edison está atualizado.",
	"MODAL_FIRMWARE_UPDATE_PROBLEMS" : "Está tendo problemas?",
	"MODAL_FIRMWARE_UPDATE_SEE_DIAG" : "Consulte o diagnóstico",
	"MODAL_USB_CONTROL" : "Controles USB",
	"MODAL_USB_RUN_BUTTON" : "Executar USB",
	"MODAL_USB_CONNECTED_STATUS" : "CONECTADO",
	"MODAL_USB_DISCONNECTED_STATUS" : "DESCONECTADO",
	"MODAL_USB_RUNNING_STATUS" : "EM EXECUÇÃO",
	"MODAL_USB_DATA_TO" : "Dados para USB",
	"MODAL_USB_DATA_TO_BUTTON" : "Enviar para USB",
	"MODAL_USB_DATA_FROM" : "Dados do USB",
	"MODAL_USB_DATA_FROM_CLEAR" : "Limpar",
	"MODAL_USB_DATA_FROM_COPY" : "Copiar para a área de transferência",
	"MODAL_USB_DATA_FROM_COPIED" : "Copiado!",
	"MODAL_BAD_BROWSER_TITLE" : "Navegador não suportado",
	"MODAL_BAD_BROWSER_USING" : "Parece que você está usando:",
	"MODAL_BAD_BROWSER_WEB_USB" : "O Edison V3 é programado diretamente de seu navegador da Web via USB. Isso requer que seu navegador da Web seja compatível com conexões USB.",
	"MODAL_BAD_BROWSER_UNFORTUNATLY" : "Infelizmente, o",
	"MODAL_BAD_BROWSER_UNSUPORTED" : "não é compatível com conexões USB no momento e, portanto, não pode programar seu robô Edison V3.",
	"MODAL_BAD_BROWSER_USE_CHROME" : "Recomendamos o uso do Google Chrome.",
	"MODAL_BAD_BROWSER_GET_CHROME" : "Obter o Chrome.",
	"MODAL_LOADING" : "Carregando espaço de trabalho...",
	"MODAL_FLASHER_TITLE" : "Pisca-pisca",
	"MODAL_FLASHER_STEP_1" : "Coloque o Edison sobre a imagem",
	"MODAL_FLASHER_STEP_2" : "Pressione o botão redondo do Edison uma vez",
	"MODAL_FLASHER_STEP_3" : "Pressione Download program",
	"MODAL_FLASHER_RELIABLE" : "Confiável",
	"MODAL_FLASHER_FAST" : "Rápido",
	"MODAL_FLASHER_ADJUST_SPEED" : "Se o download não funcionar ou não for rápido o suficiente, tente ajustar a velocidade acima. A velocidade mais baixa geralmente é a mais confiável.",
	"MODAL_FLASHER_DOWNLOAD" : "Download do programa",
	"MODAL_FLASHER_CANCEL" : "Cancelar",
	"MODAL_FLASHER_TIPS_HEADING" : "Dicas",
	"MODAL_FLASHER_TIPS_BODY_1" : "Ajuste o brilho da tela entre 80% e 90%.",
	"MODAL_FLASHER_TIPS_BODY_2" : "Afaste-se da luz solar direta e indireta ou de luzes fortes.",
	"MODAL_FLASHER_TIPS_BODY_3" : "Certifique-se de ter atualizado o Edison V3 para o firmware mais recente.",
	"MODAL_FLASHER_DOWNLOADING" : "Download...",
	"MODAL_FLASHER_COMPLETE" : "Completo",
	"MODAL_FLASHER_BYTES" : "bytes em",
	"MODAL_FLASHER_SECONDS" : "segundos",
	"ERROR_RED_OBS_SETTING" : "Os blocos de detecção de obstáculos não funcionam a menos que o feixe de detecção de obstáculos seja ativado usando o bloco de feixe de detecção de obstáculos da categoria Sensoriamento.",
	"ERROR_RED_OBS_SETTING_EVENT" : "Os eventos de detecção de obstáculos não funcionam a menos que o feixe de detecção de obstáculos seja ativado usando o bloco de feixe de detecção de obstáculos da categoria Sensoriamento no programa principal.",
	"ERROR_RED_LINE_SETTING" : "Os blocos de detecção de linha não funcionam a menos que o LED de detecção de linha esteja ligado usando o bloco de LED de rastreamento de linha da categoria Sensoriamento.",
	"ERROR_RED_LINE_SETTING_EVENT" : "Os eventos de detecção de linha não funcionam a menos que o LED de detecção de linha esteja ligado usando o bloco de LED de rastreamento de linha da categoria Sensoriamento no programa principal.",
	"ERROR_RED_DRIVE_CLAP" : "O Edison não pode detectar palmas durante a condução porque os motores são muito barulhentos.",
	"ERROR_RED_EMPTY_IN_FORWARDS" : "Os blocos ''para frente até'' precisam de uma entrada de condição.",
	"ERROR_RED_EMPTY_IN_BACKWARDS" : "Para trás até que os blocos precisem de uma entrada de condição.",
	"ERROR_RED_EMPTY_IN_LEFT" : "Para a esquerda até que os blocos precisem de uma entrada de condição.",
	"ERROR_RED_EMPTY_IN_RIGHT" : "Direita até que os blocos precisem de uma entrada de condição.",
	"ERROR_RED_EMPTY_IN_SET_VAR" : "Os blocos de definição de variável precisam de uma variável.",
	"ERROR_RED_EMPTY_IN_INC_VAR" : "Os blocos de variável de incremento precisam de uma variável.",
	"ERROR_RED_EMPTY_IN_DEC_VAR" : "Os blocos de variáveis decrescentes precisam de uma variável.",
	"ERROR_RED_EMPTY_IN_IF" : "Os blocos If precisam de uma entrada de condição.",
	"ERROR_RED_EMPTY_IN_IF_ELSE" : "Os blocos If-else precisam de uma entrada de condição.",
	"ERROR_RED_EMPTY_IN_WAIT" : "Os blocos Wait until precisam de uma condição de entrada.",
	"ERROR_RED_EMPTY_IN_WAIT_MILLI" : "Os blocos Wait milliseconds precisam de um valor de entrada.",
	"ERROR_RED_EMPTY_IN_REP" : "Repetir até que os blocos precisem de uma condição de entrada.",
	"ERROR_RED_EMPTY_IN_BS_RIGHT" : "Os blocos de deslocamento de bits à direita precisam de uma variável.",
	"ERROR_RED_EMPTY_IN_BS_LEFT" : "Os blocos de deslocamento de bits à esquerda precisam de uma variável.",
	"ERROR_RED_EMPTY_IN_OPERATOR_NOT" : "Os blocos Not precisam de uma condição de entrada.",
	"ERROR_RED_EMPTY_IN_OPERATOR_AND" : "E os blocos precisam de uma condição de entrada.",
	"ERROR_RED_EMPTY_IN_OPERATOR_OR" : "Ou os blocos precisam de uma entrada de condição.",
	"ERROR_RED_EMPTY_BACKGROUND_MUSIC" : "Os blocos de agrupamento de reprodução de música em segundo plano precisam conter pelo menos um bloco de notas.",
	"ERROR_RED_NO_START" : "Os programas devem ter um evento de início para funcionar corretamente. Se estiver vendo essa mensagem de erro, inicie um novo programa acessando o menu e selecionando novo.",
	"ERROR_RED_NOT_BACKGROUND_MUSIC" : "Os blocos de agrupamento Play music in background só podem aceitar blocos de notas.",
	"ERROR_RED_NO_MAIN_BLOCKS" : "Não há blocos conectados ao evento de início, portanto, não há programa principal para o Edison executar.",
	"ERROR_RED_EMPTY_IN_USB_RECEIVED" : "Os blocos de dados wait for usb precisam de uma variável.",
	"ERROR_RED_DEVIDE_BY_ZERO" : "Os blocos de operadores de divisão não podem dividir por zero.",
	"ERROR_RED_FUNCTION_IN_FUNCTION" : "Os blocos de chamada de função não podem ser colocados sob um bloco de início de função",
	"ERROR_YELLOW_RECEIVE_MESSAGE_OBS_ON" : "O Edison não pode receber mensagens enquanto a detecção de obstáculos estiver ativada. Certifique-se de desativar a detecção de obstáculos no programa antes de tentar receber uma mensagem.",
	"ERROR_YELLOW_RECEIVE_REMOTE_OBS_ON" : "O Edison não pode receber códigos de controle remoto enquanto a detecção de obstáculos estiver ativada. Certifique-se de desativar a detecção de obstáculos no programa antes de tentar receber um código de controle remoto.",
	"ERROR_YELLOW_RECEIVE_MESSAGE_EVENT_OBS_ON" : "O Edison não pode receber mensagens enquanto a detecção de obstáculos estiver ativada. Certifique-se de desativar a detecção de obstáculos no programa principal antes de tentar receber uma mensagem.",
	"ERROR_YELLOW_RECEIVE_REMOTE_EVENT_OBS_ON" : "O Edison não pode receber códigos de controle remoto enquanto a detecção de obstáculos estiver ativada. Certifique-se de desativar a detecção de obstáculos no programa principal antes de tentar receber um código remoto.",
	"ERROR_YELLOW_READ_LIGHT_LINE_OFF" : "Considere a possibilidade de ligar o LED de detecção de linha usando o bloco de LED de rastreamento de linha da categoria Sensoriamento se estiver medindo a refletividade da superfície de condução.",
	"ERROR_YELLOW_OPPERATOR_WAIT_UNTIL" : "Um bloco de operador dentro de um bloco wait until (esperar até) pode fazer com que o Edison espere para sempre ou ignore o bloco de espera.",
	"ERROR_YELLOW_OPPERATOR_REPEAT_UNTIL" : "Um bloco de operador dentro de um bloco de repetição até pode fazer com que o Edison faça um loop eterno ou pule o bloco de repetição.",
	"ERROR_YELLOW_OPPERATOR_WAIT" : "Um bloco de operador dentro de um bloco de espera pode fazer com que o Edison pule o bloco de espera.",
	"ERROR_YELLOW_OPPERATOR_REPEAT" : "Um bloco de operador dentro de um bloco de repetição pode fazer com que o Edison pule o bloco de repetição.",
	"ERROR_YELLOW_OPPERATOR_DRIVE_FOR_UNTIL" : "Um bloco de operador dentro de um bloco de avanço até pode fazer com que Edison dirija para sempre ou pule o bloco de avanço.",
	"ERROR_YELLOW_OPPERATOR_DRIVE_BACK_UNTIL" : "Um operator block dentro de um drive backwards until block pode fazer com que Edison dirija para sempre ou pule o drive block.",
	"ERROR_YELLOW_OPPERATOR_DRIVE_LEFT_UNTIL" : "Um bloqueio de operador dentro de uma unidade para a esquerda até o bloco pode fazer com que Edison dirija para sempre ou pule o bloco de unidade.",
	"ERROR_YELLOW_OPPERATOR_DRIVE_RIGHT_UNTIL" : "Um bloqueio de operador dentro de um bloco de dirigir para a direita até pode fazer com que Edison dirija para sempre ou pule o bloco de dirigir.",
	"ERROR_YELLOW_OPPERATOR_DRIVE_FOR_DIST" : "Um bloqueio de operador dentro de um bloco de avanço pode fazer com que a Edison pule o bloco de avanço.",
	"ERROR_YELLOW_OPPERATOR_DRIVE_BACK_DIST" : "Um operator block dentro de um drive backwards block pode fazer com que a Edison pule o drive block.",
	"ERROR_YELLOW_OPPERATOR_DRIVE_LEFT_DIST" : "Um bloqueio de operador dentro de um bloco de acionamento à esquerda pode fazer com que a Edison pule o bloco de acionamento.",
	"ERROR_YELLOW_OPPERATOR_DRIVE_RIGHT_DIST" : "Um bloqueio de operador dentro de um bloco de acionamento à direita pode fazer com que a Edison pule o bloco de acionamento.",
	"ERROR_YELLOW_DRIVE_LIGHT" : "Um bloco de nível de luz dentro de um bloco de acionamento pode fazer com que o Edison acione para sempre ou ignore o bloco de acionamento.",
	"ERROR_YELLOW_OPPERATOR_IR_MESSAGE" : "Um bloco de operador dentro de um bloco de envio de mensagem IR não poderá enviar um valor maior que 255",
	"ERROR_YELLOW_FOREVER_LOOP_IN" : "Um loop infinito continuará em loop até que você pressione o botão quadrado no Edison.",
	"ERROR_YELLOW_SET_MOTOR_LEFT" : "O bloco set left motor ligará somente o motor esquerdo. Certifique-se de que haja blocos adicionais usados no programa para controlar a duração do motor esquerdo.",
	"ERROR_YELLOW_SET_MOTOR_RIGHT" : "O bloco set right motor só ligará o motor direito. Certifique-se de que haja blocos adicionais usados no programa para controlar a duração do motor direito.",
	"ERROR_YELLOW_SET_MOTOR_BOTH" : "O bloco set both motors só ligará os motores. Certifique-se de que haja blocos adicionais usados no programa para controlar a duração do motor.",
	"ERROR_YELLOW_CLAP_EVENT_DRIVE" : "O acionamento dos motores cria ruído que pode fazer com que o evento de palmas seja acionado. Isso pode fazer com que os blocos de eventos de palmas sejam acionados repetidamente enquanto o Edison estiver funcionando.",
	"ERROR_YELLOW_FLOAT_BLOCKS" : "Os blocos não conectados a um bloco de evento amarelo ou a um bloco de definição de função não serão programados no Edison.",
	"ERROR_YELLOW_WAIT_TIME_LIGHT" : "O nível de luz retornará um valor muito alto, o que pode fazer com que o Edison espere por muito tempo.",
	"ERROR_YELLOW_REPEAT_LOOP_LIGHT" : "O nível de luz retornará um valor muito alto, o que pode fazer com que o Edison fique em loop por um longo período.",
	"ERROR_YELLOW_DRIVE_STRAIN" : "O bloco de detecção de tensão do acionamento só detectará a tensão enquanto os motores estiverem funcionando.",
	"ERROR_YELLOW_DRIVE_STRAIN_EVENT" : "O evento de tensão do inversor só pode ser acionado enquanto os motores estiverem funcionando.",
	"ERROR_YELLOW_COMMENT" : "Os comentários são notas para ajudar a manter o controle das coisas. Os blocos de comentários não serão programados no Edison.",
	"ERROR_YELLOW_USB_USED" : "Os blocos USB exigem que o Edison esteja conectado a um dispositivo para funcionar",
	"ERROR_YELLOW_CLEAR_SENSOR" : "Alguns dados do sensor são armazenados na memória do Edison. Talvez seja necessário limpar os dados do sensor para que seu programa funcione corretamente.",
	"ERROR_YELLOW_CLEAR_LEARN_MORE" : "Saiba mais",
	"MODAL_FIRMWARE_ERROR_TITLE" : "Erro de firmware",
	"MODAL_FIRMWARE_ERROR_BODY_1" : "Um arquivo de firmware corrompido foi detectado em seu robô Edison.",
	"MODAL_FIRMWARE_ERROR_BODY_2" : "Isso pode ter ocorrido durante uma atualização de firmware que foi interrompida.",
	"MODAL_FIRMWARE_ERROR_BODY_3" : "Não entre em pânico! Isso pode ser corrigido clicando no botão Fixar firmware abaixo.",
	"MODAL_FIRMWARE_ERROR_CANCEL_BODY_1" : "Atenção!",
	"MODAL_FIRMWARE_ERROR_CANCEL_BODY_2" : "O cancelamento desse processo significa que o robô Edison não poderá ser programado.",
	"MODAL_FIRMWARE_ERROR_CANCEL_BODY_3" : "É recomendável que você corrija o firmware agora clicando no botão Fix firmware.",
	"MODAL_FIRMWARE_ERROR_CANCEL_BODY_4" : "Se você optar por cancelar, poderá corrigir o firmware posteriormente.",
	"MODAL_FIRMWARE_ERROR_BUTTON_FIX" : "Corrigir o firmware",
	"MODAL_FIRMWARE_ERROR_BUTTON_CANCEL" : "Cancelar",
	"MODAL_FIRMWARE_ERROR_BUTTON_CANCEL_CONFIRM" : "Confirmar o cancelamento",
	"MODAL_NEW_CONFIRM_HEADING" : "Tem certeza?",
	"MODAL_NEW_CONFIRM_BODY_TEXT_1" : "Tem certeza de que deseja iniciar um novo programa?",
	"MODAL_NEW_CONFIRM_BODY_TEXT_2" : "Todas as alterações podem ser perdidas!",
	"MODAL_NEW_CONFIRM_BUTTON_CANCEL" : "Cancelar",
	"MODAL_NEW_CONFIRM_BUTTON_PROCEED" : "Continuar",
	"CHANGELANG" : "Alterar o idioma",
	"HELP_TEXT_ALL_TITLE" : "Bloquear ajuda",
	"HELP_TEXT_ALL_BLOCKS_EXAMPLE_USES" : "Exemplo de uso:",
	"HELP_TEXT_ALL_BLOCKS_EXAMPLE_LOAD" : "Abrir programa",
	"HELP_TEXT_ALL_BLOCKS_WATCH_FOR" : "Cuidado com:",
	"HELP_TEXT_DRIVE_FORWARD_FOR_TITLE" : "para frente para",
	"HELP_TEXT_DRIVE_FORWARD_FOR_BODY_1" : "O bloco forwards for aciona as rodas para mover o robô na direção para frente.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_BODY_2" : "O bloco tem três parâmetros:",
	"HELP_TEXT_DRIVE_FORWARD_FOR_BODY_3" : "Valor - Pode ser uma constante (digitada na entrada e não varia), uma variável, um sensor ou um bloco de operador.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_BODY_4" : "Unidades - Há três opções que podem ser selecionadas: cm, polegada e segundos.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_BODY_5" : "Velocidade - A velocidade pode ser selecionada de 1 a 10 (como um valor constante), uma variável, um sensor ou um bloco do operador.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_BODY_6" : "Os avanços para o bloco serão concluídos antes da execução do próximo bloco. Por exemplo, o uso do bloco forwards for não executará outros blocos do programa ao mesmo tempo. Para fazer isso, consulte a seção Definir ambos os motores para bloquear.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_1_TITLE" : "Exemplo 1: Emita um bipe e, em seguida, leve o robô Edison para frente 15 cm na velocidade 1 e, em seguida, emita um bipe novamente.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_1_BODY_1" : "Nesse programa de exemplo, o Edison emite um bipe, mas não começa a dirigir até que o bipe termine de tocar. Além disso, o segundo bipe não começa até que o Edison tenha parado de dirigir.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_2_TITLE" : "Exemplo 2: Definição da distância de condução usando uma variável e dados de um sensor",
	"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_2_BODY_1" : "Neste programa de exemplo, o Edison define a variável Distance como o nível de luz do sensor de luz esquerdo (um valor de 1 a 1.000) dividido por 50. Em seguida, o Edison se dirige para a frente para o valor na variável (Distância) na velocidade 5. O resultado é que o Edison se dirige mais longe sob luz mais clara e mais curto sob luz mais fraca.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_3_TITLE" : "Exemplo 3: Alteração da velocidade de acionamento usando uma variável.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_3_BODY_1" : "Neste programa de exemplo, a variável Speed (Velocidade) é definida como 1. Em seguida, o programa entra em um loop de repetição por 10 vezes. Em cada loop, o Edison avança 5 cm na velocidade da variável. Inicialmente, o valor na variável Speed é 1, portanto, o Edison avança 5 cm na velocidade 1. O próximo bloco na repetição incrementa (+1) a variável Speed. Na segunda repetição do bloco de avanço, o valor na variável Speed é 2, portanto, o Edison avança 5 cm na velocidade 2.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_3_BODY_2" : "Esse processo se repete as 10 vezes completas do loop de repetição, fazendo com que o Edison dirija cada vez mais rápido até parar quando o programa termina.",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_TITLE" : "para trás para",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_BODY_1" : "O bloco backwards for aciona as rodas para mover o robô na direção contrária.",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_BODY_2" : "O bloco tem três parâmetros:",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_BODY_3" : "Valor - Pode ser uma constante (digitada na entrada e não varia), uma variável, um sensor ou um bloco de operador.",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_BODY_4" : "Unidades - Há três opções que podem ser selecionadas: cm, polegada e segundos.",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_BODY_5" : "Velocidade - A velocidade pode ser selecionada de 1 a 10 (como um valor constante), uma variável, um sensor ou um bloco do operador.",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_BODY_6" : "O bloco backwards for será concluído antes que o próximo bloco seja executado. Por exemplo, o uso do bloco backwards for não executará outros blocos do programa ao mesmo tempo. Para fazer isso, consulte a opção definir ambos os motores para o bloco.",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_EXAMPLE_1_TITLE" : "Exemplo 1: Luzes de LED acesas durante a condução",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_EXAMPLE_1_BODY_1" : "Neste programa de exemplo, o LED esquerdo acende e permanece aceso enquanto o Edison se desloca para trás por um segundo. O LED esquerdo se apaga depois que o Edison para de andar. Em seguida, o programa aguarda um segundo antes de terminar.",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_EXAMPLE_2_TITLE" : "Exemplo 2: Quando há um obstáculo, dirija para trás",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_EXAMPLE_2_BODY_1" : "Nesse programa de exemplo, o feixe de detecção de obstáculos é ligado primeiro. Em seguida, o programa entra em um loop infinito. Dentro do loop, o bloco wait until impede que o programa progrida até que um obstáculo seja detectado em qualquer lugar; quando isso acontece, o Edison recua uma polegada na velocidade 10. Esse comportamento se repete para sempre em um loop. Isso faz com que o Edison se afaste dos objetos colocados à sua frente.",
	"HELP_TEXT_DRIVE_LEFT_FOR_TITLE" : "esquerda para",
	"HELP_TEXT_DRIVE_LEFT_FOR_BODY_1" : "O bloco left for aciona as rodas para mover o robô na direção esquerda.",
	"HELP_TEXT_DRIVE_LEFT_FOR_BODY_2" : "O bloco tem quatro parâmetros:",
	"HELP_TEXT_DRIVE_LEFT_FOR_BODY_3" : "Movimento - Há três opções que podem ser selecionadas: girar, virar para frente e virar para trás.",
	"HELP_TEXT_DRIVE_LEFT_FOR_BODY_4" : "Valor - Pode ser uma constante (digitada na entrada e não varia), uma variável, um sensor ou um bloco de operador.",
	"HELP_TEXT_DRIVE_LEFT_FOR_BODY_5" : "Unidades - Há duas opções que podem ser selecionadas: graus e segundos.",
	"HELP_TEXT_DRIVE_LEFT_FOR_BODY_6" : "Velocidade - A velocidade pode ser selecionada de 1 a 10 (como um valor constante), uma variável, um sensor ou um bloco do operador.",
	"HELP_TEXT_DRIVE_LEFT_FOR_BODY_7" : "O giro e a rotação são mais precisos em velocidades mais baixas. Isso ocorre porque as rodas podem perder a tração e escorregar em altas velocidades. A velocidade 1 é a melhor quando é necessário fazer um giro preciso.",
	"HELP_TEXT_DRIVE_LEFT_FOR_BODY_8" : "O bloco da esquerda deve ser concluído antes que o próximo bloco seja executado. Por exemplo, o uso do bloco left for não executará outros blocos do programa ao mesmo tempo. Para fazer isso, consulte a seção Definir ambos os motores para bloquear.",
	"HELP_TEXT_DRIVE_LEFT_FOR_EXAMPLE_1_TITLE" : "Programa de exemplo 1: beep, spin, beep",
	"HELP_TEXT_DRIVE_LEFT_FOR_EXAMPLE_1_BODY_1" : "Nesse programa de exemplo, o Edison emite um bipe, mas não começa a girar até que o bipe termine de tocar. Além disso, o segundo bipe não começa até que Edison tenha parado de girar.",
	"HELP_TEXT_DRIVE_LEFT_FOR_EXAMPLE_2_TITLE" : "Programa de exemplo 2: Dirigir em um quadrado",
	"HELP_TEXT_DRIVE_LEFT_FOR_EXAMPLE_2_BODY_1" : "Nesse programa de exemplo, o loop de repetição repete o deslocamento para a frente por 10 cm na velocidade 1 e gira para a esquerda por 90 graus quatro vezes. Isso resulta em Edison dirigindo em um padrão quadrado.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_TITLE" : "direita para",
	"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_1" : "O bloco for da direita aciona as rodas para mover o robô na direção esquerda.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_2" : "O bloco tem quatro parâmetros:",
	"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_3" : "Movimento - Há três opções que podem ser selecionadas: girar, virar para frente e virar para trás.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_4" : "Valor - Pode ser uma constante (digitada na entrada e não varia), uma variável, um sensor ou um bloco de operador.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_5" : "Unidades - Há duas opções que podem ser selecionadas: graus e segundos.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_6" : "Velocidade - A velocidade pode ser selecionada de 1 a 10 (como um valor constante), uma variável, um sensor ou um bloco do operador.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_7" : "O giro e a rotação são mais precisos em velocidades mais baixas. Isso ocorre porque as rodas podem perder a tração e escorregar em altas velocidades. A velocidade 1 é a melhor quando é necessário fazer um giro preciso.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_8" : "O bloco da direita deve ser concluído antes que o próximo bloco seja executado. Por exemplo, o uso do bloco right for não executará outros blocos do programa ao mesmo tempo. Para fazer isso, consulte a seção Definir ambos os motores para bloquear.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_EXAMPLE_1_TITLE" : "Programa de exemplo 1: Beep, spin, beep",
	"HELP_TEXT_DRIVE_RIGHT_FOR_EXAMPLE_1_BODY_1" : "Nesse programa de exemplo, o Edison emite um bipe, mas não começa a girar até que o bipe termine de tocar. Além disso, o segundo bipe não começa até que Edison tenha parado de girar.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_EXAMPLE_2_TITLE" : "Exemplo 2: Girar para a direita com a velocidade controlada pelo nível de luz",
	"HELP_TEXT_DRIVE_RIGHT_FOR_EXAMPLE_2_BODY_1" : "Neste programa de exemplo, Edison gira para a direita dentro de um loop infinito. Cada vez que o bloco right for é executado, Edison gira 1 grau. A velocidade é definida pela leitura do nível de luz do sensor de luz esquerdo (1 a 1.000) e é dividida por 100 (resultado 0 a 10). O resultado é que o Edison gira mais rápido sob luz mais clara e mais devagar sob luz mais fraca.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_EXAMPLE_3_TITLE" : "Programa de exemplo 3: Evitar obstáculos",
	"HELP_TEXT_DRIVE_RIGHT_FOR_EXAMPLE_3_BODY_1" : "Neste programa de exemplo, o feixe de detecção de obstáculos é ativado. Em seguida, o programa entra em um loop infinito em que os dois motores são configurados para avançar. Em seguida, o programa espera até que um obstáculo seja detectado em qualquer lugar. Quando isso acontece, o programa avança para o próximo bloco e o robô Edison gira 180 graus para a direita na velocidade 1. Isso faz com que o Edison se afaste dos obstáculos em seu caminho.",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_TITLE" : "para frente até",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_BODY_1" : "O bloco forwards until (para frente até) faz com que as rodas movam o robô para frente até que a condição especificada seja verdadeira. Quando a condição especificada for verdadeira, as rodas param e o programa avança para o próximo bloco.",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_BODY_2" : "O bloco tem dois parâmetros:",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_BODY_3" : "Entrada condicional - A entrada condicional aceita um bloco em forma de diamante que pode ser um bloco de detecção ou de operador.",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_BODY_4" : "Velocidade - A velocidade pode ser selecionada de 1 a 10 (como um valor constante), uma variável, um sensor ou um bloco do operador.",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_BODY_5" : "O bloco ''forwards until'' deve ser concluído antes que o próximo bloco seja executado. Por exemplo, o uso do bloco forwards until não executará outros blocos do programa ao mesmo tempo. Para fazer isso, consulte a seção Definir ambos os motores para bloquear.",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_EXAMPLE_1_TITLE" : "Programa de exemplo 1: Parar por causa de um obstáculo",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_EXAMPLE_1_BODY_1" : "Neste programa de exemplo, o feixe de detecção de obstáculos é ativado e o robô avança na velocidade 5 até que um obstáculo seja detectado. Quando isso acontece, o robô para de se mover e o programa termina.",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_EXAMPLE_2_TITLE" : "Programa de exemplo 2: Saltar nas bordas",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_EXAMPLE_2_BODY_1" : "Nesse programa de exemplo, o LED do rastreador de linha é ligado e o programa entra em um loop infinito. Dentro do loop, o bloco ''forwards until'' impulsiona o robô para frente na velocidade 1 até que o rastreador de linha esteja em uma superfície não reflexiva (ou seja, preta). Quando isso acontece, o próximo bloco é executado, girando o robô para a esquerda por 180 graus na velocidade 5. O programa então volta ao loop do bloco forwards until. Isso faz com que o Edison se afaste das linhas pretas detectadas.",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_TITLE" : "para trás até",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_BODY_1" : "O bloco ''backwards until'' aciona as rodas para mover o robô na direção contrária até que a condição especificada seja verdadeira. Quando a condição especificada for verdadeira, as rodas param e o programa avança para o próximo bloco.",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_BODY_2" : "O bloco tem dois parâmetros:",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_BODY_3" : "Entrada condicional - A entrada condicional aceita um bloco em forma de diamante que pode ser um bloco de detecção ou de operador.",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_BODY_4" : "Velocidade - A velocidade pode ser selecionada de 1 a 10 (como um valor constante), uma variável, um sensor ou um bloco do operador.",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_BODY_5" : "O bloco backwards until deve ser concluído antes que o próximo bloco seja executado. Por exemplo, o uso do bloco backwards until não executará outros blocos do programa ao mesmo tempo. Para fazer isso, consulte o bloco set both motors to.",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_EXAMPLE_1_TITLE" : "Programa de exemplo 1: Parar quando o acionamento estiver tenso",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_EXAMPLE_1_BODY_1" : "Neste programa de exemplo, o robô se desloca para trás na velocidade 10 até que as rodas fiquem tensas (não consigam girar ou fiquem presas). Quando isso acontece, os motores param e o programa termina.",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_EXAMPLE_2_TITLE" : "Programa de exemplo 2: controle de acionamento com botões",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_EXAMPLE_2_BODY_1" : "Neste exemplo, o programa começa com um loop infinito. O primeiro bloco do loop aguarda até que o botão triangular seja pressionado. Quando isso acontece, o robô se desloca para trás na velocidade 1 até que o botão redondo seja pressionado. Quando isso acontece, as rodas do robô param e o programa volta ao loop para esperar que o botão triangular seja pressionado.",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_TITLE" : "esquerda até",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_BODY_1" : "O bloco left until aciona as rodas para mover o robô na direção esquerda até que a condição especificada seja verdadeira. Quando a condição especificada for verdadeira, as rodas param e o programa avança para o próximo bloco.",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_BODY_2" : "O bloco tem três parâmetros:",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_BODY_3" : "Movimento - Há três opções que podem ser selecionadas: girar, virar para frente e virar para trás.",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_BODY_4" : "Entrada condicional - A entrada condicional aceita um bloco em forma de diamante que pode ser um bloco de detecção ou de operador.",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_BODY_5" : "Velocidade - A velocidade pode ser selecionada de 1 a 10 (como um valor constante), uma variável, um sensor ou um bloco do operador.",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_BODY_6" : "O bloco spin left until deve ser concluído antes que o próximo bloco seja executado. Por exemplo, o uso do bloco spin left until não executará outros blocos do programa ao mesmo tempo. Para fazer isso, consulte a seção Definir ambos os motores para bloquear.",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_EXAMPLE_1_TITLE" : "Programa de exemplo 1: Parar quando o acionamento estiver tenso",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_EXAMPLE_1_BODY_1" : "Nesse programa de exemplo, o robô avança para a esquerda (a roda direita se move) na velocidade 1 até que a roda fique tensa (incapaz de girar ou fique presa). Quando isso acontece, o motor para e o programa termina.",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_EXAMPLE_2_TITLE" : "Programa de exemplo 2: Seguir a luz",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_EXAMPLE_2_BODY_1" : "Neste exemplo, o programa começa com um loop infinito. O primeiro bloco do loop gira o robô para a esquerda na velocidade 5 até que o nível da luz esquerda seja menor que o nível da luz direita. Quando isso acontece, o motor para e o próximo bloco é executado. O próximo bloco gira o robô para a direita na velocidade 5 até que o nível da luz esquerda seja maior do que o nível da luz direita. O resultado disso é que o robô Edison se move em direção à luz.",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_TITLE" : "direita até",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_BODY_1" : "O bloco right until aciona as rodas para mover o robô na direção certa até que a condição especificada seja verdadeira. Quando a condição especificada for verdadeira, as rodas param e o programa avança para o próximo bloco.",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_BODY_2" : "O bloco tem três parâmetros:",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_BODY_3" : "Movimento - Há três opções que podem ser selecionadas: girar, virar para frente e virar para trás.",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_BODY_4" : "Entrada condicional - A entrada condicional aceita um bloco em forma de diamante que pode ser um bloco de detecção ou de operador.",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_BODY_5" : "Velocidade - A velocidade pode ser selecionada de 1 a 10 (como um valor constante), uma variável, um sensor ou um bloco do operador.",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_BODY_6" : "O bloco right until deve ser concluído antes que o próximo bloco seja executado. Por exemplo, o uso do bloco spin right until não executará outros blocos do programa ao mesmo tempo. Para fazer isso, consulte a seção Definir ambos os motores para bloquear.",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_EXAMPLE_1_TITLE" : "Programa de exemplo 1: Parar em uma superfície preta",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_EXAMPLE_1_BODY_1" : "Neste exemplo, programe o robô para girar à direita na velocidade 5 até que o rastreador de linha detecte uma superfície não reflexiva (preta). Quando isso acontece, o motor para e o programa termina.",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_EXAMPLE_2_TITLE" : "Programa de exemplo 2: Seguir a luz",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_EXAMPLE_2_BODY_1" : "Neste exemplo, o programa começa com um loop infinito. O primeiro bloco do loop gira o robô para a esquerda na velocidade 5 até que o nível da luz esquerda seja menor que o nível da luz direita. Quando isso acontece, o motor para e o próximo bloco é executado. O próximo bloco gira o robô para a direita na velocidade 5 até que o nível da luz esquerda seja maior do que o nível da luz direita. O resultado disso é que o robô Edison se move em direção à luz.",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_TITLE" : "Definir ambos os motores para",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_BODY_1" : "O bloco set both motors to aciona as rodas para mover o robô na direção e na velocidade selecionadas. Como esse bloco de acionamento ajusta os motores, o programa pode continuar diretamente para o próximo bloco. Isso é diferente dos blocos de acionamento que têm uma distância, um tempo ou um ângulo a ser concluído antes de o programa continuar para o próximo bloco.",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_BODY_2" : "O bloco tem dois parâmetros:",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_BODY_3" : "Movimento - Há seis opções que podem ser selecionadas: dirigir para frente, dirigir para trás, girar o robô para a esquerda, girar o robô para a direita, virar o robô para a esquerda e virar o robô para a direita.",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_BODY_4" : "Velocidade - A velocidade pode ser selecionada de 1 a 10 (como um valor constante), uma variável, um sensor ou um bloco do operador.",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_EXAMPLE_1_TITLE" : "Programa de exemplo 1: Música enquanto dirige",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_EXAMPLE_1_BODY" : "Neste programa de exemplo, o robô Edison é configurado para dirigir para frente e, em seguida, três notas são tocadas enquanto o robô ainda está dirigindo. Quando a última nota termina de tocar, o programa termina e o robô Edison para de dirigir.",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_EXAMPLE_2_TITLE" : "Programa de exemplo 2: Dirigir até um obstáculo",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_EXAMPLE_2_BODY" : "Nesse programa de exemplo, o feixe de detecção de obstáculos é ativado e, em seguida, os dois motores são configurados para dirigir para frente na velocidade 8. O próximo bloco aguarda até que um obstáculo seja detectado. Quando isso acontece, o programa termina e o robô para de dirigir.",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_EXAMPLE_3_TITLE" : "Programa de exemplo 3: Seguir uma linha",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_EXAMPLE_3_BODY" : "Neste programa de exemplo, o LED do rastreador de linha é ligado e o programa entra em um loop infinito. Dentro do loop, os dois motores são configurados para girar o robô para a esquerda na velocidade 1 e, em seguida, o bloco wait until mantém o programa lá até que o rastreador de linha detecte uma superfície reflexiva (branca). Quando isso acontece, os dois motores são ajustados para virar o robô para a direita na velocidade 1 e o bloco wait until mantém o programa lá até que o rastreador de linha detecte uma superfície não reflexiva (preta). Quando isso acontece, o programa volta ao início do loop infinito e se repete. Isso faz com que o Edison siga uma linha não reflexiva.",
	"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_TITLE" : "ajustar o motor direito para",
	"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_BODY_1" : "O bloco ''set right motor to'' aciona as rodas para mover o robô na direção e velocidade selecionadas. Como esse bloco de acionamento define os motores, o programa pode continuar diretamente para o próximo bloco. Isso é diferente dos blocos de acionamento que têm uma distância, um tempo ou um ângulo a ser concluído antes de o programa passar para o próximo bloco.",
	"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_BODY_2" : "O bloco tem dois parâmetros:",
	"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_BODY_3" : "Movimento - Há duas opções que podem ser selecionadas: para frente e para trás.",
	"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_BODY_4" : "Velocidade - A velocidade pode ser selecionada de 1 a 10 (como um valor constante), uma variável, um sensor ou um bloco do operador.",
	"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_EXAMPLE_1_TITLE" : "Exemplo de programa 1: Motor ligado e desligado com o pressionamento de um botão",
	"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_EXAMPLE_1_BODY" : "Neste exemplo, o programa entra em um loop infinito. O primeiro bloco do loop aguarda até que o botão redondo seja pressionado. Quando isso acontece, o motor direito é ajustado para frente na velocidade 5. O programa então avança para outro bloco de espera até que o botão redondo seja pressionado. Quando isso acontece, o motor direito é parado e o programa volta ao início do loop infinito.",
	"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_TITLE" : "ajustar o motor esquerdo para",
	"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_BODY_1" : "O bloco set left motor to aciona as rodas para mover o robô na direção e na velocidade selecionadas. Como esse bloco de acionamento define os motores, o programa pode continuar diretamente para o próximo bloco. Isso é diferente dos blocos de acionamento que têm uma distância, um tempo ou um ângulo a ser concluído antes de o programa passar para o próximo bloco.",
	"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_BODY_2" : "O bloco tem dois parâmetros:",
	"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_BODY_3" : "Movimento - Há duas opções que podem ser selecionadas: para frente e para trás.",
	"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_BODY_4" : "Velocidade - A velocidade pode ser selecionada de 1 a 10 (como um valor constante), uma variável, um sensor ou um bloco do operador.",
	"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_EXAMPLE_1_TITLE" : "Programa de exemplo 1: Seguimento de luz",
	"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_EXAMPLE_1_BODY" : "Neste exemplo, o programa entra em um loop infinito. O primeiro bloco do loop faz o motor esquerdo avançar em uma velocidade calculada. A velocidade calculada é o nível de luz do sensor direito menos o nível de luz do sensor esquerdo dividido por 100, 3 também é adicionado ao resultado para definir uma velocidade mínima. O próximo bloco define o motor direito para a frente em uma velocidade calculada. A velocidade calculada é o nível de luz do sensor esquerdo menos o nível de luz do sensor direito dividido por 100, 3 também é adicionado ao resultado para definir uma velocidade mínima. Em seguida, o programa volta ao início do loop infinito. Os resultados calculados controlam a velocidade de modo que o lado que tem a menor quantidade de luz seja o mais rápido. O resultado é que o robô Edison sempre tenta ficar de frente para a luz mais brilhante.",
	"HELP_TEXT_DRIVE_STOP_TITLE" : "parar",
	"HELP_TEXT_DRIVE_STOP_BODY_1" : "O bloco de parada faz com que os motores parem de acionar as rodas.",
	"HELP_TEXT_DRIVE_STOP_BODY_2" : "O bloco de parada tem apenas um parâmetro para selecionar quais motores são parados. As opções são os dois motores, o motor esquerdo e o motor direito.",
	"HELP_TEXT_DRIVE_STOP_EXAMPLE_1_TITLE" : "Exemplo de programa 1: Motor ligado e desligado com o pressionamento de um botão",
	"HELP_TEXT_DRIVE_STOP_EXAMPLE_1_BODY" : "Neste exemplo, o programa entra em um loop infinito. O primeiro bloco do loop aguarda até que o botão redondo seja pressionado. Quando isso acontece, o motor direito é ajustado para frente na velocidade 5. O programa então avança para outro bloco de espera até que o botão redondo seja pressionado. Quando isso acontece, o motor direito é parado e o programa volta ao início do loop infinito.",
	"HELP_TEXT_LEDS_LEFT_TITLE" : "girar o LED esquerdo",
	"HELP_TEXT_LEDS_LEFT_BODY_1" : "O bloco turn left LED controla o LED esquerdo. Há duas opções: ligado ou desligado.",
	"HELP_TEXT_LEDS_LEFT_EXAMPLE_1_TITLE" : "Programa de exemplo 1: piscar o LED esquerdo uma vez",
	"HELP_TEXT_LEDS_LEFT_EXAMPLE_1_BODY" : "Nesse exemplo, o programa começa ligando o LED esquerdo, aguarda um segundo e, em seguida, desliga o LED esquerdo.",
	"HELP_TEXT_LEDS_LEFT_EXAMPLE_2_TITLE" : "Programa de exemplo 2: Piscar o LED esquerdo para sempre",
	"HELP_TEXT_LEDS_LEFT_EXAMPLE_2_BODY" : "Neste exemplo, o programa começa entrando em um loop infinito. Dentro do loop, o LED esquerdo é ligado, o programa aguarda um segundo, o LED esquerdo é desligado, o programa aguarda um segundo, o programa volta ao início do loop e repete para sempre.",
	"HELP_TEXT_LEDS_RIGHT_TITLE" : "girar o LED direito",
	"HELP_TEXT_LEDS_RIGHT_BODY_1" : "O bloco Turn Right LED controla o LED direito. Há duas opções: ligado ou desligado.",
	"HELP_TEXT_LEDS_RIGHT_EXAMPLE_1_TITLE" : "Programa de exemplo 1: Piscar o LED direito uma vez",
	"HELP_TEXT_LEDS_RIGHT_EXAMPLE_1_BODY" : "Neste exemplo, o programa começa ligando o LED direito, aguarda um segundo e, em seguida, desliga o LED direito.",
	"HELP_TEXT_LEDS_RIGHT_EXAMPLE_2_TITLE" : "Programa de exemplo 2: Piscar o LED direito para sempre",
	"HELP_TEXT_LEDS_RIGHT_EXAMPLE_2_BODY" : "Neste exemplo, o programa começa entrando em um loop infinito. Dentro do loop, o LED direito é ligado, o programa aguarda um segundo, o LED direito é desligado, o programa aguarda um segundo, o programa volta ao início do loop e repete para sempre.",
	"HELP_TEXT_LEDS_SEND_MESSAGE_TITLE" : "enviar mensagem IR",
	"HELP_TEXT_LEDS_SEND_MESSAGE_BODY_1" : "O bloco de mensagens send IR envia dados por meio de luz infravermelha (IR). Os dados que podem ser enviados são um valor de 0 a 255. O valor pode ser uma constante (digitada na entrada e que não varia), uma variável, um sensor ou um bloco de operador.",
	"HELP_TEXT_LEDS_SEND_MESSAGE_BODY_2" : "Os dados enviados podem ser recebidos por qualquer outro robô Edison que esteja dentro do alcance do sinal de luz infravermelha. O alcance máximo pode ser de até 10 metros/30 pés em condições ideais (ou seja, dentro de casa, sem luz solar direta, teto e paredes brancas para a luz infravermelha refletir).",
	"HELP_TEXT_LEDS_SEND_MESSAGE_BODY_3" : "Se você usar uma variável, o número na variável poderá exceder o limite de 255 (8 bits). Quando isso acontecer, o número enviado por infravermelho será ''enrolado'' (ou seja, 256 envia 0, 257 envia 1, 258 envia 2...).",
	"HELP_TEXT_LEDS_SEND_MESSAGE_EXAMPLE_1_TITLE" : "Programa de exemplo 1: Enviar mensagem IR 1 quando o botão redondo for pressionado",
	"HELP_TEXT_LEDS_SEND_MESSAGE_EXAMPLE_1_BODY" : "Neste exemplo, o programa começa entrando em um loop infinito. Dentro do loop, o programa espera que o botão redondo seja pressionado. Quando isso acontece, a mensagem IR 1 é enviada. Em seguida, o programa volta ao início do loop infinito.",
	"HELP_TEXT_LEDS_SEND_MESSAGE_EXAMPLE_2_TITLE" : "Programa de exemplo 2: Enviar nível de luz a cada um segundo",
	"HELP_TEXT_LEDS_SEND_MESSAGE_EXAMPLE_2_BODY" : "Nesse exemplo, o programa começa entrando em um loop infinito. Dentro do loop, o programa envia a leitura do nível de luz do sensor de luz esquerdo dividida por quatro. O valor é dividido por quatro, pois a saída do sensor de luz é de 1 a 1.000, mas o número mais alto que pode ser enviado com o IR é 255 (1.000/4 = 250). Esse cálculo adicional permite que o alcance total do sensor de luz seja enviado. Em seguida, o programa espera por um segundo e volta ao início do loop infinito.",
	"HELP_TEXT_SOUND_BEEP_TITLE" : "bip",
	"HELP_TEXT_SOUND_BEEP_BODY_1" : "O bloco de bipe reproduz um som de bipe de 3,5 kHz por 125 mS (0,125 segundos).",
	"HELP_TEXT_SOUND_BEEP_EXAMPLE_1_TITLE" : "Programa de exemplo 1: Bip quando o botão redondo é pressionado",
	"HELP_TEXT_SOUND_BEEP_EXAMPLE_1_BODY" : "Neste exemplo, o programa começa entrando em um loop infinito. Dentro do loop, o programa espera que o botão redondo seja pressionado. Quando isso acontece, o bipe é reproduzido. Em seguida, o programa volta ao início do loop infinito e o repete.",
	"HELP_TEXT_SOUND_PLAY_NOTE_TITLE" : "reproduzir uma nota",
	"HELP_TEXT_SOUND_PLAY_NOTE_BODY_1" : "O bloco play a note reproduz uma nota musical. Os parâmetros do bloco permitem que a duração, a nota e o tipo de nota sejam selecionados.",
	"HELP_TEXT_SOUND_PLAY_NOTE_BODY_2" : "O bloco tem três parâmetros:",
	"HELP_TEXT_SOUND_PLAY_NOTE_BODY_3" : "Comprimento - Há quatro opções: inteiro, meio, quarto e oitavo.",
	"HELP_TEXT_SOUND_PLAY_NOTE_BODY_4" : "Nota - Há dez opções: C, B, A, G, F, E, D, C médio, B baixo e repouso.",
	"HELP_TEXT_SOUND_PLAY_NOTE_BODY_5" : "Modificador de nota - Há três opções: - (não modificada), sustenido e bemol.",
	"HELP_TEXT_SOUND_PLAY_NOTE_BODY_6" : "O bloco tocar uma nota deve ser concluído antes que o próximo bloco seja executado. Por exemplo, o uso do bloco tocar uma nota não executará outros blocos do programa ao mesmo tempo. Para fazer isso, consulte o bloco reproduzir música em segundo plano.",
	"HELP_TEXT_SOUND_PLAY_NOTE_EXAMPLE_1_TITLE" : "Exemplo de programa 1: Mary had a little lamb",
	"HELP_TEXT_SOUND_PLAY_NOTE_EXAMPLE_1_BODY" : "Neste exemplo, o programa começa definindo o andamento das notas musicais e, em seguida, toca as notas da canção infantil Mary had a little lamb em ordem, tocando cada nota completamente antes de prosseguir.",
	"HELP_TEXT_SOUND_SET_TEMPO_TITLE" : "ajustar o andamento da música para",
	"HELP_TEXT_SOUND_SET_TEMPO_BODY_1" : "O bloco set music temp to define o andamento em que as notas seguintes são tocadas.",
	"HELP_TEXT_SOUND_SET_TEMPO_BODY_2" : "Há cinco opções: muito lento, lento, médio, rápido e muito rápido.",
	"HELP_TEXT_SOUND_SET_TEMPO_EXAMPLE_1_TITLE" : "Exemplo de programa 1: Mary had a little lamb",
	"HELP_TEXT_SOUND_SET_TEMPO_EXAMPLE_1_BODY" : "Nesse exemplo, o programa começa definindo o andamento das notas musicais e, em seguida, toca as notas da canção infantil Mary had a little lamb nessa velocidade, tocando cada nota por completo antes de prosseguir.",
	"HELP_TEXT_SOUND_PLAYINBACKGROUND_TITLE" : "Reproduzir música em segundo plano",
	"HELP_TEXT_SOUND_PLAYINBACKGROUND_BODY_1" : "O bloco de reprodução de música em segundo plano permite que as notas musicais colocadas dentro do bloco sejam reproduzidas enquanto o robô Edison estiver executando outras partes do programa.",
	"HELP_TEXT_SOUND_PLAYINBACKGROUND_EXAMPLE_1_TITLE" : "Programa de exemplo 1: Mary tinha um cordeirinho enquanto dançava",
	"HELP_TEXT_SOUND_PLAYINBACKGROUND_EXAMPLE_1_BODY" : "Nesse programa de exemplo, o programa começa definindo o andamento das notas musicais e, em seguida, as notas dentro do bloco reproduzir música em segundo plano começam a tocar, o programa entra no loop de repetição e os blocos girar para a esquerda e girar para a direita são executados quatro vezes com a música ainda sendo reproduzida em segundo plano. Isso faz com que o Edison dance enquanto toca a música.",
	"HELP_TEXT_VARIABLE_TITLE" : "Variável",
	"HELP_TEXT_VARIABLE_BODY_1" : "Um bloco variável é um local onde os dados podem ser armazenados e usados por um programa. Os dados em uma variável podem variar e mudar enquanto o programa estiver sendo executado. É por isso que ela é chamada de variável.",
	"HELP_TEXT_VARIABLE_BODY_2" : "Os dados em uma variável são um número que pode variar de -1.073.741.824 a 1.073.741.823 (32 bits com sinal).",
	"HELP_TEXT_VARIABLE_BODY_3" : "As variáveis devem ser personalizadas, nomeando-as com um nome que faça sentido para o programa. Por exemplo:",
	"HELP_TEXT_VARIABLE_BODY_4" : "Se o número em uma variável exceder o intervalo de -1.073.741.824 a 1.073.741.823, o programa será interrompido e o Edison tocará um tom de falha.",
	"HELP_TEXT_VARIABLE_EXAMPLE_1_TITLE" : "Programa de exemplo 1: Uma taxa de flash aleatória definida no início do programa",
	"HELP_TEXT_VARIABLE_EXAMPLE_1_BODY_1" : "Nesse programa de exemplo, a variável ''FlashRate'' é definida como um número aleatório entre 10 e 100. Em seguida, o programa entra em um loop infinito. Dentro do loop, os LEDs esquerdo e direito são ligados e, em seguida, o programa aguarda o valor de milissegundos em ''FlashRate'', depois desliga os LEDs esquerdo e direito e, em seguida, o programa aguarda novamente o valor de milissegundos em ''FlashRate''. Em seguida, o programa volta ao início do loop infinito e se repete. Isso faz com que o Edison pisque seus LEDs em velocidades diferentes cada vez que o programa é executado",
	"HELP_TEXT_VARIABLE_EXAMPLE_2_TITLE" : "Programa de exemplo 2: Contagem de linhas pretas percorridas",
	"HELP_TEXT_VARIABLE_EXAMPLE_2_BODY_1" : "Nesse programa de exemplo, o LED do rastreador de linha é ligado primeiro e, em seguida, o robô Edison avança 30 cm na velocidade 5. Enquanto avança, qualquer superfície não reflexiva (preta) detectada pelo rastreador de linha acionará o programa para saltar para o bloco de eventos Rastreador de linha em superfície não reflexiva. Quando isso acontece, a variável 'LineCount' é incrementada (+1). Quando o percurso de 30 cm tiver sido concluído, o programa repetirá os blocos de espera de 1 segundo e de bipe pelo número de vezes indicado na variável 'LineCount'.",
	"HELP_TEXT_VARIABLE_EXAMPLE_3_TITLE" : "Programa de exemplo 3: Contador de radiação luminosa",
	"HELP_TEXT_VARIABLE_EXAMPLE_3_BODY_1" : "Nesse programa de exemplo, o andamento da música é primeiro definido como muito rápido. Em seguida, o programa entra em um loop infinito. Dentro do loop, o programa define a variável ''Delay'' como 1000 menos o nível de luz esquerdo (invertendo a leitura do nível de luz). O próximo bloco aguarda o valor na variável ''Delay''. Em seguida, o programa toca a nota Dó, volta ao início do loop infinito e repete. O resultado desse programa é que o Edison emitirá um bipe lento quando estiver no escuro e mais rápido quando o nível de luz estiver mais claro.",
	"HELP_TEXT_DATA_SETVARIABLETO_TITLE" : "set to",
	"HELP_TEXT_DATA_SETVARIABLETO_BODY_1" : "O bloco set to é usado para definir um valor em uma variável.",
	"HELP_TEXT_DATA_SETVARIABLETO_BODY_2" : "Há duas entradas:",
	"HELP_TEXT_DATA_SETVARIABLETO_BODY_3" : "Variável - É onde o bloco de variável é colocado.",
	"HELP_TEXT_DATA_SETVARIABLETO_BODY_4" : "Valor - Pode ser uma constante (digitada na entrada e não varia), uma variável, um sensor ou um bloco de operador.",
	"HELP_TEXT_DATA_SETVARIABLETO_EXAMPLE_1_TITLE" : "Programa de exemplo 1: Definir o número de bipes",
	"HELP_TEXT_DATA_SETVARIABLETO_EXAMPLE_1_BODY_1" : "Neste programa de exemplo, a variável ''NumberOfBeeps'' é definida como 5 e, em seguida, o bloco de repetição repete o bipe para o valor 5 mantido na variável ''NumberOfBeeps''.",
	"HELP_TEXT_DATA_SETVARIABLETO_EXAMPLE_2_TITLE" : "Programa de exemplo 2: uma taxa de flash aleatória definida no início do programa",
	"HELP_TEXT_DATA_SETVARIABLETO_EXAMPLE_2_BODY_1" : "Neste programa de exemplo, a variável ''FlashRate'' é definida como um número aleatório entre 10 e 1000. Em seguida, o programa entra em um loop infinito. Dentro do loop, os LEDs esquerdo e direito são ligados e, em seguida, o programa aguarda o valor de milissegundos em 'FlashRate', depois desliga os LEDs esquerdo e direito e, em seguida, o programa aguarda novamente o valor de milissegundos em 'FlashRate'. Em seguida, o programa volta ao início do loop infinito e se repete. Isso faz com que o Edison pisque seus LEDs em velocidades diferentes cada vez que o programa é executado",
	"HELP_TEXT_DATA_SETVARIABLETO_EXAMPLE_3_TITLE" : "Programa de exemplo 3: Siga a luz",
	"HELP_TEXT_DATA_SETVARIABLETO_EXAMPLE_3_BODY_1" : "Neste exemplo, o programa começa entrando em um loop infinito. Dentro do loop, o programa define a variável ''LightLeftvsRight'' como o nível de luz esquerda menos o nível de luz direita. O bloco if else testa se o valor na variável 'LightLeftvsRight' é maior que 0. Se o resultado for verdadeiro, o motor direito é configurado para avançar e o motor esquerdo é parado. Se o resultado for falso, o motor esquerdo será ajustado para avançar e o motor direito será parado. Em seguida, o programa volta ao início do loop infinito e se repete. O resultado é que o Edison dirige em direção à fonte de luz mais brilhante.",
	"HELP_TEXT_DATA_INCVARIABLE_TITLE" : "incrementar",
	"HELP_TEXT_DATA_INCVARIABLE_BODY_1" : "O bloco de incremento incrementa (adiciona 1) à variável colocada no bloco.",
	"HELP_TEXT_DATA_INCVARIABLE_EXAMPLE_1_TITLE" : "Programa de exemplo 1: Desaceleração do piscar",
	"HELP_TEXT_DATA_INCVARIABLE_EXAMPLE_1_BODY_1" : "Nesse programa de exemplo, a variável 'Delay' é definida como 0 e o programa entra em um loop infinito. Dentro do loop, a variável ''Delay'' é incrementada (+1), o LED direito é ligado e o LED esquerdo é desligado, o programa aguarda o valor da variável ''Delay'' em milissegundos, o LED direito é desligado e o LED esquerdo é ligado e, novamente, o programa aguarda o valor da variável ''Delay'' em milissegundos. Em seguida, o programa volta ao início do loop infinito e se repete. À medida que o programa se repete no loop infinito, a variável 'Delay' é incrementada a cada vez, fazendo com que o tempo que os LEDs passam ligados e desligados seja cada vez maior. Após 1.000 loops, o tempo em que os LEDs ficam acesos é de um segundo e o tempo em que os LEDs ficam apagados é de um segundo.",
	"HELP_TEXT_DATA_DECVARIABLE_TITLE" : "decremento",
	"HELP_TEXT_DATA_DECVARIABLE_BODY_1" : "O bloco de decremento decrementa (menos 1) a variável colocada no bloco.",
	"HELP_TEXT_DATA_DECVARIABLE_EXAMPLE_1_TITLE" : "Programa de exemplo 1: Aceleração da intermitência",
	"HELP_TEXT_DATA_DECVARIABLE_EXAMPLE_1_BODY_1" : "Nesse programa de exemplo, a variável 'Delay' é definida como 100 e o programa entra em um loop infinito. Dentro do loop, a variável ''Delay'' é decrementada (-1), o LED direito é ligado e o LED esquerdo é desligado, o programa aguarda o valor da variável ''Delay'' em milissegundos, o LED direito é desligado e o LED esquerdo é ligado e, novamente, o programa aguarda o valor da variável ''Delay'' em milissegundos. Em seguida, o programa volta ao início do loop infinito e se repete. À medida que o programa se repete no loop infinito, a variável 'Delay' é decrementada a cada vez, diminuindo o tempo que os LEDs passam ligados e desligados. Após 100 loops, o tempo em que os LEDs ficam acesos é de um milissegundo e o tempo em que os LEDs ficam apagados é de um milissegundo.",
	"HELP_TEXT_BIT_SHIFT_RIGHT_TITLE" : "deslocamento de bit para a direita",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_1" : "O deslocamento de bits à direita por bloco ajusta matematicamente o bloco de variáveis conectado em sua forma binária, deslocando os bits à direita pelo valor definido.",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_2" : "O formato numérico que os computadores usam é chamado de binário. É um sistema numérico composto apenas pelos números 0 e 1. Cada número em um computador é uma sequência de 1s e 0s. Aqui estão alguns exemplos de números binários com 8 bits de comprimento:",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_HUMAN" : "Humano/decimal",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_COMPUTER" : "Computador/binário de 8 bits",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_3" : "Aqui estão alguns exemplos de números binários com 32 bits de comprimento:",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_4" : "O Edison V3 usa números binários de 8 e 32 bits. Por exemplo, os blocos variáveis são capazes de armazenar números grandes de 32 bits (na verdade, 31 bits assinados), mas somente números de 8 bits podem ser enviados por meio do bloco de mensagens send IR. Além disso, alguns sensores, como os sensores de luz, têm um intervalo de 1 a 1000. Como o número de 8 bits mais alto possível é 255, o intervalo completo da leitura do sensor de luz não pode ser enviado por meio do bloco de mensagem IR de envio. É nesse ponto que o bloco de deslocamento de bits à direita pode ajudar!",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_5" : "A leitura do sensor de luz é binária de 10 bits. Aqui estão os valores mínimo e máximo:",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_6" : "Se o número 1000 fosse enviado com o bloco de mensagens IR send, o número recebido seria apenas os últimos 8 bits. Isso seria 11111010 (binário) ou 232 (humano/decimal). Esse é um número muito diferente da leitura real de luz de 1000.",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_7" : "Para enviar os dados de nível de luz por meio do bloco de mensagens IR, o bloco de deslocamento de bits para a direita pode ser usado para encurtar o número em um número de 8 bits (deslocamento para a direita em 2) sem perder muito dos dados. Em seguida, na extremidade receptora, o bloco de deslocamento de bit à esquerda pode ser usado para restaurar a leitura do nível de luz de volta para 10 bits (deslocamento à esquerda por 2).",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_4_LINE_1_BOX_1" : "Estágio",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_4_LINE_2_BOX_1" : "Leitura de luz",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_4_LINE_3_BOX_1" : "Deslocamento de bit para a direita (2)",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_4_LINE_4_BOX_1" : "Envio/recebimento de dados de IR",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_4_LINE_5_BOX_1" : "Deslocamento de bit à esquerda (2)",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_BIT" : "bit",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_8" : "Nesse cenário, o número resultante não é exatamente o mesmo, pois algumas informações foram perdidas. Entretanto, os bits mais significativos, que contêm mais de 99% dos dados originais, foram mantidos por meio desse processo.",
	"HELP_TEXT_BIT_SHIFT_LEFT_TITLE" : "deslocamento de bits à esquerda",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_1" : "O deslocamento de bits à esquerda por bloco ajusta matematicamente o bloco de variáveis conectado em sua forma binária, deslocando os bits à esquerda pelo valor definido.",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_2" : "O formato numérico que os computadores usam é chamado de binário. É um sistema numérico composto apenas pelos números 0 e 1. Cada número em um computador é uma sequência de 1s e 0s. Aqui estão alguns exemplos de números binários com 8 bits de comprimento:",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_HUMAN" : "Humano/decimal",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_COMPUTER" : "Computador/binário de 8 bits",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_3" : "Aqui estão alguns exemplos de números binários com 32 bits de comprimento:",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_4" : "O Edison V3 usa números binários de 8 e 32 bits. Por exemplo, os blocos variáveis são capazes de armazenar números grandes de 32 bits (na verdade, 31 bits assinados), mas somente números de 8 bits podem ser enviados por meio do bloco de mensagens send IR. Além disso, alguns sensores, como os sensores de luz, têm um intervalo de 1 a 1000. Como o número de 8 bits mais alto possível é 255, o intervalo completo da leitura do sensor de luz não pode ser enviado por meio do bloco de mensagem IR de envio. É nesse ponto que o bloco de deslocamento de bits à direita pode ajudar!",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_5" : "A leitura do sensor de luz é binária de 10 bits. Aqui estão os valores mínimo e máximo:",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_6" : "Se o número 1000 fosse enviado com o bloco de mensagens IR send, o número recebido seria apenas os últimos 8 bits. Isso seria 11111010 (binário) ou 232 (humano/decimal). Esse é um número muito diferente da leitura real de luz de 1000.",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_7" : "Para enviar os dados de nível de luz por meio do bloco de mensagens IR, o bloco de deslocamento de bits para a direita pode ser usado para encurtar o número em um número de 8 bits (deslocamento para a direita em 2) sem perder muito dos dados. Em seguida, na extremidade receptora, o bloco de deslocamento de bit à esquerda pode ser usado para restaurar a leitura do nível de luz de volta para 10 bits (deslocamento à esquerda por 2).",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_4_LINE_1_BOX_1" : "Estágio",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_4_LINE_2_BOX_1" : "Leitura de luz",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_4_LINE_3_BOX_1" : "Deslocamento de bit para a direita (2)",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_4_LINE_4_BOX_1" : "Envio/recebimento de dados de IR",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_4_LINE_5_BOX_1" : "Deslocamento de bit à esquerda (2)",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_BIT" : "bit",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_8" : "Nesse cenário, o número resultante não é exatamente o mesmo, pois algumas informações foram perdidas. Entretanto, os bits mais significativos, que contêm mais de 99% dos dados originais, foram mantidos por meio desse processo.",
	"HELP_TEXT_EVENT_ANYOBSTACLE_TITLE" : "Qualquer obstáculo detectado",
	"HELP_TEXT_EVENT_ANYOBSTACLE_BODY_1" : "O bloco de eventos Qualquer obstáculo detectado faz com que o programa salte para esse bloco quando qualquer obstáculo for detectado pelo detector de obstáculos.",
	"HELP_TEXT_EVENT_ANYOBSTACLE_BODY_2" : "Certifique-se sempre de que o feixe do detector de obstáculos esteja ligado no programa principal.",
	"HELP_TEXT_EVENT_ANYOBSTACLE_EXAMPLE_1_TITLE" : "Programa de exemplo 1: Emite um bipe quando um obstáculo é detectado.",
	"HELP_TEXT_EVENT_ANYOBSTACLE_EXAMPLE_1_BODY_1" : "Nesse programa de exemplo, o detector de obstáculos é ligado primeiro e, em seguida, o programa entra no bloco de loop infinito. Quando algum obstáculo é detectado, o programa sai do loop infinito e vai para o bloco de eventos Qualquer obstáculo detectado. Isso faz com que o bloco de bipes seja executado e o robô Edison emite um bip. Em seguida, o programa retorna ao ponto de partida no programa principal.",
	"HELP_TEXT_EVENT_ANYOBSTACLE_EXAMPLE_2_TITLE" : "Programa de exemplo 2: parar de dirigir quando houver um obstáculo",
	"HELP_TEXT_EVENT_ANYOBSTACLE_EXAMPLE_2_BODY_1" : "Nesse programa de exemplo, o detector de obstáculos é ligado primeiro e, em seguida, os dois motores são configurados para dirigir para a frente na velocidade 5. Quando algum obstáculo é detectado, o programa sai do loop infinito e vai para o bloco de eventos Qualquer obstáculo detectado. Isso faz com que o bloco de parada de ambos os motores seja executado e interrompe o funcionamento dos dois motores. Em seguida, o programa retorna ao ponto de partida no programa principal.",
	"HELP_TEXT_EVENT_ANYOBSTACLE_EXAMPLE_3_TITLE" : "Programa de exemplo 3: Evitar obstáculos",
	"HELP_TEXT_EVENT_ANYOBSTACLE_EXAMPLE_3_BODY_1" : "Nesse programa de exemplo, o detector de obstáculos é ativado primeiro e, em seguida, o programa entra em um loop infinito; dentro do loop, os dois motores são configurados para avançar na velocidade 5. Quando algum obstáculo é detectado, o programa sai do loop infinito e vai para o bloco de evento Qualquer obstáculo detectado. Os blocos sob o bloco de eventos Qualquer obstáculo detectado fazem o Edison retroceder 1 cm na velocidade 1 e, em seguida, girar 120 graus para a esquerda na velocidade 1. O programa retorna ao ponto em que parou no loop infinito e ambos os motores são configurados para avançar na velocidade 5 novamente. Isso faz com que o Edison se afaste dos obstáculos em seu caminho.",
	"HELP_TEXT_OBSTACLE_LEFT_EVENT_TITLE" : "Obstáculo detectado à esquerda",
	"HELP_TEXT_OBSTACLE_LEFT_EVENT_BODY_1" : "O bloco de eventos Obstacle detected left (Obstáculo detectado à esquerda) faz com que o programa salte para esse bloco quando um obstáculo é detectado à esquerda pelo detector de obstáculos.",
	"HELP_TEXT_OBSTACLE_LEFT_EVENT_BODY_2" : "Certifique-se sempre de que o feixe do detector de obstáculos esteja ligado no programa principal.",
	"HELP_TEXT_OBSTACLE_LEFT_EVENT_EXAMPLE_1_TITLE" : "Programa de exemplo 1: emitir um bipe quando um obstáculo é detectado à esquerda",
	"HELP_TEXT_OBSTACLE_LEFT_EVENT_EXAMPLE_1_BODY_1" : "Nesse programa de exemplo, o detector de obstáculos é ligado primeiro e, em seguida, o programa entra no bloco de loop para sempre. Quando um obstáculo é detectado à esquerda, o programa sai do loop infinito e vai para o bloco de eventos Obstacle detected left (Obstáculo detectado à esquerda). Isso faz com que o bloco de bipes seja executado e o robô Edison emite um bip. Em seguida, o programa retorna ao ponto de partida no bloco do loop infinito.",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_TITLE" : "Obstáculo detectado à direita",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_BODY_1" : "O bloco de eventos Obstacle detected right (Obstáculo detectado à direita) faz com que o programa pule para esse bloco quando um obstáculo é detectado à direita pelo detector de obstáculos.",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_BODY_2" : "Certifique-se sempre de que o feixe do detector de obstáculos esteja ligado no programa principal.",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_1_TITLE" : "Programa de exemplo 1: emitir um bipe quando um obstáculo é detectado à direita",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_1_BODY_1" : "Nesse programa de exemplo, o detector de obstáculos é ligado primeiro e, em seguida, o programa entra no bloco de loop para sempre. Quando um obstáculo é detectado à direita, o programa sai do loop infinito e vai para o bloco de eventos Obstacle detected right (Obstáculo detectado à direita). Isso faz com que o bloco de bipes seja executado e o robô Edison emite um bip. Em seguida, o programa retorna ao ponto de partida no bloco do loop infinito.",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_2_TITLE" : "Programa de exemplo 2: evasão de obstáculos",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_2_BODY_1" : "Nesse programa de exemplo, o detector de obstáculos é ativado primeiro e, em seguida, o programa entra no bloco de loop infinito. Quando...",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_2_BODY_2" : "...um obstáculo é detectado à frente, o programa salta para o bloco de eventos Obstáculo detectado à frente e o robô Edison retrocede por 0,25 segundo na velocidade 10 e, em seguida, retorna ao ponto de partida no bloco de loop infinito.",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_2_BODY_3" : "...um obstáculo é detectado à direita, o programa salta para o bloco de eventos Obstáculo detectado à direita e o robô Edison vira à esquerda para trás por 0,25 segundos na velocidade 10 e, em seguida, retorna ao ponto de partida no bloco de loop permanente.",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_2_BODY_4" : "...um obstáculo é detectado à esquerda, o programa salta para o bloco de eventos Obstacle detected left (Obstáculo detectado à esquerda) e o robô Edison vira à direita para trás por 0,25 segundos na velocidade 10 e, em seguida, retorna ao ponto de partida no bloco de loop permanente.",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_TITLE" : "Obstáculo detectado à frente",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_BODY_1" : "O bloco de eventos Obstacle detected ahead (Obstáculo detectado à frente) faz com que o programa pule para esse bloco quando um obstáculo é detectado à frente pelo detector de obstáculos. Isso significa que, ao mesmo tempo, os detectores de obstáculos esquerdo e direito detectaram um obstáculo.",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_BODY_2" : "Certifique-se sempre de que o feixe do detector de obstáculos esteja ligado no programa principal.",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_1_TITLE" : "Programa de exemplo 1: Emite um bipe quando um obstáculo é detectado à frente",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_1_BODY_1" : "Nesse programa de exemplo, o detector de obstáculos é ligado primeiro e, em seguida, o programa entra no bloco de loop para sempre. Quando um obstáculo é detectado à direita, o programa sai do loop infinito e vai para o bloco de eventos Obstacle detected right (Obstáculo detectado à direita). Isso faz com que o bloco de bipes seja executado e o robô Edison emite um bip. Em seguida, o programa retorna ao ponto de partida no bloco do loop infinito.",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_2_TITLE" : "Programa de exemplo 2: O evadidor de obstáculos",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_2_BODY_1" : "Nesse programa de exemplo, o detector de obstáculos é ativado primeiro e, em seguida, o programa entra no bloco de loop infinito. Quando...",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_2_BODY_2" : "...um obstáculo é detectado à frente, o programa salta para o bloco de eventos Obstáculo detectado à frente e o robô Edison retrocede por 0,25 segundo na velocidade 10 e, em seguida, retorna ao ponto de partida no bloco de loop infinito.",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_2_BODY_3" : "...um obstáculo é detectado à direita, o programa salta para o bloco de eventos Obstáculo detectado à direita e o robô Edison vira à esquerda para trás por 0,25 segundos na velocidade 10 e, em seguida, retorna ao ponto de partida no bloco de loop permanente.",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_2_BODY_4" : "...um obstáculo é detectado à esquerda, o programa salta para o bloco de eventos Obstacle detected left (Obstáculo detectado à esquerda) e o robô Edison vira à direita para trás por 0,25 segundos na velocidade 10 e, em seguida, retorna ao ponto de partida no bloco de loop permanente.",
	"HELP_TEXT_CLAP_EVENT_TITLE" : "Palmas detectadas",
	"HELP_TEXT_CLAP_EVENT_BODY_1" : "O bloco de eventos Clap detected faz com que o programa pule para esse bloco quando um clap é detectado.",
	"HELP_TEXT_CLAP_EVENT_BODY_2" : "Quando o Edison está dirigindo, o ruído do motor e os choques fazem com que o sensor de palmas seja acionado, portanto, é melhor não usar o sensor de palmas ao dirigir. Além disso, se houver probabilidade de haver detecções de ruído falsas ou indesejadas, os dados do sensor de palmas podem ser apagados com o bloco de dados do sensor clear definido como detector de palmas (veja o programa de exemplo).",
	"HELP_TEXT_CLAP_EVENT_EXAMPLE_1_TITLE" : "Programa de exemplo: Edison tem medo de ruídos altos",
	"HELP_TEXT_CLAP_EVENT_EXAMPLE_1_BODY_1" : "Nesse exemplo, o programa começa entrando em um loop infinito vazio e nada acontece. Quando uma batida de palmas (ou outro som alto e assustador) é detectada, o programa sai do loop infinito e vai para o bloco de eventos Clap detected. Os blocos abaixo do bloco de evento Clap detected são executados, retrocedendo 5 cm a uma velocidade de 10 (pulo de susto) e, em seguida, entram em um loop de repetição definido para 25 vezes, em que os blocos spin left e spin right são executados repetidamente, fazendo com que o Edison vibre (trema de susto). Por fim, (quando o Edison se recupera do susto), o bloco de dados do sensor limpa todas as detecções de palmas falsas que possam ter ocorrido durante a condução. O programa agora retorna ao loop infinito.",
	"HELP_TEXT_TRIANGLEBUTTON_EVENT_TITLE" : "Botão triangular pressionado",
	"HELP_TEXT_TRIANGLEBUTTON_EVENT_BODY_1" : "O bloco de eventos Triangle button pressed faz com que o programa pule para esse bloco quando o botão triangular for pressionado.",
	"HELP_TEXT_TRIANGLEBUTTON_EVENT_EXAMPLE_1_TITLE" : "Programa de exemplo: Controle da configuração da velocidade do flash do LED com botões",
	"HELP_TEXT_TRIANGLEBUTTON_EVENT_EXAMPLE_1_BODY_1" : "Neste exemplo, o programa começa definindo a variável chamada 'Delay' como 100 e, em seguida, entra em um loop infinito. Dentro do loop infinito, os LEDs esquerdo e direito são ligados e desligados com uma espera pelo valor da variável ''Delay'' em milissegundos. Isso faz com que os LEDs fiquem acesos por 100 milissegundos (0,1 segundo) e apagados por 100 milissegundos (0,1 segundo).",
	"HELP_TEXT_TRIANGLEBUTTON_EVENT_EXAMPLE_1_BODY_2" : "Quando o botão triangular é pressionado, o programa salta para o bloco de eventos Triangle button pressed (Botão triangular pressionado). Os blocos abaixo do bloco de eventos do botão Triângulo pressionado são executados, definindo a variável chamada 'Delay' como 50 e, em seguida, emitindo um bipe. O programa retorna ao loop infinito, mas agora o valor da variável chamada ''Delay'' é 50, de modo que o tempo entre o acendimento e o apagamento dos LEDs é agora de 50 milissegundos (0,05 segundo). Isso faz com que eles liguem e desliguem mais rapidamente.",
	"HELP_TEXT_TRIANGLEBUTTON_EVENT_EXAMPLE_1_BODY_3" : "Quando o botão redondo é pressionado, o programa salta para o bloco de evento Round button pressed (Botão redondo pressionado). Os blocos abaixo do bloco de evento Botão redondo pressionado são executados, definindo a variável chamada 'Delay' como 200 e, em seguida, emitindo um bipe. O programa retorna ao loop infinito, mas agora o valor da variável chamada ''Delay'' é 200, portanto, o tempo entre o acendimento e o apagamento dos LEDs agora é de 200 milissegundos (0,2 segundo). Isso faz com que eles liguem e desliguem mais lentamente.",
	"HELP_TEXT_ROUNDBUTTON_EVENT_TITLE" : "Botão redondo pressionado",
	"HELP_TEXT_ROUNDBUTTON_EVENT_BODY_1" : "O bloco de eventos Botão redondo pressionado faz com que o programa pule para esse bloco quando o botão redondo é pressionado.",
	"HELP_TEXT_ROUNDBUTTON_EVENT_EXAMPLE_1_TITLE" : "Programa de exemplo: Controle da configuração da velocidade do flash do LED com botões",
	"HELP_TEXT_ROUNDBUTTON_EVENT_EXAMPLE_1_BODY_1" : "Neste exemplo, o programa começa definindo a variável chamada 'Delay' como 100 e, em seguida, entra em um loop infinito. Dentro do loop infinito, os LEDs esquerdo e direito são ligados e desligados com uma espera pelo valor da variável ''Delay'' em milissegundos. Isso faz com que os LEDs fiquem acesos por 100 milissegundos (0,1 segundo) e apagados por 100 milissegundos (0,1 segundo).",
	"HELP_TEXT_ROUNDBUTTON_EVENT_EXAMPLE_1_BODY_2" : "Quando o botão triangular é pressionado, o programa salta para o bloco de eventos Triangle button pressed (Botão triangular pressionado). Os blocos abaixo do bloco de eventos do botão Triângulo pressionado são executados, definindo a variável chamada 'Delay' como 50 e, em seguida, emitindo um bipe. O programa retorna ao loop infinito, mas agora o valor da variável chamada ''Delay'' é 50, de modo que o tempo entre o acendimento e o apagamento dos LEDs é agora de 50 milissegundos (0,05 segundo). Isso faz com que eles liguem e desliguem mais rapidamente.",
	"HELP_TEXT_ROUNDBUTTON_EVENT_EXAMPLE_1_BODY_3" : "Quando o botão redondo é pressionado, o programa salta para o bloco de evento Round button pressed (Botão redondo pressionado). Os blocos abaixo do bloco de evento Botão redondo pressionado são executados, definindo a variável chamada 'Delay' como 200 e, em seguida, emitindo um bipe. O programa retorna ao loop infinito, mas agora o valor da variável chamada ''Delay'' é 200, portanto, o tempo entre o acendimento e o apagamento dos LEDs agora é de 200 milissegundos (0,2 segundo). Isso faz com que eles liguem e desliguem mais lentamente.",
	"HELP_TEXT_LINEREFLECTIVE_EVENT_TITLE" : "Rastreador de linha em superfície refletiva",
	"HELP_TEXT_LINEREFLECTIVE_EVENT_BODY_1" : "O bloco de eventos Rastreador de linha em superfície reflexiva faz com que o programa pule para esse bloco quando o sensor do rastreador de linha detecta uma mudança de uma superfície não reflexiva (por exemplo, preta) para uma superfície reflexiva (por exemplo, branca).",
	"HELP_TEXT_LINEREFLECTIVE_EVENT_BODY_2" : "O LED do rastreador de linha deve estar ligado para que o bloco de eventos Rastreador de linha em superfície reflexiva funcione.",
	"HELP_TEXT_LINEREFLECTIVE_EVENT_EXAMPLE_1_TITLE" : "Exemplo de programa: Seguir a borda de uma linha",
	"HELP_TEXT_LINEREFLECTIVE_EVENT_EXAMPLE_1_BODY_1" : "Neste exemplo, o programa começa ligando o LED de rastreamento de linha e, em seguida, faz com que o robô vire à direita (procurando a borda de uma linha).",
	"HELP_TEXT_LINEREFLECTIVE_EVENT_EXAMPLE_1_BODY_2" : "Quando o rastreador de linha detecta uma mudança de uma superfície reflexiva (branca) para uma não reflexiva (preta), o programa salta para o bloco Rastreador de linha em superfície não reflexiva e executa o bloco de acionamento para fazer com que o robô vire à esquerda (voltando para a superfície reflexiva (branca)).",
	"HELP_TEXT_LINEREFLECTIVE_EVENT_EXAMPLE_1_BODY_3" : "Quando o rastreador de linha detecta uma mudança de uma superfície não reflexiva para uma reflexiva, o programa salta para o bloco de eventos Rastreador de linha em superfície reflexiva e executa o bloco de acionamento para configurar o robô para virar à direita (voltando para a superfície não reflexiva (preta)).",
	"HELP_TEXT_LINEREFLECTIVE_EVENT_EXAMPLE_1_BODY_4" : "Cada vez que o robô vira para a esquerda ou para a direita, ele avança seguindo a borda da linha.",
	"HELP_TEXT_LINENONREFLECTIVE_EVENT_TITLE" : "Rastreador de linha em superfície não reflexiva",
	"HELP_TEXT_LINENONREFLECTIVE_EVENT_BODY_1" : "O bloco de eventos Rastreador de linha em superfície não reflexiva faz com que o programa salte para esse bloco quando o sensor do rastreador de linha detecta uma mudança de uma superfície reflexiva (ou seja, branca) para uma superfície não reflexiva (ou seja, preta).",
	"HELP_TEXT_LINENONREFLECTIVE_EVENT_BODY_2" : "O LED do rastreador de linha deve estar ligado para que o bloco de eventos Rastreador de linha em superfície não reflexiva funcione.",
	"HELP_TEXT_LINENONREFLECTIVE_EVENT_EXAMPLE_1_TITLE" : "Exemplo de programa: Seguir a borda de uma linha",
	"HELP_TEXT_LINENONREFLECTIVE_EVENT_EXAMPLE_1_BODY_1" : "Neste exemplo, o programa começa ligando o LED de rastreamento de linha e, em seguida, faz com que o robô vire à direita (procurando a borda de uma linha).",
	"HELP_TEXT_LINENONREFLECTIVE_EVENT_EXAMPLE_1_BODY_2" : "Quando o rastreador de linha detecta uma mudança de uma superfície reflexiva (branca) para uma não reflexiva (preta), o programa salta para o bloco Rastreador de linha em superfície não reflexiva e executa o bloco de acionamento para fazer com que o robô vire à esquerda (voltando para a superfície reflexiva (branca)).",
	"HELP_TEXT_LINENONREFLECTIVE_EVENT_EXAMPLE_1_BODY_3" : "Quando o rastreador de linha detecta uma mudança de uma superfície não reflexiva para uma reflexiva, o programa salta para o bloco Rastreador de linha em superfície reflexiva e executa o bloco de acionamento para configurar o robô para virar à direita (voltando para a superfície não reflexiva (preta)).",
	"HELP_TEXT_LINENONREFLECTIVE_EVENT_EXAMPLE_1_BODY_4" : "Cada vez que o robô vira para a esquerda ou para a direita, ele avança seguindo a borda da linha.",
	"HELP_TEXT_LINECHANGE_EVENT_TITLE" : "O rastreador de linha muda de superfície",
	"HELP_TEXT_LINECHANGE_EVENT_BODY_1" : "O bloco de eventos Line tracker changes surface faz com que o programa salte para esse bloco quando o sensor do line tracker detecta uma mudança de uma superfície não reflexiva (ou seja, preta) para uma superfície reflexiva (ou seja, branca) ou de uma superfície reflexiva (ou seja, branca) para uma superfície não reflexiva (ou seja, preta).",
	"HELP_TEXT_LINECHANGE_EVENT_BODY_2" : "O LED do rastreador de linha deve estar ligado para que o bloco de eventos Line tracker changes surface funcione.",
	"HELP_TEXT_LINECHANGE_EVENT_EXAMPLE_1_TITLE" : "Programa de exemplo: Parada para mudança",
	"HELP_TEXT_LINECHANGE_EVENT_EXAMPLE_1_BODY_1" : "Neste exemplo, o programa começa com a ativação do LED do rastreador de linha, o robô segue em frente na velocidade 1 e entra em um loop infinito. O robô continuará a avançar até que o sensor do rastreador de linha detecte uma mudança na refletividade da superfície (branco para preto ou preto para branco). Quando isso acontece, o programa salta para o bloco Line tracker changes surface (O rastreador de linha muda a superfície). O código abaixo do rastreador de linha altera a superfície e é executado, parando os dois motores, emitindo um bipe, aguardando um segundo, emitindo um bipe novamente e, em seguida, configurando os dois motores para avançar novamente.",
	"HELP_TEXT_MESSAGE_EVENT_TITLE" : "Mensagem IR recebida",
	"HELP_TEXT_MESSAGE_EVENT_BODY_1" : "O bloco de eventos IR message received faz com que o programa pule para esse bloco quando uma mensagem de infravermelho (IR) de outro robô Edison for recebida.",
	"HELP_TEXT_MESSAGE_EVENT_BODY_3" : "O bloco de eventos de mensagem IR recebida não funcionará quando o receptor IR estiver sendo usado para detectar obstáculos.",
	"HELP_TEXT_MESSAGE_EVENT_BODY_4" : "O programa saltará para o bloco de eventos de mensagem IR recebida quando qualquer mensagem IR for recebida de outro robô Edison. O bloco de eventos de mensagem IR recebida não decodifica os dados da mensagem IR. A decodificação da mensagem exige que os dados da mensagem sejam colocados em uma variável e, em seguida, decodificados usando um bloco if then.",
	"HELP_TEXT_MESSAGE_EVENT_EXAMPLE_1_TITLE" : "Programa de exemplo: Receber mensagem IR para emitir um ou dois bipes",
	"HELP_TEXT_MESSAGE_EVENT_EXAMPLE_1_BODY_1" : "Neste exemplo, o programa começa entrando em um loop infinito vazio e nada acontece. Quando uma mensagem IR é recebida, o programa salta para o bloco de eventos de mensagem IR recebida. O código abaixo do bloco de eventos de mensagem IR recebida é executado. Primeiro, os dados da mensagem recebida são armazenados na variável 'ReceivedMessage'. Isso é necessário porque toda vez que os dados da mensagem IR recebida são lidos, eles também são apagados. Agora que os dados da mensagem estão em uma variável, ela é testada se é igual a 1; se for verdadeira, o bloco de bipes é reproduzido uma vez. Em seguida, a variável é testada se for igual a 2; se for verdadeira, o bloco de bipes será reproduzido duas vezes. O programa agora retorna ao loop infinito.",
	"HELP_TEXT_MESSAGE_EVENT_EXAMPLE_2_TITLE" : "Programa de envio de mensagem IR:",
	"HELP_TEXT_MESSAGE_EVENT_EXAMPLE_2_BODY_1" : "O programa acima é usado no robô Edison que está enviando a mensagem IR. O programa primeiro entra em um loop infinito vazio. Quando o botão triangular é pressionado, o programa salta para o bloco de eventos Triangle button pressed (Botão triangular pressionado) e uma mensagem IR é enviada com o número 1. Quando o botão redondo é pressionado, o programa salta para o bloco de eventos Botão redondo pressionado e uma mensagem IR é enviada com o número 2.",
	"HELP_TEXT_DRIVESTRAIN_EVENT_TITLE" : "Acionamento tensionado",
	"HELP_TEXT_DRIVESTRAIN_EVENT_BODY_1" : "O bloco de eventos Drive strained faz com que o programa pule para esse bloco quando um ou ambos os motores estiverem sendo acionados, mas não puderem girar (sob tensão).",
	"HELP_TEXT_DRIVESTRAIN_EVENT_EXAMPLE_1_TITLE" : "Exemplo de programa: Alarme quando a roda esquerda não pode girar",
	"HELP_TEXT_DRIVESTRAIN_EVENT_EXAMPLE_1_BODY_1" : "Neste exemplo, o programa começa configurando o motor esquerdo para dirigir para a frente e, em seguida, entra em um loop infinito. Quando a roda não pode girar por estar sob tensão, o programa salta para o bloco de eventos Drive strained e executa o código abaixo. O código abaixo do bloco de eventos Drive strained é o bloco beep, que emite um bipe. Em seguida, o programa retorna ao loop infinito.",
	"HELP_TEXT_REMOTE_EVENT_TITLE" : "Código remoto recebido",
	"HELP_TEXT_REMOTE_EVENT_BODY_1" : "O bloco de eventos Remote code received faz com que o programa pule para esse bloco quando um código de controle remoto é recebido.",
	"HELP_TEXT_REMOTE_EVENT_BODY_3" : "Certifique-se de pressionar o botão triangular para iniciar o programa. Isso é fácil de esquecer, pois o robô Edison responderá como um robô de controle remoto e não fará o que você programou.",
	"HELP_TEXT_REMOTE_EVENT_BODY_4" : "Para usar os blocos de controle remoto, o robô Edison deve primeiro aprender quais botões do seu controle remoto correspondem a qual código remoto. Saiba mais sobre isso aqui:",
	"HELP_TEXT_REMOTE_EVENT_BODY_5" : "Se o programa se comportar de forma não esperada, talvez seja necessário usar o bloco de dados do sensor para limpar o conteúdo do bloco de código remoto recebido. Veja o programa de exemplo 1 abaixo.",
	"HELP_TEXT_REMOTE_EVENT_BODY_6" : "A recepção de códigos remotos de infravermelho funcionará com aproximadamente 90% dos controles remotos de TV padrão, mas cada marca usa formatos de dados ligeiramente diferentes. Ao decodificar dados, isso pode causar algum comportamento inesperado de uma marca de controle remoto para outra. A decodificação avançada de controles remotos funciona melhor com o EdRemote (disponível em meados de 2025).",
	"HELP_TEXT_REMOTE_EVENT_EXAMPLE_1_TITLE" : "Programa de exemplo: Controle remoto para frente ou para trás",
	"HELP_TEXT_REMOTE_EVENT_EXAMPLE_1_BODY" : "Neste exemplo, o programa começa entrando em um loop infinito vazio. Quando um código de controle remoto é recebido, o programa salta para o bloco de eventos Remote code received (Código remoto recebido). O código abaixo do bloco de eventos Código remoto recebido é executado, o código remoto é testado para ver se é igual a 1; se for verdadeiro, os dois motores são configurados para dirigir para frente, e isso continua até que o código recebido não seja mais igual a 1. Em seguida, o código recebido é testado para ver se é igual a 2; se for verdadeiro, os dois motores são ajustados para dirigir para trás. Isso continua até que o código que está sendo recebido não seja mais igual a 2. Por fim, depois que os códigos remotos tiverem sido testados e não estiverem mais sendo recebidos, o bloco de parada interrompe os dois motores. O programa retorna ao loop infinito vazio.",
	"HELP_TEXT_CONTROL_WAIT_TITLE" : "Wait sec",
	"HELP_TEXT_CONTROL_WAIT_BODY_1" : "O bloco wait sec pausa o programa por um período de tempo em segundos. O tempo pode variar de 0,001 segundo (1 milissegundo) a 1.073.741 segundos (12,4 dias).",
	"HELP_TEXT_CONTROL_WAIT_BODY_2" : "O bloco wait tem apenas um parâmetro:",
	"HELP_TEXT_CONTROL_WAIT_BODY_3" : "Valor - Pode ser uma constante (digitada na entrada e não varia), uma variável, um sensor ou um bloco de operador.",
	"HELP_TEXT_CONTROL_WAIT_EXAMPLE_1_TITLE" : "Programa de exemplo 1: piscar o LED esquerdo",
	"HELP_TEXT_CONTROL_WAIT_EXAMPLE_1_BODY" : "Neste exemplo, o programa começa entrando em um loop infinito. Dentro do loop, o LED esquerdo é ligado, o programa faz uma pausa e aguarda 0,5 segundo, o LED esquerdo é desligado, o programa faz uma nova pausa e aguarda 0,5 segundo e volta ao início.",
	"HELP_TEXT_CONTROL_WAIT_EXAMPLE_2_TITLE" : "Programa de exemplo 2: críquete noturno do robô",
	"HELP_TEXT_CONTROL_WAIT_EXAMPLE_2_BODY" : "Nesse exemplo, o programa começa entrando em um loop infinito. Dentro do loop, há um bloco wait until que pausa a progressão do programa até que o nível de luz no sensor de luz esquerdo seja menor que 100. Quando isso acontece, o programa avança para esperar por um número aleatório de segundos entre 20 e 300. Quando essa espera termina, o alto-falante toca uma nota. Em seguida, o programa volta ao início do loop infinito. Isso resulta em um comportamento semelhante ao de um grilo à noite, de modo que ele não pode ser encontrado.",
	"HELP_TEXT_CONTROL_REPEAT_TITLE" : "Repetição",
	"HELP_TEXT_CONTROL_REPEAT_BODY_1" : "O bloco de repetição é um tipo de loop que faz um loop apenas um número definido de vezes. Todos os blocos dentro do bloco de repetição são executados apenas por esse número definido de vezes.",
	"HELP_TEXT_CONTROL_REPEAT_BODY_2" : "O bloco de repetição tem apenas um parâmetro:",
	"HELP_TEXT_CONTROL_REPEAT_BODY_3" : "Valor - Pode ser uma constante (digitada na entrada e não varia), uma variável, um sensor ou um bloco de operador.",
	"HELP_TEXT_CONTROL_REPEAT_EXAMPLE_1_TITLE" : "Programa de exemplo 1: Dirigir em um quadrado",
	"HELP_TEXT_CONTROL_REPEAT_EXAMPLE_1_BODY" : "Neste exemplo, o programa começa entrando em um bloco de repetição que está definido para ser repetido quatro vezes. Dentro do bloco de repetição, o robô avança 10 cm e, em seguida, gira 90 graus para a direita. Esses dois blocos dentro do bloco de repetição são executados quatro vezes. O resultado é que o robô Edison se move na forma de um quadrado.",
	"HELP_TEXT_CONTROL_FOREVER_TITLE" : "Para sempre",
	"HELP_TEXT_CONTROL_FOREVER_BODY_1" : "O bloco para sempre é um tipo de bloco de loop que faz loop incondicionalmente para sempre (a menos que o programa seja interrompido). Os blocos colocados dentro do bloco para sempre são executados e, em seguida, executados novamente e novamente e...",
	"HELP_TEXT_CONTROL_FOREVER_EXAMPLE_1_TITLE" : "Programa de exemplo: Piscar um LED",
	"HELP_TEXT_CONTROL_FOREVER_EXAMPLE_1_BODY" : "Neste exemplo, o programa começa entrando em um loop infinito. Dentro do loop infinito, o LED esquerdo é ligado e o bloco de espera pausa o programa por 0,25 segundo; em seguida, o LED esquerdo é desligado e o bloco de espera pausa o programa por 0,25 segundo. O programa volta ao bloco de ligar o LED esquerdo e a sequência se repete para sempre.",
	"HELP_TEXT_CONTROL_IF_TITLE" : "Se então",
	"HELP_TEXT_CONTROL_IF_BODY_1" : "O bloco if then executa os blocos se a condição de entrada for verdadeira. Se a condição não for verdadeira, o programa continua para o próximo bloco do programa.",
	"HELP_TEXT_CONTROL_IF_BODY_2" : "Esse bloco tem um parâmetro de entrada:",
	"HELP_TEXT_CONTROL_IF_BODY_3" : "Entrada condicional - A entrada condicional aceita blocos em forma de diamante que podem ser um bloco de operador ou um bloco de detecção.",
	"HELP_TEXT_CONTROL_IF_BODY_4" : "O bloco if then geralmente é usado dentro de um loop infinito, de modo que a condição if then possa ser testada várias vezes. Se um programa tiver apenas um bloco if then, o teste será executado uma vez e o programa será encerrado.",
	"HELP_TEXT_CONTROL_IF_EXAMPLE_1_TITLE" : "Programa de exemplo 1: LED pisca se houver um aplauso",
	"HELP_TEXT_CONTROL_IF_EXAMPLE_1_BODY" : "esse exemplo, o programa começa entrando em um loop infinito. O primeiro bloco no loop infinito é o bloco if then que testa se houve um aplauso. Se for falso, o conteúdo do bloco if then é ignorado e o programa volta ao início do loop infinito. Se um aplauso tiver sido detectado (verdadeiro), os blocos dentro do bloco if then serão executados. Primeiro, o LED esquerdo é ligado, depois o programa faz uma pausa de um segundo e, em seguida, o LED esquerdo é desligado. O programa agora volta ao início do loop infinito. O resultado é que o robô Edison pisca seu LED esquerdo por um segundo sempre que detecta uma batida de palmas.",
	"HELP_TEXT_CONTROL_IF_EXAMPLE_2_TITLE" : "Programa de exemplo 2: desenhar alarme aberto",
	"HELP_TEXT_CONTROL_IF_EXAMPLE_2_BODY" : "Neste exemplo, o programa começa entrando em um loop infinito. O primeiro bloco no loop infinito é o bloco if then que testa se o nível de luz no sensor de luz esquerdo é maior que 100. Se isso for verdade (o nível de luz é maior que 100), o bloco beep é executado e o robô Edison emite um bipe como um alarme. Se não for verdadeiro (o nível de luz é menor que 100), o bloco de bipe é ignorado e o programa volta ao início do loop infinito. O resultado é que o Edison emite um bipe rápido sempre que detecta um nível de luz acima de 100.",
	"HELP_TEXT_CONTROL_IF_ELSE_TITLE" : "If then else",
	"HELP_TEXT_CONTROL_IF_ELSE_BODY_1" : "O bloco if then else executa o primeiro conjunto de blocos se a condição de entrada for verdadeira. Se a condição for falsa, o segundo conjunto de blocos será executado.",
	"HELP_TEXT_CONTROL_IF_ELSE_BODY_2" : "Esse bloco tem um parâmetro de entrada:",
	"HELP_TEXT_CONTROL_IF_ELSE_BODY_3" : "Entrada condicional - A entrada condicional aceita blocos em forma de diamante que podem ser um bloco de operador ou um bloco de detecção.",
	"HELP_TEXT_CONTROL_IF_ELSE_BODY_4" : "O bloco if then else geralmente é usado dentro de um loop infinito, de modo que a condição if then else possa ser testada várias vezes. Se um programa tiver apenas um bloco if then else, o teste será executado uma vez e o programa será encerrado.",
	"HELP_TEXT_CONTROL_IF_ELSE_EXAMPLE_1_TITLE" : "Programa de exemplo 1: Bounce in borders",
	"HELP_TEXT_CONTROL_IF_ELSE_EXAMPLE_1_BODY" : "Neste exemplo, o programa começa ligando o LED do sensor do rastreador de linha e, em seguida, entra em um loop infinito. O primeiro bloco no loop infinito é o bloco if then else que testa se o sensor do rastreador de linha está em uma superfície não reflexiva (preta). Se isso for verdade, o primeiro conjunto de blocos é executado, fazendo o robô retroceder e girar 90 graus. O programa pula o bloco else e, em seguida, faz um loop para testar novamente se o sensor do rastreador de linha está em uma superfície não reflexiva (preta); se isso for falso (em branco), o bloco else é executado, configurando os dois motores para avançar. Isso faz com que o robô Edison ''ricocheteie'' em uma linha preta e se vire. Isso faz com que o Edison se afaste das linhas pretas detectadas.",
	"HELP_TEXT_CONTROL_IF_ELSE_EXAMPLE_2_TITLE" : "Programa de exemplo 2: Siga a luz",
	"HELP_TEXT_CONTROL_IF_ELSE_EXAMPLE_2_BODY" : "Neste exemplo, o programa começa entrando em um loop infinito. O primeiro bloco no loop infinito é o bloco if then else que testa se o nível de luz no sensor direito é menor que o nível de luz no sensor esquerdo. Se isso for verdadeiro (a luz é mais brilhante à esquerda), o próximo bloco a ser executado é o conjunto de ambos os motores para virar o robô para a esquerda (o robô vira para a esquerda em direção à luz). Por outro lado, se o resultado for falso (a luz é mais brilhante à direita), o próximo bloco a ser executado será o bloco else. Agora, o bloco que define ambos os motores para virar o robô para a direita é executado (o robô vira na direção da luz). O resultado é que o robô Edison se dirige para a fonte de luz mais brilhante (tente usar uma lanterna para controlar para onde o Edison se dirige).",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_TITLE" : "Esperar até",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_BODY_1" : "O bloco wait until pausa o programa até que a condição de entrada seja verdadeira.",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_BODY_2" : "Esse bloco tem um parâmetro de entrada:",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_BODY_3" : "Entrada condicional - A entrada condicional aceita blocos em forma de diamante que podem ser um bloco de operador ou um bloco de detecção.",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_BODY_4" : "O bloco wait until geralmente é usado dentro de um loop infinito, de modo que a condição wait until possa ser testada várias vezes. Se um programa tiver apenas um bloco wait until, o teste será executado uma vez e o programa será encerrado.",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_EXAMPLE_1_TITLE" : "Programa de exemplo 1: LED pisca se houver um aplauso",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_EXAMPLE_1_BODY" : "Neste exemplo, o programa começa entrando em um loop infinito. O primeiro bloco no loop infinito é o bloco de dados do sensor de limpeza que limpa todos os dados de palmas falsas. Em seguida, vem o bloco wait until com um bloco de entrada condicional de clap detectado. O programa fará uma pausa aqui e aguardará até que uma batida de palmas seja detectada. Quando um aplauso é detectado, o programa avança para ligar o LED esquerdo, esperar um segundo e desligar o LED esquerdo. O programa agora volta ao bloco wait until. Cada vez que há uma batida de palmas, o LED esquerdo é ligado por um segundo. O resultado é que o robô Edison pisca seu LED esquerdo por um segundo sempre que detecta uma batida de palmas.",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_EXAMPLE_2_TITLE" : "Programa de exemplo 2: Detector de fonte de luz mais brilhante",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_EXAMPLE_2_BODY" : "Neste exemplo, o programa começa entrando em um loop infinito. O primeiro bloco no loop infinito é o bloco wait until com uma entrada condicional usando um operador que exige que o nível de luz no sensor de luz direito seja igual ao nível de luz no sensor de luz esquerdo. Se a condição não for verdadeira (os níveis de luz não são iguais), o programa será pausado aqui. Quando o nível de luz em ambos os sensores de luz é igual, o programa avança para o bloco do bipe. O programa agora volta ao bloco wait until (esperar até) e o programa se repete. O resultado é que o robô Edison emite um bipe quando está apontando para a fonte de luz mais brilhante",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_TITLE" : "Repetir até",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_BODY_1" : "O bloco repeat until executa os blocos dentro dele, até que a condição de entrada seja verdadeira.",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_BODY_2" : "Esse bloco tem um parâmetro de entrada:",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_BODY_3" : "Entrada condicional - A entrada condicional aceita blocos em forma de diamante que podem ser um bloco de operador ou um bloco de detecção.",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_BODY_4" : "O bloco repeat until é frequentemente usado dentro de um loop infinito, de modo que a condição repeat until possa ser testada várias vezes. Se um programa tiver apenas um bloco repeat until, o teste será executado uma vez e o programa será encerrado.",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_EXAMPLE_1_TITLE" : "Programa de exemplo 1: Parar o alarme de tocar",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_EXAMPLE_1_BODY" : "Neste exemplo, o programa começa sintonizando o detector de obstáculos (ativando o alarme) e, em seguida, entra em um loop infinito. O primeiro bloco no loop infinito é um bloco wait until com uma entrada condicional de obstáculo detectado em qualquer lugar (o detector de intrusos). O programa fará uma pausa e aguardará aqui até que um obstáculo (intruso) seja detectado. Quando um obstáculo é detectado, o programa avança para o bloco repeat until, o que faz com que o bloco beep seja executado e repetido várias vezes (o som do alarme), ''até que'' o botão redondo seja pressionado (parando e redefinindo o alarme).",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_EXAMPLE_2_TITLE" : "Exemplo de programa 2: Edison sente frio sem luz quente",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_EXAMPLE_2_BODY" : "Neste exemplo, o programa começa entrando em um loop infinito. O primeiro bloco no loop infinito é o bloco ''repeat until'' (repetir até) com uma entrada condicional usando um operador que exige que o nível de luz do sensor de luz esquerdo seja maior que 980 (muito brilhante/luz do sol). Se isso não for verdade, os blocos abaixo serão executados, girando rapidamente o robô Edison para a esquerda e para a direita (tremendo). Se o nível de luz do sensor de luz esquerdo aumentar acima de 980 (o Edison se move para uma luz muito brilhante), a condição se torna verdadeira e o programa pausa (o robô Edison está aquecido e feliz).",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_TITLE" : "Espera de milissegundos",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_BODY_1" : "O bloco wait milliseconds pausa o programa por um período de tempo em milissegundos (ms). Um milissegundo é um milésimo (1/1000) de segundo ou 0,001 segundo.",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_BODY_2" : "1500 milissegundos = 1,5 segundos",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_BODY_3" : "100 milissegundos = 0,1 segundo",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_BODY_4" : "25 milissegundos = 0,025 segundos",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_BODY_5" : "O bloco wait milliseconds tem apenas um parâmetro:",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_BODY_6" : "Valor - Pode ser uma variável, um sensor ou um bloco de operador",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_EXAMPLE_1_TITLE" : "Programa de exemplo 1: LED piscando rapidamente",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_EXAMPLE_1_BODY" : "Neste exemplo, o programa começa definindo a variável 'Delay' como 50 e, em seguida, entra em um loop infinito. Dentro do loop infinito, o LED esquerdo é ligado e, em seguida, o bloco wait milliseconds faz uma pausa para o valor em milissegundos de 'Delay', nesse caso, 50 milissegundos. Em seguida, o LED esquerdo é desligado e o bloco wait milliseconds faz uma pausa de 50 milissegundos. O programa agora volta ao início do loop infinito.",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_EXAMPLE_2_TITLE" : "Programa de exemplo 2: luzes malucas",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_EXAMPLE_2_BODY" : "Neste exemplo, o programa começa entrando em um loop infinito. Dentro do loop infinito, os LEDs esquerdo e direito são ligados e desligados. Os tempos de espera entre ligar e desligar são controlados pelos blocos wait milliseconds. O tempo em milissegundos é definido pelos blocos de números aleatórios dentro deles. Eles são definidos para gerar números aleatórios entre 30 e 300 milissegundos. O resultado é um piscar aleatório das luzes de LED do robô Edison.",
	"HELP_TEXT_SENSING_TURNLINETRACKINGLED_TITLE" : "Ligar/desligar o LED de rastreamento de linha",
	"HELP_TEXT_SENSING_TURNLINETRACKINGLED_BODY_1" : "O bloco ligar/desligar o LED do rastreador de linha define o LED do rastreador de linha como ligado ou desligado.",
	"HELP_TEXT_SENSING_TURNLINETRACKINGLED_BODY_2" : "O LED do rastreador de linha deve estar ligado para que o sensor de rastreamento de linha funcione.",
	"HELP_TEXT_SENSING_TURNLINETRACKINGLED_EXAMPLE_1_TITLE" : "Programa de exemplo: Parar em uma superfície preta",
	"HELP_TEXT_SENSING_TURNLINETRACKINGLED_EXAMPLE_1_BODY" : "Neste exemplo, o programa começa ligando o LED de rastreamento de linha e, em seguida, os dois motores são configurados para avançar. O programa aguarda até que o sensor de rastreamento de linha detecte uma superfície não reflexiva (preta); quando isso acontece, o programa termina e os motores param.",
	"HELP_TEXT_SENSING_TURNOBSTACLEBEAM_TITLE" : "Ligar/desligar o feixe de detecção de obstáculos",
	"HELP_TEXT_SENSING_TURNOBSTACLEBEAM_BODY_1" : "O bloco ligar/desligar o feixe de detecção de obstáculos define o feixe de detecção de obstáculos como ligado ou desligado.",
	"HELP_TEXT_SENSING_TURNOBSTACLEBEAM_BODY_2" : "O feixe de detecção de obstáculos deve estar ligado para que a detecção de obstáculos funcione.",
	"HELP_TEXT_SENSING_TURNOBSTACLEBEAM_EXAMPLE_1_TITLE" : "Exemplo de programa: Parar por causa de um obstáculo",
	"HELP_TEXT_SENSING_TURNOBSTACLEBEAM_EXAMPLE_1_BODY" : "Neste exemplo, o programa começa ligando o feixe de detecção de obstáculo e, em seguida, ambos os motores são configurados para dirigir para a frente. O programa aguarda até que um obstáculo seja detectado em qualquer lugar; quando isso acontece, o programa termina e os motores param.",
	"HELP_TEXT_SENSING_CLEARSENSOR_TITLE" : "Limpar dados do sensor",
	"HELP_TEXT_SENSING_CLEARSENSOR_BODY_1" : "O bloco Limpar dados do sensor limpa todos os dados do sensor (detecções) do sensor selecionado. Esse bloco é usado quando pode haver detecções falsas ou indesejadas que impedem que o programa funcione da maneira que você deseja. Um exemplo é quando um programa aciona o robô Edison como resultado da detecção de uma batida de palmas. Geralmente, a condução é bastante barulhenta e pode disparar novamente uma detecção adicional de palmas. Isso faz com que o programa detecte uma segunda batida de palmas que não ocorreu. O bloco limpar dados do sensor é usado para limpar os dados do sensor de quaisquer detecções indesejadas como essa.",
	"HELP_TEXT_SENSING_CLEARSENSOR_BODY_2" : "O bloco limpar dados do sensor tem cinco opções de entrada:",
	"HELP_TEXT_SENSING_CLEARSENSOR_BODY_3" : "detector de palmas",
	"HELP_TEXT_SENSING_CLEARSENSOR_BODY_4" : "teclado",
	"HELP_TEXT_SENSING_CLEARSENSOR_BODY_5" : "detector de obstáculos",
	"HELP_TEXT_SENSING_CLEARSENSOR_BODY_6" : "código remoto",
	"HELP_TEXT_SENSING_CLEARSENSOR_BODY_7" : "Mensagem IR",
	"HELP_TEXT_SENSING_CLEARSENSOR_EXAMPLE_1_TITLE" : "Programa de exemplo 1: Bater palmas e girar",
	"HELP_TEXT_SENSING_CLEARSENSOR_EXAMPLE_1_BODY" : "Neste exemplo, o programa começa entrando em um loop infinito. Dentro do loop infinito, o bloco de dados do sensor de limpeza é definido para limpar o detector de palmas. Em seguida, o programa aguarda até que uma palma seja detectada; quando isso acontece, o programa avança e o robô gira para a esquerda por dois segundos. Durante o giro, os motores, as rodas e o skid fazem barulho, esse barulho aciona novamente o detector de palmas, de modo que agora o detector de palmas pensa que houve uma segunda batida. O programa volta ao início do loop infinito (ainda mantendo a detecção de palmas), mas o bloco de dados do sensor limpa a detecção e o bloco wait until não será acionado até que haja de fato uma batida de palmas.",
	"HELP_TEXT_SENSING_CLAPDETECTED_TITLE" : "Palmas detectadas",
	"HELP_TEXT_SENSING_CLAPDETECTED_BODY_1" : "O bloco de detecção de palmas é um bloco de entrada de sensor que indica se uma palma foi detectada ou não. É um bloco em forma de diamante, de modo que os dados no bloco só podem ser verdadeiros (as palmas foram detectadas) ou falsos (as palmas não foram detectadas).",
	"HELP_TEXT_SENSING_CLAPDETECTED_BODY_2" : "Outros ruídos, como o acionamento dos motores, podem fazer com que o bloco de detecção de palmas seja acionado falsamente. Use o bloco Limpar dados do sensor para limpar detecções de palmas falsas ou indesejadas.",
	"HELP_TEXT_SENSING_CLAPDETECTED_EXAMPLE_1_TITLE" : "Programa de exemplo 1: LED pisca se houver um aplauso",
	"HELP_TEXT_SENSING_CLAPDETECTED_EXAMPLE_1_BODY" : "Neste exemplo, o programa começa entrando em um loop infinito. Dentro do loop infinito, há um bloco if then que testa se uma batida de palmas foi detectada. Quando um aplauso é detectado, o LED esquerdo se acende, o programa aguarda um segundo e, em seguida, o LED esquerdo se apaga. Em seguida, o programa volta ao início do loop infinito. O resultado é que o robô Edison pisca seu LED esquerdo por um segundo sempre que detecta uma batida de palmas.",
	"HELP_TEXT_SENSING_BUTTONPRESSED_TITLE" : "Botão pressionado",
	"HELP_TEXT_SENSING_BUTTONPRESSED_BODY_1" : "O bloco de botão pressionado é uma entrada de sensor que indica se um botão foi pressionado ou não. Há duas opções de botão:",
	"HELP_TEXT_SENSING_BUTTONPRESSED_BODY_2" : "redondo",
	"HELP_TEXT_SENSING_BUTTONPRESSED_BODY_3" : "triângulo",
	"HELP_TEXT_SENSING_BUTTONPRESSED_BODY_4" : "O bloco de botão pressionado é um bloco em forma de diamante, de modo que os dados no bloco só podem ser verdadeiros (o botão foi pressionado) ou falsos (o botão não foi pressionado).",
	"HELP_TEXT_SENSING_BUTTONPRESSED_EXAMPLE_1_TITLE" : "Programa de exemplo: Bip ao pressionar o botão",
	"HELP_TEXT_SENSING_BUTTONPRESSED_EXAMPLE_1_BODY" : "Neste exemplo, o programa começa entrando em um loop infinito. Dentro do loop infinito, há um bloco if then que testa se o botão redondo foi pressionado. Quando o botão redondo é pressionado, o programa executa o bloco de bipe e, em seguida, volta ao início do loop infinito.",
	"HELP_TEXT_SENSING_OBSTACLE_TITLE" : "Obstáculo detectado",
	"HELP_TEXT_SENSING_OBSTACLE_BODY_1" : "O bloco de detecção de obstáculo é um bloco de entrada de sensor que indica se um obstáculo foi detectado ou não. Há quatro opções de detecção:",
	"HELP_TEXT_SENSING_OBSTACLE_BODY_2" : "em qualquer lugar",
	"HELP_TEXT_SENSING_OBSTACLE_BODY_3" : "à frente",
	"HELP_TEXT_SENSING_OBSTACLE_BODY_4" : "esquerda",
	"HELP_TEXT_SENSING_OBSTACLE_BODY_5" : "direita",
	"HELP_TEXT_SENSING_OBSTACLE_BODY_6" : "O bloco de detecção de obstáculo é um bloco em forma de diamante, de modo que os dados no bloco só podem ser verdadeiros (o obstáculo foi detectado) ou falsos (o obstáculo não foi detectado).",
	"HELP_TEXT_SENSING_OBSTACLE_BODY_7" : "Para usar o bloco de detecção de obstáculo, o bloco de ativação/desativação do feixe de detecção de obstáculo deve ser usado para ativar o feixe de detecção de obstáculo.",
	"HELP_TEXT_SENSING_OBSTACLE_EXAMPLE_1_TITLE" : "Exemplo de programa: Evitar obstáculos",
	"HELP_TEXT_SENSING_OBSTACLE_EXAMPLE_1_BODY" : "Neste exemplo, o programa começa definindo o feixe de detecção de obstáculos como ligado e, em seguida, entra em um loop infinito. Dentro do loop infinito, os motores são configurados para ambos dirigirem para a frente e, em seguida, há um bloco if then que testa se um obstáculo foi detectado em algum lugar. Quando isso acontece, o robô gira 180 graus e volta ao início do loop infinito. No início do loop infinito, os dois motores são novamente configurados para dirigir para a frente. Isso faz com que o Edison se afaste dos obstáculos em seu caminho.",
	"HELP_TEXT_SENSING_LINETRACKER_TITLE" : "Rastreador de linha na superfície",
	"HELP_TEXT_SENSING_LINETRACKER_BODY_1" : "O bloco rastreador de linha na superfície é um bloco de entrada de sensor que indica se a superfície é reflexiva ou não. Uma superfície reflexiva é uma superfície que reflete a luz do LED do rastreador de linha de volta para o sensor de luz. Geralmente é uma superfície branca, mas uma superfície vermelha também refletirá a luz vermelha do LED vermelho do rastreador de linha. Uma superfície não reflexiva é uma superfície que não reflete a luz do LED do rastreador de linha de volta para o sensor de luz. Geralmente é preta, mas uma superfície azul ou verde também não refletirá a luz vermelha do LED vermelho do rastreador de linha.",
	"HELP_TEXT_SENSING_LINETRACKER_BODY_2" : "Há duas opções de detecção:",
	"HELP_TEXT_SENSING_LINETRACKER_BODY_3" : "reflexiva (branca)",
	"HELP_TEXT_SENSING_LINETRACKER_BODY_4" : "não reflexiva (preta)",
	"HELP_TEXT_SENSING_LINETRACKER_BODY_5" : "O bloco do rastreador de linha na superfície é um bloco em forma de diamante, de modo que os dados no bloco só podem ser verdadeiros (o tipo de superfície foi detectado) ou falsos (o tipo de superfície não foi detectado).",
	"HELP_TEXT_SENSING_LINETRACKER_BODY_6" : "Para usar o rastreador de linha no bloco de superfície, o bloco ligar/desligar o LED de rastreamento de linha deve ser usado para ligar o LED de rastreamento de linha.",
	"HELP_TEXT_SENSING_LINETRACKER_EXAMPLE_1_TITLE" : "Programa de exemplo: Bounce em bordas",
	"HELP_TEXT_SENSING_LINETRACKER_EXAMPLE_1_BODY" : "Neste exemplo, o programa começa ligando o LED de rastreamento de linha e, em seguida, entra em um loop infinito. Dentro do loop infinito, os motores são configurados para ambos se moverem para frente e, em seguida, há um bloco if then que testa se a superfície não é reflexiva. Quando isso é verdade, o robô gira 180 graus e volta ao início do loop infinito. No início do loop infinito, os dois motores são novamente configurados para dirigir para a frente. Isso faz com que o Edison se afaste das linhas pretas detectadas.",
	"HELP_TEXT_SENSING_REMOTE_BOOL_TITLE" : "Código remoto recebido",
	"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_1" : "O bloco de código remoto recebido é um bloco de entrada de sensor que indica se um determinado código de controle remoto foi recebido ou não.",
	"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_2" : "Há oito opções de código remoto de 0 a 7.",
	"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_3" : "O bloco de código remoto recebido é um bloco em forma de diamante, de modo que os dados no bloco só podem ser verdadeiros (o código foi recebido) ou falsos (o código não foi recebido).",
	"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_4" : "Certifique-se de pressionar o botão triangular para iniciar o programa. Isso é fácil de esquecer, pois o robô Edison responderá como um robô de controle remoto e não fará o que você programou.",
	"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_5" : "Para usar o bloco de código remoto recebido, o robô Edison deve primeiro aprender quais botões do seu controle remoto correspondem a qual código remoto. Saiba mais sobre isso aqui:",
	"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_6" : "Se o programa se comportar de forma inesperada, talvez seja necessário usar o bloco clear sensor data (limpar dados do sensor) para limpar o conteúdo do bloco remote code received (código remoto recebido). Veja o programa de exemplo 1 abaixo.",
	"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_7" : "O bloco de código remoto recebido funcionará com aproximadamente 90% dos controles remotos de infravermelho (IR) de TV padrão, mas cada marca de TV usa formatos de dados de IR ligeiramente diferentes. Quando o Edison está decodificando dados de IR, essas diferenças podem causar algum comportamento inesperado de uma marca de controle remoto para outra. A decodificação avançada de controle remoto funciona melhor com o EdRemote (disponível em meados de 2025).",
	"HELP_TEXT_SENSING_REMOTE_BOOL_EXAMPLE_1_TITLE" : "Programa de exemplo 1: Um bipe ou dois?",
	"HELP_TEXT_SENSING_REMOTE_BOOL_EXAMPLE_1_BODY" : "Neste exemplo, o programa começa entrando em um loop infinito. Dentro do loop infinito, há dois blocos if then que testam o código remoto recebido. O primeiro if then testa se o código remoto recebido é o código remoto 1. Se for verdadeiro, o bloco de bipes é reproduzido uma vez e os dados do sensor são apagados. Se for falso, o programa avança para o próximo bloco if then e testa se o código remoto recebido é o código remoto 2. Se for verdadeiro, o bloco de bipes é reproduzido duas vezes e os dados do sensor são apagados. Em seguida, o programa volta ao início do loop infinito.",
	"HELP_TEXT_SENSING_REMOTE_BOOL_EXAMPLE_2_TITLE" : "Programa de exemplo 2: Girar no comando do controle remoto (funciona melhor com o EdRemote)",
	"HELP_TEXT_SENSING_REMOTE_BOOL_EXAMPLE_2_BODY" : "Neste exemplo, o programa começa entrando em um loop infinito. Dentro do loop infinito, o bloco if then testa se o código remoto 0 foi recebido. Se isso for verdade, os dois motores serão ajustados para girar o robô para a direita. Isso continua até que a condição do bloco wait until seja aprovada. Para passar, o código remoto recebido não deve ser o código remoto 0 (o botão de controle remoto não está mais sendo pressionado). Quando isso acontece, o programa progride para parar os dois motores e, em seguida, volta ao início do loop infinito. Isso faz com que o Edison gire enquanto o botão do controle remoto é mantido pressionado.",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_TITLE" : "Mensagem IR detectada",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_BODY_1" : "O bloco de detecção de mensagem IR é uma entrada de sensor que indica se uma mensagem IR foi ou não detectada (recebida) de outro robô Edison. O termo ''IR'' é a abreviação de ''infrared'' (infravermelho). O infravermelho refere-se a uma faixa de luz que não é visível para os seres humanos. Isso faz com que seja útil como meio de comunicar dados a curtas distâncias.",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_BODY_2" : "O bloco de detecção de mensagem IR é um bloco em forma de diamante, de modo que os dados no bloco só podem ser verdadeiros (a mensagem IR foi recebida) ou falsos (a mensagem IR não foi recebida).",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_BODY_4" : "O bloco de detecção de mensagem IR não conhece o conteúdo da mensagem IR que foi recebida. Ele apenas informa ao programa se uma mensagem IR foi recebida. Para ler os dados da mensagem IR, use o bloco de mensagem IR recebida. Veja o programa de exemplo.",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_BODY_5" : "As mensagens de infravermelho entre robôs Edison funcionam melhor em ambientes fechados, longe da luz solar direta. O alcance típico pode ser de até 10 metros (30 pés).",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_EXAMPLE_1_TITLE" : "Programa de exemplo: Ligar e desligar a luz remota do Edison",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_EXAMPLE_1_BODY" : "Neste exemplo, o programa começa entrando em um loop infinito. Dentro do loop infinito, o primeiro bloco if then testa se uma mensagem IR foi recebida; se isso for verdade, a variável 'IRMessage' é definida com o valor do bloco de mensagem IR recebida. Isso permite que a mensagem recebida seja lida/testada várias vezes sem ser apagada ou perdida. A próxima instrução if then testa se os dados em 'IRMessage' são iguais a 1; se isso for verdade, o LED esquerdo será ligado. Se isso não for verdade, o programa passará para o próximo bloco if then. Esse bloco if then testa se os dados em ''IR Message'' são iguais a 2; se isso for verdade, o LED esquerdo será desligado. Em seguida, o programa volta ao início do loop infinito.",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_EXAMPLE_2_TITLE" : "O robô Edison que envia a mensagem IR executa esse programa.",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_EXAMPLE_2_BODY" : "Pressionar o botão triangular envia uma mensagem IR com o número 1 (liga o LED) e pressionar o botão redondo envia uma mensagem IR com o número 2 (desliga o LED)",
	"HELP_TEXT_SENSING_DRIVESTRAINED_TITLE" : "Detecção de tensão no acionamento",
	"HELP_TEXT_SENSING_DRIVESTRAINED_BODY_1" : "O bloco de detecção de tensão de acionamento é um bloco de entrada de sensor que indica se uma ou ambas as rodas pararam de girar por estarem sob tensão (fisicamente impedidas de girar ao tentar dirigir).",
	"HELP_TEXT_SENSING_DRIVESTRAINED_BODY_2" : "O bloco ''drive strain detected'' é um bloco em forma de diamante, de modo que os dados no bloco só podem ser verdadeiros (a roda está sob tensão) ou falsos (a roda não está sob tensão).",
	"HELP_TEXT_SENSING_DRIVESTRAINED_EXAMPLE_1_TITLE" : "Exemplo de programa: Alarme de roda sob tensão",
	"HELP_TEXT_SENSING_DRIVESTRAINED_EXAMPLE_1_BODY" : "Neste exemplo, o programa começa definindo a roda esquerda para dirigir para a frente e, em seguida, entra em um loop infinito. Dentro do loop, há um bloco if then que testa se a tensão na roda foi detectada. Quando isso for verdade, o bloco de bipe é executado. O bloco de bipes continuará a ser executado até que a tensão seja removida e a roda possa girar.",
	"HELP_TEXT_SENSING_REMOTE_NUM_TITLE" : "Código remoto recebido",
	"HELP_TEXT_SENSING_REMOTE_NUM_BODY_1" : "O bloco de código remoto recebido é um bloco de entrada de sensor que contém dados recebidos de um controle remoto. Os dados são números de 0 a 7.",
	"HELP_TEXT_SENSING_REMOTE_NUM_BODY_2" : "Quando um programa executa esse bloco, seu conteúdo é apagado. É sempre melhor colocar os dados do bloco de código remoto recebido em uma variável antes de testá-los com um bloco condicional (if then). Veja o programa de exemplo.",
	"HELP_TEXT_SENSING_REMOTE_NUM_EXAMPLE_1_TITLE" : "Programa de exemplo: Ligar e desligar a luz do controle remoto",
	"HELP_TEXT_SENSING_REMOTE_NUM_EXAMPLE_1_BODY" : "Neste exemplo, o programa começa entrando em um loop infinito. O primeiro bloco dentro do loop infinito coloca os dados do bloco de código remoto recebido na variável 'RemoteCode'. A variável 'RemoteCode' agora pode ser testada. O primeiro bloco if then testa se o conteúdo de 'RemoteCode' é igual a 1. Se isso for verdadeiro, o LED esquerdo será ligado. Se isso for falso, o próximo bloco if then testa se o conteúdo de 'RemoteCode' é igual a 2. Se isso for verdadeiro, o LED esquerdo é desligado. Em seguida, o programa volta ao início do loop infinito.",
	"HELP_TEXT_SENSING_IRMESSAGE_TITLE" : "Mensagem IR recebida",
	"HELP_TEXT_SENSING_IRMESSAGE_BODY_1" : "O bloco de mensagem IR recebida é um bloco de entrada de sensor que contém dados recebidos de outro robô Edison. O termo ''IR'' é a abreviação de ''infrared'' (infravermelho). O infravermelho refere-se a uma faixa de luz que não é visível para os seres humanos. Isso o torna útil como um meio de comunicar dados a curtas distâncias. Os dados são baseados em um número binário de 8 bits e têm um intervalo de 0 a 255.",
	"HELP_TEXT_SENSING_IRMESSAGE_BODY_2" : "Quando um programa executa esse bloco, seu conteúdo é apagado. É sempre melhor colocar os dados do código remoto recebido em uma variável antes de testá-lo com um bloco condicional (bloco if then).",
	"HELP_TEXT_SENSING_IRMESSAGE_BODY_3" : "As mensagens de infravermelho entre robôs Edison funcionam melhor em ambientes fechados, longe da luz solar direta. O alcance típico pode ser de até 10 metros (30 pés).",
	"HELP_TEXT_SENSING_IRMESSAGE_EXAMPLE_1_TITLE" : "Programa de exemplo: Iniciar uma revolução de dança",
	"HELP_TEXT_SENSING_IRMESSAGE_EXAMPLE_1_BODY" : "Neste exemplo, o programa começa entrando em um loop infinito. O primeiro bloco dentro do loop infinito limpa os dados do sensor de mensagem IR e o programa aguarda até que seja recebida uma mensagem IR igual a 3. Quando isso acontece, o programa entra em um loop de repetição por quatro vezes. Dentro do loop de repetição estão as manobras de dança do robô Edison. Cada um desses movimentos é baseado no tempo e não na distância. Isso é muito importante se houver uma turma inteira de robôs Edison dançando em sincronia com a música. As manobras de dança se repetem quatro vezes e o programa volta ao início do loop infinito.",
	"HELP_TEXT_SENSING_IRMESSAGE_EXAMPLE_2_TITLE" : "Programa de exemplo: Enviar mensagem IR 3",
	"HELP_TEXT_SENSING_IRMESSAGE_EXAMPLE_2_BODY" : "Neste exemplo, o programa começa entrando em um loop infinito. O primeiro bloco dentro do loop infinito aguarda até que o botão redondo seja pressionado; quando isso acontece, a mensagem número 3 é transmitida por luz infravermelha. Em seguida, o programa volta ao início do loop infinito.",
	"HELP_TEXT_SENSING_LIGHTLEVEL_TITLE" : "Nível de luz do sensor",
	"HELP_TEXT_SENSING_LIGHTLEVEL_BODY_1" : "O bloco de sensor de nível de luz é um bloco de entrada de sensor que contém dados dos sensores de luz. O nível de luz é um número entre 1 e 1000. Os dados do bloco de sensor de nível de luz são atualizados constantemente.",
	"HELP_TEXT_SENSING_LIGHTLEVEL_BODY_2" : "Há três entradas de sensor de luz para selecionar:",
	"HELP_TEXT_SENSING_LIGHTLEVEL_BODY_3" : "- luz esquerda (sensor na parte frontal esquerda)",
	"HELP_TEXT_SENSING_LIGHTLEVEL_BODY_4" : "- luz direita (sensor na parte frontal direita)",
	"HELP_TEXT_SENSING_LIGHTLEVEL_BODY_5" : "- rastreamento de linha (sensor usado para detectar linhas sob o robô)",
	"HELP_TEXT_SENSING_LIGHTLEVEL_EXAMPLE_1_TITLE" : "Programa de exemplo: Luz noturna",
	"HELP_TEXT_SENSING_LIGHTLEVEL_EXAMPLE_1_BODY" : "Neste exemplo, o programa começa entrando em um loop infinito. O primeiro bloco dentro do loop infinito testa se a leitura do nível de luz no sensor de luz esquerdo é menor que 50. Se isso for verdadeiro, os LEDs esquerdo e direito serão ligados. Se for falso, o programa salta para else e os LEDs esquerdo e direito são desligados. Em seguida, o programa faz um loop até o início do loop infinito e o repete. Isso faz com que os LEDs do Edison fiquem acesos enquanto ele está em uma luz fraca.",
	"HELP_TEXT_ADDITION_TITLE" : "Adição",
	"HELP_TEXT_ADDITION_BODY" : "O bloco do operador de adição soma dois valores. Os valores podem ser uma constante (digitada na entrada e que não varia), uma variável, uma detecção ou um bloco de operador.",
	"HELP_TEXT_ADDITION_EXAMPLE_1_TITLE" : "O valor constante 2 é adicionado ao valor constante 2.",
	"HELP_TEXT_ADDITION_EXAMPLE_2_TITLE" : "A variável ''Counter'' é adicionada ao valor constante 2.",
	"HELP_TEXT_ADDITION_EXAMPLE_3_TITLE" : "O nível de luz do sensor de entrada do sensor é adicionado ao valor constante 10.",
	"HELP_TEXT_SUBTRACTION_TITLE" : "Subtração",
	"HELP_TEXT_SUBTRACTION_BODY" : "O bloco do operador de subtração subtrai um valor de outro. Os valores podem ser uma constante (digitada na entrada e que não varia), uma variável, um sensor ou um bloco de operador.",
	"HELP_TEXT_SUBTRACTION_EXAMPLE_1_TITLE" : "O valor constante 10 é subtraído do valor constante 200.",
	"HELP_TEXT_SUBTRACTION_EXAMPLE_2_TITLE" : "O valor constante 100 é subtraído da variável 'Counter'.",
	"HELP_TEXT_SUBTRACTION_EXAMPLE_3_TITLE" : "O valor constante 10 é subtraído do nível de luz de entrada do sensor.",
	"HELP_TEXT_SUBTRACTION_EXAMPLE_4_TITLE" : "Programa de exemplo: Contador de radiação luminosa",
	"HELP_TEXT_SUBTRACTION_EXAMPLE_4_BODY" : "Nesse programa de exemplo, o andamento da música é primeiro definido como muito rápido. Em seguida, o programa entra em um loop infinito. Dentro do loop, o programa define a variável (Delay) como 1000 menos o nível de luz esquerdo (invertendo a leitura do nível de luz). O próximo bloco aguarda o valor na variável (Delay). Em seguida, o programa toca a nota Dó, volta ao início do loop infinito e repete. Isso faz com que o Edison emita um bipe lento quando está no escuro e mais rápido quando o nível de luz está mais claro.",
	"HELP_TEXT_MULTIPLICATION_TITLE" : "Multiplicação",
	"HELP_TEXT_MULTIPLICATION_BODY" : "O bloco do operador de multiplicação multiplica dois valores. Os valores podem ser uma constante (digitada na entrada e que não varia), uma variável, uma detecção ou um bloco de operador.",
	"HELP_TEXT_MULTIPLICATION_EXAMPLE_1_TITLE" : "O valor constante 2 é multiplicado pelo valor constante 4.",
	"HELP_TEXT_MULTIPLICATION_EXAMPLE_2_TITLE" : "A variável ''Counter'' é multiplicada pelo valor constante 2.",
	"HELP_TEXT_MULTIPLICATION_EXAMPLE_3_TITLE" : "O nível de luz do sensor de entrada do sensor é multiplicado pelo valor constante 4.",
	"HELP_TEXT_DIVISION_TITLE" : "Divisão",
	"HELP_TEXT_DIVISION_BODY_1" : "O bloco do operador de divisão divide um valor por outro valor. Os valores podem ser uma constante (digitada na entrada e que não varia), uma variável, um sensor ou um bloco de operador.",
	"HELP_TEXT_DIVISION_BODY_2" : "Como não é possível dividir por zero, o Edison apresentará um erro se a entrada mais à direita for zero.",
	"HELP_TEXT_DIVISION_EXAMPLE_1_TITLE" : "O valor constante 10 é dividido pelo valor constante 2.",
	"HELP_TEXT_DIVISION_EXAMPLE_2_TITLE" : "A variável ''Contador'' é dividida pelo valor constante 2.",
	"HELP_TEXT_DIVISION_EXAMPLE_3_TITLE" : "O nível de luz de entrada do sensor é dividido por 10.",
	"HELP_TEXT_DIVISION_EXAMPLE_4_TITLE" : "Programa de exemplo: Definição da distância de acionamento usando uma variável e dados de um sensor",
	"HELP_TEXT_DIVISION_EXAMPLE_4_BODY" : "Nesse programa de exemplo, o Edison define a variável (Distance) como o nível de luz do sensor de luz esquerdo (um valor de 1 a 1.000) dividido por 50. Em seguida, o Edison dirige para a frente de acordo com o valor da variável (Distance) na velocidade 5. Isso faz com que o Edison dirija mais longe sob luz forte, até uma distância máxima de 20 cm.",
	"HELP_TEXT_RANDOM_NUMBER_TITLE" : "Número aleatório",
	"HELP_TEXT_RANDOM_NUMBER_BODY" : "O bloco de número aleatório entre gera um número aleatório entre dois valores. Os valores podem ser uma constante (digitada na entrada e que não varia), uma variável, um sensor ou um bloco de operador.",
	"HELP_TEXT_RANDOM_NUMBER_EXAMPLE_1_TITLE" : "Gerar um número aleatório entre o valor constante 10 e o valor constante 100.",
	"HELP_TEXT_RANDOM_NUMBER_EXAMPLE_2_TITLE" : "Gere um número aleatório entre a variável ''Counter'' e o valor constante 5000.",
	"HELP_TEXT_RANDOM_NUMBER_EXAMPLE_3_TITLE" : "Gerar um número aleatório entre o valor constante 10 e o nível de luz de entrada do sensor.",
	"HELP_TEXT_RANDOM_NUMBER_EXAMPLE_4_TITLE" : "Programa de exemplo: Luzes malucas",
	"HELP_TEXT_RANDOM_NUMBER_EXAMPLE_4_BODY" : "Neste exemplo, o programa começa entrando em um loop infinito. Dentro do loop infinito, os LEDs esquerdo e direito são ligados e desligados. Os tempos de espera entre ligar e desligar são controlados pelos blocos wait milliseconds. O tempo em milissegundos é definido pelos blocos de números aleatórios dentro deles. Eles são configurados para gerar números aleatórios entre 30 e 300 milissegundos. O resultado é um piscar louco e inconsistente das luzes de LED do robô Edison.",
	"HELP_TEXT_ABS_VAL_TITLE" : "abs",
	"HELP_TEXT_ABS_VAL_BODY" : "O bloco abs (valor absoluto) converte um valor em um valor absoluto. Um valor absoluto é um valor que é sempre positivo. O valor pode ser uma constante (digitada na entrada e que não varia), uma variável, um sensor ou um bloco de operador.",
	"HELP_TEXT_ABS_VAL_EXAMPLE_1_BODY" : "Tem como resultado o valor 3.",
	"HELP_TEXT_ABS_VAL_EXAMPLE_2_BODY" : "Tem como resultado o valor 3.",
	"HELP_TEXT_ABS_VAL_EXAMPLE_3_TITLE" : "Programa de exemplo: relatar a diferença entre os níveis de luz",
	"HELP_TEXT_ABS_VAL_EXAMPLE_3_BODY" : "Neste exemplo, o programa começa entrando em um loop infinito. O primeiro bloco do loop infinito define a variável ''Difference'' (Diferença) como o valor absoluto do nível de luz do sensor de luz direito menos o nível de luz do sensor de luz esquerdo. O bloco abs garante que o resultado seja sempre positivo (sem números negativos). O programa aguarda um segundo e, em seguida, envia o valor na variável ''Difference'' (Diferença) via USB. Esse valor é sempre um valor positivo (absoluto).",
	"HELP_TEXT_LESS_THAN_TITLE" : "Menor que",
	"HELP_TEXT_LESS_THAN_BODY_1" : "O bloco menos que compara dois valores de entrada para determinar se o primeiro valor é menor que o segundo e retorna um resultado que é verdadeiro ou falso. Os valores podem ser uma constante (digitada na entrada e que não varia), uma variável, uma detecção ou um bloco de operador.",
	"HELP_TEXT_LESS_THAN_BODY_2" : "O bloco menor que é um bloco em forma de diamante, de modo que o resultado do bloco só pode ser verdadeiro ou falso.",
	"HELP_TEXT_LESS_THAN_EXAMPLE_1_BODY" : "Resultado: verdadeiro",
	"HELP_TEXT_LESS_THAN_EXAMPLE_2_BODY" : "Resultado: falso",
	"HELP_TEXT_LESS_THAN_EXAMPLE_3_TITLE" : "A variável 'Counter' é menor que o valor constante 120?",
	"HELP_TEXT_LESS_THAN_EXAMPLE_4_TITLE" : "O nível de luz do sensor esquerdo é menor que o valor constante 500?",
	"HELP_TEXT_LESS_THAN_EQUAL_TITLE" : "Menor que ou igual a",
	"HELP_TEXT_LESS_THAN_EQUAL_BODY_1" : "O bloco menor que ou igual a compara dois valores de entrada para determinar se o primeiro valor é menor ou igual ao segundo e retorna um resultado que é verdadeiro ou falso. Os valores podem ser uma constante (digitada na entrada e que não varia), uma variável, uma detecção ou um bloco de operadores.",
	"HELP_TEXT_LESS_THAN_EQUAL_BODY_2" : "O bloco menor que ou igual a é um bloco em forma de diamante, de modo que o resultado do bloco só pode ser verdadeiro ou falso.",
	"HELP_TEXT_LESS_THAN_EQUAL_EXAMPLE_1_BODY" : "Resultado: verdadeiro",
	"HELP_TEXT_LESS_THAN_EQUAL_EXAMPLE_2_BODY" : "Resultado: falso",
	"HELP_TEXT_LESS_THAN_EQUAL_EXAMPLE_3_BODY" : "Resultado: verdadeiro",
	"HELP_TEXT_LESS_THAN_EQUAL_EXAMPLE_4_TITLE" : "A variável ''Counter'' é menor ou igual ao valor constante 120?",
	"HELP_TEXT_LESS_THAN_EQUAL_EXAMPLE_5_TITLE" : "O nível de luz do sensor esquerdo é menor ou igual ao valor constante 500?",
	"HELP_TEXT_EQUAL_TITLE" : "Igual a",
	"HELP_TEXT_EQUAL_BODY_1" : "O bloco igual a compara dois valores de entrada para determinar se o primeiro valor é igual ao segundo e retorna um resultado que é verdadeiro ou falso. Os valores podem ser uma constante (digitada na entrada e que não varia), uma variável, uma detecção ou um bloco de operador.",
	"HELP_TEXT_EQUAL_BODY_2" : "O bloco igual a é um bloco em forma de diamante, de modo que o resultado do bloco só pode ser verdadeiro ou falso.",
	"HELP_TEXT_EQUAL_EXAMPLE_1_BODY" : "Resultado: verdadeiro",
	"HELP_TEXT_EQUAL_EXAMPLE_2_BODY" : "Resultado: falso",
	"HELP_TEXT_EQUAL_EXAMPLE_3_TITLE" : "A variável 'Counter' é igual ao valor constante 60?",
	"HELP_TEXT_EQUAL_EXAMPLE_4_TITLE" : "O código remoto recebido é igual ao valor constante 3?",
	"HELP_TEXT_GREATER_THAN_EQUAL_TITLE" : "Maior que ou igual a",
	"HELP_TEXT_GREATER_THAN_EQUAL_BODY_1" : "O bloco maior que ou igual a compara dois valores de entrada para determinar se o primeiro valor é maior ou igual ao segundo e retorna um resultado que é verdadeiro ou falso. Os valores podem ser uma constante (digitada na entrada e que não varia), uma variável, uma detecção ou um bloco de operador.",
	"HELP_TEXT_GREATER_THAN_EQUAL_BODY_2" : "O bloco maior ou igual a é um bloco em forma de diamante, de modo que o resultado do bloco só pode ser verdadeiro ou falso.",
	"HELP_TEXT_GREATER_THAN_EQUAL_EXAMPLE_1_BODY" : "Resultado: verdadeiro",
	"HELP_TEXT_GREATER_THAN_EQUAL_EXAMPLE_2_BODY" : "Resultado: falso",
	"HELP_TEXT_GREATER_THAN_EQUAL_EXAMPLE_3_BODY" : "Resultado: verdadeiro",
	"HELP_TEXT_GREATER_THAN_EQUAL_EXAMPLE_4_TITLE" : "A variável ''Counter'' é maior ou igual ao valor constante 120?",
	"HELP_TEXT_GREATER_THAN_EQUAL_EXAMPLE_5_TITLE" : "O nível de luz do sensor esquerdo é maior ou igual ao valor constante 500?",
	"HELP_TEXT_GREATER_THAN_TITLE" : "Maior que",
	"HELP_TEXT_GREATER_THAN_BODY_1" : "O bloco maior que compara dois valores de entrada para determinar se o primeiro valor é maior que o segundo e retorna um resultado que é verdadeiro ou falso. Os valores podem ser uma constante (digitada na entrada e que não varia), uma variável, uma detecção ou um bloco de operador.",
	"HELP_TEXT_GREATER_THAN_BODY_2" : "O bloco maior que é um bloco em forma de diamante, de modo que o resultado do bloco só pode ser verdadeiro ou falso",
	"HELP_TEXT_GREATER_THAN_EXAMPLE_1_BODY" : "Resultado: verdadeiro",
	"HELP_TEXT_GREATER_THAN_EXAMPLE_2_BODY" : "Resultado: falso",
	"HELP_TEXT_GREATER_THAN_EXAMPLE_3_TITLE" : "A variável 'Counter' é maior que o valor constante 120?",
	"HELP_TEXT_GREATER_THAN_EXAMPLE_4_TITLE" : "O nível de luz do sensor esquerdo é maior que o valor constante 500?",
	"HELP_TEXT_NOT_EQUAL_TITLE" : "Não é igual a",
	"HELP_TEXT_NOT_EQUAL_BODY_1" : "O bloco diferente de compara dois valores de entrada para determinar se o primeiro valor não é igual ao segundo e retorna um resultado que é verdadeiro ou falso. Os valores podem ser uma constante (digitada na entrada e que não varia), uma variável, uma detecção ou um bloco de operador.",
	"HELP_TEXT_NOT_EQUAL_BODY_2" : "O bloco diferente de é um bloco em forma de diamante, de modo que o resultado do bloco só pode ser verdadeiro ou falso.",
	"HELP_TEXT_NOT_EQUAL_EXAMPLE_1_BODY" : "Resultado: verdadeiro",
	"HELP_TEXT_NOT_EQUAL_EXAMPLE_2_BODY" : "Resultado: falso",
	"HELP_TEXT_NOT_EQUAL_EXAMPLE_3_TITLE" : "A variável 'Counter' não é igual ao valor constante 120?",
	"HELP_TEXT_NOT_EQUAL_EXAMPLE_4_TITLE" : "O código remoto recebido não é igual ao valor constante 3?",
	"HELP_TEXT_IS_BETWEEN_TITLE" : "Está entre",
	"HELP_TEXT_IS_BETWEEN_BODY_1" : "O bloco is between determina se um valor está dentro de um intervalo de dois outros valores. Os valores podem ser uma constante (digitada na entrada e que não varia), uma variável, um sensor ou um bloco de operador.",
	"HELP_TEXT_IS_BETWEEN_BODY_2" : "O bloco is between é um bloco em forma de diamante, de modo que o resultado do bloco só pode ser verdadeiro ou falso.",
	"HELP_TEXT_IS_BETWEEN_EXAMPLE_1_BODY" : "Resultado: verdadeiro",
	"HELP_TEXT_IS_BETWEEN_EXAMPLE_2_BODY" : "Resultado: falso",
	"HELP_TEXT_IS_BETWEENL_EXAMPLE_3_TITLE" : "A variável ''Contador'' está entre o valor constante 60 e o valor constante 120?",
	"HELP_TEXT_IS_BETWEEN_EXAMPLE_4_TITLE" : "O nível de luz do sensor de luz esquerdo está entre o valor constante 250 e o valor constante 750.",
	"HELP_TEXT_AND_TITLE" : "E",
	"HELP_TEXT_AND_BODY_1" : "O bloco and determina se duas entradas são verdadeiras. Se ambas as entradas forem verdadeiras, o resultado também será verdadeiro. Se uma ou ambas as entradas forem falsas, o resultado será falso. As entradas aceitam blocos em forma de diamante que podem ser um bloco de operador ou um bloco de detecção.",
	"HELP_TEXT_AND_BODY_2" : "O bloco e é um bloco em forma de diamante, portanto o resultado do bloco só pode ser verdadeiro ou falso.",
	"HELP_TEXT_AND_EXAMPLE_1_BODY" : "Resultado: verdadeiro",
	"HELP_TEXT_AND_EXAMPLE_2_BODY" : "Resultado: falso",
	"HELP_TEXT_AND_EXAMPLE_3_TITLE" : "O rastreador de linha está na superfície reflexiva ''e'' a tensão de acionamento foi detectada?",
	"HELP_TEXT_AND_EXAMPLE_4_TITLE" : "A variável 'Counter' é maior que 50 ''e'' o código remoto recebido é igual ao valor constante 3.",
	"HELP_TEXT_OR_TITLE" : "Ou",
	"HELP_TEXT_OR_BODY_1" : "O bloco ou determina se a primeira entrada ''ou'' a segunda entrada são verdadeiras. Se uma ou ambas as entradas forem verdadeiras, o resultado será verdadeiro. Se ambas as entradas forem falsas, o resultado será falso. As entradas aceitam blocos em forma de diamante que podem ser um bloco de operador ou um bloco de detecção.",
	"HELP_TEXT_OR_BODY_2" : "O bloco ou é um bloco em forma de diamante, portanto o resultado do bloco só pode ser verdadeiro ou falso.",
	"HELP_TEXT_OR_EXAMPLE_1_BODY" : "Resultado: verdadeiro",
	"HELP_TEXT_OR_EXAMPLE_2_BODY" : "Resultado: verdadeiro",
	"HELP_TEXT_OR_EXAMPLE_3_BODY" : "Resultado: falso",
	"HELP_TEXT_OR_EXAMPLE_4_TITLE" : "O rastreador de linha está na superfície reflexiva ''ou'' a tensão do acionamento foi detectada?",
	"HELP_TEXT_OR_EXAMPLE_5_TITLE" : "A variável 'Counter' é menor que o valor constante 50 ''ou'' o código remoto recebido é igual ao valor constante 3.",
	"HELP_TEXT_NOT_TITLE" : "Não",
	"HELP_TEXT_NOT_BODY_1" : "O bloco not determina se a entrada é ''não'' verdadeira. Se a entrada for falsa, a saída será verdadeira. Se a entrada for verdadeira, a saída será falsa. A entrada aceita blocos em forma de diamante que podem ser um bloco de operador ou um bloco de detecção.",
	"HELP_TEXT_NOT_BODY_2" : "O bloco not é um bloco em forma de diamante, portanto o resultado do bloco só pode ser verdadeiro ou falso.",
	"HELP_TEXT_NOT_EXAMPLE_1_BODY" : "Resultado: falso",
	"HELP_TEXT_NOT_EXAMPLE_2_BODY" : "Resultado: verdadeiro",
	"HELP_TEXT_NOT_EXAMPLE_3_TITLE" : "O código remoto 0 não é recebido.",
	"HELP_TEXT_NOT_EXAMPLE_4_TITLE" : "Exemplo de programa: Girar no comando do controle remoto (funciona melhor com o EdRemote)",
	"HELP_TEXT_NOT_EXAMPLE_4_BODY" : "Neste exemplo, o programa começa entrando em um loop infinito. Dentro do loop infinito, o bloco if then testa se o código remoto 0 foi recebido. Se isso for verdade, os dois motores serão ajustados para girar o robô para a direita. Isso continua até que a condição do bloco wait until seja aprovada. Para passar, o código remoto recebido não deve ser o código remoto 0 (o botão de controle remoto não está mais sendo pressionado). Quando isso acontece, o programa progride para parar os dois motores e, em seguida, volta ao início do loop infinito. Isso faz com que o Edison gire enquanto o botão remoto é mantido pressionado.",
	"HELP_TEXT_COMMENT_TITLE" : "Comentário",
	"HELP_TEXT_COMMENT_BODY_1" : "O bloco de comentários é usado para adicionar notas a um programa. As notas descrevem em linguagem simples como o programa deve funcionar. Fazer comentários em um programa ajuda quando outra pessoa precisa editar seu programa ou quando você precisa editar seu programa muito tempo depois de tê-lo escrito.",
	"HELP_TEXT_COMMENT_BODY_2" : "Os comentários não são programados no Edison, portanto, não alteram o comportamento do seu programa.",
	"HELP_TEXT_COMMENT_EXAMPLE_1_TITLE" : "Programa de exemplo: Os comentários explicam como o programa funciona em linguagem simples",
	"HELP_TEXT_SEND_USB_TITLE" : "enviar via USB",
	"HELP_TEXT_SEND_USB_BODY_1" : "O bloco send via USB transmite um valor para um computador por meio da conexão USB. O valor pode ser uma constante (digitada na entrada e que não varia), uma variável, um sensor ou um bloco de operador.",
	"HELP_TEXT_SEND_USB_BODY_2" : "Para ver o número no computador, clique no botão USB no EdScratch e uma janela pop-up será exibida. Clique em Run USB para se conectar ao robô Edison V3. Os dados recebidos do Edison V3 aparecerão na janela Data from USB (Dados do USB).",
	"HELP_TEXT_SEND_USB_BODY_3" : "O bloco send to USB também pode ser usado para ajudar a depurar um programa.",
	"HELP_TEXT_SEND_USB_BODY_4" : "As rodas do Edison V3 não se movimentarão enquanto estiverem conectadas ao USB. Isso se deve aos padrões internacionais de segurança que não permitem que produtos destinados a crianças possam acionar um motor enquanto estiverem conectados a uma porta USB.",
	"HELP_TEXT_SEND_USB_EXAMPLE_1_TITLE" : "Exemplo de programa: Medir o nível de luz",
	"HELP_TEXT_SEND_USB_EXAMPLE_1_BODY" : "Neste exemplo, o programa começa entrando em um loop infinito. O primeiro bloco dentro do loop envia o nível de luz do sensor de luz esquerdo via USB. Em seguida, o programa espera um segundo e se repete.",
	"HELP_TEXT_SAVE_USB_TITLE" : "aguarde os dados do USB e salve-os em",
	"HELP_TEXT_SAVE_USB_BODY_1" : "O bloco wait for USB data and save to pausa o programa até que os dados sejam recebidos via USB e, em seguida, coloca os dados em uma variável.",
	"HELP_TEXT_SAVE_USB_BODY_2" : "As rodas do Edison V3 não se movimentarão enquanto estiverem conectadas ao USB. Isso se deve aos padrões internacionais de segurança que não permitem que produtos destinados a crianças possam acionar um motor enquanto estiverem conectados a uma porta USB.",
	"HELP_TEXT_SAVE_USB_EXAMPLE_1_TITLE" : "Programa de exemplo: Número de bipes do USB",
	"HELP_TEXT_SAVE_USB_EXAMPLE_1_BODY_1" : "Neste exemplo, o programa começa entrando em um loop infinito. O primeiro bloco dentro do loop aguarda até que os dados sejam recebidos do USB. Quando os dados são recebidos, eles são salvos na variável ''Count''. Em seguida, o programa avança para o bloco de repetição, que repete o valor da variável 'Count'. Dentro do bloco de repetição, são executados os blocos beep e wait sec. Isso faz com que o Edison emita um bipe pelo número de vezes enviado via USB.",
	"HELP_TEXT_SAVE_USB_EXAMPLE_1_BODY_2" : "Para testar esse programa, clique no botão USB no aplicativo EdScratch e uma janela pop-up será exibida. Clique em Run USB para se conectar ao robô Edison V3. Para enviar dados para o Edison V3, digite um número na caixa Data to USB (Dados para USB) e clique no botão Send to USB (Enviar para USB).",
	"HELP_TEXT_FUNCTION_START_TITLE" : "Início da função",
	"HELP_TEXT_FUNCTION_START_BODY_1" : "O bloco de início da função é onde sua função começa. Conecte blocos ao bloco de início de função para criar uma função personalizada.",
	"HELP_TEXT_FUNCTION_START_BODY_2" : "Os blocos de função ajudam a simplificar um programa, pois o código pode ser agrupado, facilitando a leitura. As funções também ajudam a reduzir o tamanho de um programa, pois as partes repetitivas de um programa só precisam ser escritas uma vez.",
	"HELP_TEXT_FUNCTION_START_BODY_3" : "Os blocos de chamada de função não podem ser colocados sob blocos de início de função.",
	"HELP_TEXT_FUNCTION_START_EXAMPLE_1_TITLE" : "Exemplo de programa 1: Drive em forma de quadrado",
	"HELP_TEXT_FUNCTION_START_EXAMPLE_1_BODY" : "Neste exemplo, o programa começa entrando em um loop de repetição por quatro vezes. Dentro do bloco de repetição há uma chamada de função chamada 'DriveAndTurn'. Quando o programa chega a esse bloco, ele salta para o bloco de início de função correspondente. Nesse bloco, o robô é instruído a dirigir 10 cm para a frente e, em seguida, girar 90 graus para a direita. Essa função é chamada quatro vezes dentro do loop de repetição. O resultado é que o Edison dirige em um quadrado.",
	"HELP_TEXT_FUNCTION_START_EXAMPLE_2_TITLE" : "Programa de exemplo 2: Evitar linhas e obstáculos",
	"HELP_TEXT_FUNCTION_START_EXAMPLE_2_BODY" : "Nesse exemplo, o programa começa ligando o detector de obstáculos e o LED de rastreamento de linha e, em seguida, entra em um loop infinito. Dentro do loop infinito, os dois motores são configurados para dirigir para frente. Em seguida, o bloco if then testa se há algum obstáculo detectado; se for verdadeiro, o bloco de chamada de função 'TurnAround' faz com que o programa pule para o bloco de início de função 'TurnAround'. Em seguida, o programa para os motores, acende a luz LED, emite um bipe, retrocede, gira 175 graus, apaga os LEDs e volta para o programa principal de onde parou. O próximo bloco if then testa se a superfície é não reflexiva (preta); se verdadeiro, o bloco de chamada de função 'TurnAround' faz com que o programa pule para o bloco de início de função 'TurnAround'. Em seguida, o programa para os motores, acende a luz de LED, emite um bipe, retrocede, gira 175 graus, apaga os LEDs e volta para o programa principal de onde parou. Isso faz com que o Edison se afaste das linhas e dos objetos que detecta.",
	"HELP_TEXT_FUNCTION_CALL_TITLE" : "Chamada de função",
	"HELP_TEXT_FUNCTION_CALL_BODY_1" : "O bloco de chamada de função diz ao programa para pular para o bloco de início de função.",
};
Blockly.ScratchMsgs.locales['pl'] ={
	"CONTROL_FOREVER" : "na zawsze",
	"CONTROL_REPEAT" : "powtarzaj",
	"CONTROL_IF" : "if",
	"CONTROL_THAN" : "then",
	"CONTROL_ELSE" : "else",
	"CONTROL_STOP" : "stop",
	"CONTROL_STOP_ALL" : "wszystko",
	"CONTROL_WAIT" : "czekaj",
	"CONTROL_WAIT_SEC" : "sekunda",
	"CONTROL_WAIT_MILLISECONDS" : "milisekundy",
	"CONTROL_WAITUNTIL" : "czekaj do",
	"CONTROL_REPEATUNTIL" : "powtarzaj do",
	"DATA_BUTTONCREATE" : "Utwórz zmienną",
	"DATA_BUTTONMANAGE" : "Zarządzaj zmiennymi",
	"DATA_SET" : "ustaw",
	"DATA_TO" : "do",
	"DATA_INCVARIABLE" : "inkrementacja",
	"DATA_DECVARIABLE" : "zmniejszanie",
	"DATA_BITSHIFT" : "przesunięcie bitowe",
	"DATA_BITSHIFTLEFT" : "w lewo o",
	"DATA_BITSHIFTRIGHT" : "w prawo o",
	"EVENT_ANY_OBSTACLE" : "Wykryto jakąkolwiek przeszkodę",
	"EVENT_OBSTACLE_AHEAD" : "Wykryto przeszkodę z przodu",
	"EVENT_OBSTACLE_LEFT" : "Wykryta przeszkoda w lewo",
	"EVENT_OBSTACLE_RIGHT" : "Wykryto przeszkodę z prawej strony",
	"EVENT_CLAP" : "Wykryto klaśnięcie",
	"EVENT_BUTTON_TRIANGLE" : "Naciśnięto przycisk trójkąta",
	"EVENT_BUTTON_ROUND" : "Naciśnięto okrągły przycisk",
	"EVENT_LINE_REFLECTIVE" : "Lokalizator linii na powierzchni odblaskowej",
	"EVENT_LINE_NON_REFLECTIVE" : "Lokalizator linii na powierzchni nieodblaskowej",
	"EVENT_LINE_CHANGE" : "Lokalizator linii zmienia powierzchnię",
	"EVENT_MESSAGE" : "Odebrano komunikat IR",
	"EVENT_REMOTE" : "Odebrano kod zdalny",
	"EVENT_DRIVE_STRAIN" : "Naprężenie napędu",
	"EVENT_START" : "Uruchom",
	"OPERATORS_RANDOM" : "losowa liczba pomiędzy",
	"OPERATORS_AND" : "a",
	"OPERATORS_OR" : "lub",
	"OPERATORS_NOT" : "nie",
	"OPERATORS_ABS" : "abs",
	"OPERATORS_BETWEEN" : "jest pomiędzy",
	"SENSING_TURN_LINE_TRACKING_LED" : "dioda LED śledzenia linii skrętu",
	"SENSING_TURN_OBSTACLE_BEAM" : "obróć wiązkę wykrywania przeszkód",
	"SENSING_CLEAR" : "czysty",
	"SENSING_SENSOR" : "dane czujnika",
	"SENSING_CLAP_DETECTED" : "wykryto klaśnięcie",
	"SENSING_BUTTON_PRESSED" : "przycisk wciśnięty",
	"SENSING_OBSTACLE" : "wykryto przeszkodę",
	"SENSING_LINE_TRACKER" : "tracker linii na",
	"SENSING_LINE_SURFACE" : "powierzchnia",
	"SENSING_REMOTE_NUM" : "odebrany kod zdalny",
	"SENSING_REMOTE_BOOL" : "zdalny kod",
	"SENSING_REMOTE_RECEIVED" : "odebrany",
	"SENSING_IR_MESSAGE_DETECTED" : "Wykryto komunikat IR",
	"SENSING_IR_MESSAGE" : "odebrany komunikat IR",
	"SENSING_LIGHT_LEVEL" : "poziom oświetlenia",
	"SENSING_LIGHT_SENSOR" : "czujnik",
	"SENSING_DRIVE_STRAIN" : "wykryte obciążenie napędu",
	"SENSING_DROPDOWN_ON" : "włączony",
	"SENSING_DROPDOWN_OFF" : "wyłączony",
	"SENSING_CLEAR_DROPDOWN_CLAP" : "czujnik klaskania",
	"SENSING_CLEAR_DROPDOWN_KEY" : "klawiatura",
	"SENSING_CLEAR_DROPDOWN_OBS" : "detektor przeszkód",
	"SENSING_CLEAR_DROPDOWN_REMOTE" : "zdalny kod",
	"SENSING_CLEAR_DROPDOWN_IR" : "Komunikat IR",
	"SENSING_KEY_DROPDOWN_ROUND" : "okrągły",
	"SENSING_KEY_DROPDOWN_TRIANGLE" : "trójkąt",
	"SENSING_OBS_DROPDOWN_ANY" : "gdziekolwiek",
	"SENSING_OBS_DROPDOWN_AHEAD" : "z przodu",
	"SENSING_OBS_DROPDOWN_LEFT" : "lewo",
	"SENSING_OBS_DROPDOWN_RIGHT" : "prawo",
	"SENSING_LINE_DROPDOWN_WHITE" : "odblaskowy",
	"SENSING_LINE_DROPDOWN_BLACK" : "nieodblaskowe",
	"SENSING_LIGHT_DROPDOWN_LEFT" : "lewe światło",
	"SENSING_LIGHT_DROPDOWN_RIGHT" : "prawe światło",
	"SENSING_LIGHT_DROPDOWN_LINE" : "śledzenie linii",
	"COMMENT_USER_COMMENT" : "komentarz:",
	"ADVANCED_USB_SEND_DATA" : "wyślij",
	"ADVANCED_USB_SEND_VIA" : "przez USB",
	"ADVANCED_USB_RECEIVED_DATA" : "dane odebrane z USB",
	"ADVANCED_USB_RECEIVED_DATA_VAR" : "poczekaj na dane USB i zapisz je",
	"SOUND_BEEP" : "sygnał dźwiękowy",
	"SOUND_PLAY_NOTE" : "odtwórz",
	"SOUND_PLAY_NOTE_DROP_DURATION_WHOLE" : "cały",
	"SOUND_PLAY_NOTE_DROP_DURATION_HALF" : "pół",
	"SOUND_PLAY_NOTE_DROP_DURATION_QUARTER" : "ćwierć",
	"SOUND_PLAY_NOTE_DROP_DURATION_EIGHTH" : "ósma",
	"SOUND_PLAY_NOTE_DROP_NOTE_C" : "C",
	"SOUND_PLAY_NOTE_DROP_NOTE_B" : "B",
	"SOUND_PLAY_NOTE_DROP_NOTE_A" : "A",
	"SOUND_PLAY_NOTE_DROP_NOTE_G" : "G",
	"SOUND_PLAY_NOTE_DROP_NOTE_F" : "F",
	"SOUND_PLAY_NOTE_DROP_NOTE_E" : "E",
	"SOUND_PLAY_NOTE_DROP_NOTE_D" : "D",
	"SOUND_PLAY_NOTE_DROP_NOTE_MID_C" : "środkowe C",
	"SOUND_PLAY_NOTE_DROP_NOTE_LOW_B" : "niskie B",
	"SOUND_PLAY_NOTE_DROP_NOTE_REST" : "reszta",
	"SOUND_PLAY_NOTE_DROP_MOD_SHARP" : "ostry",
	"SOUND_PLAY_NOTE_DROP_MOD_FLAT" : "płaski",
	"SOUND_SET_TEMPO" : "Ustaw tempo muzyki na",
	"SOUND_SET_TEMPO_DROP_VERY_SLOW" : "bardzo wolne",
	"SOUND_SET_TEMPO_DROP_SLOW" : "wolny",
	"SOUND_SET_TEMPO_DROP_MEDIUM" : "średnie",
	"SOUND_SET_TEMPO_DROP_FAST" : "szybki",
	"SOUND_SET_TEMPO_DROP_VERY_FAST" : "bardzo szybko",
	"SOUND_PLAY_IN_BACKGROUND" : "odtwarzaj muzykę w tle",
	"CATEGORY_SOUND" : "Dźwięk",
	"CATEGORY_EVENTS" : "Wydarzenia",
	"CATEGORY_CONTROL" : "Kontrola",
	"CATEGORY_SENSING" : "Wykrywanie",
	"CATEGORY_OPERATORS" : "Operatorzy",
	"CATEGORY_VARIABLES" : "Zmienne",
	"CATEGORY_MYBLOCKS" : "Funkcje",
	"CATEGORY_DRIVE" : "Napęd",
	"CATEGORY_COMMENT" : "Komentarz",
	"CATEGORY_LED" : "Diody LED",
	"CATEGORY_ADVANCED" : "Zaawansowane",
	"DUPLICATE" : "Duplikat",
	"DELETE" : "Usuń",
	"DELETE_BLOCK" : "Usuń blok",
	"CONTEXT_DELETE" : "Usuń",
	"CONTEXT_DELETE_ALL" : "Usuń wszystkie",
	"CONTEXT_BLOCKS" : "Bloki",
	"CLEAN_UP" : "Wyczyść bloki",
	"HELP" : "Pomoc",
	"UNDO" : "Cofnij",
	"REDO" : "Powtórz",
	"CHANGE_VALUE_TITLE" : "Zmień wartość:",
	"RENAME_VARIABLE" : "Zmień nazwę zmiennej",
	"RENAME_VARIABLE_MODAL_TITLE" : "Zmień nazwę zmiennej",
	"NEW_VARIABLE" : "Utwórz zmienną",
	"NEW_VARIABLE_TITLE" : "Nowa nazwa zmiennej:",
	"VARIABLE_MODAL_TITLE" : "Nowa zmienna",
	"NEW_PROCEDURE" : "Utwórz funkcję",
	"MANAGE_PROCEDURE" : "Zarządzaj funkcją",
	"PROCEDURE_DEFAULT_NAME" : "nazwa bloku",
	"PROCEDURE_USED" : "Aby usunąć definicję bloku, najpierw usuń wszystkie użycia bloku",
	"DRIVE_FORWARDS_DISTANCE" : "do przodu dla",
	"DRIVE_BACKWARDS_DISTANCE" : "do tyłu dla",
	"DRIVE_LEFT_DISTANCE" : "w lewo dla",
	"DRIVE_RIGHT_DISTANCE" : "prawo dla",
	"DRIVE_DISTANCE_DROPDOWN_CM" : "cm",
	"DRIVE_DISTANCE_DROPDOWN_INCH" : "cale",
	"DRIVE_DISTANCE_DROPDOWN_SECONDS" : "sekundy",
	"DRIVE_DISTANCE_DROPDOWN_DEGREES" : "stopnie",
	"DRIVE_TURN_DROPDOWN_SPIN" : "obrót",
	"DRIVE_TURN_DROPDOWN_FORWARDS" : "obrót do przodu",
	"DRIVE_TURN_DROPDOWN_BACKWARDS" : "obróć do tyłu",
	"DRIVE_FORWARDS_UNTIL" : "do przodu do",
	"DRIVE_BACKWARDS_UNTIL" : "do tyłu do",
	"DRIVE_LEFT_UNTIL" : "w lewo do",
	"DRIVE_RIGHT_UNTIL" : "w prawo do",
	"DRIVE_SET_LEFT_MOTOR" : "ustaw lewy silnik na",
	"DRIVE_SET_RIGHT_MOTOR" : "ustaw prawy silnik na",
	"DRIVE_SET_MOTOR_DROPDOWN_FORWARDS" : "do przodu",
	"DRIVE_SET_MOTOR_DROPDOWN_BACKWARDS" : "do tyłu",
	"DRIVE_SET_BOTH_MOTOR" : "ustaw oba silniki na",
	"DRIVE_SET_BOTH_MOTOR_DROPDOWN_FORWARDS" : "jazda do przodu",
	"DRIVE_SET_BOTH_MOTOR_DROPDOWN_BACKWARDS" : "jedź do tyłu",
	"DRIVE_SET_BOTH_MOTOR_DROPDOWN_SPIN_LEFT" : "obróć robota w lewo",
	"DRIVE_SET_BOTH_MOTOR_DROPDOWN_SPIN_RIGHT" : "obróć robota w prawo",
	"DRIVE_SET_BOTH_MOTOR_DROPDOWN_TURN_LEFT" : "obróć robota w lewo",
	"DRIVE_SET_BOTH_MOTOR_DROPDOWN_TURN_RIGHT" : "obróć robota w prawo",
	"DRIVE_AT_SPEED" : "z prędkością",
	"DRIVE_STOP" : "stop",
	"DRIVE_STOP_DROPDOWN_BOTH" : "oba silniki",
	"DRIVE_STOP_DROPDOWN_LEFT" : "lewy silnik",
	"DRIVE_STOP_DROPDOWN_RIGHT" : "prawy silnik",
  "LED_LEFT" : "lewa dioda LED",
  "LED_RIGHT" : "prawa dioda LED",
	"LED_DROPDOWN_ON" : "włączony",
	"LED_DROPDOWN_OFF" : "wyłączony",
	"LED_SEND_MESSAGE" : "wyślij wiadomość IR",
	"DEMO_TEST_PROGRAM" : "Przetestuj program",
	"DEMO_TEST_PROGRAM_DISC" : "Testuje napęd, diody LED i głośnik",
	"DEMO_MOVE_WITH_MUSIC" : "Poruszaj się z muzyką",
	"DEMO_MOVE_WITH_MUSIC_DISC" : "Jedź podczas odtwarzania muzyki",
	"DEMO_FOLLOW_A_LINE" : "Podążaj za linią",
	"DEMO_FOLLOW_A_LINE_DISC" : "Użyj czujnika linii, aby podążać za czarną linią",
	"DEMO_BOUNCE_IN_BORDERS" : "Odbijanie się w granicach",
	"DEMO_BOUNCE_IN_BORDERS_DISC" : "Użyj czujnika linii, aby pozostać wewnątrz czarnej linii.",
	"DEMO_WARNINGS" : "Demonstracja komunikatów ostrzegawczych",
	"DEMO_WARNINGS_DISC" : "Demonstruje czerwone komunikaty o błędach i żółte komunikaty ostrzegawcze",
	"DEMO_CLAP_CONTROL" : "Jazda sterowana klaśnięciem",
	"DEMO_CLAP_CONTROL_DISC" : "Klaśnij raz, aby skręcić, klaśnij dwa razy, aby jechać do przodu",
	"DEMO_AVOID_OBSTACLES" : "Omijaj przeszkody",
	"DEMO_AVOID_OBSTACLES_DISC" : "Użyj czujnika przeszkód, aby uniknąć najechania na przeszkodę.",
	"DEMO_FOLLOW_TORCH" : "Podążaj za latarką",
	"DEMO_FOLLOW_TORCH_DISC" : "Użyj czujników światła, aby podążać za latarką",
	"DEMO_FOLLOW_A_LINE_IF" : "Podążaj za linią za pomocą instrukcji if",
	"DEMO_FOLLOW_A_LINE_IF_DISC" : "Inny sposób wykorzystania czujnika linii do podążania za linią przy użyciu bloku if",
	"MENU_DROP_MENU" : "Menu",
	"MENU_DROP_NEW" : "Nowy",
	"MENU_DROP_LOAD_DEMO" : "Załaduj demo",
	"MENU_DROP_LOAD_LOCAL" : "Załaduj z komputera",
	"MENU_DROP_SAVE_LOCAL" : "Zapisz do komputera",
	"MENU_DROP_UPDATE_FIRMWARE" : "Zaktualizuj oprogramowanie sprzętowe",
	"MENU_DROP_DIAGNOSTICS" : "Diagnostyka",
	"MENU_DROP_LANGUAGE_LABEL" : "Język",
	"MENU_DROP_ABOUT" : "Informacje",
	"MENU_DROP_TERMS" : "Warunki użytkowania",
	"MENU_USB" : "USB",
	"MENU_SAVE" : "Zapisz",
	"MENU_VERSION_MAIN" : "Edison V3",
	"MENU_VERSION_SWITCH" : "Przełącz na Edison V1/V2",
	"MENU_VERSION_WHICH_VERSION" : "Którą wersję posiadam?",
	"MENU_PROGRAM" : "Program",
	"MENU_PROGRAM_FLASH" : "Program",
	"MODAL_CREATE_VAR" : "Utwórz zmienną",
	"MODAL_CREATE_VAR_NAME" : "Nazwa zmiennej",
	"MODAL_CREATE_VAR_BUTTON" : "Utwórz zmienną",
	"MODAL_CREATE_VAR_EXIT" : "Wyjdź",
	"MODAL_CREATE_VAR_SUCCESS" : "Nowa zmienna została pomyślnie utworzona.",
	"MODAL_MANAGE_VAR" : "Zmienne",
	"MODAL_MANAGE_VAR_NAME" : "Nazwa zmiennej",
	"MODAL_MANAGE_VAR_ACTION" : "Działanie",
	"MODAL_MANAGE_VAR_BUTTON_DELETE" : "usuń",
	"MODAL_MANAGE_VAR_BUTTON_RENAME" : "zmień nazwę",
	"MODAL_MANAGE_VAR_BUTTON_CONFIRM" : "potwierdź",
	"MODAL_MANAGE_VAR_BUTTON_CANCEL" : "anuluj",
	"MODAL_MANAGE_VAR_CONFIRM_NOT_CHANGED" : "Nie zmieniłeś nazwy zmiennej. Spróbuj ponownie.",
	"MODAL_MANAGE_VAR_CONFIRM_SUCCESS" : "Nazwa zmiennej została zmieniona pomyślnie!",
	"MODAL_MANAGE_VAR_NAME_NONE" : "Wprowadź nazwę zmiennej.",
	"MODAL_MANAGE_VAR_NAME_IN_USE" : "Masz już zmienną o tej nazwie.",
	"MODAL_MANAGE_VAR_NAME_UNSUPPORTED" : "Nazwa zmiennej zawiera nieobsługiwany znak. Nazwy zmiennych mogą zawierać tylko małe litery angielskie, wielkie litery angielskie, cyfry i podkreślenia ( _ ).",
	"MODAL_MANAGE_VAR_NAME_NUMBER_START" : "Nazwy zmiennych nie mogą zaczynać się od cyfry.",
	"MODAL_MANAGE_VAR_DELETE_IN_USE" : "Ta zmienna jest obecnie używana w twoim programie. Czy na pewno chcesz ją usunąć?",
	"MODAL_MANAGE_VAR_DELETE_CONFIRM" : "Tak",
	"MODAL_MANAGE_VAR_DELETE_DECLINE" : "Nie",
	"MODAL_CREATE_FUNCT" : "Utwórz funkcję",
	"MODAL_CREATE_FUNCT_NAME" : "Nazwa funkcji",
	"MODAL_CREATE_FUNCT_WARNING" : "Tylko znaki alfanumeryczne i musi zaczynać się od litery.",
	"MODAL_CREATE_FUNCT_BUTTON" : "Utwórz funkcję",
	"MODAL_CREATE_FUNCT_BUTTON_EXIT" : "Wyjdź",
	"MODAL_CREATE_FUNCT_SUCCESS" : "Nowa funkcja została pomyślnie utworzona.",
	"MODAL_MANAGE_FUNCT" : "Funkcje",
	"MODAL_MANAGE_FUNCT_NAME" : "Nazwa funkcji",
	"MODAL_MANAGE_FUNCT_ACTION" : "Działanie",
	"MODAL_MANAGE_FUNCT_BUTTON_DELETE" : "usuń",
	"MODAL_MANAGE_FUNCT_BUTTON_RENAME" : "zmień nazwę",
	"MODAL_MANAGE_FUNCT_BUTTON_CONFIRM" : "potwierdź",
	"MODAL_MANAGE_FUNCT_BUTTON_CANCEL" : "anuluj",
	"MODAL_MANAGE_FUNCT_CONFIRM_NOT_CHANGED" : "Nie zmieniłeś nazwy funkcji. Spróbuj ponownie.",
	"MODAL_MANAGE_FUNCT_CONFIRM_SUCCESS" : "Pomyślnie zmieniono nazwę funkcji!",
	"MODAL_MANAGE_FUNCT_NAME_NONE" : "Wprowadź nazwę funkcji.",
	"MODAL_MANAGE_FUNCT_NAME_IN_USE" : "Masz już funkcję o takiej nazwie.",
	"MODAL_MANAGE_FUNCT_NAME_START_WITH" : "Nazwy funkcji użytkownika nie mogą zaczynać się od",
	"MODAL_MANAGE_FUNCT_NAME_UNSUPPORTED" : "Nazwa funkcji zawiera nieobsługiwany znak. Nazwy funkcji mogą zawierać tylko małe litery angielskie, wielkie litery angielskie, cyfry i znaki podkreślenia ( _ ).",
	"MODAL_MANAGE_FUNCT_NAME_NUMBER_START" : "Nazwy funkcji nie mogą zaczynać się od liczby.",
	"MODAL_MANAGE_FUNCT_DELETE_IN_USE" : "Ta funkcja jest obecnie używana w Twoim programie. Czy na pewno chcesz ją usunąć?",
	"MODAL_MANAGE_FUNCT_DELETE_CONFIRM" : "Tak",
	"MODAL_MANAGE_FUNCT_DELETE_DECLINE" : "Nie",
	"MODAL_SAVE_TITLE" : "Zapisz do komputera",
	"MODAL_SAVE_PROG_TITLE" : "Nazwa programu",
	"MODAL_SAVE_BUTTON" : "Zapisz do komputera",
	"MODAL_SAVE_ERROR_NO_NAME" : "Wprowadź nazwę swojego programu. Musisz nazwać program, aby go zapisać.",
	"MODAL_SAVE_ERROR_LONG_NAME" : "Ups. Masz problem z nazwą programu. Nazwy programów mogą mieć maksymalnie 255 znaków.",
	"MODAL_SAVE_SAVING" : "OK! Twój program jest zapisywany. Wkrótce rozpocznie się pobieranie Twojego programu.",
	"MODAL_LOAD_PC_TITLE" : "Załaduj z komputera",
	"MODAL_LOAD_PC_FILE_ERROR_1" : "Wybierz plik zapisu EdScratch.",
	"MODAL_LOAD_PC_FILE_ERROR_2" : "Wszystkie pliki zapisu EdScratch są typu",
	"MODAL_LOAD_PC_FILE_ERROR_3" : ".edscratch",
	"MODAL_LOAD_PC_FILE_BUTTON" : "Wybierz plik do przesłania...",
	"MODAL_LOAD_PC_BUTTON" : "Załaduj program",
	"MODAL_LOAD_PC_NO_FILE_ERROR_1" : "Nie wybrałeś jeszcze pliku. Najpierw wybierz plik zapisu EdScratch z komputera, a następnie załaduj plik. [Wszystkie pliki zapisu EdScratch mają typ pliku (.edscratch)].",
	"MODAL_LOAD_PC_FILE_DATA_ERROR_1" : "Uh-oh. Wystąpił problem z danymi w tym pliku.",
	"MODAL_LOAD_PC_FILE_DATA_ERROR_2" : "Prześlij inny plik zapisu EdScratch. [Wszystkie pliki zapisu EdScratch są typu (.edscratch)].",
	"MODAL_LOAD_PC_FILE_TYPE_ERROR_1" : "Uh-oh. Przesłałeś nieprawidłowy typ pliku.",
	"MODAL_LOAD_PC_FILE_TYPE_ERROR_2" : "Prześlij plik zapisu EdScratch. [Wszystkie pliki zapisu EdScratch mają typ pliku (.edscratch).",
	"MODAL_LOAD_PC_FILE_READY" : "Gotowy do załadowania programu:",
	"MODAL_LOAD_DEMO_TITLE" : "Załaduj demo",
	"MODAL_LOAD_DEMO_BUTTON" : "Załaduj program",
  "MODAL_COOKIES_TITLE" : "Pliki cookie",
  "MODAL_COOKIES_BODY_1" : "Używamy Google Analytics do mierzenia, w jaki sposób odwiedzający korzystają z tej aplikacji internetowej, abyśmy mogli ją ulepszać w oparciu o potrzeby użytkowników. Na przykład, z których opcji użytkownicy korzystają najczęściej i czy otrzymują komunikaty o błędach z aplikacji internetowej. Te pliki cookie nie zbierają informacji identyfikujących użytkownika.",
  "MODAL_COOKIES_BODY_2" : "Nie zezwalamy Google na wykorzystywanie ani udostępnianie danych dotyczących sposobu korzystania z tej witryny, a wszystkie informacje gromadzone przez te pliki cookie są zagregowane, a zatem anonimowe. Są one wykorzystywane wyłącznie w celu poprawy działania aplikacji internetowej. Ten plik cookie jest przechowywany przez okres jednego roku.",
  "MODAL_COOKIES_ACCEPT" : "Akceptuj pliki cookie",
  "MODAL_COOKIES_BUTTON_YES" : "Tak",
  "MODAL_COOKIES_BUTTON_NO" : "Nie",
  "MODAL_ABOUT_TITLE" : "O EdScratch",
	"MODAL_ABOUT_COPYRIGHT" : "Copyright 2023 Microbric Pty Ltd",
	"MODAL_ABOUT_BODY_1" : "Aplikacja EdScratch została opracowana przy użyciu bazy kodu Scratch Blocks opracowanej przez MIT. Scratch Blocks został zbudowany na bazie kodu Blockly opracowanej przez Google.",
	"MODAL_ABOUT_BODY_2" : "Wkład i kredyty:",
	"MODAL_ABOUT_BODY_3" : "Język programowania EdScratch i kompilator bloków opracowany przez Bena Haytona, Microbric",
	"MODAL_ABOUT_BODY_4" : "Interfejs użytkownika EdScratch opracowany przez Seana Killiana, Killian Web Development",
	"MODAL_ABOUT_BODY_5" : "Oprogramowanie układowe Edison V3 opracowane przez Damiena George'a, George Robotics (baza kodu MicroPython)",
	"MODAL_LANGUAGE" : "Język",
	"MODAL_DIAGNOSTICS" : "Diagnostyka",
	"MODAL_DIAGNOSTICS_CONNECT_ISSUES_TITLE" : "Problemy z łącznością",
	"MODAL_DIAGNOSTICS_CONNECT_ISSUES_BODY" : "Aby upewnić się, że twój program może zostać skompilowany i wysłany do robota Edison, dobrym pomysłem jest sprawdzenie połączenia za pomocą kompilatora EdScratch.",
	"MODAL_DIAGNOSTICS_CONNECT_ISSUES_BUTTON" : "Uruchom narzędzie do sprawdzania połączenia",
	"MODAL_DIAGNOSTICS_FIRMWARE_TITLE" : "Napraw oprogramowanie układowe",
	"MODAL_DIAGNOSTICS_FIRMWARE_BODY" : "Jeśli Edison V3 nie zachowuje się zgodnie z oczekiwaniami, może to być problem z oprogramowaniem układowym. Kliknij przycisk Fix firmware (Napraw oprogramowanie sprzętowe), aby przesłać aktualizację oprogramowania sprzętowego.",
	"MODAL_DIAGNOSTICS_FIRMWARE_BUTTON" : "Napraw oprogramowanie układowe",
	"MODAL_DIAGNOSTICS_PROGRAMMING_TITLE" : "Metoda programowania",
	"MODAL_DIAGNOSTICS_PROGRAMMING_BODY" : "Ta opcja umożliwia przełączanie między programowaniem USB a programowaniem pamięci flash na ekranie tego urządzenia.",
	"MODAL_DIAGNOSTICS_PROGRAMMING_BUTTON" : "Zmień metodę programowania",
	"MODAL_DIAGNOSTICS_IR_TITLE" : "Wyczyść wyuczone polecenia pilota IR",
	"MODAL_DIAGNOSTICS_IR_BODY" : "Ta opcja umożliwia wyczyszczenie wszystkich wyuczonych poleceń pilota na podczerwień z robota Edison V3.",
	"MODAL_DIAGNOSTICS_IR_BUTTON" : "Wyczyść kody pilota",
	"MODAL_DIAGNOSTICS_IR_SUCCESS" : "Kody zdalne zostały wyczyszczone.",
	"MODAL_DIAGNOSTICS_IR_ERROR" : "Wystąpił błąd.",
	"MODAL_CONNECTION" : "Połączenie",
	"MODAL_CONNECTION_TEST_1" : "Jeśli powyższy test dał wynik",
	"MODAL_CONNECTION_TEST_EXAMPLE" : "NIE ZNALEZIONO SERWERA",
	"MODAL_CONNECTION_TEST_2" : "to firewall może blokować dostęp do kompilatora.",
	"MODAL_CONNECTION_TEST_3" : "Aby temu zaradzić, poproś administratora sieci o umieszczenie tych adresów na białej liście:",
	"MODAL_CONNECTION_PORTS" : "Administrator sieci musi również odblokować porty 80, 8080, 443 i 8443.",
	"MODAL_CONNECTION_BACK" : "Wróć do diagnostyki",
	"MODAL_CONNECTION_SERVER" : "Serwer:",
	"MODAL_CONNECTION_SERVER_SEARCHING" : "wyszukiwanie",
	"MODAL_CONNECTION_SERVER_NONE" : "NIE ZNALEZIONO SERWERA",
	"MODAL_CONNECTION_COMIPLE_TEST" : "Test kompilacji:",
	"MODAL_CONNECTION_COMIPLE_TEST_WORKING" : "działa",
	"MODAL_CONNECTION_COMIPLE_TEST_ERROR" : "błąd kompilacji",
	"MODAL_CONNECTION_COMIPLE_TEST_COMPLETE" : "kompilacja zakończona",
	"MODAL_STATUS_TITLE" : "Napraw oprogramowanie układowe",
	"MODAL_STATUS_BUTTON" : "Połącz Edison",
	"MODAL_STATUS_STATUS_LABEL" : "Status:",
	"MODAL_STATUS_STATUS_NOT_CONNECTED" : "niepołączony",
	"MODAL_STATUS_STATUS_CONNECTED" : "połączony",
	"MODAL_STATUS_FIRMWARE_LABEL" : "Wersja oprogramowania układowego:",
	"MODAL_STATUS_FIRMWARE_BOOT_MODE" : "tryb bootloadera",
	"MODAL_STATUS_FIRMWARE_FACTORY_MODE" : "tryb aplikacji fabrycznej",
	"MODAL_STATUS_FIRMWARE_USER_MODE" : "tryb aplikacji użytkownika",
	"MODAL_STATUS_FIRMWARE_TAG" : "firmware",
	"MODAL_STATUS_BOOT_TAG" : "boot",
	"MODAL_STATUS_FIRMWARE_UPDATE" : "Aktualizacja oprogramowania sprzętowego",
	"MODAL_STATUS_FIRMWARE_UPDATE_AVAILABLE" : "jest dostępna",
	"MODAL_STATUS_BOOT_UPDATE" : "Aktualizacja rozruchowa",
	"MODAL_STATUS_FIRMWARE_UPDATE_BUTTON" : "Wymuś aktualizację oprogramowania",
	"MODAL_STATUS_FIRMWARE_UP_TO_DATE" : "Twój Edison jest aktualny.",
	"MODAL_PROGRAMING_METHOD_TITLE" : "Metoda programowania",
	"MODAL_PROGRAMING_METHOD_BODY" : "Programowanie flash ekranu zostało opracowane dla iPadów Apple. Wynika to z faktu, że Apple nie zezwala na normalny dostęp do portu danych iPada. Dlatego programowanie flashowania ekranu jest w pełni obsługiwane tylko dla iPadów. Jednakże, flashowanie ekranu działa z niektórymi urządzeniami z systemem Android. Poniższa opcja umożliwia programowanie flashowania ekranu na tym urządzeniu. Jeśli to urządzenie nie jest iPadem, nie ma gwarancji, że będzie działać.",
	"MODAL_PROGRAMING_METHOD_CURRENT_LABEL" : "Obecnie używasz",
	"MODAL_PROGRAMING_METHOD_CURRENT_LABEL_USB" : "USB",
	"MODAL_PROGRAMING_METHOD_CURRENT_LABEL_FLASH" : "FLASH",
	"MODAL_PROGRAMING_METHOD_CURRENT_LABEL_METHOD" : "metoda.",
	"MODAL_PROGRAMING_METHOD_BUTTON_USB" : "Ustaw na metodę USB",
	"MODAL_PROGRAMING_METHOD_BUTTON_FLASH" : "Ustaw metodę FLASH",
	"MODAL_PROGRAMING_METHOD_ACCORD_BUTTON_FLASH_GUARANTEE" : "Dlaczego flashowanie ekranu nie działa na urządzeniach z systemem Android?",
	"MODAL_PROGRAMING_METHOD_ACCORD_BODY_FLASH_GUARANTEE" : "Urządzenia z Androidem są produkowane przez wielu różnych producentów i istnieją tysiące różnych modeli. Oznacza to, że istnieje również wiele różnych technologii ekranu. Nie jest możliwe przetestowanie i dostosowanie flashowania ekranu dla wszystkich urządzeń z Androidem.",
	"MODAL_PROGRAMING_METHOD_ACCORD_BUTTON_FLASH_SETTINGS" : "Czy istnieją ustawienia, które mogą pomóc mojemu urządzeniu z Androidem pracować z miganiem ekranu?",
	"MODAL_PROGRAMING_METHOD_ACCORD_BODY_FLASH_SETTINGS" : "Tak, w wyskakującym oknie flashowania ekranu znajduje się niezawodne/szybkie ustawienie, które ma cztery pozycje. Wypróbuj każdą z czterech pozycji. Spróbuj również dostosować jasność ekranu. Przetestuj z jasnością 50%, 75%, 90% i 100%.",
	"MODAL_PROGRAMING_METHOD_ACCORD_BUTTON_FLASH_FAIL" : "Co zrobić, jeśli miganie ekranu nie działa na moim urządzeniu z Androidem?",
	"MODAL_PROGRAMING_METHOD_ACCORD_BODY_FLASH_FAIL" : "Aby zaprogramować, musisz podłączyć kabel Edison V3 do portu danych urządzenia z systemem Android za pomocą kabla adaptera. Są one powszechnie i tanio dostępne w serwisach ebay, Amazon itp.",
	"MODAL_PROGRAMING_METHOD_BACK" : "Wróć do diagnostyki",
	"MODAL_PROGRAMING_TITLE" : "Programowanie",
	"MODAL_PROGRAMING_TITLE_COMPLETE" : "Programowanie zakończone",
	"MODAL_PROGRAMING_TITLE_ERROR" : "Błąd programowania",
	"MODAL_PROGRAMING_TIP_1_TITLE" : "Wskazówka: Nie grupuj robotów Edison na hubie USB!",
	"MODAL_PROGRAMING_TIP_1_TEXT" : "Zamiast tego użyj ładowarki EdCharger.",
	"MODAL_PROGRAMING_TIP_2_TITLE" : "Wskazówka: Nie zostawiaj Edisona wiszącego!",
	"MODAL_PROGRAMING_TIP_2_TEXT" : "Trzymaj Edisona opartego na solidnej powierzchni.",
	"MODAL_PROGRAMING_TIP_3_TITLE" : "Wskazówka: Nie zostawiaj Edisona wiszącego!",
	"MODAL_PROGRAMING_TIP_3_TEXT" : "Używaj przedłużacza podczas ładowania z gniazdka elektrycznego.",
	"MODAL_PROGRAMING_TIP_4_TITLE" : "Wskazówka: Nie ciągnij za Edisona!",
	"MODAL_PROGRAMING_TIP_4_TEXT" : "Odłączaj urządzenie ciągnąc za kabel USB, a nie za robota.",
	"MODAL_PROGRAMING_ERROR_NO_BLOCK" : "Nie można pobrać bez bloków podłączonych do bloku startowego.",
	"MODAL_PROGRAMING_ERROR_RED" : "Nie można pobrać z czerwonymi błędami.",
	"MODAL_PROGRAMING_UPDATE_FIRMWARE" : "Aby zaprogramować Edisona, musisz zaktualizować oprogramowanie sprzętowe do najnowszej wersji",
	"MODAL_PROGRAMING_UPDATE_FIRMWARE_BUTTON" : "Zaktualizuj oprogramowanie sprzętowe",
	"MODAL_PROGRAMING_UPDATE_FIRMWARE_NOW" : "Wymagana aktualizacja oprogramowania sprzętowego. Aktualizuję teraz...",
	"MODAL_PROGRAMING_FIRMWARE_UPDATED" : "Oprogramowanie sprzętowe zaktualizowane.",
	"MODAL_PROGRAMING_FIRMWARE_UPDATED_NOW_PROGRAMMING" : "Teraz programuj Edisona...",
	"MODAL_PROGRAMING_FIRMWARE_UPDATE_INCOMPLETE" : "Niekompletna aktualizacja oprogramowania.",
	"MODAL_PROGRAMING_DONE" : "OK! Program został załadowany do twojego Edisona.",
	"MODAL_PROGRAMING_ERROR_JSON" : "Odpowiedź nie jest JSON!",
	"MODAL_PROGRAMING_ERROR_UNKNOWN" : "Nieznany błąd!",
	"MODAL_FIRMWARE_UPDATE_TITLE" : "Aktualizacja oprogramowania sprzętowego",
	"MODAL_FIRMWARE_UPDATE_LATEST" : "Najnowsza wersja oprogramowania Edison V3:",
	"MODAL_FIRMWARE_UPDATE_POPUP" : "Użyj tego wyskakującego okienka, aby zaktualizować oprogramowanie sprzętowe w urządzeniu Edison.",
	"MODAL_FIRMWARE_UPDATE_TO_UPDATE1" : "Aby zaktualizować oprogramowanie Edison V3:",
	"MODAL_FIRMWARE_UPDATE_TO_UPDATE2" : "Podłącz urządzenie Edison i kliknij przycisk Aktualizuj oprogramowanie sprzętowe poniżej, a następnie postępuj zgodnie z instrukcjami.",
	"MODAL_FIRMWARE_UPDATE_TO_UPDATE_BUTTON" : "Zaktualizuj oprogramowanie sprzętowe",
	"MODAL_FIRMWARE_UPDATE_TO_RECONNECT_BUTTON" : "Podłącz ponownie Edisona",
	"MODAL_FIRMWARE_UPDATE_FEEDBACK_START" : "Gotowe...",
	"MODAL_FIRMWARE_UPDATE_TWO_STEP_START" : "Rozpoczyna się dwuetapowa aktualizacja oprogramowania sprzętowego",
	"MODAL_FIRMWARE_UPDATE_BOOT_COMPLETE" : "Aktualizacja bootloadera zakończona.",
	"MODAL_FIRMWARE_UPDATE_PLEASE_CLICK" : "Kliknij przycisk",
	"MODAL_FIRMWARE_UPDATE_ISSUE_LOADING" : "Problem z ładowaniem oprogramowania sprzętowego",
	"MODAL_FIRMWARE_UPDATE_ONE_STEP_START" : "Rozpoczyna się aktualizacja oprogramowania sprzętowego",
	"MODAL_FIRMWARE_UPDATE_ERROR_ISSUE_LOADING" : "Błąd: Problem z ładowaniem oprogramowania sprzętowego.",
	"MODAL_FIRMWARE_UPDATE_ERROR_ISSUE_DOWNLOADING" : "Błąd: Problem z pobraniem oprogramowania sprzętowego.",
	"MODAL_FIRMWARE_UPDATE_FIRM_COMPLETE" : "Aktualizacja oprogramowania sprzętowego zakończona.",
	"MODAL_FIRMWARE_UPDATE_NONE_NEEDED" : "Aktualizacja nie jest wymagana: oprogramowanie sprzętowe Twojego urządzenia Edison jest aktualne.",
	"MODAL_FIRMWARE_UPDATE_PROBLEMS" : "Masz problemy?",
	"MODAL_FIRMWARE_UPDATE_SEE_DIAG" : "Zobacz diagnostykę",
	"MODAL_USB_CONTROL" : "Elementy sterujące USB",
	"MODAL_USB_RUN_BUTTON" : "Uruchom USB",
	"MODAL_USB_CONNECTED_STATUS" : "PODŁĄCZONY",
	"MODAL_USB_DISCONNECTED_STATUS" : "ODŁĄCZONY",
	"MODAL_USB_RUNNING_STATUS" : "URUCHOMIONY",
	"MODAL_USB_DATA_TO" : "Dane do USB",
	"MODAL_USB_DATA_TO_BUTTON" : "Wyślij do USB",
	"MODAL_USB_DATA_FROM" : "Dane z USB",
	"MODAL_USB_DATA_FROM_CLEAR" : "Wyczyść",
	"MODAL_USB_DATA_FROM_COPY" : "Kopiuj do schowka",
	"MODAL_USB_DATA_FROM_COPIED" : "Skopiowano!",
	"MODAL_BAD_BROWSER_TITLE" : "Nieobsługiwana przeglądarka",
	"MODAL_BAD_BROWSER_USING" : "Wygląda na to, że używasz:",
	"MODAL_BAD_BROWSER_WEB_USB" : "Edison V3 jest programowany bezpośrednio z Twojej przeglądarki internetowej przez USB. Wymaga to, aby Twoja przeglądarka internetowa obsługiwała połączenia USB.",
	"MODAL_BAD_BROWSER_UNFORTUNATLY" : "Niestety",
	"MODAL_BAD_BROWSER_UNSUPORTED" : "nie obsługuje obecnie połączeń USB, więc nie możesz zaprogramować robota Edison V3.",
	"MODAL_BAD_BROWSER_USE_CHROME" : "Zalecamy korzystanie z przeglądarki Google Chrome.",
	"MODAL_BAD_BROWSER_GET_CHROME" : "Pobierz Chrome.",
	"MODAL_LOADING" : "Ładowanie obszaru roboczego...",
	"MODAL_FLASHER_TITLE" : "Flasher",
	"MODAL_FLASHER_STEP_1" : "Umieść Edisona nad obrazem",
	"MODAL_FLASHER_STEP_2" : "Naciśnij raz okrągły przycisk Edisona",
	"MODAL_FLASHER_STEP_3" : "Naciśnij Pobierz program",
	"MODAL_FLASHER_RELIABLE" : "Niezawodny",
	"MODAL_FLASHER_FAST" : "Szybko",
	"MODAL_FLASHER_ADJUST_SPEED" : "Jeśli pobieranie nie działa lub nie jest wystarczająco szybkie, spróbuj dostosować prędkość powyżej. Najniższa prędkość jest zazwyczaj najbardziej niezawodna.",
	"MODAL_FLASHER_DOWNLOAD" : "Pobierz program",
	"MODAL_FLASHER_CANCEL" : "Anuluj",
	"MODAL_FLASHER_TIPS_HEADING" : "Wskazówki",
	"MODAL_FLASHER_TIPS_BODY_1" : "Ustaw jasność ekranu w zakresie od 80% do 90%.",
	"MODAL_FLASHER_TIPS_BODY_2" : "Odsuń się od bezpośredniego światła słonecznego lub jasnych świateł.",
	"MODAL_FLASHER_TIPS_BODY_3" : "Upewnij się, że Edison V3 został zaktualizowany do najnowszej wersji oprogramowania sprzętowego.",
	"MODAL_FLASHER_DOWNLOADING" : "Pobieranie...",
	"MODAL_FLASHER_COMPLETE" : "Zakończono",
	"MODAL_FLASHER_BYTES" : "bajtów",
	"MODAL_FLASHER_SECONDS" : "sekundy",
	"ERROR_RED_OBS_SETTING" : "Bloki wykrywania przeszkód nie działają, jeśli wiązka wykrywania przeszkód nie jest włączona przy użyciu bloku wiązki wykrywania przeszkód z kategorii Wykrywanie.",
	"ERROR_RED_OBS_SETTING_EVENT" : "Zdarzenia wykrywania przeszkód nie działają, jeśli wiązka wykrywania przeszkód nie jest włączona przy użyciu bloku wiązki wykrywania przeszkód z kategorii Sensing w programie głównym.",
	"ERROR_RED_LINE_SETTING" : "Bloki detekcji linii nie działają, jeśli dioda LED detekcji linii nie jest włączona za pomocą bloku diody LED śledzenia linii z kategorii Sensing.",
	"ERROR_RED_LINE_SETTING_EVENT" : "Zdarzenia wykrywania linii nie działają, jeśli dioda LED wykrywania linii nie zostanie włączona przy użyciu bloku LED śledzenia linii z kategorii Sensing w programie głównym.",
	"ERROR_RED_DRIVE_CLAP" : "Edison nie może wykrywać klaśnięć podczas jazdy, ponieważ silniki są zbyt głośne.",
	"ERROR_RED_EMPTY_IN_FORWARDS" : "Do przodu, dopóki bloki nie wymagają wejścia warunku.",
	"ERROR_RED_EMPTY_IN_BACKWARDS" : "Do tyłu, aż bloki będą wymagały wejścia warunku.",
	"ERROR_RED_EMPTY_IN_LEFT" : "W lewo, aż bloki będą wymagały wejścia warunku.",
	"ERROR_RED_EMPTY_IN_RIGHT" : "W prawo, dopóki bloki nie wymagają wejścia warunku.",
	"ERROR_RED_EMPTY_IN_SET_VAR" : "Bloki ustawiania zmiennej wymagają zmiennej.",
	"ERROR_RED_EMPTY_IN_INC_VAR" : "Bloki zwiększania zmiennej wymagają zmiennej.",
	"ERROR_RED_EMPTY_IN_DEC_VAR" : "Bloki zmniejszania zmiennej wymagają zmiennej.",
	"ERROR_RED_EMPTY_IN_IF" : "Bloki if wymagają wejścia warunku.",
	"ERROR_RED_EMPTY_IN_IF_ELSE" : "Bloki if-else wymagają podania warunku.",
	"ERROR_RED_EMPTY_IN_WAIT" : "Bloki wait until wymagają podania warunku.",
	"ERROR_RED_EMPTY_IN_WAIT_MILLI" : "Bloki wait milliseconds wymagają wartości wejściowej.",
	"ERROR_RED_EMPTY_IN_REP" : "Powtarzaj aż do bloki wymagają wejścia warunku.",
	"ERROR_RED_EMPTY_IN_BS_RIGHT" : "Bloki przesunięcia bitowego w prawo wymagają zmiennej.",
	"ERROR_RED_EMPTY_IN_BS_LEFT" : "Bloki przesunięcia bitowego w lewo wymagają zmiennej.",
	"ERROR_RED_EMPTY_IN_OPERATOR_NOT" : "Bloki not wymagają wejścia warunku.",
	"ERROR_RED_EMPTY_IN_OPERATOR_AND" : "I bloki potrzebują wejścia warunku.",
	"ERROR_RED_EMPTY_IN_OPERATOR_OR" : "Lub bloki potrzebują wejścia warunku.",
	"ERROR_RED_EMPTY_BACKGROUND_MUSIC" : "Bloki grupowania odtwarzania muzyki w tle muszą zawierać co najmniej jeden blok nut.",
	"ERROR_RED_NO_START" : "Aby programy działały poprawnie, muszą mieć zdarzenie startowe. Jeśli widzisz ten komunikat o błędzie, uruchom nowy program, przechodząc do menu i wybierając nowy.",
	"ERROR_RED_NOT_BACKGROUND_MUSIC" : "Odtwarzaj muzykę w tle bloki grupowania mogą akceptować tylko bloki nut.",
	"ERROR_RED_NO_MAIN_BLOCKS" : "Nie ma bloków połączonych ze zdarzeniem startowym, więc nie ma głównego programu do uruchomienia przez Edisona.",
	"ERROR_RED_EMPTY_IN_USB_RECEIVED" : "Bloki oczekiwania na dane usb wymagają zmiennej.",
	"ERROR_RED_DEVIDE_BY_ZERO" : "Bloki operatora dzielenia nie mogą dzielić przez zero.",
	"ERROR_RED_FUNCTION_IN_FUNCTION" : "Bloki wywołania funkcji nie mogą być umieszczone pod blokiem uruchomienia funkcji",
	"ERROR_YELLOW_RECEIVE_MESSAGE_OBS_ON" : "Edison nie może odbierać wiadomości, gdy wykrywanie przeszkód jest włączone. Wyłącz wykrywanie przeszkód w programie przed próbą odebrania wiadomości.",
	"ERROR_YELLOW_RECEIVE_REMOTE_OBS_ON" : "Edison nie może odbierać kodów zdalnego sterowania, gdy detekcja przeszkód jest włączona. Upewnij się, że wykrywanie przeszkód jest wyłączone w programie przed próbą odebrania zdalnego kodu.",
	"ERROR_YELLOW_RECEIVE_MESSAGE_EVENT_OBS_ON" : "Edison nie może odbierać wiadomości, gdy detekcja przeszkód jest włączona. Upewnij się, że wykrywanie przeszkód zostało wyłączone w programie głównym przed próbą odebrania wiadomości.",
	"ERROR_YELLOW_RECEIVE_REMOTE_EVENT_OBS_ON" : "Edison nie może odbierać kodów pilota, gdy detekcja przeszkód jest włączona. Upewnij się, że wykrywanie przeszkód jest wyłączone w głównym programie przed próbą odebrania zdalnego kodu.",
	"ERROR_YELLOW_READ_LIGHT_LINE_OFF" : "Rozważ włączenie diody LED wykrywania linii za pomocą bloku diody LED śledzenia linii z kategorii Wykrywanie, jeśli mierzysz współczynnik odbicia powierzchni jezdnej.",
	"ERROR_YELLOW_OPPERATOR_WAIT_UNTIL" : "Blok operatora wewnątrz bloku czekaj do może spowodować, że Edison będzie czekał wiecznie lub pominie blok oczekiwania.",
	"ERROR_YELLOW_OPPERATOR_REPEAT_UNTIL" : "Blok operatora wewnątrz bloku repeat until może spowodować, że Edison wykona pętlę w nieskończoność lub pominie blok repeat.",
	"ERROR_YELLOW_OPPERATOR_WAIT" : "Blok operatora wewnątrz bloku wait może spowodować, że Edison pominie blok wait.",
	"ERROR_YELLOW_OPPERATOR_REPEAT" : "Blok operatora wewnątrz bloku powtarzania może spowodować, że Edison pominie blok powtarzania.",
	"ERROR_YELLOW_OPPERATOR_DRIVE_FOR_UNTIL" : "Blok operatora wewnątrz bloku drive forward until może spowodować, że Edison będzie jechał wiecznie lub pominie blok drive.",
	"ERROR_YELLOW_OPPERATOR_DRIVE_BACK_UNTIL" : "Blok operatora wewnątrz bloku jazdy do tyłu aż do bloku może spowodować, że Edison będzie jechał bez końca lub pominie blok jazdy.",
	"ERROR_YELLOW_OPPERATOR_DRIVE_LEFT_UNTIL" : "Blok operatora wewnątrz bloku jazdy w lewo do momentu zablokowania może spowodować, że Edison będzie jechał wiecznie lub pominie blok jazdy.",
	"ERROR_YELLOW_OPPERATOR_DRIVE_RIGHT_UNTIL" : "Blok operatora wewnątrz bloku jazdy w prawo do może spowodować, że Edison będzie jechał bez końca lub pominie blok jazdy.",
	"ERROR_YELLOW_OPPERATOR_DRIVE_FOR_DIST" : "Blok operatora wewnątrz bloku jazdy do przodu może spowodować, że Edison pominie blok jazdy.",
	"ERROR_YELLOW_OPPERATOR_DRIVE_BACK_DIST" : "Blok operatora wewnątrz bloku jazdy do tyłu może spowodować, że Edison pominie blok jazdy.",
	"ERROR_YELLOW_OPPERATOR_DRIVE_LEFT_DIST" : "Blok operatora wewnątrz lewego bloku przemiennika może spowodować, że Edison pominie blok przemiennika.",
	"ERROR_YELLOW_OPPERATOR_DRIVE_RIGHT_DIST" : "Blok operatora wewnątrz prawego bloku jazdy może spowodować, że Edison pominie blok jazdy.",
	"ERROR_YELLOW_DRIVE_LIGHT" : "Blok poziomu światła wewnątrz bloku napędu może spowodować, że Edison będzie jeździł bez końca lub pominie blok napędu.",
	"ERROR_YELLOW_OPPERATOR_IR_MESSAGE" : "Blok operatora wewnątrz bloku wysyłania wiadomości IR nie będzie w stanie wysłać wartości większej niż 255.",
	"ERROR_YELLOW_FOREVER_LOOP_IN" : "Pętla bez końca będzie kontynuowana, dopóki nie naciśniesz kwadratowego przycisku na Edisonie.",
	"ERROR_YELLOW_SET_MOTOR_LEFT" : "Blok set left motor włączy tylko lewy silnik. Upewnij się, że w programie używane są dodatkowe bloki do kontrolowania czasu trwania lewego silnika.",
	"ERROR_YELLOW_SET_MOTOR_RIGHT" : "Ustawienie bloku prawego silnika spowoduje włączenie tylko prawego silnika. Upewnij się, że w programie używane są dodatkowe bloki do sterowania czasem trwania prawego silnika.",
	"ERROR_YELLOW_SET_MOTOR_BOTH" : "Blok set both motors włączy tylko oba silniki. Upewnij się, że w programie używane są dodatkowe bloki do sterowania czasem trwania silnika.",
	"ERROR_YELLOW_CLAP_EVENT_DRIVE" : "Napędzanie silników generuje hałas, który może spowodować wyzwolenie zdarzenia klaskania. Może to spowodować wielokrotne wyzwalanie bloków zdarzeń klaskania podczas jazdy Edisona.",
	"ERROR_YELLOW_FLOAT_BLOCKS" : "Bloki niepodłączone do żółtego bloku zdarzeń lub bloku definicji funkcji nie zostaną zaprogramowane w Edison.",
	"ERROR_YELLOW_WAIT_TIME_LIGHT" : "Poziom światła zwróci bardzo wysoką wartość, co może spowodować, że Edison będzie czekał przez długi czas.",
	"ERROR_YELLOW_REPEAT_LOOP_LIGHT" : "Poziom światła zwróci bardzo wysoką wartość, co może spowodować, że Edison będzie zapętlony przez długi czas.",
	"ERROR_YELLOW_DRIVE_STRAIN" : "Blok wykrywania odkształcenia napędu wykryje odkształcenie tylko podczas pracy silników.",
	"ERROR_YELLOW_DRIVE_STRAIN_EVENT" : "Zdarzenie naprężenia napędu może zostać wyzwolone tylko podczas pracy silników.",
	"ERROR_YELLOW_COMMENT" : "Komentarze to notatki ułatwiające śledzenie zdarzeń. Bloki komentarzy nie zostaną zaprogramowane w Edison.",
	"ERROR_YELLOW_USB_USED" : "Bloki USB wymagają podłączenia Edisona do urządzenia, aby działały",
	"ERROR_YELLOW_CLEAR_SENSOR" : "Niektóre dane z czujników są przechowywane w pamięci Edisona. Może być konieczne wyczyszczenie danych czujnika, aby program działał poprawnie.",
	"ERROR_YELLOW_CLEAR_LEARN_MORE" : "Dowiedz się więcej",
	"MODAL_FIRMWARE_ERROR_TITLE" : "Błąd oprogramowania sprzętowego",
	"MODAL_FIRMWARE_ERROR_BODY_1" : "W twoim robocie Edison wykryto uszkodzony plik oprogramowania sprzętowego.",
	"MODAL_FIRMWARE_ERROR_BODY_2" : "Mogło to nastąpić podczas aktualizacji oprogramowania sprzętowego, która została przerwana.",
	"MODAL_FIRMWARE_ERROR_BODY_3" : "Nie panikuj! Możesz to naprawić, klikając przycisk Napraw oprogramowanie sprzętowe poniżej.",
	"MODAL_FIRMWARE_ERROR_CANCEL_BODY_1" : "Ostrzeżenie!",
	"MODAL_FIRMWARE_ERROR_CANCEL_BODY_2" : "Anulowanie tego procesu oznacza, że Twój robot Edison nie może zostać zaprogramowany.",
	"MODAL_FIRMWARE_ERROR_CANCEL_BODY_3" : "Zaleca się, aby naprawić oprogramowanie sprzętowe teraz, klikając przycisk Napraw oprogramowanie sprzętowe.",
	"MODAL_FIRMWARE_ERROR_CANCEL_BODY_4" : "Jeśli zdecydujesz się anulować, możesz naprawić oprogramowanie sprzętowe w późniejszym czasie.",
	"MODAL_FIRMWARE_ERROR_BUTTON_FIX" : "Napraw oprogramowanie układowe",
	"MODAL_FIRMWARE_ERROR_BUTTON_CANCEL" : "Anuluj",
	"MODAL_FIRMWARE_ERROR_BUTTON_CANCEL_CONFIRM" : "Potwierdź anulowanie",
	"MODAL_NEW_CONFIRM_HEADING" : "Czy na pewno?",
	"MODAL_NEW_CONFIRM_BODY_TEXT_1" : "Czy na pewno chcesz rozpocząć nowy program?",
	"MODAL_NEW_CONFIRM_BODY_TEXT_2" : "Wszelkie zmiany mogą zostać utracone!",
	"MODAL_NEW_CONFIRM_BUTTON_CANCEL" : "Anuluj",
	"MODAL_NEW_CONFIRM_BUTTON_PROCEED" : "Kontynuuj",
	"CHANGELANG" : "Zmień język",
	"HELP_TEXT_ALL_TITLE" : "Zablokuj pomoc",
	"HELP_TEXT_ALL_BLOCKS_EXAMPLE_USES" : "Przykładowe użycie:",
	"HELP_TEXT_ALL_BLOCKS_EXAMPLE_LOAD" : "Otwórz program",
	"HELP_TEXT_ALL_BLOCKS_WATCH_FOR" : "Uważaj na:",
	"HELP_TEXT_DRIVE_FORWARD_FOR_TITLE" : "do przodu dla",
	"HELP_TEXT_DRIVE_FORWARD_FOR_BODY_1" : "Blok for napędza koła, aby robot poruszał się w kierunku do przodu.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_BODY_2" : "Blok ma trzy parametry:",
	"HELP_TEXT_DRIVE_FORWARD_FOR_BODY_3" : "Wartość - Może być stałą (wpisaną do wejścia i nie zmienia się), zmienną, czujnikiem lub blokiem operatora.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_BODY_4" : "Jednostki - do wyboru są trzy opcje: cm, cale i sekundy.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_BODY_5" : "Prędkość - Prędkość może być wybrana z zakresu od 1 do 10 (jako wartość stała), zmienna, czujnik lub blok operatora.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_BODY_6" : "Blok przewijania do przodu zostanie zakończony przed uruchomieniem następnego bloku. Na przykład użycie bloku forwards for nie spowoduje uruchomienia innych bloków w programie w tym samym czasie. Aby to zrobić, zapoznaj się z sekcją Ustaw oba silniki na blok.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_1_TITLE" : "Przykład 1: Wyemituj sygnał dźwiękowy, a następnie przejedź robotem Edison do przodu o 15 cm z prędkością 1, a następnie ponownie wyemituj sygnał dźwiękowy.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_1_BODY_1" : "W tym przykładzie Edison emituje sygnał dźwiękowy, ale nie rozpoczyna jazdy, dopóki sygnał dźwiękowy nie zostanie odtworzony. Również drugi sygnał dźwiękowy nie rozpocznie się, dopóki Edison nie przestanie jechać.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_2_TITLE" : "Przykład 2: Ustawianie odległości jazdy przy użyciu zmiennej i danych z czujnika",
	"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_2_BODY_1" : "W tym przykładzie Edison ustawia zmienną Distance na poziom światła z lewego czujnika światła (wartość od 1 do 1000) podzielony przez 50. Następnie Edison jedzie do przodu dla wartości zmiennej (Distance) z prędkością 5. W rezultacie Edison jedzie dalej przy jaśniejszym świetle i jedzie krócej przy słabszym świetle.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_3_TITLE" : "Przykład 3: Zmiana prędkości jazdy przy użyciu zmiennej.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_3_BODY_1" : "W tym przykładowym programie zmienna Speed jest ustawiona na 1. Następnie program przechodzi do pętli powtarzanej 10 razy. W każdej pętli Edison przesuwa się o 5 cm do przodu z prędkością określoną w zmiennej. Początkowo wartość zmiennej Speed wynosi 1, więc Edison jedzie do przodu przez 5 cm z prędkością 1. Następny blok w powtórzeniu zwiększa (+1) zmienną Speed. W drugim powtórzeniu bloku do przodu wartość zmiennej Speed wynosi 2, więc Edison jedzie do przodu przez 5 cm z prędkością 2.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_3_BODY_2" : "Proces ten powtarza się pełne 10 razy w pętli powtarzania, powodując, że Edison jedzie coraz szybciej, aż do zatrzymania po zakończeniu programu.",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_TITLE" : "do tyłu dla",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_BODY_1" : "Blok backwards for napędza koła, aby przesunąć robota w kierunku do tyłu.",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_BODY_2" : "Blok ma trzy parametry:",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_BODY_3" : "Wartość - Może być stałą (wpisaną do wejścia i nie zmienia się), zmienną, czujnikiem lub blokiem operatora.",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_BODY_4" : "Jednostki - do wyboru są trzy opcje: cm, cale i sekundy.",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_BODY_5" : "Prędkość - Prędkość może być wybrana z zakresu od 1 do 10 (jako wartość stała), zmienna, czujnik lub blok operatora.",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_BODY_6" : "Blok backwards for zakończy się przed uruchomieniem następnego bloku. Na przykład, użycie bloku backwards for nie spowoduje uruchomienia innych bloków w programie w tym samym czasie. Aby to zrobić, ustaw oba silniki na blok.",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_EXAMPLE_1_TITLE" : "Przykład 1: Światła LED włączone podczas jazdy",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_EXAMPLE_1_BODY_1" : "W tym przykładowym programie lewa dioda LED włącza się i pozostaje włączona, gdy Edison jedzie do tyłu przez jedną sekundę. Lewa dioda LED zgaśnie, gdy Edison przestanie jechać. Następnie program odczekuje jedną sekundę przed zakończeniem.",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_EXAMPLE_2_TITLE" : "Przykład 2: Gdy pojawi się przeszkoda, jedź do tyłu",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_EXAMPLE_2_BODY_1" : "W tym przykładowym programie najpierw włączana jest wiązka wykrywania przeszkód. Następnie program przechodzi do pętli forever. Wewnątrz pętli blok wait until zatrzymuje program do momentu wykrycia przeszkody w dowolnym miejscu, a gdy to nastąpi, Edison jedzie do tyłu o jeden cal z prędkością 10. To zachowanie powtarza się w nieskończoność w pętli. Powoduje to, że Edison cofa się przed obiektami umieszczonymi przed nim.",
	"HELP_TEXT_DRIVE_LEFT_FOR_TITLE" : "w lewo dla",
	"HELP_TEXT_DRIVE_LEFT_FOR_BODY_1" : "Lewy blok for kieruje koła robota w lewą stronę.",
	"HELP_TEXT_DRIVE_LEFT_FOR_BODY_2" : "Blok ma cztery parametry:",
	"HELP_TEXT_DRIVE_LEFT_FOR_BODY_3" : "Ruch - do wyboru są trzy opcje: obrót, obrót do przodu i obrót do tyłu.",
	"HELP_TEXT_DRIVE_LEFT_FOR_BODY_4" : "Wartość - Może być stałą (wpisaną do wejścia i nie zmienia się), zmienną, czujnikiem lub blokiem operatora.",
	"HELP_TEXT_DRIVE_LEFT_FOR_BODY_5" : "Jednostki - do wyboru są dwie opcje: stopnie i sekundy.",
	"HELP_TEXT_DRIVE_LEFT_FOR_BODY_6" : "Prędkość - Prędkość może być wybrana z zakresu od 1 do 10 (jako wartość stała), zmienna, czujnik lub blok operatora.",
	"HELP_TEXT_DRIVE_LEFT_FOR_BODY_7" : "Skręcanie i obracanie jest dokładniejsze przy niższych prędkościach. Dzieje się tak, ponieważ koła mogą tracić przyczepność i ślizgać się przy dużych prędkościach. Prędkość 1 jest najlepsza, gdy wymagany jest dokładny skręt.",
	"HELP_TEXT_DRIVE_LEFT_FOR_BODY_8" : "Blok w lewo musi zostać ukończony, zanim uruchomiony zostanie następny blok. Na przykład użycie bloku left for nie spowoduje uruchomienia innych bloków w programie w tym samym czasie. Aby to zrobić, zapoznaj się z sekcją Ustaw oba silniki na blok.",
	"HELP_TEXT_DRIVE_LEFT_FOR_EXAMPLE_1_TITLE" : "Przykładowy program 1: beep, spin, beep",
	"HELP_TEXT_DRIVE_LEFT_FOR_EXAMPLE_1_BODY_1" : "W tym przykładowym programie Edison emituje sygnał dźwiękowy, ale nie zaczyna się obracać, dopóki sygnał dźwiękowy nie zostanie odtworzony. Również drugi sygnał dźwiękowy nie rozpocznie się, dopóki Edison nie przestanie się obracać.",
	"HELP_TEXT_DRIVE_LEFT_FOR_EXAMPLE_2_TITLE" : "Przykładowy program 2: Jedź w kwadracie",
	"HELP_TEXT_DRIVE_LEFT_FOR_EXAMPLE_2_BODY_1" : "W tym przykładowym programie pętla powtarza jazdę do przodu przez 10 cm z prędkością 1 i czterokrotny obrót w lewo o 90 stopni. Powoduje to, że Edison jedzie w kształcie kwadratu.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_TITLE" : "prawo dla",
	"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_1" : "Prawy blok for napędza koła, aby przesunąć robota w lewą stronę.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_2" : "Blok ma cztery parametry:",
	"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_3" : "Ruch - do wyboru są trzy opcje: obrót, obrót do przodu i obrót do tyłu.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_4" : "Wartość - Może być stałą (wpisaną do wejścia i nie zmienia się), zmienną, czujnikiem lub blokiem operatora.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_5" : "Jednostki - do wyboru są dwie opcje: stopnie i sekundy.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_6" : "Prędkość - Prędkość może być wybrana z zakresu od 1 do 10 (jako wartość stała), zmienna, czujnik lub blok operatora.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_7" : "Skręcanie i obracanie jest dokładniejsze przy niższych prędkościach. Dzieje się tak, ponieważ koła mogą tracić przyczepność i ślizgać się przy dużych prędkościach. Prędkość 1 jest najlepsza, gdy wymagany jest dokładny skręt.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_8" : "Prawy blok musi się zakończyć, zanim uruchomiony zostanie następny blok. Na przykład użycie prawego bloku for nie spowoduje uruchomienia innych bloków w programie w tym samym czasie. Aby to zrobić, zobacz Ustaw oba silniki na blok.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_EXAMPLE_1_TITLE" : "Przykładowy program 1: Beep, spin, beep",
	"HELP_TEXT_DRIVE_RIGHT_FOR_EXAMPLE_1_BODY_1" : "W tym przykładzie Edison wydaje sygnał dźwiękowy, ale nie zaczyna się obracać, dopóki sygnał dźwiękowy nie zostanie odtworzony. Również drugi sygnał dźwiękowy nie rozpocznie się, dopóki Edison nie przestanie się obracać.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_EXAMPLE_2_TITLE" : "Przykład 2: Kręć w prawo z prędkością kontrolowaną przez poziom oświetlenia",
	"HELP_TEXT_DRIVE_RIGHT_FOR_EXAMPLE_2_BODY_1" : "W tym przykładzie Edison obraca się w prawo wewnątrz pętli forever. Za każdym razem, gdy uruchamiany jest blok for, Edison obraca się o 1 stopień. Prędkość jest ustawiana na podstawie odczytu poziomu światła z lewego czujnika światła (od 1 do 1000) i dzielona przez 100 (wynik od 0 do 10). W rezultacie Edison obraca się szybciej przy jaśniejszym świetle i wolniej przy słabszym.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_EXAMPLE_3_TITLE" : "Przykładowy program 3: Omijaj przeszkody",
	"HELP_TEXT_DRIVE_RIGHT_FOR_EXAMPLE_3_BODY_1" : "W tym przykładowym programie wiązka wykrywania przeszkód jest włączona. Następnie program przechodzi do wiecznej pętli, w której oba silniki są ustawione na jazdę do przodu. Następnie program czeka, aż w dowolnym miejscu zostanie wykryta przeszkoda. Gdy to nastąpi, program przechodzi do następnego bloku, a robot Edison obraca się w prawo o 180 stopni z prędkością 1. Powoduje to, że Edison odjeżdża od przeszkód na swojej drodze.",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_TITLE" : "do przodu do",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_BODY_1" : "Blok forwards until powoduje, że koła poruszają robota w kierunku do przodu, dopóki określony warunek nie zostanie spełniony. Gdy określony warunek jest spełniony, koła zatrzymują się, a program przechodzi do następnego bloku.",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_BODY_2" : "Blok ma dwa parametry:",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_BODY_3" : "Wejście warunkowe - wejście warunkowe akceptuje blok w kształcie rombu, który może być blokiem czujnika lub operatora.",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_BODY_4" : "Prędkość - prędkość może być wybrana z zakresu od 1 do 10 (jako wartość stała), zmienna, czujnik lub blok operatora.",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_BODY_5" : "Blok przewijania do przodu musi zostać ukończony przed uruchomieniem następnego bloku. Na przykład użycie bloku do przodu nie spowoduje uruchomienia innych bloków w programie w tym samym czasie. Aby to zrobić, zapoznaj się z sekcją Ustaw oba silniki na blok.",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_EXAMPLE_1_TITLE" : "Przykładowy program 1: Zatrzymaj się przed przeszkodą",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_EXAMPLE_1_BODY_1" : "W tym przykładowym programie wiązka wykrywania przeszkód jest włączona, a następnie robot jedzie do przodu z prędkością 5 do momentu wykrycia przeszkody. Gdy to nastąpi, robot zatrzyma się i program zostanie zakończony.",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_EXAMPLE_2_TITLE" : "Przykładowy program 2: Odbijanie w granicach",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_EXAMPLE_2_BODY_1" : "W tym przykładowym programie dioda LED śledzenia linii jest włączona, a następnie program wchodzi w pętlę na zawsze. Wewnątrz pętli blok ''naprzód, aż'' kieruje robota do przodu z prędkością 1, aż tracker linii znajdzie się na nieodblaskowej powierzchni (tj. czarnej). Gdy tak się stanie, uruchomiony zostanie następny blok, który obróci robota w lewo o 180 stopni z prędkością 5. Następnie program zapętli się z powrotem do bloku forwards until. Powoduje to, że Edison odjeżdża od wykrytych czarnych linii.",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_TITLE" : "do tyłu do",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_BODY_1" : "Blok backwards until powoduje, że koła poruszają robota w kierunku do tyłu, dopóki określony warunek nie zostanie spełniony. Gdy określony warunek jest spełniony, koła zatrzymują się, a program przechodzi do następnego bloku.",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_BODY_2" : "Blok ma dwa parametry:",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_BODY_3" : "Wejście warunkowe - wejście warunkowe akceptuje blok w kształcie rombu, który może być blokiem czujnika lub operatora.",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_BODY_4" : "Prędkość - Prędkość może być wybrana z zakresu od 1 do 10 (jako wartość stała), zmienna, czujnik lub blok operatora.",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_BODY_5" : "Blok backwards until musi zostać ukończony przed uruchomieniem następnego bloku. Na przykład użycie bloku backwards until nie spowoduje uruchomienia innych bloków w programie w tym samym czasie. Aby to zrobić, zapoznaj się z sekcją Ustaw oba silniki na blok.",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_EXAMPLE_1_TITLE" : "Przykładowy program 1: Zatrzymaj, gdy napęd jest obciążony",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_EXAMPLE_1_BODY_1" : "W tym przykładowym programie robot jedzie do tyłu z prędkością 10, aż koła zostaną naprężone (nie będą w stanie się obracać lub utkną). Gdy to nastąpi, silniki zatrzymają się i program zostanie zakończony.",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_EXAMPLE_2_TITLE" : "Przykładowy program 2: Sterowanie napędem za pomocą przycisków",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_EXAMPLE_2_BODY_1" : "W tym przykładzie program rozpoczyna się od pętli forever. Pierwszy blok w pętli czeka, aż zostanie naciśnięty przycisk trójkąta. Gdy to nastąpi, robot jedzie do tyłu z prędkością 1 do momentu naciśnięcia okrągłego przycisku. Gdy to nastąpi, koła robota zatrzymają się, a program powróci do oczekiwania na naciśnięcie przycisku trójkąta.",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_TITLE" : "w lewo do",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_BODY_1" : "Blok ''left until'' powoduje, że koła poruszają robota w lewą stronę, dopóki określony warunek nie zostanie spełniony. Po spełnieniu określonego warunku koła zatrzymują się, a program przechodzi do następnego bloku.",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_BODY_2" : "Blok ma trzy parametry:",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_BODY_3" : "Ruch - do wyboru są trzy opcje: obrót, obrót do przodu i obrót do tyłu.",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_BODY_4" : "Wejście warunkowe - wejście warunkowe akceptuje blok w kształcie rombu, który może być blokiem czujnika lub operatora.",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_BODY_5" : "Prędkość - Prędkość może być wybrana z zakresu od 1 do 10 (jako wartość stała), zmienna, czujnik lub blok operatora.",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_BODY_6" : "Blok ''spin left until'' musi zostać ukończony przed uruchomieniem następnego bloku. Na przykład, użycie bloku spin left until nie spowoduje uruchomienia innych bloków w programie w tym samym czasie. Aby to zrobić, ustaw oba silniki na blok.",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_EXAMPLE_1_TITLE" : "Przykładowy program 1: Zatrzymaj, gdy napęd jest obciążony",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_EXAMPLE_1_BODY_1" : "W tym przykładowym programie robot jedzie do przodu w lewo (prawe koło porusza się) z prędkością 1, dopóki koło nie zostanie naprężone (nie będzie w stanie się obracać lub utknie). Gdy to nastąpi, silnik zatrzyma się i program zostanie zakończony.",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_EXAMPLE_2_TITLE" : "Przykładowy program 2: Podążaj za światłem",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_EXAMPLE_2_BODY_1" : "W tym przykładzie program rozpoczyna się od pętli forever. Pierwszy blok w pętli obraca robota w lewo z prędkością 5, aż poziom lewego światła będzie mniejszy niż poziom prawego światła. Gdy to nastąpi, silnik zatrzyma się i uruchomiony zostanie następny blok. Następny blok obraca robota w prawo z prędkością 5, aż poziom lewego światła będzie większy niż poziom prawego światła. W rezultacie robot Edisona jedzie w kierunku światła.",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_TITLE" : "w prawo do",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_BODY_1" : "Blok right until napędza koła, aby robot poruszał się we właściwym kierunku, dopóki określony warunek nie zostanie spełniony. Gdy określony warunek jest spełniony, koła zatrzymują się, a program przechodzi do następnego bloku.",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_BODY_2" : "Blok ma trzy parametry:",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_BODY_3" : "Ruch - do wyboru są trzy opcje: obrót, obrót do przodu i obrót do tyłu.",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_BODY_4" : "Wejście warunkowe - wejście warunkowe akceptuje blok w kształcie rombu, który może być blokiem czujnika lub operatora.",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_BODY_5" : "Prędkość - Prędkość może być wybrana z zakresu od 1 do 10 (jako wartość stała), zmienna, czujnik lub blok operatora.",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_BODY_6" : "Blok right until musi zostać ukończony przed uruchomieniem następnego bloku. Na przykład użycie bloku spin right until nie spowoduje uruchomienia innych bloków w programie w tym samym czasie. Aby to zrobić, zapoznaj się z sekcją Ustaw oba silniki na blok.",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_EXAMPLE_1_TITLE" : "Przykładowy program 1: Zatrzymaj się na czarnej powierzchni",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_EXAMPLE_1_BODY_1" : "W tym przykładzie zaprogramuj, że robot obraca się w prawo z prędkością 5, aż tracker linii wykryje nieodblaskową powierzchnię (czarną). Gdy to nastąpi, silnik zatrzyma się i program zostanie zakończony.",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_EXAMPLE_2_TITLE" : "Przykładowy program 2: Podążaj za światłem",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_EXAMPLE_2_BODY_1" : "W tym przykładzie program rozpoczyna się od pętli forever. Pierwszy blok w pętli obraca robota w lewo z prędkością 5, aż poziom lewego światła będzie mniejszy niż poziom prawego światła. Gdy to nastąpi, silnik zatrzyma się i uruchomiony zostanie następny blok. Następny blok obraca robota w prawo z prędkością 5, aż poziom lewego światła będzie większy niż poziom prawego światła. W rezultacie robot Edisona jedzie w kierunku światła.",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_TITLE" : "Ustaw oba silniki na",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_BODY_1" : "Blok ustaw oba silniki na napędza koła, aby robot poruszał się w wybranym kierunku i z wybraną prędkością. Ponieważ ten blok napędu ustawia silniki, program może być kontynuowany bezpośrednio do następnego bloku. Różni się to od bloków napędu, które mają do pokonania odległość, czas lub kąt, zanim program przejdzie do następnego bloku.",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_BODY_2" : "Blok ma dwa parametry:",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_BODY_3" : "Ruch - do wyboru jest sześć opcji: jazda do przodu, jazda do tyłu, obrót robota w lewo, obrót robota w prawo, obrót robota w lewo i obrót robota w prawo.",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_BODY_4" : "Prędkość - Prędkość może być wybrana z zakresu od 1 do 10 (jako wartość stała), zmienna, czujnik lub blok operatora.",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_EXAMPLE_1_TITLE" : "Przykładowy program 1: Muzyka podczas jazdy",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_EXAMPLE_1_BODY" : "W tym przykładowym programie robot Edison jest ustawiony na jazdę do przodu, a następnie odtwarzane są trzy nuty, podczas gdy robot nadal jedzie. Po zakończeniu odtwarzania ostatniej nuty program kończy się, a robot Edison zatrzymuje jazdę.",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_EXAMPLE_2_TITLE" : "Przykładowy program 2: Jedź do przeszkody",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_EXAMPLE_2_BODY" : "W tym przykładowym programie wiązka wykrywania przeszkód jest włączona, a następnie oba silniki są ustawione na jazdę do przodu z prędkością 8. Następny blok czeka, aż zostanie wykryta jakakolwiek przeszkoda. Gdy to nastąpi, program kończy się i robot przestaje jechać.",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_EXAMPLE_3_TITLE" : "Przykładowy program 3: Podążaj za linią",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_EXAMPLE_3_BODY" : "W tym przykładowym programie dioda LED śledzenia linii jest włączona, a program wchodzi w pętlę na zawsze. Wewnątrz pętli oba silniki są ustawione tak, aby obrócić robota w lewo z prędkością 1, a następnie blok wait until zatrzymuje program w tym miejscu, aż tracker linii wykryje powierzchnię odbijającą światło (białą). Gdy tak się stanie, oba silniki są następnie ustawiane na obrót robota w prawo z prędkością 1, a blok wait until utrzymuje program w tym miejscu do momentu, aż tracker linii wykryje nieodblaskową powierzchnię (czarną). Gdy tak się stanie, program powraca do początku pętli forever i powtarza ją. Powoduje to, że Edison podąża za nieodblaskową linią.",
	"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_TITLE" : "ustaw prawy silnik na",
	"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_BODY_1" : "Blok set right motor to napędza koła, aby robot poruszał się w wybranym kierunku i z wybraną prędkością. Gdy ten blok napędu ustawia silniki, program może przejść bezpośrednio do następnego bloku. Różni się to od bloków napędowych, które mają odległość, czas lub kąt do wykonania, zanim program przejdzie do następnego bloku.",
	"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_BODY_2" : "Blok ma dwa parametry:",
	"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_BODY_3" : "Ruch - dostępne są dwie opcje: do przodu i do tyłu.",
	"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_BODY_4" : "Prędkość - Prędkość może być wybrana z zakresu od 1 do 10 (jako wartość stała), zmienna, czujnik lub blok operatora.",
	"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_EXAMPLE_1_TITLE" : "Przykładowy program 1: Włączanie i wyłączanie silnika za pomocą przycisku",
	"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_EXAMPLE_1_BODY" : "W tym przykładzie program wchodzi w pętlę forever. Pierwszy blok w pętli czeka, aż zostanie naciśnięty okrągły przycisk. Gdy to nastąpi, prawy silnik zostanie ustawiony na jazdę do przodu z prędkością 5, a następnie program przejdzie do kolejnego bloku oczekiwania na naciśnięcie okrągłego przycisku. Gdy to nastąpi, prawy silnik zostanie zatrzymany, a program powróci do początku pętli forever.",
	"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_TITLE" : "ustaw lewy silnik na",
	"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_BODY_1" : "Blok set left motor to napędza koła, aby robot poruszał się w wybranym kierunku i z wybraną prędkością. Ponieważ ten blok napędu ustawia silniki, program może przejść bezpośrednio do następnego bloku. Różni się to od bloków napędowych, które mają określoną odległość, czas lub kąt do wykonania, zanim program przejdzie do następnego bloku.",
	"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_BODY_2" : "Blok ma dwa parametry:",
	"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_BODY_3" : "Ruch - dostępne są dwie opcje: do przodu i do tyłu.",
	"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_BODY_4" : "Prędkość - Prędkość może być wybrana z zakresu od 1 do 10 (jako wartość stała), zmienna, czujnik lub blok operatora.",
	"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_EXAMPLE_1_TITLE" : "Przykładowy program 1: Podążanie za światłem",
	"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_EXAMPLE_1_BODY" : "W tym przykładzie program wchodzi w pętlę forever. Pierwszy blok w pętli ustawia lewy silnik do przodu z obliczoną prędkością. Obliczona prędkość to poziom światła z prawego czujnika minus poziom światła z lewego czujnika podzielony przez 100, 3 jest również dodawane do wyniku, aby ustawić minimalną prędkość. Następny blok ustawia prawy silnik na jazdę do przodu z obliczoną prędkością. Obliczona prędkość to poziom światła z lewego czujnika minus poziom światła z prawego czujnika podzielony przez 100, 3 jest również dodawane do wyniku, aby ustawić minimalną prędkość. Następnie program powraca do początku pętli forever. Obliczone wyniki kontrolują prędkość w taki sposób, że strona z najmniejszą ilością światła jedzie najszybciej. Powoduje to, że robot Edison zawsze stara się jechać w kierunku najjaśniejszego światła.",
	"HELP_TEXT_DRIVE_STOP_TITLE" : "stop",
	"HELP_TEXT_DRIVE_STOP_BODY_1" : "Blok zatrzymania zatrzymuje silniki przed napędzaniem kół.",
	"HELP_TEXT_DRIVE_STOP_BODY_2" : "Blok zatrzymania ma tylko jeden parametr do wyboru silnika/silników, które zostaną zatrzymane. Dostępne opcje to oba silniki, lewy silnik i prawy silnik.",
	"HELP_TEXT_DRIVE_STOP_EXAMPLE_1_TITLE" : "Przykładowy program 1: Włączanie i wyłączanie silnika za pomocą przycisku",
	"HELP_TEXT_DRIVE_STOP_EXAMPLE_1_BODY" : "W tym przykładzie program wchodzi w pętlę forever. Pierwszy blok w pętli czeka, aż zostanie naciśnięty okrągły przycisk. Gdy to nastąpi, prawy silnik zostanie ustawiony na jazdę do przodu z prędkością 5, a następnie program przejdzie do kolejnego bloku oczekiwania na naciśnięcie okrągłego przycisku. Gdy to nastąpi, prawy silnik zostanie zatrzymany, a program powróci do początku pętli forever.",
	"HELP_TEXT_LEDS_LEFT_TITLE" : "obróć lewą diodę LED",
	"HELP_TEXT_LEDS_LEFT_BODY_1" : "Blok Turn left LED steruje lewą diodą LED. Dostępne są dwie opcje: włączona lub wyłączona.",
	"HELP_TEXT_LEDS_LEFT_EXAMPLE_1_TITLE" : "Przykładowy program 1: Mrugnij raz lewą diodą LED",
	"HELP_TEXT_LEDS_LEFT_EXAMPLE_1_BODY" : "W tym przykładzie program rozpoczyna się od włączenia lewej diody LED, następnie odczekuje jedną sekundę, po czym wyłącza lewą diodę LED.",
	"HELP_TEXT_LEDS_LEFT_EXAMPLE_2_TITLE" : "Przykładowy program 2: Mrugaj lewą diodą LED w nieskończoność",
	"HELP_TEXT_LEDS_LEFT_EXAMPLE_2_BODY" : "W tym przykładzie program rozpoczyna się od wejścia w pętlę forever. Wewnątrz pętli lewa dioda LED jest włączana, następnie program czeka przez jedną sekundę, następnie lewa dioda LED jest wyłączana, następnie program czeka przez jedną sekundę, następnie program przeskakuje do początku pętli i powtarza w nieskończoność.",
	"HELP_TEXT_LEDS_RIGHT_TITLE" : "obróć prawą diodę LED",
	"HELP_TEXT_LEDS_RIGHT_BODY_1" : "Blok Turn Right LED kontroluje prawą diodę LED. Dostępne są dwie opcje: włączona lub wyłączona.",
	"HELP_TEXT_LEDS_RIGHT_EXAMPLE_1_TITLE" : "Przykładowy program 1: Mrugnij raz prawą diodą LED",
	"HELP_TEXT_LEDS_RIGHT_EXAMPLE_1_BODY" : "W tym przykładzie program rozpoczyna się od włączenia prawej diody LED, następnie odczekuje jedną sekundę, po czym wyłącza prawą diodę LED.",
	"HELP_TEXT_LEDS_RIGHT_EXAMPLE_2_TITLE" : "Przykładowy program 2: Mrugaj prawą diodą LED w nieskończoność",
	"HELP_TEXT_LEDS_RIGHT_EXAMPLE_2_BODY" : "W tym przykładzie program rozpoczyna się od wejścia w pętlę forever. Wewnątrz pętli prawa dioda LED jest włączana, następnie program czeka przez jedną sekundę, następnie prawa dioda LED jest wyłączana, następnie program czeka przez jedną sekundę, następnie program przeskakuje do początku pętli i powtarza w nieskończoność.",
	"HELP_TEXT_LEDS_SEND_MESSAGE_TITLE" : "wyślij wiadomość IR",
	"HELP_TEXT_LEDS_SEND_MESSAGE_BODY_1" : "Blok wysyłania wiadomości IR wysyła dane za pomocą światła podczerwonego (IR). Dane, które mogą być wysyłane to wartości od 0 do 255. Wartość może być stałą (wpisaną na wejściu i nie zmieniającą się), zmienną, czujnikiem lub blokiem operatora.",
	"HELP_TEXT_LEDS_SEND_MESSAGE_BODY_2" : "Wysłane dane mogą zostać odebrane przez dowolnego innego robota Edison, który znajduje się w zasięgu sygnału podczerwieni. Maksymalny zasięg może wynosić do 10 metrów w idealnych warunkach (tj. w pomieszczeniu, bez bezpośredniego światła słonecznego, biały sufit i ściany, od których odbija się światło podczerwone).",
	"HELP_TEXT_LEDS_SEND_MESSAGE_BODY_3" : "Jeśli używasz zmiennej, liczba w zmiennej może przekroczyć limit 255 (8 bitów). Gdy tak się stanie, liczba wysyłana przez IR zostanie ''zawinięta'' (tj. 256 wysyła 0, 257 wysyła 1, 258 wysyła 2...).",
	"HELP_TEXT_LEDS_SEND_MESSAGE_EXAMPLE_1_TITLE" : "Przykładowy program 1: Wyślij wiadomość IR 1 po naciśnięciu okrągłego przycisku",
	"HELP_TEXT_LEDS_SEND_MESSAGE_EXAMPLE_1_BODY" : "W tym przykładzie program rozpoczyna się od wejścia w pętlę forever. Wewnątrz pętli program czeka na naciśnięcie okrągłego przycisku. Gdy to nastąpi, wysyłany jest komunikat IR 1. Następnie program powraca do początku pętli forever.",
	"HELP_TEXT_LEDS_SEND_MESSAGE_EXAMPLE_2_TITLE" : "Przykładowy program 2: Wysyłaj poziom światła co jedną sekundę",
	"HELP_TEXT_LEDS_SEND_MESSAGE_EXAMPLE_2_BODY" : "W tym przykładzie program rozpoczyna się od wejścia w pętlę forever. Wewnątrz pętli program wysyła odczyt poziomu światła z lewego czujnika światła podzielony przez cztery. Wartość jest dzielona przez cztery, ponieważ wyjście z czujnika światła wynosi od 1 do 1000, ale najwyższą liczbą, jaką można wysłać za pomocą podczerwieni, jest 255 (1000/4 = 250). To dodatkowe obliczenie umożliwia wysłanie pełnego zakresu czujnika światła. Następnie program czeka przez jedną sekundę, a następnie powraca do początku pętli forever.",
	"HELP_TEXT_SOUND_BEEP_TITLE" : "sygnał dźwiękowy",
	"HELP_TEXT_SOUND_BEEP_BODY_1" : "Blok sygnału dźwiękowego odtwarza sygnał dźwiękowy o częstotliwości 3,5 kHz przez 125 ms (0,125 sekundy).",
	"HELP_TEXT_SOUND_BEEP_EXAMPLE_1_TITLE" : "Przykładowy program 1: Sygnał dźwiękowy po naciśnięciu okrągłego przycisku",
	"HELP_TEXT_SOUND_BEEP_EXAMPLE_1_BODY" : "W tym przykładzie program rozpoczyna się od wejścia w pętlę forever. Wewnątrz pętli program czeka na naciśnięcie okrągłego przycisku. Gdy to nastąpi, zostanie odtworzony sygnał dźwiękowy. Następnie program powraca do początku pętli forever i powtarza tę czynność.",
	"HELP_TEXT_SOUND_PLAY_NOTE_TITLE" : "play a note",
	"HELP_TEXT_SOUND_PLAY_NOTE_BODY_1" : "Blok play a note odtwarza nutę muzyczną. Parametry bloku umożliwiają wybór długości, nuty i typu nuty.",
	"HELP_TEXT_SOUND_PLAY_NOTE_BODY_2" : "Blok ma trzy parametry:",
	"HELP_TEXT_SOUND_PLAY_NOTE_BODY_3" : "Długość - dostępne są cztery opcje: cała, połowa, ćwierćnuta i ósemka.",
	"HELP_TEXT_SOUND_PLAY_NOTE_BODY_4" : "Nuta - dostępnych jest dziesięć opcji: C, B, A, G, F, E, D, środkowe C, niskie B i reszta.",
	"HELP_TEXT_SOUND_PLAY_NOTE_BODY_5" : "Modyfikator nuty - dostępne są trzy opcje: - (niemodyfikowana), ostra i płaska.",
	"HELP_TEXT_SOUND_PLAY_NOTE_BODY_6" : "Blok odtwarzania nuty musi zostać ukończony przed uruchomieniem następnego bloku. Na przykład, użycie bloku play a note nie spowoduje uruchomienia innych bloków w programie w tym samym czasie. Aby to zrobić, zobacz blok odtwarzania muzyki w tle.",
	"HELP_TEXT_SOUND_PLAY_NOTE_EXAMPLE_1_TITLE" : "Przykładowy program 1: Mary miała małą owieczkę",
	"HELP_TEXT_SOUND_PLAY_NOTE_EXAMPLE_1_BODY" : "W tym przykładzie program rozpoczyna się od ustawienia tempa dla nut, a następnie odtwarza nuty rymowanki Mary had a little lamb w kolejności, odtwarzając każdą nutę w całości przed przejściem dalej.",
	"HELP_TEXT_SOUND_SET_TEMPO_TITLE" : "Ustaw tempo muzyki na",
	"HELP_TEXT_SOUND_SET_TEMPO_BODY_1" : "Opcja set music temp to block ustawia tempo, w jakim odtwarzane są kolejne nuty.",
	"HELP_TEXT_SOUND_SET_TEMPO_BODY_2" : "Dostępnych jest pięć opcji: bardzo wolne, wolne, średnie, szybkie i bardzo szybkie.",
	"HELP_TEXT_SOUND_SET_TEMPO_EXAMPLE_1_TITLE" : "Przykładowy program 1: Mary miała małą owieczkę",
	"HELP_TEXT_SOUND_SET_TEMPO_EXAMPLE_1_BODY" : "W tym przykładzie program rozpoczyna od ustawienia tempa dla nut, a następnie odtwarza nuty rymowanki Mary had a little lamb z tą prędkością, odtwarzając każdą nutę w całości przed przejściem dalej.",
	"HELP_TEXT_SOUND_PLAYINBACKGROUND_TITLE" : "Odtwarzanie muzyki w tle",
	"HELP_TEXT_SOUND_PLAYINBACKGROUND_BODY_1" : "Blok odtwarzania muzyki w tle umożliwia odtwarzanie nut umieszczonych wewnątrz bloku, podczas gdy robot Edison wykonuje inne części programu.",
	"HELP_TEXT_SOUND_PLAYINBACKGROUND_EXAMPLE_1_TITLE" : "Przykładowy program 1: Mary miała małą owieczkę podczas tańca",
	"HELP_TEXT_SOUND_PLAYINBACKGROUND_EXAMPLE_1_BODY" : "W tym przykładowym programie program rozpoczyna się od ustawienia tempa dla nut, następnie nuty wewnątrz bloku odtwarzania muzyki w tle zaczynają grać, program wchodzi w pętlę powtarzania, a bloki obracania w lewo i obracania w prawo działają cztery razy z melodią nadal odtwarzaną w tle. Powoduje to, że Edison tańczy podczas odtwarzania muzyki.",
	"HELP_TEXT_VARIABLE_TITLE" : "Zmienna",
	"HELP_TEXT_VARIABLE_BODY_1" : "Blok zmiennej to miejsce, w którym dane mogą być przechowywane i używane przez program. Dane w zmiennej mogą się różnić i zmieniać podczas działania programu. Dlatego właśnie nazywana jest zmienną.",
	"HELP_TEXT_VARIABLE_BODY_2" : "Dane w zmiennej są liczbami z zakresu od -1,073,741,824 do 1,073,741,823 (32-bitowe ze znakiem).",
	"HELP_TEXT_VARIABLE_BODY_3" : "Zmienne należy dostosować, nadając im nazwę, która ma sens dla programu. Na przykład:",
	"HELP_TEXT_VARIABLE_BODY_4" : "Jeśli liczba w zmiennej przekroczy zakres od -1,073,741,824 do 1,073,741,823, program zostanie zatrzymany, a Edison odtworzy sygnał błędu.",
	"HELP_TEXT_VARIABLE_EXAMPLE_1_TITLE" : "Przykładowy program 1: Losowa częstotliwość błysków ustawiona na początku programu",
	"HELP_TEXT_VARIABLE_EXAMPLE_1_BODY_1" : "W tym przykładowym programie zmienna ''FlashRate'' jest ustawiona na losową liczbę od 10 do 100. Następnie program przechodzi do pętli forever. Wewnątrz pętli włączane są lewa i prawa dioda LED, następnie program czeka na wartość milisekundową w ''FlashRate'', następnie wyłącza lewą i prawą diodę LED, a następnie program ponownie czeka na wartość milisekundową w ''FlashRate''. Następnie program powraca do początku pętli forever i powtarza. Powoduje to, że Edison miga diodami LED z różną prędkością za każdym razem, gdy program jest uruchamiany",
	"HELP_TEXT_VARIABLE_EXAMPLE_2_TITLE" : "Przykładowy program 2: Zliczanie przejechanych czarnych linii",
	"HELP_TEXT_VARIABLE_EXAMPLE_2_BODY_1" : "W tym przykładowym programie najpierw włączana jest dioda LED line trackera, a następnie robot Edison jedzie do przodu przez 30 cm z prędkością 5. Podczas jazdy do przodu każda wykryta nieodblaskowa (czarna) powierzchnia przez line tracker spowoduje, że program przejdzie do bloku zdarzeń Line tracker on non-reflective surface. Gdy tak się stanie, zmienna ''LineCount'' zostanie zwiększona (+1). Po przejechaniu 30 cm program powtarza bloki oczekiwania przez 1 sekundę i sygnału dźwiękowego określoną liczbę razy w zmiennej ''LineCount''.",
	"HELP_TEXT_VARIABLE_EXAMPLE_3_TITLE" : "Przykładowy program 3: Licznik promieniowania świetlnego",
	"HELP_TEXT_VARIABLE_EXAMPLE_3_BODY_1" : "W tym przykładowym programie tempo muzyki jest najpierw ustawione na bardzo szybkie. Następnie program przechodzi do pętli forever. Wewnątrz pętli program ustawia zmienną ''Delay'' na 1000 minus lewy poziom światła (odwracając odczyt poziomu światła). Następny blok czeka na wartość w zmiennej ''Delay''. Następnie program odtwarza nutę C i powraca do początku pętli forever i powtarza. Wynikiem tego programu jest to, że Edison będzie emitował sygnał dźwiękowy powoli, gdy jest ciemno i szybciej, gdy poziom światła jest jaśniejszy.",
	"HELP_TEXT_DATA_SETVARIABLETO_TITLE" : "set to",
	"HELP_TEXT_DATA_SETVARIABLETO_BODY_1" : "Blok set to służy do ustawiania wartości w zmiennej.",
	"HELP_TEXT_DATA_SETVARIABLETO_BODY_2" : "Dostępne są dwa wejścia:",
	"HELP_TEXT_DATA_SETVARIABLETO_BODY_3" : "Zmienna - w tym miejscu umieszczany jest blok zmiennej.",
	"HELP_TEXT_DATA_SETVARIABLETO_BODY_4" : "Wartość - Może być stałą (wpisaną do wejścia i nie zmienia się), zmienną, czujnikiem lub blokiem operatora.",
	"HELP_TEXT_DATA_SETVARIABLETO_EXAMPLE_1_TITLE" : "Przykładowy program 1: Ustaw liczbę sygnałów dźwiękowych",
	"HELP_TEXT_DATA_SETVARIABLETO_EXAMPLE_1_BODY_1" : "W tym przykładowym programie zmienna ''NumberOfBeeps'' jest ustawiona na 5, a następnie blok repeat powtarza sygnał dźwiękowy dla wartości 5 przechowywanej w zmiennej ''NumberOfBeeps''.",
	"HELP_TEXT_DATA_SETVARIABLETO_EXAMPLE_2_TITLE" : "Przykładowy program 2: Losowa częstotliwość migania ustawiona na początku programu",
	"HELP_TEXT_DATA_SETVARIABLETO_EXAMPLE_2_BODY_1" : "W tym przykładowym programie zmienna ''FlashRate'' jest ustawiona na losową liczbę z zakresu od 10 do 1000. Następnie program przechodzi do pętli forever. Wewnątrz pętli włączane są lewa i prawa dioda LED, następnie program czeka na wartość milisekundową w ''FlashRate'', następnie wyłącza lewą i prawą diodę LED, a następnie program ponownie czeka na wartość milisekundową w ''FlashRate''. Następnie program powraca do początku pętli forever i powtarza. Powoduje to, że Edison miga diodami LED z różną prędkością za każdym razem, gdy program jest uruchamiany",
	"HELP_TEXT_DATA_SETVARIABLETO_EXAMPLE_3_TITLE" : "Przykładowy program 3: Podążaj za światłem",
	"HELP_TEXT_DATA_SETVARIABLETO_EXAMPLE_3_BODY_1" : "W tym przykładzie program rozpoczyna się od wejścia w pętlę forever. Wewnątrz pętli program ustawia zmienną ''LightLeftvsRight'' na poziom światła lewego minus poziom światła prawego. Następnie blok if else sprawdza, czy wartość w zmiennej ''LightLeftvsRight'' jest większa niż 0. Jeśli wynik jest prawdziwy, prawy silnik jest ustawiony na jazdę do przodu, a lewy silnik jest zatrzymany. Jeśli wynik jest fałszywy, lewy silnik zostanie ustawiony na jazdę do przodu, a prawy silnik zostanie zatrzymany. Następnie program powraca do początku pętli forever i powtarza. Powoduje to, że Edison jedzie w kierunku najjaśniejszego źródła światła.",
	"HELP_TEXT_DATA_INCVARIABLE_TITLE" : "inkrementacja",
	"HELP_TEXT_DATA_INCVARIABLE_BODY_1" : "Blok inkrementacji inkrementuje (dodaje 1) do zmiennej umieszczonej w bloku.",
	"HELP_TEXT_DATA_INCVARIABLE_EXAMPLE_1_TITLE" : "Przykładowy program 1: Zwalnianie migania",
	"HELP_TEXT_DATA_INCVARIABLE_EXAMPLE_1_BODY_1" : "W tym przykładowym programie zmienna ''Delay'' jest ustawiona na 0, a następnie program przechodzi do pętli forever. Wewnątrz pętli zmienna ''Delay'' jest zwiększana (+1), następnie prawa dioda LED jest włączana, a lewa dioda LED jest wyłączana, następnie program czeka na wartość w zmiennej ''Delay'' w milisekundach, następnie prawa dioda LED jest wyłączana, a lewa dioda LED jest włączana, a następnie ponownie program czeka na wartość w zmiennej ''Delay'' w milisekundach. Następnie program powraca do początku pętli forever i powtarza. Gdy program powtarza pętlę forever, zmienna ''Delay'' jest zwiększana za każdym razem, wydłużając czas włączania i wyłączania diod LED. Po 1000 pętlach czas, w którym diody LED są włączone, wynosi jedną sekundę, a czas, w którym diody LED są wyłączone, wynosi jedną sekundę.",
	"HELP_TEXT_DATA_DECVARIABLE_TITLE" : "zmniejszanie",
	"HELP_TEXT_DATA_DECVARIABLE_BODY_1" : "Blok dekrementacji dekrementuje (minus 1) do zmiennej umieszczonej w bloku.",
	"HELP_TEXT_DATA_DECVARIABLE_EXAMPLE_1_TITLE" : "Przykładowy program 1: Przyspieszenie migania",
	"HELP_TEXT_DATA_DECVARIABLE_EXAMPLE_1_BODY_1" : "W tym przykładowym programie zmienna ''Delay'' jest ustawiona na 100, a następnie program przechodzi do pętli forever. Wewnątrz pętli zmienna ''Delay'' jest zmniejszana (-1), następnie prawa dioda LED jest włączana, a lewa dioda LED jest wyłączana, następnie program czeka na wartość w zmiennej ''Delay'' w milisekundach, następnie prawa dioda LED jest wyłączana, a lewa dioda LED jest włączana, a następnie ponownie program czeka na wartość w zmiennej ''Delay'' w milisekundach. Następnie program powraca do początku pętli forever i powtarza. Gdy program powtarza pętlę forever, zmienna ''Delay'' jest zmniejszana za każdym razem, co skraca czas włączania i wyłączania diod LED. Po 100 pętlach czas, w którym diody LED są włączone, wynosi jedną milisekundę, a czas, w którym diody LED są wyłączone, wynosi jedną milisekundę.",
	"HELP_TEXT_BIT_SHIFT_RIGHT_TITLE" : "przesunięcie bitowe w prawo",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_1" : "Przesunięcie bitowe w prawo według bloku matematycznie dostosowuje podłączony blok zmiennej w jego postaci binarnej poprzez przesunięcie bitów w prawo o ustawioną wartość.",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_2" : "Format liczb używany przez komputery nazywany jest binarnym. Jest to system liczbowy składający się wyłącznie z cyfr 0 i 1. Każda liczba w komputerze jest ciągiem cyfr 1 i 0. Oto kilka przykładów liczb binarnych o długości 8 bitów:",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_HUMAN" : "Ludzki/dziesiętny",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_COMPUTER" : "Komputer/8-bitowa liczba binarna",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_3" : "Oto kilka przykładów liczb binarnych o długości 32 bitów:",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_4" : "Edison V3 używa zarówno 8-bitowych, jak i 32-bitowych liczb binarnych. Na przykład bloki zmiennych są w stanie przechowywać duże liczby 32-bitowe (w rzeczywistości 31-bitowe ze znakiem), ale tylko liczby 8-bitowe mogą być wysyłane za pośrednictwem bloku wysyłania wiadomości IR. Ponadto niektóre czujniki, takie jak czujniki światła, mają zakres od 1 do 1000. Ponieważ najwyższą możliwą liczbą 8-bitową jest 255, pełny zakres odczytu czujnika światła nie może zostać wysłany za pośrednictwem bloku wysyłania wiadomości IR. W tym miejscu może pomóc blok przesunięcia bitowego w prawo!",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_5" : "Odczyt z czujnika światła to 10-bitowa liczba binarna. Oto wartości minimalne i maksymalne:",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_6" : "Jeśli liczba 1000 zostanie wysłana za pomocą bloku wysyłania wiadomości IR, otrzymana liczba będzie miała tylko 8 ostatnich bitów. Będzie to 11111010 (binarnie) lub 232 (ludzko/dziesiętnie). Jest to bardzo różna liczba od rzeczywistego odczytu światła wynoszącego 1000.",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_7" : "Aby wysłać dane o poziomie oświetlenia za pośrednictwem bloku wysyłania wiadomości IR, można użyć bloku przesunięcia bitowego w prawo, aby skrócić liczbę do 8-bitowej liczby (przesunięcie w prawo o 2) bez utraty zbyt dużej ilości danych. Następnie po stronie odbiorczej blok przesunięcia bitowego w lewo może zostać użyty do przywrócenia odczytu poziomu światła z powrotem do 10 bitów (przesunięcie w lewo o 2).",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_4_LINE_1_BOX_1" : "Etap",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_4_LINE_2_BOX_1" : "Odczyt światła",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_4_LINE_3_BOX_1" : "Przesunięcie bitów w prawo (2)",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_4_LINE_4_BOX_1" : "Wysyłanie/odbieranie danych IR",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_4_LINE_5_BOX_1" : "Przesunięcie bitów w lewo (2)",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_BIT" : "bit",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_8" : "W tym scenariuszu wynikowa liczba nie jest idealnie taka sama, ponieważ niektóre informacje zostały utracone. Jednak najbardziej znaczące bity zawierające ponad 99% oryginalnych danych zostały zachowane w tym procesie.",
	"HELP_TEXT_BIT_SHIFT_LEFT_TITLE" : "przesunięcie bitowe w lewo",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_1" : "Przesunięcie bitów w lewo przez blok matematycznie dostosowuje połączony blok zmiennej w jego postaci binarnej poprzez przesunięcie bitów w lewo o ustawioną wartość.",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_2" : "Format liczb używany przez komputery nazywany jest binarnym. Jest to system liczbowy składający się wyłącznie z cyfr 0 i 1. Każda liczba w komputerze jest ciągiem cyfr 1 i 0. Oto kilka przykładów liczb binarnych o długości 8 bitów:",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_HUMAN" : "Ludzki/dziesiętny",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_COMPUTER" : "Komputer/8-bitowa liczba binarna",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_3" : "Oto kilka przykładów liczb binarnych o długości 32 bitów:",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_4" : "Edison V3 używa zarówno 8-bitowych, jak i 32-bitowych liczb binarnych. Na przykład bloki zmiennych są w stanie przechowywać duże liczby 32-bitowe (w rzeczywistości 31-bitowe ze znakiem), ale tylko liczby 8-bitowe mogą być wysyłane za pośrednictwem bloku wysyłania wiadomości IR. Ponadto niektóre czujniki, takie jak czujniki światła, mają zakres od 1 do 1000. Ponieważ najwyższą możliwą liczbą 8-bitową jest 255, pełny zakres odczytu czujnika światła nie może zostać wysłany za pośrednictwem bloku wysyłania wiadomości IR. W tym miejscu może pomóc blok przesunięcia bitowego w prawo!",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_5" : "Odczyt z czujnika światła to 10-bitowa liczba binarna. Oto wartości minimalne i maksymalne:",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_6" : "Jeśli liczba 1000 zostanie wysłana za pomocą bloku wysyłania wiadomości IR, otrzymana liczba będzie miała tylko 8 ostatnich bitów. Będzie to 11111010 (binarnie) lub 232 (ludzko/dziesiętnie). Jest to bardzo różna liczba od rzeczywistego odczytu światła wynoszącego 1000.",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_7" : "Aby wysłać dane o poziomie oświetlenia za pośrednictwem bloku wysyłania wiadomości IR, można użyć bloku przesunięcia bitowego w prawo, aby skrócić liczbę do 8-bitowej liczby (przesunięcie w prawo o 2) bez utraty zbyt dużej ilości danych. Następnie po stronie odbiorczej blok przesunięcia bitowego w lewo może zostać użyty do przywrócenia odczytu poziomu światła z powrotem do 10 bitów (przesunięcie w lewo o 2).",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_4_LINE_1_BOX_1" : "Etap",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_4_LINE_2_BOX_1" : "Odczyt światła",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_4_LINE_3_BOX_1" : "Przesunięcie bitów w prawo (2)",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_4_LINE_4_BOX_1" : "Wysyłanie/odbieranie danych IR",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_4_LINE_5_BOX_1" : "Przesunięcie bitów w lewo (2)",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_BIT" : "bit",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_8" : "W tym scenariuszu wynikowa liczba nie jest idealnie taka sama, ponieważ niektóre informacje zostały utracone. Jednak najbardziej znaczące bity zawierające ponad 99% oryginalnych danych zostały zachowane w tym procesie.",
	"HELP_TEXT_EVENT_ANYOBSTACLE_TITLE" : "Wykryto jakąkolwiek przeszkodę",
	"HELP_TEXT_EVENT_ANYOBSTACLE_BODY_1" : "Blok zdarzeń Any obstacle detected powoduje, że program przeskakuje do tego bloku, gdy jakakolwiek przeszkoda zostanie wykryta przez detektor przeszkód.",
	"HELP_TEXT_EVENT_ANYOBSTACLE_BODY_2" : "Zawsze upewnij się, że wiązka detektora przeszkód jest włączona w programie głównym.",
	"HELP_TEXT_EVENT_ANYOBSTACLE_EXAMPLE_1_TITLE" : "Przykładowy program 1: Sygnał dźwiękowy po wykryciu przeszkody.",
	"HELP_TEXT_EVENT_ANYOBSTACLE_EXAMPLE_1_BODY_1" : "W tym przykładowym programie najpierw włączany jest detektor przeszkód, a następnie program przechodzi do bloku pętli forever. Gdy zostanie wykryta jakakolwiek przeszkoda, program wyskakuje z pętli forever i przechodzi do bloku zdarzeń Any obstacle detected. Powoduje to uruchomienie bloku sygnału dźwiękowego, a robot Edison emituje sygnał dźwiękowy. Następnie program powraca do miejsca, z którego wyszedł w programie głównym.",
	"HELP_TEXT_EVENT_ANYOBSTACLE_EXAMPLE_2_TITLE" : "Przykładowy program 2: Zatrzymaj jazdę, gdy pojawi się przeszkoda",
	"HELP_TEXT_EVENT_ANYOBSTACLE_EXAMPLE_2_BODY_1" : "W tym przykładowym programie najpierw włączany jest detektor przeszkód, a następnie oba silniki są ustawiane na jazdę do przodu z prędkością 5, a następnie program przechodzi do bloku pętli na zawsze. Gdy zostanie wykryta jakakolwiek przeszkoda, program wyskakuje z pętli forever i przechodzi do bloku zdarzeń Any obstacle detected. Powoduje to uruchomienie bloku zatrzymania obu silników i zatrzymanie pracy obu silników. Następnie program powraca do miejsca, z którego wyszedł w programie głównym.",
	"HELP_TEXT_EVENT_ANYOBSTACLE_EXAMPLE_3_TITLE" : "Przykładowy program 3: Omijaj przeszkody",
	"HELP_TEXT_EVENT_ANYOBSTACLE_EXAMPLE_3_BODY_1" : "W tym przykładowym programie detektor przeszkód jest najpierw włączany, a następnie program wchodzi w pętlę forever, wewnątrz pętli oba silniki są ustawione na jazdę do przodu z prędkością 5. Po wykryciu jakiejkolwiek przeszkody program wyskakuje z pętli forever i przechodzi do bloku zdarzeń Any obstacle detected. Bloki pod blokiem zdarzenia Any obstacle detected powodują cofnięcie Edisona o 1 cm z prędkością 1, a następnie obrót w lewo o 120 stopni z prędkością 1. Następnie program powraca do miejsca, w którym wyszedł z pętli forever, a oba silniki są ponownie ustawione na jazdę do przodu z prędkością 5. Powoduje to, że Edison odjeżdża od przeszkód na swojej drodze.",
	"HELP_TEXT_OBSTACLE_LEFT_EVENT_TITLE" : "Wykryta przeszkoda w lewo",
	"HELP_TEXT_OBSTACLE_LEFT_EVENT_BODY_1" : "Blok zdarzeń Obstacle detected left powoduje, że program przeskakuje do tego bloku po wykryciu przeszkody po lewej stronie przez detektor przeszkód.",
	"HELP_TEXT_OBSTACLE_LEFT_EVENT_BODY_2" : "Zawsze upewnij się, że wiązka detektora przeszkód jest włączona w programie głównym.",
	"HELP_TEXT_OBSTACLE_LEFT_EVENT_EXAMPLE_1_TITLE" : "Przykładowy program 1: Sygnał dźwiękowy po wykryciu przeszkody po lewej stronie",
	"HELP_TEXT_OBSTACLE_LEFT_EVENT_EXAMPLE_1_BODY_1" : "W tym przykładowym programie najpierw włączany jest detektor przeszkód, a następnie program przechodzi do bloku pętli forever. Po wykryciu przeszkody po lewej stronie, program wyskakuje z pętli forever i przechodzi do bloku zdarzeń Obstacle detected left. Powoduje to uruchomienie bloku sygnału dźwiękowego, a robot Edison emituje sygnał dźwiękowy. Następnie program powraca do miejsca, z którego wyszedł w bloku pętli forever.",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_TITLE" : "Wykryto przeszkodę z prawej strony",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_BODY_1" : "Blok zdarzeń Obstacle detected right powoduje, że program przeskakuje do tego bloku po wykryciu przeszkody po prawej stronie przez detektor przeszkód.",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_BODY_2" : "Zawsze upewnij się, że wiązka detektora przeszkód jest włączona w programie głównym.",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_1_TITLE" : "Przykładowy program 1: Sygnał dźwiękowy po wykryciu przeszkody po prawej stronie",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_1_BODY_1" : "W tym przykładowym programie najpierw włączany jest detektor przeszkód, a następnie program przechodzi do bloku pętli forever. Po wykryciu przeszkody po prawej stronie, program wychodzi z pętli forever i przechodzi do bloku zdarzeń Obstacle detected right. Powoduje to uruchomienie bloku sygnału dźwiękowego, a robot Edison emituje sygnał dźwiękowy. Następnie program powraca do miejsca, z którego wyszedł w bloku pętli forever.",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_2_TITLE" : "Przykładowy program 2: Omijanie przeszkód",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_2_BODY_1" : "W tym przykładowym programie najpierw włączany jest detektor przeszkód, a następnie program przechodzi do bloku pętli forever. Gdy...",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_2_BODY_2" : "...przed Tobą zostanie wykryta przeszkoda, program przejdzie do bloku zdarzeń Obstacle detected ahead i robot Edison będzie jechał do tyłu przez 0,25 sekundy z prędkością 10, a następnie powróci do miejsca, w którym wyszedł z bloku pętli forever.",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_2_BODY_3" : "...wykryto przeszkodę po prawej stronie, program przeskakuje do bloku zdarzeń Przeszkoda wykryta po prawej stronie, a robot Edison skręca w lewo do tyłu na 0,25 sekundy z prędkością 10, a następnie powraca do miejsca, z którego wyszedł w bloku pętli na zawsze.",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_2_BODY_4" : "...wykryto przeszkodę po lewej stronie, program przeskakuje do bloku zdarzeń Wykryto przeszkodę po lewej stronie i robot Edison skręca w prawo do tyłu na 0,25 sekundy z prędkością 10, a następnie powraca do miejsca, z którego wyszedł w bloku pętli na zawsze.",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_TITLE" : "Wykryto przeszkodę z przodu",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_BODY_1" : "Blok zdarzeń Obstacle detected ahead powoduje, że program przeskakuje do tego bloku po wykryciu przeszkody z przodu przez detektor przeszkód. Oznacza to, że w tym samym czasie zarówno lewy, jak i prawy detektor przeszkód wykryły przeszkodę.",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_BODY_2" : "Zawsze upewnij się, że wiązka detektora przeszkód jest włączona w programie głównym.",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_1_TITLE" : "Przykładowy program 1: Sygnał dźwiękowy po wykryciu przeszkody z przodu.",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_1_BODY_1" : "W tym przykładowym programie najpierw włączany jest detektor przeszkód, a następnie program przechodzi do bloku pętli forever. Po wykryciu przeszkody po prawej stronie, program wychodzi z pętli forever i przechodzi do bloku zdarzeń Obstacle detected right. Powoduje to uruchomienie bloku sygnału dźwiękowego, a robot Edison emituje sygnał dźwiękowy. Następnie program powraca do miejsca, z którego wyszedł w bloku pętli forever.",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_2_TITLE" : "Przykładowy program 2: Omijanie przeszkód",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_2_BODY_1" : "W tym przykładowym programie najpierw włączany jest detektor przeszkód, a następnie program przechodzi do bloku pętli forever. Gdy...",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_2_BODY_2" : "...przed Tobą zostanie wykryta przeszkoda, program przejdzie do bloku zdarzeń Obstacle detected ahead i robot Edison będzie jechał do tyłu przez 0,25 sekundy z prędkością 10, a następnie powróci do miejsca, w którym wyszedł z bloku pętli forever.",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_2_BODY_3" : "...wykryto przeszkodę po prawej stronie, program przeskakuje do bloku zdarzeń Przeszkoda wykryta po prawej stronie, a robot Edison skręca w lewo do tyłu na 0,25 sekundy z prędkością 10, a następnie powraca do miejsca, z którego wyszedł w bloku pętli na zawsze.",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_2_BODY_4" : "...wykryto przeszkodę po lewej stronie, program przeskakuje do bloku zdarzeń Wykryto przeszkodę po lewej stronie i robot Edison skręca w prawo do tyłu na 0,25 sekundy z prędkością 10, a następnie powraca do miejsca, z którego wyszedł w bloku pętli na zawsze.",
	"HELP_TEXT_CLAP_EVENT_TITLE" : "Wykryto klaśnięcie",
	"HELP_TEXT_CLAP_EVENT_BODY_1" : "Blok zdarzeń wykrycia klaśnięcia powoduje, że program przeskakuje do tego bloku po wykryciu klaśnięcia.",
	"HELP_TEXT_CLAP_EVENT_BODY_2" : "Gdy Edison jedzie, hałas silnika i uderzenia powodują wyzwolenie czujnika klaskania, więc najlepiej nie używać czujnika klaskania podczas jazdy. Ponadto, jeśli istnieje prawdopodobieństwo wystąpienia fałszywych lub niepożądanych detekcji hałasu, dane czujnika klaskania można wyczyścić za pomocą bloku czyszczenia danych czujnika ustawionego na detektor klaskania (patrz przykładowy program).",
	"HELP_TEXT_CLAP_EVENT_EXAMPLE_1_TITLE" : "Przykładowy program: Edison boi się głośnych dźwięków",
	"HELP_TEXT_CLAP_EVENT_EXAMPLE_1_BODY_1" : "W tym przykładzie program rozpoczyna się od wejścia w pustą pętlę forever i nic się nie dzieje. Po wykryciu klaśnięcia (lub innego głośnego, przerażającego dźwięku) program wyskakuje z pętli forever i przechodzi do bloku zdarzenia Clap detected. Następnie bloki znajdujące się poniżej bloku zdarzenia Clap detected uruchamiają się, cofając się o 5 cm z prędkością 10 (podskok ze strachu), a następnie wchodzą w pętlę powtarzania ustawioną na 25 razy, w której bloki spin left i spin right wielokrotnie uruchamiają się, powodując wibracje Edisona (drżenie ze strachu). Na koniec (gdy Edison otrząśnie się z przerażenia) blok czyszczenia danych czujnika usuwa wszelkie fałszywe wykrycia klaskania, które mogły wystąpić podczas jazdy. Program powraca teraz do pętli forever.",
	"HELP_TEXT_TRIANGLEBUTTON_EVENT_TITLE" : "Naciśnięto przycisk trójkąta",
	"HELP_TEXT_TRIANGLEBUTTON_EVENT_BODY_1" : "Blok zdarzenia naciśnięcia przycisku trójkąta powoduje, że program przeskakuje do tego bloku po naciśnięciu przycisku trójkąta.",
	"HELP_TEXT_TRIANGLEBUTTON_EVENT_EXAMPLE_1_TITLE" : "Przykładowy program: Sterowanie szybkością migania diody LED za pomocą przycisków",
	"HELP_TEXT_TRIANGLEBUTTON_EVENT_EXAMPLE_1_BODY_1" : "W tym przykładzie program rozpoczyna się od ustawienia zmiennej o nazwie ''Delay'' na 100, a następnie przechodzi do pętli forever. Wewnątrz pętli forever, lewa i prawa dioda LED są włączane i wyłączane z oczekiwaniem na wartość w zmiennej ''Delay'' w milisekundach. Powoduje to, że diody LED są włączone przez 100 milisekund (0,1 sekundy) i wyłączone przez 100 milisekund (0,1 sekundy).",
	"HELP_TEXT_TRIANGLEBUTTON_EVENT_EXAMPLE_1_BODY_2" : "Po naciśnięciu przycisku trójkąta program przeskakuje do bloku zdarzenia Triangle button pressed. Następnie uruchamiane są bloki poniżej bloku zdarzenia Triangle button pressed, ustawiając zmienną o nazwie ''Delay'' na 50, a następnie odtwarzając sygnał dźwiękowy. Następnie program powraca do pętli forever, ale teraz wartość zmiennej ''Delay'' wynosi 50, więc czas między włączeniem i wyłączeniem diod LED wynosi teraz 50 milisekund (0,05 sekundy). Dzięki temu diody będą migać szybciej.",
	"HELP_TEXT_TRIANGLEBUTTON_EVENT_EXAMPLE_1_BODY_3" : "Po naciśnięciu okrągłego przycisku program przeskakuje do bloku zdarzenia Round button pressed. Następnie uruchamiane są bloki poniżej bloku zdarzenia Round button pressed, ustawiając zmienną o nazwie ''Delay'' na 200, a następnie odtwarzając sygnał dźwiękowy. Następnie program powraca do pętli forever, ale teraz wartość zmiennej ''Delay'' wynosi 200, więc czas między włączeniem i wyłączeniem diod LED wynosi teraz 200 milisekund (0,2 sekundy). Dzięki temu diody będą migać wolniej.",
	"HELP_TEXT_ROUNDBUTTON_EVENT_TITLE" : "Naciśnięto okrągły przycisk",
	"HELP_TEXT_ROUNDBUTTON_EVENT_BODY_1" : "Blok zdarzeń Round button pressed powoduje, że program przeskakuje do tego bloku po naciśnięciu okrągłego przycisku.",
	"HELP_TEXT_ROUNDBUTTON_EVENT_EXAMPLE_1_TITLE" : "Przykładowy program: Sterowanie szybkością migania diody LED za pomocą przycisków",
	"HELP_TEXT_ROUNDBUTTON_EVENT_EXAMPLE_1_BODY_1" : "W tym przykładzie program rozpoczyna się od ustawienia zmiennej o nazwie ''Delay'' na 100, a następnie przechodzi do pętli forever. Wewnątrz pętli forever, lewa i prawa dioda LED są włączane i wyłączane z oczekiwaniem na wartość w zmiennej ''Delay'' w milisekundach. Powoduje to, że diody LED są włączone przez 100 milisekund (0,1 sekundy) i wyłączone przez 100 milisekund (0,1 sekundy).",
	"HELP_TEXT_ROUNDBUTTON_EVENT_EXAMPLE_1_BODY_2" : "Po naciśnięciu przycisku trójkąta program przeskakuje do bloku zdarzenia Triangle button pressed. Następnie uruchamiane są bloki poniżej bloku zdarzenia Triangle button pressed, ustawiając zmienną o nazwie ''Delay'' na 50, a następnie odtwarzając sygnał dźwiękowy. Następnie program powraca do pętli forever, ale teraz wartość zmiennej ''Delay'' wynosi 50, więc czas między włączeniem i wyłączeniem diod LED wynosi teraz 50 milisekund (0,05 sekundy). Dzięki temu diody będą migać szybciej.",
	"HELP_TEXT_ROUNDBUTTON_EVENT_EXAMPLE_1_BODY_3" : "Po naciśnięciu okrągłego przycisku program przeskakuje do bloku zdarzenia Round button pressed. Następnie uruchamiane są bloki poniżej bloku zdarzenia Round button pressed, ustawiając zmienną o nazwie ''Delay'' na 200, a następnie odtwarzając sygnał dźwiękowy. Następnie program powraca do pętli forever, ale teraz wartość zmiennej ''Delay'' wynosi 200, więc czas między włączeniem i wyłączeniem diod LED wynosi teraz 200 milisekund (0,2 sekundy). Dzięki temu diody będą migać wolniej.",
	"HELP_TEXT_LINEREFLECTIVE_EVENT_TITLE" : "Lokalizator linii na powierzchni odblaskowej",
	"HELP_TEXT_LINEREFLECTIVE_EVENT_BODY_1" : "Blok zdarzeń Line tracker on reflective surface powoduje, że program przeskakuje do tego bloku, gdy czujnik line tracker wykryje zmianę z powierzchni nieodblaskowej (np. czarnej) na odblaskową (np. białą).",
	"HELP_TEXT_LINEREFLECTIVE_EVENT_BODY_2" : "Aby blok zdarzeń Line tracker on reflective surface zadziałał, dioda LED śledzenia linii musi być włączona.",
	"HELP_TEXT_LINEREFLECTIVE_EVENT_EXAMPLE_1_TITLE" : "Przykładowy program: Podążaj za krawędzią linii",
	"HELP_TEXT_LINEREFLECTIVE_EVENT_EXAMPLE_1_BODY_1" : "W tym przykładzie program rozpoczyna się od włączenia diody LED śledzenia linii, a następnie program powoduje, że robot skręca w prawo (szukając krawędzi linii).",
	"HELP_TEXT_LINEREFLECTIVE_EVENT_EXAMPLE_1_BODY_2" : "Gdy tracker linii wykryje zmianę z powierzchni odblaskowej (białej) na nieodblaskową (czarną), program przeskakuje do bloku Line tracker on non-reflective surface i uruchamia blok napędu, aby ustawić robota tak, aby skręcił w lewo (zawracając w kierunku odblaskowej (białej) powierzchni).",
	"HELP_TEXT_LINEREFLECTIVE_EVENT_EXAMPLE_1_BODY_3" : "Gdy tracker linii wykryje zmianę z powierzchni nieodblaskowej na odblaskową, program przeskakuje do bloku zdarzeń Line tracker on reflective surface i uruchamia blok napędu, aby ustawić robota tak, aby skręcił w prawo (zawracając w kierunku nieodblaskowej (czarnej) powierzchni).",
	"HELP_TEXT_LINEREFLECTIVE_EVENT_EXAMPLE_1_BODY_4" : "Za każdym razem, gdy robot skręca w lewo lub w prawo, porusza się do przodu wzdłuż krawędzi linii.",
	"HELP_TEXT_LINENONREFLECTIVE_EVENT_TITLE" : "Lokalizator linii na powierzchni nieodblaskowej",
	"HELP_TEXT_LINENONREFLECTIVE_EVENT_BODY_1" : "Blok zdarzenia Line tracker on non-reflective surface powoduje, że program przeskakuje do tego bloku, gdy czujnik śledzenia linii wykryje zmianę z powierzchni odblaskowej (tj. białej) na nieodblaskową (tj. czarną).",
	"HELP_TEXT_LINENONREFLECTIVE_EVENT_BODY_2" : "Aby blok zdarzeń Line tracker on non-reflective surface zadziałał, dioda LED line trackera musi być włączona.",
	"HELP_TEXT_LINENONREFLECTIVE_EVENT_EXAMPLE_1_TITLE" : "Przykładowy program: Podążaj za krawędzią linii",
	"HELP_TEXT_LINENONREFLECTIVE_EVENT_EXAMPLE_1_BODY_1" : "W tym przykładzie program rozpoczyna się od włączenia diody LED śledzenia linii, a następnie program powoduje, że robot skręca w prawo (szukając krawędzi linii).",
	"HELP_TEXT_LINENONREFLECTIVE_EVENT_EXAMPLE_1_BODY_2" : "Gdy tracker linii wykryje zmianę z powierzchni odblaskowej (białej) na nieodblaskową (czarną), program przeskakuje do bloku Line tracker on non-reflective surface i uruchamia blok napędu, aby ustawić robota tak, aby skręcił w lewo (zawracając w kierunku odblaskowej (białej) powierzchni).",
	"HELP_TEXT_LINENONREFLECTIVE_EVENT_EXAMPLE_1_BODY_3" : "Gdy line tracker wykryje zmianę z powierzchni nieodblaskowej na odblaskową, program przeskakuje do bloku Line tracker on reflective surface i uruchamia blok drive, aby ustawić robota na skręt w prawo (zawrócenie w kierunku nieodblaskowej (czarnej) powierzchni).",
	"HELP_TEXT_LINENONREFLECTIVE_EVENT_EXAMPLE_1_BODY_4" : "Za każdym razem, gdy robot skręca w lewo lub w prawo, porusza się do przodu wzdłuż krawędzi linii.",
	"HELP_TEXT_LINECHANGE_EVENT_TITLE" : "Lokalizator linii zmienia powierzchnię",
	"HELP_TEXT_LINECHANGE_EVENT_BODY_1" : "Blok zdarzenia Line tracker changes surface powoduje, że program przeskakuje do tego bloku, gdy czujnik line trackera wykryje zmianę z powierzchni nieodblaskowej (tj. czarnej) na odblaskową (tj. białą) lub z powierzchni odblaskowej (tj. białej) na nieodblaskową (tj. czarną).",
	"HELP_TEXT_LINECHANGE_EVENT_BODY_2" : "Aby blok zdarzeń Line tracker zmienia powierzchnię działał, dioda LED śledzenia linii musi być włączona.",
	"HELP_TEXT_LINECHANGE_EVENT_EXAMPLE_1_TITLE" : "Przykładowy program: Zatrzymanie w celu zmiany",
	"HELP_TEXT_LINECHANGE_EVENT_EXAMPLE_1_BODY_1" : "W tym przykładzie program rozpoczyna się od włączenia diody LED śledzenia linii, a następnie robot jedzie do przodu z prędkością 1 i wchodzi w pętlę na zawsze. Następnie robot będzie kontynuował jazdę do przodu, dopóki czujnik śledzenia linii nie wykryje zmiany współczynnika odbicia powierzchni (biały na czarny lub czarny na biały). Gdy to nastąpi, program przeskoczy do bloku Line tracker changes surface. Następnie uruchamiany jest kod poniżej bloku Line tracker changes surface, zatrzymując oba silniki, wydając sygnał dźwiękowy, odczekując 1 sekundę, ponownie wydając sygnał dźwiękowy, a następnie ustawiając oba silniki, aby ponownie jechały do przodu.",
	"HELP_TEXT_MESSAGE_EVENT_TITLE" : "Odebrano komunikat IR",
	"HELP_TEXT_MESSAGE_EVENT_BODY_1" : "Blok zdarzeń odebranego komunikatu IR powoduje, że program przeskakuje do tego bloku po odebraniu komunikatu w podczerwieni (IR) od innego robota Edison.",
	"HELP_TEXT_MESSAGE_EVENT_BODY_3" : "Blok zdarzeń odebranego komunikatu IR nie będzie działał, gdy odbiornik IR jest używany do wykrywania przeszkód.",
	"HELP_TEXT_MESSAGE_EVENT_BODY_4" : "Program przejdzie do bloku zdarzeń odebranego komunikatu IR, gdy jakikolwiek komunikat IR zostanie odebrany od innego robota Edison. Blok zdarzeń odebranego komunikatu IR nie dekoduje danych w komunikacie IR. Dekodowanie komunikatu wymaga umieszczenia danych komunikatu w zmiennej, a następnie dekodowania za pomocą bloku if then.",
	"HELP_TEXT_MESSAGE_EVENT_EXAMPLE_1_TITLE" : "Przykładowy program: Odbierz wiadomość IR, aby wydać sygnał dźwiękowy raz lub dwa razy",
	"HELP_TEXT_MESSAGE_EVENT_EXAMPLE_1_BODY_1" : "W tym przykładzie program rozpoczyna się od wejścia w pustą pętlę forever i nic się nie dzieje. Po odebraniu komunikatu IR program przechodzi do bloku zdarzeń odebranego komunikatu IR. Następnie wykonywany jest kod znajdujący się poniżej bloku zdarzeń odebranego komunikatu IR. Najpierw dane odebranego komunikatu są przechowywane w zmiennej ''ReceivedMessage''. Jest to konieczne, ponieważ za każdym razem, gdy dane z odebranego komunikatu IR są odczytywane, są one również czyszczone. Teraz, gdy dane wiadomości znajdują się w zmiennej, zmienna jest testowana, czy jest równa 1, jeśli tak, to blok sygnału dźwiękowego jest odtwarzany jeden raz. Następnie zmienna jest sprawdzana, czy jest równa 2, jeśli tak, to blok sygnału dźwiękowego jest odtwarzany dwukrotnie. Program powraca teraz do pętli forever.",
	"HELP_TEXT_MESSAGE_EVENT_EXAMPLE_2_TITLE" : "Program wysyłający wiadomości IR:",
	"HELP_TEXT_MESSAGE_EVENT_EXAMPLE_2_BODY_1" : "Powyższy program jest używany w robocie Edison, który wysyła wiadomość IR. Program najpierw przechodzi do pustej pętli forever. Po naciśnięciu przycisku trójkąta program przeskakuje do bloku zdarzeń Triangle button pressed i wysyłana jest wiadomość IR z numerem 1. Po naciśnięciu okrągłego przycisku program przeskakuje do bloku zdarzeń Round button pressed i wysyłany jest komunikat IR z numerem 2.",
	"HELP_TEXT_DRIVESTRAIN_EVENT_TITLE" : "Naprężenie napędu",
	"HELP_TEXT_DRIVESTRAIN_EVENT_BODY_1" : "Blok zdarzeń Drive strained powoduje, że program przeskakuje do tego bloku, gdy jeden lub oba silniki są napędzane, ale nie mogą się obracać (pod obciążeniem).",
	"HELP_TEXT_DRIVESTRAIN_EVENT_EXAMPLE_1_TITLE" : "Przykładowy program: Alarm, gdy lewe koło nie może się obracać",
	"HELP_TEXT_DRIVESTRAIN_EVENT_EXAMPLE_1_BODY_1" : "W tym przykładzie program rozpoczyna się od ustawienia lewego silnika na jazdę do przodu, a następnie wchodzi w pętlę na zawsze. Gdy koło nie może się obracać z powodu naprężenia, program przeskakuje do bloku zdarzeń Drive strained i uruchamia poniższy kod. Kod poniżej bloku zdarzeń Drive strained to blok beep, który odtwarza sygnał dźwiękowy. Następnie program powraca do pętli forever.",
	"HELP_TEXT_REMOTE_EVENT_TITLE" : "Odebrano kod zdalny",
	"HELP_TEXT_REMOTE_EVENT_BODY_1" : "Blok zdarzeń Remote code received powoduje, że program przeskakuje do tego bloku po odebraniu kodu zdalnego sterowania.",
	"HELP_TEXT_REMOTE_EVENT_BODY_3" : "Upewnij się, że naciśniesz przycisk trójkąta, aby uruchomić program. Łatwo o tym zapomnieć, ponieważ robot Edison zareaguje jak robot zdalnie sterowany i nie wykona tego, co mu zaprogramowałeś.",
	"HELP_TEXT_REMOTE_EVENT_BODY_4" : "Aby używać bloków zdalnego sterowania, robota Edison należy najpierw nauczyć, które przyciski pilota zdalnego sterowania odpowiadają któremu kodowi pilota. Dowiedz się więcej na ten temat tutaj:",
	"HELP_TEXT_REMOTE_EVENT_BODY_5" : "Jeśli program zachowuje się w sposób nieoczekiwany, może być konieczne użycie bloku wyczyść dane czujnika, aby wyczyścić zawartość bloku odebranego kodu pilota. Zobacz przykładowy program 1 poniżej.",
	"HELP_TEXT_REMOTE_EVENT_BODY_6" : "Odbieranie kodów pilota na podczerwień będzie działać z około 90% standardowych pilotów do telewizorów, jednak każda marka używa nieco innych formatów danych. Podczas dekodowania danych może to powodować nieoczekiwane zachowanie w zależności od marki pilota. Zaawansowane dekodowanie zdalnego sterowania działa najlepiej z EdRemote (dostępnym w połowie 2025 r.).",
	"HELP_TEXT_REMOTE_EVENT_EXAMPLE_1_TITLE" : "Przykładowy program: Pilot zdalnego sterowania do przodu lub do tyłu",
	"HELP_TEXT_REMOTE_EVENT_EXAMPLE_1_BODY" : "W tym przykładzie program rozpoczyna się od wejścia w pustą pętlę forever. Po odebraniu kodu zdalnego sterowania program przeskakuje do bloku zdarzeń Remote code received. Kod poniżej bloku zdarzeń Remote code received jest uruchamiany, zdalny kod jest testowany, aby sprawdzić, czy jest równy 1, jeśli tak, to oba silniki są ustawione na jazdę do przodu, trwa to do momentu, gdy odbierany kod nie jest już równy 1. Następnie odebrany kod jest testowany, aby sprawdzić, czy jest równy 2, jeśli tak, to oba silniki są ustawione na jazdę do tyłu. Trwa to do momentu, gdy odebrany kod przestanie być równy 2. Na koniec, gdy zdalne kody zostaną przetestowane i nie będą już odbierane, blok stop zatrzyma oba silniki. Program powraca do pustej pętli forever.",
	"HELP_TEXT_CONTROL_WAIT_TITLE" : "Wait sec",
	"HELP_TEXT_CONTROL_WAIT_BODY_1" : "Blok wait sec wstrzymuje działanie programu na czas określony w sekundach. Czas ten może wynosić od 0,001 sekundy (1 milisekunda) do 1 073 741 sekund (12,4 dnia).",
	"HELP_TEXT_CONTROL_WAIT_BODY_2" : "Blok wait ma tylko jeden parametr:",
	"HELP_TEXT_CONTROL_WAIT_BODY_3" : "Wartość - Może być stałą (wpisaną do wejścia i nie zmienia się), zmienną, czujnikiem lub blokiem operatora.",
	"HELP_TEXT_CONTROL_WAIT_EXAMPLE_1_TITLE" : "Przykładowy program 1: Mrugnij lewą diodą LED",
	"HELP_TEXT_CONTROL_WAIT_EXAMPLE_1_BODY" : "W tym przykładzie program rozpoczyna się od wejścia w pętlę forever. Wewnątrz pętli lewa dioda LED jest włączana, następnie program zatrzymuje się i czeka przez 0,5 sekundy, następnie lewa dioda LED jest wyłączana, następnie program ponownie zatrzymuje się i czeka przez 0,5 sekundy, a następnie powraca do początku.",
	"HELP_TEXT_CONTROL_WAIT_EXAMPLE_2_TITLE" : "Przykładowy program 2: Nocny świerszcz robota",
	"HELP_TEXT_CONTROL_WAIT_EXAMPLE_2_BODY" : "W tym przykładzie program rozpoczyna się od wejścia w pętlę forever. Wewnątrz pętli znajduje się blok wait until, który wstrzymuje postęp programu do momentu, gdy poziom światła na lewym czujniku światła spadnie poniżej 100. Gdy tak się stanie, program przechodzi do oczekiwania na losową liczbę sekund pomiędzy 20 a 300. Po zakończeniu tego oczekiwania głośnik odtworzy dźwięk. Następnie program powraca do początku pętli forever. Powoduje to zachowanie podobne do świerszcza w nocy, więc nie można go znaleźć.",
	"HELP_TEXT_CONTROL_REPEAT_TITLE" : "Powtarzanie",
	"HELP_TEXT_CONTROL_REPEAT_BODY_1" : "Blok repeat jest rodzajem pętli, która zapętla się tylko określoną liczbę razy. Wszystkie bloki wewnątrz bloku repeat wykonują się tylko określoną liczbę razy.",
	"HELP_TEXT_CONTROL_REPEAT_BODY_2" : "Blok powtarzania ma tylko jeden parametr:",
	"HELP_TEXT_CONTROL_REPEAT_BODY_3" : "Wartość - Może być stałą (wpisaną do wejścia i nie zmienia się), zmienną, czujnikiem lub blokiem operatora.",
	"HELP_TEXT_CONTROL_REPEAT_EXAMPLE_1_TITLE" : "Przykładowy program 1: Jedź w kwadracie",
	"HELP_TEXT_CONTROL_REPEAT_EXAMPLE_1_BODY" : "W tym przykładzie program rozpoczyna się od wejścia do bloku powtarzania, który jest ustawiony na powtarzanie cztery razy. Wewnątrz powtarzanego bloku robot jedzie do przodu o 10 cm, a następnie obraca się w prawo o 90 stopni. Te dwa bloki wewnątrz bloku powtarzania są wykonywane cztery razy. W rezultacie robot Edison jeździ w kształcie kwadratu.",
	"HELP_TEXT_CONTROL_FOREVER_TITLE" : "Forever",
	"HELP_TEXT_CONTROL_FOREVER_BODY_1" : "Blok forever jest rodzajem bloku pętli, który zapętla się bezwarunkowo na zawsze (chyba że program zostanie zatrzymany). Bloki umieszczone wewnątrz bloku forever wykonują się, a następnie wykonują się ponownie i ponownie...",
	"HELP_TEXT_CONTROL_FOREVER_EXAMPLE_1_TITLE" : "Przykładowy program: Mrugaj diodą LED",
	"HELP_TEXT_CONTROL_FOREVER_EXAMPLE_1_BODY" : "W tym przykładzie program rozpoczyna się od wejścia w pętlę forever. Wewnątrz pętli forever lewa dioda LED jest włączana, następnie blok wait wstrzymuje działanie programu na 0,25 sekundy, następnie lewa dioda LED jest wyłączana, następnie blok wait wstrzymuje działanie programu na 0,25 sekundy. Następnie program powraca do bloku włączania lewej diody LED i sekwencja powtarza się w nieskończoność.",
	"HELP_TEXT_CONTROL_IF_TITLE" : "If then",
	"HELP_TEXT_CONTROL_IF_BODY_1" : "Blok if then uruchamia bloki, jeśli warunek wejściowy jest prawdziwy. Jeśli warunek nie jest prawdziwy, program przechodzi do następnego bloku w programie.",
	"HELP_TEXT_CONTROL_IF_BODY_2" : "Ten blok ma jeden parametr wejściowy:",
	"HELP_TEXT_CONTROL_IF_BODY_3" : "Wejście warunkowe - Wejście warunkowe akceptuje bloki w kształcie rombu, które mogą być blokiem operatora lub blokiem wykrywania.",
	"HELP_TEXT_CONTROL_IF_BODY_4" : "Blok if then jest zwykle używany wewnątrz pętli forever, dzięki czemu warunek if then może być testowany wielokrotnie. Jeśli program ma tylko blok if then, test zostanie uruchomiony tylko raz i program zostanie zamknięty.",
	"HELP_TEXT_CONTROL_IF_EXAMPLE_1_TITLE" : "Przykładowy program 1: Mrugnij diodą LED, jeśli rozlegnie się klaśnięcie",
	"HELP_TEXT_CONTROL_IF_EXAMPLE_1_BODY" : "W tym przykładzie program rozpoczyna się od wejścia w pętlę forever. Pierwszym blokiem w pętli forever jest blok if then, który sprawdza, czy nastąpiło klaśnięcie. Jeśli jest to fałsz, zawartość bloku if then jest pomijana, a program powraca do początku pętli forever. Jeśli wykryto klaśnięcie (prawda), uruchamiane są bloki wewnątrz bloku if then. Najpierw włączana jest lewa dioda LED, następnie program zatrzymuje się na jedną sekundę, po czym lewa dioda LED jest wyłączana. Program powraca do początku pętli forever. W rezultacie robot Edison miga lewą diodą LED przez jedną sekundę za każdym razem, gdy wykryje klaśnięcie.",
	"HELP_TEXT_CONTROL_IF_EXAMPLE_2_TITLE" : "Przykładowy program 2: Narysuj otwarty alarm",
	"HELP_TEXT_CONTROL_IF_EXAMPLE_2_BODY" : "W tym przykładzie program rozpoczyna się od wejścia w pętlę forever. Pierwszym blokiem w pętli forever jest blok if then, który sprawdza, czy poziom światła na lewym czujniku światła jest większy niż 100. Jeśli jest to prawdą (poziom światła jest większy niż 100), uruchamiany jest blok beep, a robot Edison emituje sygnał dźwiękowy przypominający alarm. Jeśli nie jest to prawdą (poziom światła jest mniejszy niż 100), wówczas blok sygnału dźwiękowego jest pomijany, a program powraca do początku pętli forever. W rezultacie Edison emituje szybki sygnał dźwiękowy za każdym razem, gdy wykryje poziom światła powyżej 100.",
	"HELP_TEXT_CONTROL_IF_ELSE_TITLE" : "If then else",
	"HELP_TEXT_CONTROL_IF_ELSE_BODY_1" : "Blok if then else uruchamia pierwszy zestaw bloków, jeśli warunek wejściowy jest prawdziwy. Jeśli warunek jest fałszywy, uruchamiany jest drugi zestaw bloków.",
	"HELP_TEXT_CONTROL_IF_ELSE_BODY_2" : "Ten blok ma jeden parametr wejściowy:",
	"HELP_TEXT_CONTROL_IF_ELSE_BODY_3" : "Wejście warunkowe - Wejście warunkowe akceptuje bloki w kształcie rombu, które mogą być blokiem operatora lub blokiem wykrywania.",
	"HELP_TEXT_CONTROL_IF_ELSE_BODY_4" : "Blok if then else jest zwykle używany wewnątrz pętli forever, dzięki czemu warunek if then else może być testowany wielokrotnie. Jeśli program ma tylko blok if then else, test zostanie wykonany tylko raz i program zakończy działanie.",
	"HELP_TEXT_CONTROL_IF_ELSE_EXAMPLE_1_TITLE" : "Przykładowy program 1: Bounce in borders",
	"HELP_TEXT_CONTROL_IF_ELSE_EXAMPLE_1_BODY" : "W tym przykładzie program rozpoczyna się od włączenia diody LED czujnika śledzenia linii, a następnie przechodzi do pętli forever. Pierwszym blokiem w pętli forever jest blok if then else, który sprawdza, czy czujnik śledzenia linii znajduje się na nieodblaskowej powierzchni (czarnej). Jeśli jest to prawdą, pierwszy zestaw bloków uruchamia jazdę robota do tyłu, a następnie obrót o 90 stopni. Program przeskakuje nad blokiem else, a następnie zapętla się z powrotem, aby ponownie sprawdzić, czy czujnik śledzenia linii znajduje się na nieodblaskowej powierzchni (czarnej), jeśli jest to fałsz (na białym tle), wówczas uruchamiany jest blok else, ustawiając oba silniki na jazdę do przodu. Powoduje to, że robot Edison ''odbija się'' od czarnej linii i zawraca. Powoduje to, że Edison odjeżdża od wykrytych czarnych linii.",
	"HELP_TEXT_CONTROL_IF_ELSE_EXAMPLE_2_TITLE" : "Przykładowy program 2: Podążaj za światłem",
	"HELP_TEXT_CONTROL_IF_ELSE_EXAMPLE_2_BODY" : "W tym przykładzie program rozpoczyna się od wejścia w pętlę forever. Pierwszym blokiem w pętli forever jest blok if then else, który sprawdza, czy poziom światła na prawym czujniku jest mniejszy niż poziom światła na lewym czujniku. Jeśli jest to prawda (światło jest jaśniejsze po lewej stronie), następnym blokiem do uruchomienia jest ustawienie obu silników, aby obrócić robota w lewo (robot skręca w lewo w kierunku światła). Alternatywnie, jeśli wynik jest fałszywy (światło jest jaśniejsze po prawej stronie), następnym blokiem do uruchomienia są bloki else. Teraz uruchom blok ustawiający oba silniki na obrót robota w prawo (robot obraca się w kierunku światła). W rezultacie robot Edison jedzie w kierunku najjaśniejszego źródła światła (spróbuj użyć latarki, aby kontrolować, gdzie Edison jedzie).",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_TITLE" : "Czekaj do",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_BODY_1" : "Blok wait until wstrzymuje działanie programu, dopóki warunek wejściowy nie będzie prawdziwy.",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_BODY_2" : "Ten blok ma jeden parametr wejściowy:",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_BODY_3" : "Wejście warunkowe - Wejście warunkowe akceptuje bloki w kształcie rombu, które mogą być blokiem operatora lub blokiem wykrywania.",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_BODY_4" : "Blok wait until jest zwykle używany wewnątrz pętli forever, dzięki czemu warunek wait until może być testowany wielokrotnie. Jeśli program ma tylko blok wait until, test zostanie uruchomiony tylko raz i program zakończy działanie.",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_EXAMPLE_1_TITLE" : "Przykładowy program 1: Mrugnij diodą LED, jeśli rozlegnie się klaśnięcie",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_EXAMPLE_1_BODY" : "W tym przykładzie program rozpoczyna się od wejścia w pętlę forever. Pierwszym blokiem w pętli forever jest blok clear sensor data, który czyści wszelkie fałszywe dane klaskania. Następny jest blok wait until z blokiem warunkowego wejścia clap detected. Program zatrzyma się w tym miejscu i poczeka, aż zostanie wykryte klaśnięcie. Po wykryciu klaśnięcia program przechodzi do włączenia lewej diody LED, następnie odczekuje jedną sekundę, a następnie wyłącza lewą diodę LED. Program powraca teraz do bloku wait until. Za każdym razem, gdy rozlegnie się klaśnięcie, lewa dioda LED włącza się na jedną sekundę. W rezultacie robot Edison miga lewą diodą LED przez jedną sekundę za każdym razem, gdy wykryje klaśnięcie.",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_EXAMPLE_2_TITLE" : "Przykładowy program 2: Detektor źródła najjaśniejszego światła",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_EXAMPLE_2_BODY" : "W tym przykładzie program rozpoczyna się od wejścia w pętlę forever. Pierwszym blokiem w pętli forever jest blok wait until z wejściem warunkowym wykorzystującym operator wymagający, aby poziom światła na prawym czujniku światła był równy poziomowi światła na lewym czujniku światła. Jeśli warunek nie jest prawdziwy (poziomy światła nie są równe), program zatrzymuje się w tym miejscu. Gdy poziom światła na obu czujnikach światła jest równy, program przechodzi do bloku sygnału dźwiękowego. Program powraca teraz do bloku wait until i powtarza się. Powoduje to, że robot Edison emituje sygnał dźwiękowy, gdy jest skierowany w stronę najjaśniejszego źródła światła",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_TITLE" : "Powtarzaj do",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_BODY_1" : "Blok repeat until uruchamia bloki wewnątrz niego, dopóki warunek wejściowy nie będzie prawdziwy.",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_BODY_2" : "Ten blok ma jeden parametr wejściowy:",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_BODY_3" : "Wejście warunkowe - Wejście warunkowe akceptuje bloki w kształcie rombu, które mogą być blokiem operatora lub blokiem wykrywania.",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_BODY_4" : "Blok repeat until jest często używany wewnątrz pętli forever, dzięki czemu warunek repeat until może być testowany wielokrotnie. Jeśli program ma tylko blok repeat until, test zostanie uruchomiony tylko raz i program zakończy działanie.",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_EXAMPLE_1_TITLE" : "Przykładowy program 1: Zatrzymaj włączanie się alarmu",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_EXAMPLE_1_BODY" : "W tym przykładzie program rozpoczyna się od dostrojenia detektora przeszkód (ustawienie alarmu), a następnie przechodzi do pętli forever. Pierwszym blokiem w pętli forever jest blok wait until z wejściem warunkowym w postaci wykrycia przeszkody w dowolnym miejscu (czujnik intruza). Program zatrzyma się i poczeka, aż zostanie wykryta przeszkoda (intruz). Gdy przeszkoda zostanie wykryta, program przejdzie do bloku repeat until, co spowoduje uruchomienie bloku beep i powtarzanie go w kółko (dźwięk alarmu), ''dopóki'' nie zostanie naciśnięty okrągły przycisk (zatrzymanie i zresetowanie alarmu).",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_EXAMPLE_2_TITLE" : "Przykładowy program 2: Edison drży z zimna bez ciepłego światła",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_EXAMPLE_2_BODY" : "W tym przykładzie program rozpoczyna się od wejścia w pętlę forever. Pierwszym blokiem w pętli forever jest blok repeat until z wejściem warunkowym wykorzystującym operator wymagający, aby poziom światła lewego czujnika światła był większy niż 980 (bardzo jasny/słoneczny). Jeśli nie jest to prawdą, poniższe bloki są uruchamiane, szybko obracając robotem Edison w lewo i w prawo (drżenie). Jeśli poziom światła lewego czujnika światła wzrośnie powyżej 980 (Edison porusza się w bardzo jasnym świetle), warunek staje się prawdziwy i program zatrzymuje się (robot Edison jest ciepły i szczęśliwy).",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_TITLE" : "Czekaj milisekundy",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_BODY_1" : "Blok wait milliseconds wstrzymuje program na określony czas w milisekundach (ms). Milisekunda to jedna tysięczna (1/1000) sekundy lub 0,001 sekundy.",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_BODY_2" : "1500 milisekund = 1,5 sekundy",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_BODY_3" : "100 milisekund = 0,1 sekundy",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_BODY_4" : "25 milisekund = 0,025 sekundy",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_BODY_5" : "Blok wait milliseconds ma tylko jeden parametr:",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_BODY_6" : "Wartość - może być zmienną, czujnikiem lub blokiem operatora",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_EXAMPLE_1_TITLE" : "Przykładowy program 1: Szybko migająca dioda LED",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_EXAMPLE_1_BODY" : "W tym przykładzie program rozpoczyna się od ustawienia zmiennej ''Delay'' na 50, a następnie przechodzi do pętli forever. Wewnątrz pętli forever włączana jest lewa dioda LED, a następnie blok wait milliseconds wstrzymuje działanie na wartość w milisekundach 'Delay', w tym przypadku 50 milisekund. Następnie lewa dioda LED jest wyłączana, a blok ''wait milliseconds'' zatrzymuje się na 50 milisekund. Program powraca do początku pętli forever.",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_EXAMPLE_2_TITLE" : "Przykładowy program 2: Szalone światła",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_EXAMPLE_2_BODY" : "W tym przykładzie program rozpoczyna się od wejścia w pętlę forever. Wewnątrz pętli forever włączane i wyłączane są lewa i prawa dioda LED. Czasy oczekiwania między włączeniem i wyłączeniem są kontrolowane przez bloki wait milliseconds. Czas w milisekundach jest ustawiany przez bloki liczb losowych wewnątrz nich. Są one ustawione na generowanie liczb losowych w zakresie od 30 do 300 milisekund. Rezultatem jest losowe miganie świateł LED robota Edison.",
	"HELP_TEXT_SENSING_TURNLINETRACKINGLED_TITLE" : "Włącz/wyłącz diodę LED śledzenia linii",
	"HELP_TEXT_SENSING_TURNLINETRACKINGLED_BODY_1" : "Blok włączania/wyłączania diody LED śledzenia linii ustawia diodę LED śledzenia linii na włączoną lub wyłączoną.",
	"HELP_TEXT_SENSING_TURNLINETRACKINGLED_BODY_2" : "Aby czujnik śledzenia linii działał, dioda LED śledzenia linii musi być włączona.",
	"HELP_TEXT_SENSING_TURNLINETRACKINGLED_EXAMPLE_1_TITLE" : "Przykładowy program: Zatrzymaj się na czarnej powierzchni",
	"HELP_TEXT_SENSING_TURNLINETRACKINGLED_EXAMPLE_1_BODY" : "W tym przykładzie program rozpoczyna się od włączenia diody LED śledzenia linii, a następnie oba silniki są ustawione na jazdę do przodu. Następnie program czeka, aż czujnik śledzenia linii wykryje nieodblaskową powierzchnię (czarną), kiedy to nastąpi, program kończy się i silniki zatrzymują się.",
	"HELP_TEXT_SENSING_TURNOBSTACLEBEAM_TITLE" : "Włącz/wyłącz wiązkę wykrywania przeszkód",
	"HELP_TEXT_SENSING_TURNOBSTACLEBEAM_BODY_1" : "Blok włączania/wyłączania wiązki wykrywania przeszkód ustawia wiązkę wykrywania przeszkód na włączoną lub wyłączoną.",
	"HELP_TEXT_SENSING_TURNOBSTACLEBEAM_BODY_2" : "Wiązka wykrywania przeszkód musi być włączona, aby wykrywanie przeszkód działało.",
	"HELP_TEXT_SENSING_TURNOBSTACLEBEAM_EXAMPLE_1_TITLE" : "Przykładowy program: Zatrzymaj się przed przeszkodą",
	"HELP_TEXT_SENSING_TURNOBSTACLEBEAM_EXAMPLE_1_BODY" : "W tym przykładzie program rozpoczyna się od włączenia wiązki wykrywania przeszkód, a następnie oba silniki są ustawione na jazdę do przodu. Następnie program czeka, aż w dowolnym miejscu zostanie wykryta przeszkoda, a gdy to nastąpi, program kończy się i silniki zatrzymują się.",
	"HELP_TEXT_SENSING_CLEARSENSOR_TITLE" : "Wyczyść dane czujnika",
	"HELP_TEXT_SENSING_CLEARSENSOR_BODY_1" : "Blok czyszczenia danych czujnika usuwa wszelkie dane czujnika (wykrycia) z wybranego czujnika. Blok ten jest używany, gdy mogą wystąpić fałszywe lub niepożądane detekcje, które uniemożliwiają działanie programu w pożądany sposób. Przykładem może być sytuacja, gdy program steruje robotem Edison w wyniku wykrycia klaśnięcia. Ogólnie rzecz biorąc, jazda jest dość głośna i może ponownie wyzwolić dodatkowe wykrycie klaśnięcia. Powoduje to, że program wykrywa drugie klaśnięcie, które nie miało miejsca. Blok czyszczenia danych czujnika służy do czyszczenia danych czujnika z wszelkich niepożądanych detekcji, takich jak ta.",
	"HELP_TEXT_SENSING_CLEARSENSOR_BODY_2" : "Blok czyszczenia danych czujnika ma pięć opcji wejściowych:",
	"HELP_TEXT_SENSING_CLEARSENSOR_BODY_3" : "czujnik klaskania",
	"HELP_TEXT_SENSING_CLEARSENSOR_BODY_4" : "klawiatura",
	"HELP_TEXT_SENSING_CLEARSENSOR_BODY_5" : "detektor przeszkód",
	"HELP_TEXT_SENSING_CLEARSENSOR_BODY_6" : "zdalny kod",
	"HELP_TEXT_SENSING_CLEARSENSOR_BODY_7" : "Komunikat IR",
	"HELP_TEXT_SENSING_CLEARSENSOR_EXAMPLE_1_TITLE" : "Przykładowy program 1: Klaśnięcie i obrót",
	"HELP_TEXT_SENSING_CLEARSENSOR_EXAMPLE_1_BODY" : "W tym przykładzie program rozpoczyna się od wejścia w pętlę forever. Wewnątrz pętli forever blok czyszczenia danych czujnika jest ustawiony na czyszczenie detektora klaskania, następnie program czeka, aż zostanie wykryte klaskanie, gdy to nastąpi, program postępuje i robot obraca się w lewo przez dwie sekundy. Podczas obracania silniki, koła i płoza wydają dźwięki, które ponownie wyzwalają detektor klaskania, więc teraz detektor klaskania myśli, że nastąpiło drugie klaśnięcie. Program zapętla się z powrotem do początku pętli forever (wciąż trzymając się wykrywania klaskania), ale następnie blok czyszczenia danych czujnika czyści wykrywanie, a blok oczekiwania do nie zostanie uruchomiony, dopóki nie nastąpi klaskanie.",
	"HELP_TEXT_SENSING_CLAPDETECTED_TITLE" : "Wykryto klaśnięcie",
	"HELP_TEXT_SENSING_CLAPDETECTED_BODY_1" : "Blok wykrywania klaśnięcia jest blokiem wejściowym czujnika, który wskazuje, czy wykryto klaśnięcie. Jest to blok w kształcie rombu, więc dane w bloku mogą być tylko prawdziwe (klaskanie zostało wykryte) lub fałszywe (klaskanie nie zostało wykryte).",
	"HELP_TEXT_SENSING_CLAPDETECTED_BODY_2" : "Inne dźwięki, takie jak praca silników, mogą powodować fałszywe wyzwolenie bloku wykrytego klaśnięcia. Użyj bloku czyszczenia danych czujnika, aby usunąć fałszywe lub niechciane wykrycia klaskania.",
	"HELP_TEXT_SENSING_CLAPDETECTED_EXAMPLE_1_TITLE" : "Przykładowy program 1: Mrugnij diodą LED, jeśli rozlegnie się klaśnięcie",
	"HELP_TEXT_SENSING_CLAPDETECTED_EXAMPLE_1_BODY" : "W tym przykładzie program rozpoczyna się od wejścia w pętlę forever. Wewnątrz pętli forever znajduje się blok if then, który sprawdza, czy wykryto klaśnięcie. Po wykryciu klaśnięcia, lewa dioda LED włącza się, następnie program czeka przez jedną sekundę, po czym lewa dioda LED wyłącza się. Następnie program powraca do początku pętli forever. W rezultacie robot Edison miga lewą diodą LED przez jedną sekundę za każdym razem, gdy wykryje klaśnięcie.",
	"HELP_TEXT_SENSING_BUTTONPRESSED_TITLE" : "Naciśnięcie przycisku",
	"HELP_TEXT_SENSING_BUTTONPRESSED_BODY_1" : "Blok naciśnięcia przycisku to wejście czujnika, które wskazuje, czy przycisk został naciśnięty. Dostępne są dwie opcje przycisków:",
	"HELP_TEXT_SENSING_BUTTONPRESSED_BODY_2" : "okrągły",
	"HELP_TEXT_SENSING_BUTTONPRESSED_BODY_3" : "trójkąt",
	"HELP_TEXT_SENSING_BUTTONPRESSED_BODY_4" : "Blok naciśnięcia przycisku jest blokiem w kształcie rombu, więc dane w bloku mogą być tylko prawdziwe (przycisk został naciśnięty) lub fałszywe (przycisk nie został naciśnięty).",
	"HELP_TEXT_SENSING_BUTTONPRESSED_EXAMPLE_1_TITLE" : "Przykładowy program: Sygnał dźwiękowy po naciśnięciu przycisku",
	"HELP_TEXT_SENSING_BUTTONPRESSED_EXAMPLE_1_BODY" : "W tym przykładzie program rozpoczyna się od wejścia w pętlę forever. Wewnątrz pętli forever znajduje się blok if then, który sprawdza, czy okrągły przycisk został naciśnięty. Po naciśnięciu okrągłego przycisku program uruchamia blok sygnału dźwiękowego, a następnie powraca do początku pętli forever.",
	"HELP_TEXT_SENSING_OBSTACLE_TITLE" : "Wykrywanie przeszkód",
	"HELP_TEXT_SENSING_OBSTACLE_BODY_1" : "Blok wykrywania przeszkód jest blokiem wejściowym czujnika, który wskazuje, czy wykryto przeszkodę. Dostępne są cztery opcje wykrywania:",
	"HELP_TEXT_SENSING_OBSTACLE_BODY_2" : "gdziekolwiek",
	"HELP_TEXT_SENSING_OBSTACLE_BODY_3" : "z przodu",
	"HELP_TEXT_SENSING_OBSTACLE_BODY_4" : "lewo",
	"HELP_TEXT_SENSING_OBSTACLE_BODY_5" : "prawo",
	"HELP_TEXT_SENSING_OBSTACLE_BODY_6" : "Blok wykrywania przeszkód jest blokiem w kształcie rombu, więc dane w bloku mogą być tylko prawdziwe (przeszkoda została wykryta) lub fałszywe (przeszkoda nie została wykryta).",
	"HELP_TEXT_SENSING_OBSTACLE_BODY_7" : "Aby użyć bloku wykrywania przeszkód, należy użyć bloku włączania/wyłączania wiązki wykrywania przeszkód, aby włączyć wiązkę wykrywania przeszkód.",
	"HELP_TEXT_SENSING_OBSTACLE_EXAMPLE_1_TITLE" : "Przykładowy program: Unikaj przeszkód",
	"HELP_TEXT_SENSING_OBSTACLE_EXAMPLE_1_BODY" : "W tym przykładzie program rozpoczyna się od włączenia wiązki wykrywania przeszkód, a następnie przechodzi do pętli forever. Wewnątrz pętli forever silniki są ustawione na jazdę do przodu, a następnie znajduje się blok if then, który sprawdza, czy gdziekolwiek wykryto przeszkodę. Gdy tak się stanie, robot obraca się o 180 stopni i powraca do początku pętli forever. Na początku pętli forever oba silniki są ponownie ustawione na jazdę do przodu. Powoduje to, że Edison odjeżdża od przeszkód na swojej drodze.",
	"HELP_TEXT_SENSING_LINETRACKER_TITLE" : "Śledzenie linii na powierzchni",
	"HELP_TEXT_SENSING_LINETRACKER_BODY_1" : "Blok śledzenia linii na powierzchni jest blokiem wejściowym czujnika, który wskazuje, czy powierzchnia jest odblaskowa. Powierzchnia odblaskowa to powierzchnia, która odbija światło diody LED śledzenia linii z powrotem do czujnika światła. Zazwyczaj jest to biała powierzchnia, ale czerwona powierzchnia będzie również odbijać czerwone światło z czerwonej diody LED line trackera. Powierzchnia nieodblaskowa to powierzchnia, która nie odbija światła diody LED śledzenia linii z powrotem do czujnika światła. Zazwyczaj jest to czarna powierzchnia, ale niebieska lub zielona powierzchnia również nie będzie odbijać czerwonego światła z czerwonej diody LED trackera linii.",
	"HELP_TEXT_SENSING_LINETRACKER_BODY_2" : "Dostępne są dwie opcje wykrywania:",
	"HELP_TEXT_SENSING_LINETRACKER_BODY_3" : "odblaskowa (biała)",
	"HELP_TEXT_SENSING_LINETRACKER_BODY_4" : "nieodblaskowa (czarna)",
	"HELP_TEXT_SENSING_LINETRACKER_BODY_5" : "Blok śledzenia linii na powierzchni jest blokiem w kształcie rombu, więc dane w bloku mogą być tylko prawdziwe (wykryto typ powierzchni) lub fałszywe (nie wykryto typu powierzchni).",
	"HELP_TEXT_SENSING_LINETRACKER_BODY_6" : "Aby użyć bloku śledzenia linii na powierzchni, należy użyć bloku włączania/wyłączania diody LED śledzenia linii, aby włączyć diodę LED śledzenia linii.",
	"HELP_TEXT_SENSING_LINETRACKER_EXAMPLE_1_TITLE" : "Przykładowy program: Odbijanie w granicach",
	"HELP_TEXT_SENSING_LINETRACKER_EXAMPLE_1_BODY" : "W tym przykładzie program rozpoczyna się od włączenia diody LED śledzenia linii, a następnie przechodzi do pętli forever. Wewnątrz pętli forever silniki są ustawione na jazdę do przodu, a następnie znajduje się blok if then, który sprawdza, czy powierzchnia nie jest odblaskowa. Jeśli to prawda, robot obraca się o 180 stopni i powraca do początku pętli forever. Na początku pętli forever oba silniki są ponownie ustawione na jazdę do przodu. Powoduje to, że Edison odjeżdża od wykrytych czarnych linii.",
	"HELP_TEXT_SENSING_REMOTE_BOOL_TITLE" : "Odebrano kod zdalny",
	"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_1" : "Blok odebranego kodu zdalnego jest blokiem wejściowym czujnika, który wskazuje, czy dany kod zdalnego sterowania został odebrany.",
	"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_2" : "Dostępnych jest osiem opcji kodów zdalnych od 0 do 7.",
	"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_3" : "Blok odebranego kodu zdalnego jest blokiem w kształcie rombu, więc dane w bloku mogą być tylko prawdziwe (kod został odebrany) lub fałszywe (kod nie został odebrany).",
	"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_4" : "Upewnij się, że naciśniesz przycisk trójkąta, aby uruchomić program. Łatwo o tym zapomnieć, ponieważ robot Edison zareaguje jak robot zdalnie sterowany i nie wykona tego, co mu zaprogramowałeś.",
	"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_5" : "Aby użyć bloku odebranego kodu zdalnego, robot Edison musi najpierw zostać nauczony, które przyciski pilota zdalnego sterowania odpowiadają któremu kodowi zdalnemu. Dowiedz się więcej na ten temat tutaj:",
	"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_6" : "Jeśli program zachowuje się nieoczekiwanie, może być konieczne użycie bloku wyczyść dane czujnika, aby wyczyścić zawartość bloku odebranego kodu zdalnego. Zobacz przykładowy program 1 poniżej.",
	"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_7" : "Blok odbieranego kodu pilota będzie działał z około 90% standardowych pilotów telewizyjnych na podczerwień (IR), jednak każda marka telewizorów używa nieco innych formatów danych IR. Gdy Edison dekoduje dane IR, różnice te mogą powodować nieoczekiwane zachowanie w zależności od marki pilota. Zaawansowane dekodowanie zdalnego sterowania działa najlepiej z EdRemote (dostępnym w połowie 2025 r.).",
	"HELP_TEXT_SENSING_REMOTE_BOOL_EXAMPLE_1_TITLE" : "Przykładowy program 1: Jeden czy dwa sygnały dźwiękowe?",
	"HELP_TEXT_SENSING_REMOTE_BOOL_EXAMPLE_1_BODY" : "W tym przykładzie program rozpoczyna się od wejścia w pętlę forever. Wewnątrz pętli forever znajdują się dwa bloki if then, które testują odebrany kod zdalny. Pierwszy if then sprawdza, czy odebrany kod zdalny jest kodem zdalnym 1. Jeśli jest to prawda, blok sygnału dźwiękowego zostanie odtworzony jeden raz, a dane czujnika zostaną wyczyszczone. Jeśli jest to fałsz, program przechodzi do następnego bloku if then i sprawdza, czy odebrany kod zdalny jest kodem zdalnym 2. Jeśli jest to prawda, blok sygnału dźwiękowego zostanie odtworzony dwukrotnie, a dane czujnika zostaną wyczyszczone. Następnie program powraca do początku pętli forever.",
	"HELP_TEXT_SENSING_REMOTE_BOOL_EXAMPLE_2_TITLE" : "Przykładowy program 2: Spin na polecenie pilota (działa najlepiej z EdRemote)",
	"HELP_TEXT_SENSING_REMOTE_BOOL_EXAMPLE_2_BODY" : "W tym przykładzie program rozpoczyna się od wejścia w pętlę forever. Wewnątrz pętli forever blok if then sprawdza, czy odebrano zdalny kod 0. Jeśli to prawda, oba silniki są ustawione na obracanie robota w prawo. Trwa to do momentu spełnienia warunku bloku wait until. Aby przejść, odebrany kod zdalny nie może być kodem zdalnym 0 (przycisk zdalnego sterowania nie jest już naciskany). Gdy tak się stanie, program zatrzyma oba silniki, a następnie powróci do początku pętli forever. Powoduje to, że Edison obraca się, gdy przycisk pilota jest wciśnięty.",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_TITLE" : "Wykryto komunikat IR",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_BODY_1" : "Blok wykrycia wiadomości IR jest wejściem czujnika, które wskazuje, czy wiadomość IR została wykryta (odebrana) od innego robota Edison. Termin ''IR'' jest skrótem od ''infrared'' (podczerwień). Podczerwień odnosi się do pasma światła, które nie jest widoczne dla ludzi. To sprawia, że jest przydatna jako środek do przekazywania danych na krótkie odległości.",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_BODY_2" : "Blok wykrywania wiadomości IR jest blokiem w kształcie rombu, więc dane w bloku mogą być tylko prawdziwe (wiadomość IR została odebrana) lub fałszywe (wiadomość IR nie została odebrana).",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_BODY_4" : "Blok wykrycia komunikatu IR nie zna treści odebranego komunikatu IR. Informuje jedynie program, czy komunikat IR został odebrany. Aby odczytać dane zawarte w komunikacie IR, użyj bloku odebranego komunikatu IR. Zobacz przykładowy program.",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_BODY_5" : "Komunikacja w podczerwieni między robotami Edison działa najlepiej w pomieszczeniach z dala od bezpośredniego światła słonecznego. Typowy zasięg może wynosić do 10 metrów (30 stóp).",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_EXAMPLE_1_TITLE" : "Przykładowy program: Zdalne włączanie i wyłączanie światła Edison",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_EXAMPLE_1_BODY" : "W tym przykładzie program rozpoczyna się od pętli forever. Wewnątrz pętli forever pierwszy blok if then sprawdza, czy wiadomość IR została odebrana, jeśli tak, to zmienna ''IRMessage'' jest ustawiana na wartość z bloku odebranej wiadomości IR. Pozwala to na wielokrotne odczytywanie/testowanie odebranego komunikatu bez jego kasowania lub utraty. Następna instrukcja if then sprawdza, czy dane w 'IRMessage' są równe 1, jeśli tak, to lewa dioda LED jest włączona. Jeśli nie jest to prawdą, program przechodzi do następnego bloku if then. Ten blok if then sprawdza, czy dane w ''IR Message'' są równe 2, jeśli tak, to lewa dioda LED jest wyłączona. Następnie program powraca do początku pętli forever.",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_EXAMPLE_2_TITLE" : "Robot Edison wysyłający komunikat IR uruchamia ten program.",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_EXAMPLE_2_BODY" : "Naciśnięcie trójkątnego przycisku powoduje wysłanie komunikatu IR z numerem 1 (włączenie diody LED), a naciśnięcie okrągłego przycisku powoduje wysłanie komunikatu IR z numerem 2 (wyłączenie diody LED).",
	"HELP_TEXT_SENSING_DRIVESTRAINED_TITLE" : "Wykrywanie odkształcenia napędu",
	"HELP_TEXT_SENSING_DRIVESTRAINED_BODY_1" : "Blok wykrywania naprężenia napędu jest blokiem wejściowym czujnika, który wskazuje, czy jedno lub oba koła przestały się obracać z powodu naprężenia (fizycznego uniemożliwienia obracania się podczas próby jazdy).",
	"HELP_TEXT_SENSING_DRIVESTRAINED_BODY_2" : "Blok drive strain detected jest blokiem w kształcie rombu, więc dane w bloku mogą być tylko prawdziwe (koło jest naprężone) lub fałszywe (koło nie jest naprężone).",
	"HELP_TEXT_SENSING_DRIVESTRAINED_EXAMPLE_1_TITLE" : "Przykładowy program: Alarm naprężenia koła",
	"HELP_TEXT_SENSING_DRIVESTRAINED_EXAMPLE_1_BODY" : "W tym przykładzie program rozpoczyna się od ustawienia lewego koła na jazdę do przodu, a następnie program przechodzi do pętli forever. Wewnątrz pętli znajduje się blok if then, który sprawdza, czy wykryto naprężenie napędu. Jeśli to prawda, uruchamiany jest blok sygnału dźwiękowego. Blok sygnału dźwiękowego będzie kontynuowany, dopóki naprężenie nie zostanie usunięte i koło będzie mogło się obracać.",
	"HELP_TEXT_SENSING_REMOTE_NUM_TITLE" : "Odebrany kod zdalny",
	"HELP_TEXT_SENSING_REMOTE_NUM_BODY_1" : "Blok odebranego kodu zdalnego jest blokiem wejścia czujnika, który zawiera dane odebrane z pilota zdalnego sterowania. Dane te są liczbami od 0 do 7.",
	"HELP_TEXT_SENSING_REMOTE_NUM_BODY_2" : "Gdy program uruchomi ten blok, jego zawartość zostanie wyczyszczona. Najlepiej jest zawsze umieścić dane z odebranego bloku kodu zdalnego w zmiennej przed przetestowaniem ich za pomocą bloku warunkowego (if then). Zobacz przykładowy program.",
	"HELP_TEXT_SENSING_REMOTE_NUM_EXAMPLE_1_TITLE" : "Przykładowy program: Zdalne włączanie i wyłączanie światła",
	"HELP_TEXT_SENSING_REMOTE_NUM_EXAMPLE_1_BODY" : "W tym przykładzie program rozpoczyna się od wejścia w pętlę forever. Pierwszy blok wewnątrz pętli forever umieszcza dane z odebranego bloku kodu zdalnego w zmiennej 'RemoteCode'. Zmienna ''RemoteCode'' może teraz zostać przetestowana. Pierwszy blok if then sprawdza, czy zawartość 'RemoteCode' jest równa 1. Jeśli jest to prawda, to lewa dioda LED jest włączona. Jeśli jest to fałsz, to następny blok if then testuje, czy zawartość 'RemoteCode' jest równa 2. Jeśli jest to prawda, to lewa dioda LED jest wyłączona. Następnie program powraca do początku pętli forever.",
	"HELP_TEXT_SENSING_IRMESSAGE_TITLE" : "Odebrany komunikat IR",
	"HELP_TEXT_SENSING_IRMESSAGE_BODY_1" : "Blok odebranego komunikatu IR jest blokiem wejściowym czujnika, który zawiera dane odebrane od innego robota Edison. Termin ''IR'' jest skrótem od ''infrared'' (podczerwień). Podczerwień odnosi się do pasma światła, które nie jest widoczne dla ludzi. Sprawia to, że jest to użyteczny sposób przekazywania danych na krótkie odległości. Dane są oparte na 8-bitowej liczbie binarnej i mają zakres od 0 do 255.",
	"HELP_TEXT_SENSING_IRMESSAGE_BODY_2" : "Gdy program uruchamia ten blok, jego zawartość jest czyszczona. Zawsze najlepiej jest umieścić dane z odebranego zdalnego kodu w zmiennej przed przetestowaniem go za pomocą bloku warunkowego (if then block).",
	"HELP_TEXT_SENSING_IRMESSAGE_BODY_3" : "Komunikacja w podczerwieni między robotami Edison działa najlepiej w pomieszczeniach z dala od bezpośredniego światła słonecznego. Typowy zasięg może wynosić do 10 metrów (30 stóp).",
	"HELP_TEXT_SENSING_IRMESSAGE_EXAMPLE_1_TITLE" : "Przykładowy program: Rozpocznij taneczną rewolucję",
	"HELP_TEXT_SENSING_IRMESSAGE_EXAMPLE_1_BODY" : "W tym przykładzie program rozpoczyna się od wejścia w pętlę forever. Pierwszy blok wewnątrz pętli forever czyści dane czujnika wiadomości IR, a następnie program czeka, aż zostanie odebrana wiadomość IR równa 3. Gdy to nastąpi, program wchodzi w pętlę powtarzania cztery razy. Wewnątrz pętli powtarzania znajdują się manewry taneczne robota Edison. Każdy z tych ruchów jest oparty na czasie, a nie na odległości. Jest to bardzo ważne, jeśli cała klasa robotów Edison tańczy zsynchronizowana z muzyką. Manewry taneczne powtarzają się cztery razy, a następnie program powraca do początku pętli.",
	"HELP_TEXT_SENSING_IRMESSAGE_EXAMPLE_2_TITLE" : "Przykładowy program: Wyślij wiadomość IR 3",
	"HELP_TEXT_SENSING_IRMESSAGE_EXAMPLE_2_BODY" : "W tym przykładzie program rozpoczyna się od wejścia w pętlę forever. Pierwszy blok wewnątrz pętli forever czeka, aż zostanie naciśnięty okrągły przycisk, a gdy to nastąpi, wiadomość numer 3 zostanie wysłana za pomocą światła podczerwonego. Następnie program powraca do początku pętli forever.",
	"HELP_TEXT_SENSING_LIGHTLEVEL_TITLE" : "Poziom światła czujnika",
	"HELP_TEXT_SENSING_LIGHTLEVEL_BODY_1" : "Blok poziomu światła czujnika jest blokiem wejściowym czujnika, który zawiera dane z czujników światła. Poziom światła jest liczbą z zakresu od 1 do 1000. Dane bloku poziomu światła czujnika są stale aktualizowane.",
	"HELP_TEXT_SENSING_LIGHTLEVEL_BODY_2" : "Do wyboru są trzy wejścia czujnika światła:",
	"HELP_TEXT_SENSING_LIGHTLEVEL_BODY_3" : "- lewe światło (czujnik z przodu po lewej stronie)",
	"HELP_TEXT_SENSING_LIGHTLEVEL_BODY_4" : "- prawe światło (czujnik z przodu po prawej stronie)",
	"HELP_TEXT_SENSING_LIGHTLEVEL_BODY_5" : "- śledzenie linii (czujnik używany do wykrywania linii pod robotem)",
	"HELP_TEXT_SENSING_LIGHTLEVEL_EXAMPLE_1_TITLE" : "Przykładowy program: Lampka nocna",
	"HELP_TEXT_SENSING_LIGHTLEVEL_EXAMPLE_1_BODY" : "W tym przykładzie program rozpoczyna się od wejścia w pętlę forever. Pierwszy blok wewnątrz pętli forever sprawdza, czy odczyt poziomu światła na lewym czujniku światła jest mniejszy niż 50. Jeśli jest to prawda, to włącza się lewa i prawa dioda LED. Jeśli jest to fałsz, program przeskakuje do else, a lewa i prawa dioda LED wyłączają się. Następnie program zapętla się do początku pętli forever i powtarza. Powoduje to, że diody LED Edisona są włączone, gdy jest on w słabym świetle.",
	"HELP_TEXT_ADDITION_TITLE" : "Dodawanie",
	"HELP_TEXT_ADDITION_BODY" : "Blok operatora dodawania dodaje do siebie dwie wartości. Wartościami mogą być stała (wpisana na wejściu i nie zmieniająca się), zmienna, wykrywanie lub blok operatora.",
	"HELP_TEXT_ADDITION_EXAMPLE_1_TITLE" : "Stała wartość 2 jest dodawana do stałej wartości 2.",
	"HELP_TEXT_ADDITION_EXAMPLE_2_TITLE" : "Zmienna ''Counter'' jest dodawana do stałej wartości 2.",
	"HELP_TEXT_ADDITION_EXAMPLE_3_TITLE" : "Poziom światła na wejściu czujnika jest dodawany do stałej wartości 10.",
	"HELP_TEXT_SUBTRACTION_TITLE" : "Odejmowanie",
	"HELP_TEXT_SUBTRACTION_BODY" : "Blok operatora odejmowania odejmuje jedną wartość od drugiej. Wartością może być stała (wpisana do wejścia i nie zmieniająca się), zmienna, czujnik lub blok operatora.",
	"HELP_TEXT_SUBTRACTION_EXAMPLE_1_TITLE" : "Stała wartość 10 jest odejmowana od stałej wartości 200.",
	"HELP_TEXT_SUBTRACTION_EXAMPLE_2_TITLE" : "Stała wartość 100 jest odejmowana od zmiennej ''Counter''.",
	"HELP_TEXT_SUBTRACTION_EXAMPLE_3_TITLE" : "Stała wartość 10 jest odejmowana od poziomu światła na wejściu czujnika.",
	"HELP_TEXT_SUBTRACTION_EXAMPLE_4_TITLE" : "Przykładowy program: Licznik promieniowania świetlnego",
	"HELP_TEXT_SUBTRACTION_EXAMPLE_4_BODY" : "W tym przykładowym programie tempo muzyki jest najpierw ustawione na bardzo szybkie. Następnie program przechodzi do pętli forever. Wewnątrz pętli program ustawia zmienną (Delay) na 1000 minus lewy poziom światła (odwracając odczyt poziomu światła). Następny blok czeka na wartość w zmiennej (Delay). Następnie program odtwarza nutę C i powraca do początku pętli forever i powtarza. Powoduje to, że Edison emituje sygnał dźwiękowy powoli, gdy jest ciemno i szybciej, gdy poziom światła jest jaśniejszy.",
	"HELP_TEXT_MULTIPLICATION_TITLE" : "Mnożenie",
	"HELP_TEXT_MULTIPLICATION_BODY" : "Blok operatora mnożenia mnoży dwie wartości. Wartości mogą być stałe (wpisane na wejściu i nie zmieniające się), zmienne, wykrywające lub blok operatora.",
	"HELP_TEXT_MULTIPLICATION_EXAMPLE_1_TITLE" : "Stała wartość 2 jest mnożona przez stałą wartość 4.",
	"HELP_TEXT_MULTIPLICATION_EXAMPLE_2_TITLE" : "Zmienna ''Counter'' jest mnożona przez stałą wartość 2.",
	"HELP_TEXT_MULTIPLICATION_EXAMPLE_3_TITLE" : "Poziom światła na wejściu czujnika jest mnożony przez stałą wartość 4.",
	"HELP_TEXT_DIVISION_TITLE" : "Dzielenie",
	"HELP_TEXT_DIVISION_BODY_1" : "Blok operatora dzielenia dzieli jedną wartość przez inną wartość. Wartością może być stała (wpisana do wejścia i nie zmieniająca się), zmienna, czujnik lub blok operatora.",
	"HELP_TEXT_DIVISION_BODY_2" : "Nie jest możliwe dzielenie przez zero, Edison doświadczy błędu, jeśli najbardziej wysunięta na prawo wartość wejściowa wynosi zero.",
	"HELP_TEXT_DIVISION_EXAMPLE_1_TITLE" : "Stała wartość 10 jest dzielona przez stałą wartość 2.",
	"HELP_TEXT_DIVISION_EXAMPLE_2_TITLE" : "Zmienna ''Counter'' jest dzielona przez stałą wartość 2.",
	"HELP_TEXT_DIVISION_EXAMPLE_3_TITLE" : "Poziom światła na wejściu czujnika jest dzielony przez 10.",
	"HELP_TEXT_DIVISION_EXAMPLE_4_TITLE" : "Przykładowy program: Ustawianie odległości jazdy przy użyciu zmiennej i danych z czujnika",
	"HELP_TEXT_DIVISION_EXAMPLE_4_BODY" : "W tym przykładowym programie Edison ustawia zmienną (Distance) na poziom światła z lewego czujnika światła (wartość od 1 do 1000) podzielony przez 50. Następnie Edison jedzie do przodu dla wartości w zmiennej (Distance) z prędkością 5. Powoduje to, że Edison jedzie dalej w jasnym świetle, do maksymalnej odległości 20 cm.",
	"HELP_TEXT_RANDOM_NUMBER_TITLE" : "liczba losowa",
	"HELP_TEXT_RANDOM_NUMBER_BODY" : "Blok random number between generuje liczbę losową pomiędzy dwiema wartościami. Wartościami mogą być stała (wpisana do wejścia i nie zmieniająca się), zmienna, czujnik lub blok operatora.",
	"HELP_TEXT_RANDOM_NUMBER_EXAMPLE_1_TITLE" : "Wygeneruj liczbę losową pomiędzy stałą wartością 10 a stałą wartością 100.",
	"HELP_TEXT_RANDOM_NUMBER_EXAMPLE_2_TITLE" : "Wygeneruj liczbę losową pomiędzy zmienną ''Counter'' a wartością stałą 5000.",
	"HELP_TEXT_RANDOM_NUMBER_EXAMPLE_3_TITLE" : "Wygeneruj liczbę losową pomiędzy stałą wartością 10 a poziomem światła wejściowego czujnika.",
	"HELP_TEXT_RANDOM_NUMBER_EXAMPLE_4_TITLE" : "Przykładowy program: Szalone światła",
	"HELP_TEXT_RANDOM_NUMBER_EXAMPLE_4_BODY" : "W tym przykładzie program rozpoczyna się od wejścia w pętlę forever. Wewnątrz pętli forever włączane i wyłączane są lewa i prawa dioda LED. Czasy oczekiwania między włączeniem i wyłączeniem są kontrolowane przez bloki wait milliseconds. Czas w milisekundach jest ustawiany przez bloki liczb losowych wewnątrz nich. Są one ustawione na generowanie liczb losowych w zakresie od 30 do 300 milisekund. Rezultatem jest szalone i niespójne miganie świateł LED robota Edison.",
	"HELP_TEXT_ABS_VAL_TITLE" : "abs",
	"HELP_TEXT_ABS_VAL_BODY" : "Blok abs (wartość bezwzględna) konwertuje wartość na wartość bezwzględną. Wartość bezwzględna to wartość, która jest zawsze dodatnia. Wartość może być stałą (wpisaną na wejściu i nie zmieniającą się), zmienną, czujnikiem lub blokiem operatora.",
	"HELP_TEXT_ABS_VAL_EXAMPLE_1_BODY" : "Ma wynik o wartości 3.",
	"HELP_TEXT_ABS_VAL_EXAMPLE_2_BODY" : "Ma wynik o wartości 3.",
	"HELP_TEXT_ABS_VAL_EXAMPLE_3_TITLE" : "Przykładowy program: zgłoś różnicę między poziomami oświetlenia",
	"HELP_TEXT_ABS_VAL_EXAMPLE_3_BODY" : "W tym przykładzie program rozpoczyna się od wprowadzenia pętli forever. Pierwszy blok w pętli forever ustawia zmienną ''Difference'' na wartość bezwzględną poziomu światła z prawego czujnika światła minus poziom światła z lewego czujnika światła. Blok abs zapewnia, że wynik jest zawsze dodatni (bez liczb ujemnych). Następnie program odczekuje jedną sekundę i wysyła wartość w zmiennej ''Difference'' przez USB. Wartość ta jest zawsze dodatnia (bezwzględna).",
	"HELP_TEXT_LESS_THAN_TITLE" : "Mniej niż",
	"HELP_TEXT_LESS_THAN_BODY_1" : "Blok less than porównuje dwie wartości wejściowe, aby określić, czy pierwsza wartość jest mniejsza od drugiej i zwraca wynik, który jest albo prawdziwy, albo fałszywy. Wartościami mogą być stała (wpisana na wejściu i nie zmieniająca się), zmienna, wykrywanie lub blok operatora.",
	"HELP_TEXT_LESS_THAN_BODY_2" : "Blok less than jest blokiem w kształcie rombu, więc wynikiem bloku może być tylko prawda lub fałsz.",
	"HELP_TEXT_LESS_THAN_EXAMPLE_1_BODY" : "Wynik: prawda",
	"HELP_TEXT_LESS_THAN_EXAMPLE_2_BODY" : "Wynik: fałsz",
	"HELP_TEXT_LESS_THAN_EXAMPLE_3_TITLE" : "Czy zmienna ''Counter'' jest mniejsza niż stała wartość 120.",
	"HELP_TEXT_LESS_THAN_EXAMPLE_4_TITLE" : "Czy poziom światła z lewego czujnika jest mniejszy niż stała wartość 500.",
	"HELP_TEXT_LESS_THAN_EQUAL_TITLE" : "Mniej niż lub równe",
	"HELP_TEXT_LESS_THAN_EQUAL_BODY_1" : "Blok less than or equal to porównuje dwie wartości wejściowe w celu określenia, czy pierwsza wartość jest mniejsza lub równa drugiej wartości i zwraca wynik, który jest albo prawdziwy, albo fałszywy. Wartościami mogą być stała (wpisana na wejściu i nie zmieniająca się), zmienna, wykrywanie lub blok operatora.",
	"HELP_TEXT_LESS_THAN_EQUAL_BODY_2" : "Blok mniejszy lub równy jest blokiem w kształcie rombu, więc wynikiem bloku może być tylko prawda lub fałsz.",
	"HELP_TEXT_LESS_THAN_EQUAL_EXAMPLE_1_BODY" : "Wynik: prawda",
	"HELP_TEXT_LESS_THAN_EQUAL_EXAMPLE_2_BODY" : "Wynik: fałsz",
	"HELP_TEXT_LESS_THAN_EQUAL_EXAMPLE_3_BODY" : "Wynik: prawda",
	"HELP_TEXT_LESS_THAN_EQUAL_EXAMPLE_4_TITLE" : "Czy zmienna ''Counter'' jest mniejsza lub równa stałej wartości 120.",
	"HELP_TEXT_LESS_THAN_EQUAL_EXAMPLE_5_TITLE" : "Czy poziom światła z lewego czujnika jest mniejszy lub równy stałej wartości 500.",
	"HELP_TEXT_EQUAL_TITLE" : "Równa się",
	"HELP_TEXT_EQUAL_BODY_1" : "Blok równa się porównuje dwie wartości wejściowe, aby określić, czy pierwsza wartość jest równa drugiej wartości i zwraca wynik, który jest albo prawdziwy, albo fałszywy. Wartościami mogą być stała (wpisana na wejściu i nie zmieniająca się), zmienna, wykrywanie lub blok operatora.",
	"HELP_TEXT_EQUAL_BODY_2" : "Blok równa się jest blokiem w kształcie rombu, więc wynikiem bloku może być tylko prawda lub fałsz.",
	"HELP_TEXT_EQUAL_EXAMPLE_1_BODY" : "Wynik: prawda",
	"HELP_TEXT_EQUAL_EXAMPLE_2_BODY" : "Wynik: fałsz",
	"HELP_TEXT_EQUAL_EXAMPLE_3_TITLE" : "Czy zmienna ''Counter'' jest równa stałej wartości 60.",
	"HELP_TEXT_EQUAL_EXAMPLE_4_TITLE" : "Czy odebrany kod zdalny jest równy stałej wartości 3.",
	"HELP_TEXT_GREATER_THAN_EQUAL_TITLE" : "Większy lub równy",
	"HELP_TEXT_GREATER_THAN_EQUAL_BODY_1" : "Blok greater than or equal to porównuje dwie wartości wejściowe w celu określenia, czy pierwsza wartość jest większa lub równa drugiej wartości i zwraca wynik, który jest albo prawdziwy, albo fałszywy. Wartościami mogą być stała (wpisana na wejściu i nie zmieniająca się), zmienna, wykrywanie lub blok operatora.",
	"HELP_TEXT_GREATER_THAN_EQUAL_BODY_2" : "Blok większy lub równy jest blokiem w kształcie rombu, więc wynikiem bloku może być tylko prawda lub fałsz.",
	"HELP_TEXT_GREATER_THAN_EQUAL_EXAMPLE_1_BODY" : "Wynik: prawda",
	"HELP_TEXT_GREATER_THAN_EQUAL_EXAMPLE_2_BODY" : "Wynik: fałsz",
	"HELP_TEXT_GREATER_THAN_EQUAL_EXAMPLE_3_BODY" : "Wynik: prawda",
	"HELP_TEXT_GREATER_THAN_EQUAL_EXAMPLE_4_TITLE" : "Czy zmienna ''Counter'' jest większa lub równa stałej wartości 120.",
	"HELP_TEXT_GREATER_THAN_EQUAL_EXAMPLE_5_TITLE" : "Czy poziom światła z lewego czujnika jest większy lub równy stałej wartości 500.",
	"HELP_TEXT_GREATER_THAN_TITLE" : "Większy niż",
	"HELP_TEXT_GREATER_THAN_BODY_1" : "Blok greater than porównuje dwie wartości wejściowe, aby określić, czy pierwsza wartość jest większa niż druga wartość i zwraca wynik, który jest albo prawdziwy, albo fałszywy. Wartościami mogą być stała (wpisana na wejściu i nie zmieniająca się), zmienna, wykrywanie lub blok operatora.",
	"HELP_TEXT_GREATER_THAN_BODY_2" : "Blok większy niż jest blokiem w kształcie rombu, więc wynikiem bloku może być tylko prawda lub fałsz",
	"HELP_TEXT_GREATER_THAN_EXAMPLE_1_BODY" : "Wynik: prawda",
	"HELP_TEXT_GREATER_THAN_EXAMPLE_2_BODY" : "Wynik: fałsz",
	"HELP_TEXT_GREATER_THAN_EXAMPLE_3_TITLE" : "Czy zmienna ''Counter'' jest większa niż stała wartość 120.",
	"HELP_TEXT_GREATER_THAN_EXAMPLE_4_TITLE" : "Czy poziom światła z lewego czujnika jest większy niż stała wartość 500.",
	"HELP_TEXT_NOT_EQUAL_TITLE" : "Nie równa się",
	"HELP_TEXT_NOT_EQUAL_BODY_1" : "Blok not equal to porównuje dwie wartości wejściowe w celu określenia, czy pierwsza wartość nie jest równa drugiej wartości i zwraca wynik, który jest albo prawdziwy, albo fałszywy. Wartościami mogą być stała (wpisana na wejściu i nie zmieniająca się), zmienna, wykrywanie lub blok operatora.",
	"HELP_TEXT_NOT_EQUAL_BODY_2" : "Blok not equal to jest blokiem w kształcie rombu, więc wynikiem bloku może być tylko prawda lub fałsz.",
	"HELP_TEXT_NOT_EQUAL_EXAMPLE_1_BODY" : "Wynik: prawda",
	"HELP_TEXT_NOT_EQUAL_EXAMPLE_2_BODY" : "Wynik: fałsz",
	"HELP_TEXT_NOT_EQUAL_EXAMPLE_3_TITLE" : "Czy zmienna ''Counter'' nie jest równa stałej wartości 120.",
	"HELP_TEXT_NOT_EQUAL_EXAMPLE_4_TITLE" : "Czy odebrany kod zdalny nie jest równy stałej wartości 3.",
	"HELP_TEXT_IS_BETWEEN_TITLE" : "Is between",
	"HELP_TEXT_IS_BETWEEN_BODY_1" : "Blok is between określa, czy wartość znajduje się w zakresie dwóch innych wartości. Wartości mogą być stałe (wpisane do wejścia i nie zmieniające się), zmienne, czujniki lub bloki operatora.",
	"HELP_TEXT_IS_BETWEEN_BODY_2" : "Blok is between jest blokiem w kształcie rombu, więc wynikiem bloku może być tylko prawda lub fałsz.",
	"HELP_TEXT_IS_BETWEEN_EXAMPLE_1_BODY" : "Wynik: prawda",
	"HELP_TEXT_IS_BETWEEN_EXAMPLE_2_BODY" : "Wynik: fałsz",
	"HELP_TEXT_IS_BETWEENL_EXAMPLE_3_TITLE" : "Czy zmienna ''Counter'' znajduje się między stałą wartością 60 a stałą wartością 120.",
	"HELP_TEXT_IS_BETWEEN_EXAMPLE_4_TITLE" : "Czy poziom światła lewego czujnika światła znajduje się między wartością stałą 250 a wartością stałą 750.",
	"HELP_TEXT_AND_TITLE" : "I",
	"HELP_TEXT_AND_BODY_1" : "Blok and określa, czy oba wejścia są prawdziwe. Jeśli oba wejścia są prawdziwe, wynik również będzie prawdziwy. Jeśli jedno lub oba wejścia są fałszywe, wynik będzie fałszywy. Wejścia akceptują bloki w kształcie rombu, które mogą być blokiem operatora lub blokiem wykrywania.",
	"HELP_TEXT_AND_BODY_2" : "Blok i jest blokiem w kształcie rombu, więc wynikiem bloku może być tylko prawda lub fałsz.",
	"HELP_TEXT_AND_EXAMPLE_1_BODY" : "Wynik: prawda",
	"HELP_TEXT_AND_EXAMPLE_2_BODY" : "Wynik: fałsz",
	"HELP_TEXT_AND_EXAMPLE_3_TITLE" : "Czy wykryto zarówno śledzenie linii na powierzchni odbijającej, jak i odkształcenie napędu.",
	"HELP_TEXT_AND_EXAMPLE_4_TITLE" : "Czy zmienna ''Counter'' jest większa niż 50 ''i'' odebrany kod zdalny jest równy stałej wartości 3.",
	"HELP_TEXT_OR_TITLE" : "Lub",
	"HELP_TEXT_OR_BODY_1" : "Blok or określa, czy pierwsze wejście ''lub'' drugie wejście są prawdziwe. Jeśli jedno lub oba wejścia są prawdziwe, wynik będzie prawdziwy. Jeśli oba wejścia są fałszywe, wynikiem będzie fałsz. Wejścia akceptują bloki w kształcie rombu, które mogą być blokiem operatora lub blokiem wykrywania.",
	"HELP_TEXT_OR_BODY_2" : "Blok lub jest blokiem w kształcie rombu, więc wynikiem bloku może być tylko prawda lub fałsz.",
	"HELP_TEXT_OR_EXAMPLE_1_BODY" : "Wynik: prawda",
	"HELP_TEXT_OR_EXAMPLE_2_BODY" : "Wynik: prawda",
	"HELP_TEXT_OR_EXAMPLE_3_BODY" : "Wynik: fałsz",
	"HELP_TEXT_OR_EXAMPLE_4_TITLE" : "Czy tracker linii na powierzchni odbijającej ''lub'' wykryto naprężenie napędu.",
	"HELP_TEXT_OR_EXAMPLE_5_TITLE" : "Czy zmienna ''Counter'' jest mniejsza niż stała wartość 50 ''lub'' odebrany zdalny kod jest równy stałej wartości 3.",
	"HELP_TEXT_NOT_TITLE" : "Nie",
	"HELP_TEXT_NOT_BODY_1" : "Blok not określa, czy wejście jest ''nieprawdziwe''. Jeśli wejście jest fałszywe, wyjście będzie prawdziwe. Jeśli wejście jest prawdziwe, wyjście będzie fałszywe. Wejście akceptuje bloki w kształcie rombu, które mogą być blokiem operatora lub blokiem wykrywania.",
	"HELP_TEXT_NOT_BODY_2" : "Blok not jest blokiem w kształcie rombu, więc wynikiem bloku może być tylko prawda lub fałsz.",
	"HELP_TEXT_NOT_EXAMPLE_1_BODY" : "Wynik: fałsz",
	"HELP_TEXT_NOT_EXAMPLE_2_BODY" : "Wynik: prawda",
	"HELP_TEXT_NOT_EXAMPLE_3_TITLE" : "Czy zdalny kod 0 nie został odebrany.",
	"HELP_TEXT_NOT_EXAMPLE_4_TITLE" : "Przykładowy program: Spin on remote control command (działa najlepiej z EdRemote)",
	"HELP_TEXT_NOT_EXAMPLE_4_BODY" : "W tym przykładzie program rozpoczyna się od wejścia w pętlę forever. Wewnątrz pętli forever blok if then sprawdza, czy odebrano zdalny kod 0. Jeśli to prawda, oba silniki są ustawione na obracanie robota w prawo. Trwa to do momentu spełnienia warunku bloku wait until. Aby pomyślnie przejść, odebrany zdalny kod nie może być zdalnym kodem 0 (przycisk zdalnego sterowania nie jest już naciskany). Gdy tak się stanie, program zatrzyma oba silniki, a następnie powróci do początku pętli forever. Powoduje to, że Edison obraca się, gdy przycisk pilota jest wciśnięty.",
	"HELP_TEXT_COMMENT_TITLE" : "komentarz",
	"HELP_TEXT_COMMENT_BODY_1" : "Blok komentarza służy do dodawania notatek do programu. Uwagi opisują prostym językiem, jak program ma działać. Dodawanie komentarzy do programu jest pomocne, gdy ktoś inny musi edytować twój program lub gdy ty musisz edytować swój program po długim czasie od jego napisania.",
	"HELP_TEXT_COMMENT_BODY_2" : "Komentarze nie są zaprogramowane w Edisonie, więc nie zmieniają zachowania twojego programu.",
	"HELP_TEXT_COMMENT_EXAMPLE_1_TITLE" : "Przykładowy program: Komentarze wyjaśniają działanie programu w prostym języku",
	"HELP_TEXT_SEND_USB_TITLE" : "wyślij przez USB",
	"HELP_TEXT_SEND_USB_BODY_1" : "Blok send via USB przesyła wartość do komputera za pośrednictwem połączenia USB. Wartość może być stałą (wpisaną na wejściu i nie zmieniającą się), zmienną, czujnikiem lub blokiem operatora.",
	"HELP_TEXT_SEND_USB_BODY_2" : "Aby zobaczyć liczbę na komputerze, kliknij przycisk USB w EdScratch, a pojawi się wyskakujące okno. Kliknij Uruchom USB, aby połączyć się z robotem Edison V3. Dane otrzymane z robota Edison V3 pojawią się w oknie Data from USB.",
	"HELP_TEXT_SEND_USB_BODY_3" : "Blok wysyłania do USB może być również używany do debugowania programu.",
	"HELP_TEXT_SEND_USB_BODY_4" : "Koła robota Edison V3 nie będą jeździć, gdy są podłączone do USB. Wynika to z międzynarodowych standardów bezpieczeństwa, które nie zezwalają, aby produkty przeznaczone dla dzieci mogły napędzać silnik podłączony do portu USB.",
	"HELP_TEXT_SEND_USB_EXAMPLE_1_TITLE" : "Przykładowy program: Zmierz poziom oświetlenia",
	"HELP_TEXT_SEND_USB_EXAMPLE_1_BODY" : "W tym przykładzie program rozpoczyna się od wejścia w pętlę forever. Pierwszy blok wewnątrz pętli wysyła poziom światła lewego czujnika światła przez USB. Następnie program czeka jedną sekundę i powtarza.",
	"HELP_TEXT_SAVE_USB_TITLE" : "poczekaj na dane USB i zapisz je",
	"HELP_TEXT_SAVE_USB_BODY_1" : "Blok wait for USB data and save to wstrzymuje działanie programu do momentu odebrania danych przez USB, a następnie umieszcza dane w zmiennej.",
	"HELP_TEXT_SAVE_USB_BODY_2" : "Koła robota Edison V3 nie będą jeździć, gdy są podłączone do USB. Wynika to z międzynarodowych standardów bezpieczeństwa, które nie zezwalają, aby produkty przeznaczone dla dzieci mogły napędzać silnik podłączony do portu USB.",
	"HELP_TEXT_SAVE_USB_EXAMPLE_1_TITLE" : "Przykładowy program: Liczba sygnałów dźwiękowych z USB",
	"HELP_TEXT_SAVE_USB_EXAMPLE_1_BODY_1" : "W tym przykładzie program rozpoczyna się od wejścia w pętlę forever. Pierwszy blok wewnątrz pętli czeka, aż dane zostaną odebrane z USB. Po odebraniu danych są one zapisywane w zmiennej ''Count''. Następnie program przechodzi do bloku powtarzania, który powtarza dla wartości zmiennej ''Count''. Wewnątrz bloku powtarzania uruchamiane są bloki beep i wait sec. Spowoduje to, że Edison wyemituje sygnał dźwiękowy wysłany przez USB określoną liczbę razy.",
	"HELP_TEXT_SAVE_USB_EXAMPLE_1_BODY_2" : "Aby przetestować ten program, kliknij przycisk USB w aplikacji EdScratch, a pojawi się wyskakujące okienko. Kliknij Uruchom USB, aby połączyć się z robotem Edison V3. Aby wysłać dane do robota Edison V3, wpisz liczbę w polu Data to USB i kliknij przycisk Send to USB.",
	"HELP_TEXT_FUNCTION_START_TITLE" : "Uruchomienie funkcji",
	"HELP_TEXT_FUNCTION_START_BODY_1" : "Blok rozpoczęcia funkcji to miejsce, w którym rozpoczyna się Twoja funkcja. Połącz bloki z blokiem rozpoczęcia funkcji, aby utworzyć funkcję niestandardową.",
	"HELP_TEXT_FUNCTION_START_BODY_2" : "Bloki funkcyjne pomagają uprościć program, ponieważ kod może być pogrupowany, co ułatwia jego odczytanie. Funkcje pomagają również zmniejszyć rozmiar programu, ponieważ powtarzające się części programu muszą być napisane tylko raz.",
	"HELP_TEXT_FUNCTION_START_BODY_3" : "Bloki wywołania funkcji nie mogą być umieszczane pod blokami rozpoczęcia funkcji.",
	"HELP_TEXT_FUNCTION_START_EXAMPLE_1_TITLE" : "Przykładowy program 1: Napęd w kształcie kwadratu",
	"HELP_TEXT_FUNCTION_START_EXAMPLE_1_BODY" : "W tym przykładzie program rozpoczyna się od wprowadzenia czterokrotnej pętli repeat. Wewnątrz bloku powtarzania znajduje się wywołanie funkcji o nazwie ''DriveAndTurn''. Gdy program dotrze do tego bloku, przeskakuje do odpowiedniego bloku uruchamiania funkcji. W tym bloku robot ma jechać do przodu 10 cm, a następnie obrócić się w prawo o 90 stopni. Funkcja ta jest wywoływana cztery razy wewnątrz pętli powtarzania. W rezultacie Edison jedzie po kwadracie.",
	"HELP_TEXT_FUNCTION_START_EXAMPLE_2_TITLE" : "Przykładowy program 2: Unikaj linii i przeszkód",
	"HELP_TEXT_FUNCTION_START_EXAMPLE_2_BODY" : "W tym przykładzie program rozpoczyna się od włączenia detektora przeszkód i diody LED śledzenia linii, a następnie przechodzi do pętli forever. Wewnątrz pętli forever oba silniki są ustawione na jazdę do przodu. Następnie blok if then sprawdza, czy wykryto jakąkolwiek przeszkodę, jeśli tak, to blok wywołania funkcji ''TurnAround'' powoduje, że program przeskakuje do bloku uruchomienia funkcji ''TurnAround''. Następnie program zatrzymuje silniki, włącza diody LED, emituje sygnał dźwiękowy, jedzie do tyłu, obraca się o 175 stopni i wyłącza diody LED, a następnie wraca do programu głównego w miejscu, w którym został przerwany. Następny blok if then sprawdza, czy powierzchnia jest nieodblaskowa (czarna), jeśli tak, to blok wywołania funkcji ''TurnAround'' powoduje, że program przeskakuje do bloku uruchomienia funkcji ''TurnAround''. Następnie program zatrzymuje silniki, włącza diody LED, emituje sygnał dźwiękowy, jedzie do tyłu, obraca się o 175 stopni i wyłącza diody LED, a następnie wraca do programu głównego w miejscu, w którym został przerwany. Powoduje to, że Edison odjeżdża od wykrytych linii i obiektów.",
	"HELP_TEXT_FUNCTION_CALL_TITLE" : "Wywołanie funkcji",
	"HELP_TEXT_FUNCTION_CALL_BODY_1" : "Blok wywołania funkcji nakazuje programowi przejście do bloku rozpoczęcia funkcji.",
};
Blockly.ScratchMsgs.locales['fr'] ={
	"CONTROL_FOREVER" : "pour toujours",
	"CONTROL_REPEAT" : "répéter",
	"CONTROL_IF" : "si",
	"CONTROL_THAN" : "alors",
	"CONTROL_ELSE" : "else",
	"CONTROL_STOP" : "arrêter",
	"CONTROL_STOP_ALL" : "tous",
	"CONTROL_WAIT" : "attendre",
	"CONTROL_WAIT_SEC" : "sec",
	"CONTROL_WAIT_MILLISECONDS" : "millisecondes",
	"CONTROL_WAITUNTIL" : "attendre jusqu'à",
	"CONTROL_REPEATUNTIL" : "répéter jusqu'à",
	"DATA_BUTTONCREATE" : "Créer une variable",
	"DATA_BUTTONMANAGE" : "Gérer les variables",
	"DATA_SET" : "mettre",
	"DATA_TO" : "à",
	"DATA_INCVARIABLE" : "incrémenter",
	"DATA_DECVARIABLE" : "décrémenter",
	"DATA_BITSHIFT" : "décalage de bits",
	"DATA_BITSHIFTLEFT" : "à gauche par",
	"DATA_BITSHIFTRIGHT" : "à droite par",
	"EVENT_ANY_OBSTACLE" : "Obstacle détecté",
	"EVENT_OBSTACLE_AHEAD" : "Obstacle détecté devant",
	"EVENT_OBSTACLE_LEFT" : "Obstacle détecté à gauche",
	"EVENT_OBSTACLE_RIGHT" : "Obstacle détecté à droite",
	"EVENT_CLAP" : "Clap détecté",
	"EVENT_BUTTON_TRIANGLE" : "Bouton triangulaire enfoncé",
	"EVENT_BUTTON_ROUND" : "Bouton rond enfoncé",
	"EVENT_LINE_REFLECTIVE" : "Traceur de ligne sur une surface réfléchissante",
	"EVENT_LINE_NON_REFLECTIVE" : "Traceur de ligne sur une surface non réfléchissante",
	"EVENT_LINE_CHANGE" : "Le traceur de ligne change de surface",
	"EVENT_MESSAGE" : "Message IR reçu",
	"EVENT_REMOTE" : "Code à distance reçu",
	"EVENT_DRIVE_STRAIN" : "Entraînement tendu",
	"EVENT_START" : "Démarrage",
	"OPERATORS_RANDOM" : "nombre aléatoire entre",
	"OPERATORS_AND" : "et",
	"OPERATORS_OR" : "ou",
	"OPERATORS_NOT" : "pas",
	"OPERATORS_ABS" : "abs",
	"OPERATORS_BETWEEN" : "est entre",
	"SENSING_TURN_LINE_TRACKING_LED" : "DEL de suivi de ligne de virage",
	"SENSING_TURN_OBSTACLE_BEAM" : "faisceau de détection d'obstacles dans les virages",
	"SENSING_CLEAR" : "dégager",
	"SENSING_SENSOR" : "données du capteur",
	"SENSING_CLAP_DETECTED" : "clap détecté",
	"SENSING_BUTTON_PRESSED" : "bouton enfoncé",
	"SENSING_OBSTACLE" : "obstacle détecté",
	"SENSING_LINE_TRACKER" : "ligne de repérage sur",
	"SENSING_LINE_SURFACE" : "surface",
	"SENSING_REMOTE_NUM" : "code à distance reçu",
	"SENSING_REMOTE_BOOL" : "code à distance",
	"SENSING_REMOTE_RECEIVED" : "reçu",
	"SENSING_IR_MESSAGE_DETECTED" : "message IR détecté",
	"SENSING_IR_MESSAGE" : "message IR reçu",
	"SENSING_LIGHT_LEVEL" : "niveau de luminosité du",
	"SENSING_LIGHT_SENSOR" : "capteur",
	"SENSING_DRIVE_STRAIN" : "tension d'entraînement détectée",
	"SENSING_DROPDOWN_ON" : "allumé",
	"SENSING_DROPDOWN_OFF" : "éteint",
	"SENSING_CLEAR_DROPDOWN_CLAP" : "détecteur de claquement",
	"SENSING_CLEAR_DROPDOWN_KEY" : "clavier",
	"SENSING_CLEAR_DROPDOWN_OBS" : "détecteur d'obstacles",
	"SENSING_CLEAR_DROPDOWN_REMOTE" : "code à distance",
	"SENSING_CLEAR_DROPDOWN_IR" : "message IR",
	"SENSING_KEY_DROPDOWN_ROUND" : "rond",
	"SENSING_KEY_DROPDOWN_TRIANGLE" : "triangle",
	"SENSING_OBS_DROPDOWN_ANY" : "n'importe où",
	"SENSING_OBS_DROPDOWN_AHEAD" : "devant",
	"SENSING_OBS_DROPDOWN_LEFT" : "à gauche",
	"SENSING_OBS_DROPDOWN_RIGHT" : "à droite",
	"SENSING_LINE_DROPDOWN_WHITE" : "réfléchissant",
	"SENSING_LINE_DROPDOWN_BLACK" : "non réfléchissant",
	"SENSING_LIGHT_DROPDOWN_LEFT" : "lumière à gauche",
	"SENSING_LIGHT_DROPDOWN_RIGHT" : "lumière droite",
	"SENSING_LIGHT_DROPDOWN_LINE" : "suivi de ligne",
	"COMMENT_USER_COMMENT" : "commente :",
	"ADVANCED_USB_SEND_DATA" : "envoyer",
	"ADVANCED_USB_SEND_VIA" : "par l'intermédiaire de l'USB",
	"ADVANCED_USB_RECEIVED_DATA" : "données reçues de l'USB",
	"ADVANCED_USB_RECEIVED_DATA_VAR" : "attendre les données de l'USB et les sauvegarder sur",
	"SOUND_BEEP" : "bip",
	"SOUND_PLAY_NOTE" : "jouer un",
	"SOUND_PLAY_NOTE_DROP_DURATION_WHOLE" : "entière",
	"SOUND_PLAY_NOTE_DROP_DURATION_HALF" : "la moitié",
	"SOUND_PLAY_NOTE_DROP_DURATION_QUARTER" : "quart",
	"SOUND_PLAY_NOTE_DROP_DURATION_EIGHTH" : "huitième",
	"SOUND_PLAY_NOTE_DROP_NOTE_C" : "C",
	"SOUND_PLAY_NOTE_DROP_NOTE_B" : "B",
	"SOUND_PLAY_NOTE_DROP_NOTE_A" : "A",
	"SOUND_PLAY_NOTE_DROP_NOTE_G" : "G",
	"SOUND_PLAY_NOTE_DROP_NOTE_F" : "F",
	"SOUND_PLAY_NOTE_DROP_NOTE_E" : "E",
	"SOUND_PLAY_NOTE_DROP_NOTE_D" : "D",
	"SOUND_PLAY_NOTE_DROP_NOTE_MID_C" : "Do moyen",
	"SOUND_PLAY_NOTE_DROP_NOTE_LOW_B" : "Si grave",
	"SOUND_PLAY_NOTE_DROP_NOTE_REST" : "reste",
	"SOUND_PLAY_NOTE_DROP_MOD_SHARP" : "dièse",
	"SOUND_PLAY_NOTE_DROP_MOD_FLAT" : "bémol",
	"SOUND_SET_TEMPO" : "règle le tempo de la musique sur",
	"SOUND_SET_TEMPO_DROP_VERY_SLOW" : "très lent",
	"SOUND_SET_TEMPO_DROP_SLOW" : "lent",
	"SOUND_SET_TEMPO_DROP_MEDIUM" : "moyen",
	"SOUND_SET_TEMPO_DROP_FAST" : "rapide",
	"SOUND_SET_TEMPO_DROP_VERY_FAST" : "très rapide",
	"SOUND_PLAY_IN_BACKGROUND" : "Joue de la musique en arrière-plan",
	"CATEGORY_SOUND" : "Son",
	"CATEGORY_EVENTS" : "Événements",
	"CATEGORY_CONTROL" : "Contrôle",
	"CATEGORY_SENSING" : "Détection",
	"CATEGORY_OPERATORS" : "Opérateurs",
	"CATEGORY_VARIABLES" : "Variables",
	"CATEGORY_MYBLOCKS" : "Fonctions",
	"CATEGORY_DRIVE" : "Pilotage",
	"CATEGORY_COMMENT" : "Commentaire",
	"CATEGORY_LED" : "LEDs",
	"CATEGORY_ADVANCED" : "Avancé",
	"DUPLICATE" : "Dupliquer",
	"DELETE" : "Supprimer",
	"DELETE_BLOCK" : "Supprimer le bloc",
	"CONTEXT_DELETE" : "Supprimer",
	"CONTEXT_DELETE_ALL" : "Supprimer tous les",
	"CONTEXT_BLOCKS" : "blocs",
	"CLEAN_UP" : "Nettoyer les blocs",
	"HELP" : "Aide",
	"UNDO" : "Annuler",
	"REDO" : "Rétablir",
	"CHANGE_VALUE_TITLE" : "Modifier la valeur :",
	"RENAME_VARIABLE" : "Renommer la variable",
	"RENAME_VARIABLE_MODAL_TITLE" : "Renommer une variable",
	"NEW_VARIABLE" : "Créer une variable",
	"NEW_VARIABLE_TITLE" : "Nouveau nom de variable :",
	"VARIABLE_MODAL_TITLE" : "Nouvelle variable",
	"NEW_PROCEDURE" : "Créer une fonction",
	"MANAGE_PROCEDURE" : "Gérer une fonction",
	"PROCEDURE_DEFAULT_NAME" : "Nom du bloc",
	"PROCEDURE_USED" : "Pour supprimer une définition de bloc, il faut d'abord supprimer toutes les utilisations du bloc",
	"DRIVE_FORWARDS_DISTANCE" : "en avant pour",
	"DRIVE_BACKWARDS_DISTANCE" : "en arrière pour",
	"DRIVE_LEFT_DISTANCE" : "gauche pour",
	"DRIVE_RIGHT_DISTANCE" : "droite pour",
	"DRIVE_DISTANCE_DROPDOWN_CM" : "cm",
	"DRIVE_DISTANCE_DROPDOWN_INCH" : "pouce",
	"DRIVE_DISTANCE_DROPDOWN_SECONDS" : "secondes",
	"DRIVE_DISTANCE_DROPDOWN_DEGREES" : "degrés",
	"DRIVE_TURN_DROPDOWN_SPIN" : "tourner",
	"DRIVE_TURN_DROPDOWN_FORWARDS" : "tourner vers l'avant",
	"DRIVE_TURN_DROPDOWN_BACKWARDS" : "tourner vers l'arrière",
	"DRIVE_FORWARDS_UNTIL" : "vers l'avant jusqu'à",
	"DRIVE_BACKWARDS_UNTIL" : "en arrière jusqu'à",
	"DRIVE_LEFT_UNTIL" : "à gauche jusqu'à",
	"DRIVE_RIGHT_UNTIL" : "droite jusqu'à",
	"DRIVE_SET_LEFT_MOTOR" : "Régler le moteur gauche sur",
	"DRIVE_SET_RIGHT_MOTOR" : "régler le moteur droit sur",
	"DRIVE_SET_MOTOR_DROPDOWN_FORWARDS" : "en avant",
	"DRIVE_SET_MOTOR_DROPDOWN_BACKWARDS" : "en arrière",
	"DRIVE_SET_BOTH_MOTOR" : "Régler les deux moteurs sur",
	"DRIVE_SET_BOTH_MOTOR_DROPDOWN_FORWARDS" : "avancer",
	"DRIVE_SET_BOTH_MOTOR_DROPDOWN_BACKWARDS" : "reculer",
	"DRIVE_SET_BOTH_MOTOR_DROPDOWN_SPIN_LEFT" : "faire tourner le robot à gauche",
	"DRIVE_SET_BOTH_MOTOR_DROPDOWN_SPIN_RIGHT" : "faire tourner le robot à droite",
	"DRIVE_SET_BOTH_MOTOR_DROPDOWN_TURN_LEFT" : "tourne le robot à gauche",
	"DRIVE_SET_BOTH_MOTOR_DROPDOWN_TURN_RIGHT" : "tourner le robot à droite",
	"DRIVE_AT_SPEED" : "à la vitesse",
	"DRIVE_STOP" : "arrêter",
	"DRIVE_STOP_DROPDOWN_BOTH" : "les deux moteurs",
	"DRIVE_STOP_DROPDOWN_LEFT" : "moteur gauche",
	"DRIVE_STOP_DROPDOWN_RIGHT" : "moteur droit",
  "LED_LEFT" : "LED gauche",
  "LED_RIGHT" : "LED droite",
	"LED_DROPDOWN_ON" : "allumé",
	"LED_DROPDOWN_OFF" : "éteint",
	"LED_SEND_MESSAGE" : "envoie un message IR",
	"DEMO_TEST_PROGRAM" : "Programme de test",
	"DEMO_TEST_PROGRAM_DISC" : "Teste le moteur, les DEL et le haut-parleur",
	"DEMO_MOVE_WITH_MUSIC" : "Bouge avec de la musique",
	"DEMO_MOVE_WITH_MUSIC_DISC" : "Conduire en jouant de la musique",
	"DEMO_FOLLOW_A_LINE" : "Suivre une ligne",
	"DEMO_FOLLOW_A_LINE_DISC" : "Utilise le capteur de ligne pour suivre une ligne noire",
	"DEMO_BOUNCE_IN_BORDERS" : "Rebondir dans les bordures",
	"DEMO_BOUNCE_IN_BORDERS_DISC" : "Utilise le capteur de ligne pour rester à l'intérieur d'une ligne noire.",
	"DEMO_WARNINGS" : "Démonstration des messages d'avertissement",
	"DEMO_WARNINGS_DISC" : "Démontre les messages d'erreur rouges et les messages d'avertissement jaunes.",
	"DEMO_CLAP_CONTROL" : "Conduite contrôlée par claquement de mains",
	"DEMO_CLAP_CONTROL_DISC" : "Frappe une fois pour tourner, deux fois pour avancer.",
	"DEMO_AVOID_OBSTACLES" : "Éviter les obstacles",
	"DEMO_AVOID_OBSTACLES_DISC" : "Utilise le capteur d'obstacles pour éviter de foncer dans les obstacles",
	"DEMO_FOLLOW_TORCH" : "Suivre une torche",
	"DEMO_FOLLOW_TORCH_DISC" : "Utilise les capteurs de lumière pour suivre une lampe de poche",
	"DEMO_FOLLOW_A_LINE_IF" : "Suivre une ligne à l'aide des instructions if",
	"DEMO_FOLLOW_A_LINE_IF_DISC" : "Une autre façon d'utiliser le capteur de ligne pour suivre une ligne à l'aide d'un bloc if.",
	"MENU_DROP_MENU" : "Menu",
	"MENU_DROP_NEW" : "Nouveau",
	"MENU_DROP_LOAD_DEMO" : "Charger la démo",
	"MENU_DROP_LOAD_LOCAL" : "Charger depuis l'ordinateur",
	"MENU_DROP_SAVE_LOCAL" : "Sauvegarder sur l'ordinateur",
	"MENU_DROP_UPDATE_FIRMWARE" : "Mettre à jour le micrologiciel",
	"MENU_DROP_DIAGNOSTICS" : "Diagnostics",
	"MENU_DROP_LANGUAGE_LABEL" : "Langue",
	"MENU_DROP_ABOUT" : "A propos de",
	"MENU_DROP_TERMS" : "Conditions d'utilisation",
	"MENU_USB" : "USB",
	"MENU_SAVE" : "Sauvegarder",
	"MENU_VERSION_MAIN" : "Edison V3",
	"MENU_VERSION_SWITCH" : "Passer à Edison V1/V2",
	"MENU_VERSION_WHICH_VERSION" : "Quelle version ai-je ?",
	"MENU_PROGRAM" : "Programme",
	"MENU_PROGRAM_FLASH" : "Programme",
	"MODAL_CREATE_VAR" : "Créer une variable",
	"MODAL_CREATE_VAR_NAME" : "Nom de la variable",
	"MODAL_CREATE_VAR_BUTTON" : "Créer une variable",
	"MODAL_CREATE_VAR_EXIT" : "Sortie",
	"MODAL_CREATE_VAR_SUCCESS" : "Nouvelle variable créée avec succès.",
	"MODAL_MANAGE_VAR" : "Variables",
	"MODAL_MANAGE_VAR_NAME" : "Nom de la variable",
	"MODAL_MANAGE_VAR_ACTION" : "Action",
	"MODAL_MANAGE_VAR_BUTTON_DELETE" : "supprimer",
	"MODAL_MANAGE_VAR_BUTTON_RENAME" : "renommer",
	"MODAL_MANAGE_VAR_BUTTON_CONFIRM" : "confirmer",
	"MODAL_MANAGE_VAR_BUTTON_CANCEL" : "annuler",
	"MODAL_MANAGE_VAR_CONFIRM_NOT_CHANGED" : "Tu n'as pas modifié le nom de la variable. Essaie à nouveau.",
	"MODAL_MANAGE_VAR_CONFIRM_SUCCESS" : "La variable a été renommée avec succès !",
	"MODAL_MANAGE_VAR_NAME_NONE" : "Saisis un nom de variable.",
	"MODAL_MANAGE_VAR_NAME_IN_USE" : "Tu as déjà une variable portant ce nom.",
	"MODAL_MANAGE_VAR_NAME_UNSUPPORTED" : "Le nom de la variable contient un caractère non pris en charge. Les noms de variables ne peuvent contenir que des lettres anglaises minuscules, des lettres anglaises majuscules, des chiffres et des traits de soulignement ( _ ).",
	"MODAL_MANAGE_VAR_NAME_NUMBER_START" : "Les noms de variables ne peuvent pas commencer par un chiffre.",
	"MODAL_MANAGE_VAR_DELETE_IN_USE" : "Cette variable est actuellement utilisée dans ton programme. Es-tu sûr de vouloir la supprimer ?",
	"MODAL_MANAGE_VAR_DELETE_CONFIRM" : "Oui",
	"MODAL_MANAGE_VAR_DELETE_DECLINE" : "Non",
	"MODAL_CREATE_FUNCT" : "Créer une fonction",
	"MODAL_CREATE_FUNCT_NAME" : "Nom de la fonction",
	"MODAL_CREATE_FUNCT_WARNING" : "Caractères alphanumériques uniquement et doit commencer par une lettre.",
	"MODAL_CREATE_FUNCT_BUTTON" : "Créer une fonction",
	"MODAL_CREATE_FUNCT_BUTTON_EXIT" : "Sortie",
	"MODAL_CREATE_FUNCT_SUCCESS" : "Nouvelle fonction créée avec succès.",
	"MODAL_MANAGE_FUNCT" : "Fonctions",
	"MODAL_MANAGE_FUNCT_NAME" : "Nom de la fonction",
	"MODAL_MANAGE_FUNCT_ACTION" : "Action",
	"MODAL_MANAGE_FUNCT_BUTTON_DELETE" : "supprimer",
	"MODAL_MANAGE_FUNCT_BUTTON_RENAME" : "renommer",
	"MODAL_MANAGE_FUNCT_BUTTON_CONFIRM" : "confirmer",
	"MODAL_MANAGE_FUNCT_BUTTON_CANCEL" : "annuler",
	"MODAL_MANAGE_FUNCT_CONFIRM_NOT_CHANGED" : "Tu n'as pas modifié le nom de la fonction. Essaie à nouveau.",
	"MODAL_MANAGE_FUNCT_CONFIRM_SUCCESS" : "Fonction renommée avec succès !",
	"MODAL_MANAGE_FUNCT_NAME_NONE" : "Saisis un nom de fonction.",
	"MODAL_MANAGE_FUNCT_NAME_IN_USE" : "Tu as déjà une fonction portant ce nom.",
	"MODAL_MANAGE_FUNCT_NAME_START_WITH" : "Les noms de fonctions utilisateur ne peuvent pas commencer par",
	"MODAL_MANAGE_FUNCT_NAME_UNSUPPORTED" : "Le nom de la fonction contient un caractère non pris en charge. Les noms de fonctions ne peuvent contenir que des lettres minuscules, des lettres majuscules, des chiffres et des traits de soulignement ( _ ).",
	"MODAL_MANAGE_FUNCT_NAME_NUMBER_START" : "Les noms de fonction ne peuvent pas commencer par un chiffre.",
	"MODAL_MANAGE_FUNCT_DELETE_IN_USE" : "Cette fonction est actuellement utilisée dans ton programme. Es-tu sûr de vouloir la supprimer ?",
	"MODAL_MANAGE_FUNCT_DELETE_CONFIRM" : "Oui",
	"MODAL_MANAGE_FUNCT_DELETE_DECLINE" : "Non",
	"MODAL_SAVE_TITLE" : "Sauvegarder sur l'ordinateur",
	"MODAL_SAVE_PROG_TITLE" : "Nom du programme",
	"MODAL_SAVE_BUTTON" : "Sauvegarder sur l'ordinateur",
	"MODAL_SAVE_ERROR_NO_NAME" : "Saisis un nom pour ton programme. Tu dois donner un nom au programme pour pouvoir le sauvegarder.",
	"MODAL_SAVE_ERROR_LONG_NAME" : "Oups ! Il y a un problème avec le nom du programme. Les noms de programmes peuvent comporter au maximum 255 caractères.",
	"MODAL_SAVE_SAVING" : "OK ! Ton programme est en train d'être enregistré. Le téléchargement de ton programme devrait bientôt commencer.",
	"MODAL_LOAD_PC_TITLE" : "Charger depuis l'ordinateur",
	"MODAL_LOAD_PC_FILE_ERROR_1" : "Choisis un fichier de sauvegarde EdScratch.",
	"MODAL_LOAD_PC_FILE_ERROR_2" : "Tous les fichiers de sauvegarde EdScratch sont de type",
	"MODAL_LOAD_PC_FILE_ERROR_3" : ".edscratch",
	"MODAL_LOAD_PC_FILE_BUTTON" : "Sélectionne un fichier à télécharger...",
	"MODAL_LOAD_PC_BUTTON" : "Charger le programme",
	"MODAL_LOAD_PC_NO_FILE_ERROR_1" : "Tu n'as pas encore sélectionné de fichier. Choisis d'abord un fichier de sauvegarde EdScratch sur ton ordinateur, puis charge le fichier. [Tous les fichiers de sauvegarde EdScratch sont de type (.edscratch)].",
	"MODAL_LOAD_PC_FILE_DATA_ERROR_1" : "Oh-oh. Il y a un problème avec les données de ce fichier.",
	"MODAL_LOAD_PC_FILE_DATA_ERROR_2" : "Télécharge un autre fichier de sauvegarde EdScratch. [Tous les fichiers de sauvegarde EdScratch sont de type (.edscratch).",
	"MODAL_LOAD_PC_FILE_TYPE_ERROR_1" : "Oh-oh. Tu as téléchargé un type de fichier incorrect.",
	"MODAL_LOAD_PC_FILE_TYPE_ERROR_2" : "Télécharge un fichier de sauvegarde EdScratch. [Tous les fichiers de sauvegarde EdScratch sont de type (.edscratch).]",
	"MODAL_LOAD_PC_FILE_READY" : "Prêt à charger le programme :",
	"MODAL_LOAD_DEMO_TITLE" : "Charger la démo",
	"MODAL_LOAD_DEMO_BUTTON" : "Charger le programme",
  "MODAL_COOKIES_TITLE" : "Cookies",
  "MODAL_COOKIES_BODY_1" : "Nous utilisons Google Analytics pour mesurer la façon dont les visiteurs utilisent cette application web afin de pouvoir l'améliorer en fonction des besoins des utilisateurs. Par exemple, quelles options les visiteurs utilisent le plus souvent et s'ils reçoivent des messages d'erreur de l'application web. Ces cookies ne collectent pas d'informations permettant d'identifier un visiteur.",
  "MODAL_COOKIES_BODY_2" : "Nous n'autorisons pas Google à utiliser ou à partager les données relatives à votre utilisation de ce site et toutes les informations collectées par ces cookies sont agrégées et donc anonymes. Elles ne sont utilisées que pour améliorer le fonctionnement de l'application web. Ce cookie est stocké pour une période d'un an.",
  "MODAL_COOKIES_ACCEPT" : "Accepter les cookies",
  "MODAL_COOKIES_BUTTON_YES" : "Oui",
  "MODAL_COOKIES_BUTTON_NO" : "Non",
  "MODAL_ABOUT_TITLE" : "À propos d'EdScratch",
	"MODAL_ABOUT_COPYRIGHT" : "Copyright 2023 Microbric Pty Ltd",
	"MODAL_ABOUT_BODY_1" : "L'application EdScratch a été développée en utilisant la base de code Scratch Blocks développée par le MIT. Scratch Blocks a été construit sur la base de code Blockly développée par Google.",
	"MODAL_ABOUT_BODY_2" : "Contributions et crédits :",
	"MODAL_ABOUT_BODY_3" : "Le langage de programmation et le compilateur de blocs EdScratch ont été développés par Ben Hayton, Microbric.",
	"MODAL_ABOUT_BODY_4" : "L'interface utilisateur d'EdScratch a été développée par Sean Killian, Killian Web Development.",
	"MODAL_ABOUT_BODY_5" : "Le micrologiciel Edison V3 a été développé par Damien George, George Robotics (base de code MicroPython).",
	"MODAL_LANGUAGE" : "Langue",
	"MODAL_DIAGNOSTICS" : "Diagnostics",
	"MODAL_DIAGNOSTICS_CONNECT_ISSUES_TITLE" : "Problèmes de connectivité",
	"MODAL_DIAGNOSTICS_CONNECT_ISSUES_BODY" : "Pour t'assurer que ton programme peut être compilé et envoyé au robot Edison, il est bon de vérifier ta connexion avec le compilateur EdScratch.",
	"MODAL_DIAGNOSTICS_CONNECT_ISSUES_BUTTON" : "Lance le vérificateur de connexion",
	"MODAL_DIAGNOSTICS_FIRMWARE_TITLE" : "Corriger le micrologiciel",
	"MODAL_DIAGNOSTICS_FIRMWARE_BODY" : "Si l'Edison V3 ne se comporte pas comme prévu, il peut s'agir d'un problème de micrologiciel. Clique sur Réparer le micrologiciel pour lancer une mise à jour du micrologiciel.",
	"MODAL_DIAGNOSTICS_FIRMWARE_BUTTON" : "Corriger le micrologiciel",
	"MODAL_DIAGNOSTICS_PROGRAMMING_TITLE" : "Méthode de programmation",
	"MODAL_DIAGNOSTICS_PROGRAMMING_BODY" : "Cette option te permet de basculer entre la programmation USB et la programmation flash à l'écran sur cet appareil.",
	"MODAL_DIAGNOSTICS_PROGRAMMING_BUTTON" : "Changer la méthode de programmation",
	"MODAL_DIAGNOSTICS_IR_TITLE" : "Effacer les commandes à distance IR apprises",
	"MODAL_DIAGNOSTICS_IR_BODY" : "Cette option te permet d'effacer toutes les commandes de télécommande IR apprises d'un robot Edison V3.",
	"MODAL_DIAGNOSTICS_IR_BUTTON" : "Effacer les codes de la télécommande",
	"MODAL_DIAGNOSTICS_IR_SUCCESS" : "Les codes de la télécommande ont été effacés.",
	"MODAL_DIAGNOSTICS_IR_ERROR" : "Une erreur s'est produite.",
	"MODAL_CONNECTION" : "Connexion",
	"MODAL_CONNECTION_TEST_1" : "Si le test ci-dessus donne le résultat",
	"MODAL_CONNECTION_TEST_EXAMPLE" : "AUCUN SERVEUR TROUVÉ",
	"MODAL_CONNECTION_TEST_2" : "il se peut qu'un pare-feu bloque l'accès au compilateur.",
	"MODAL_CONNECTION_TEST_3" : "Pour y remédier, demande à ton administrateur réseau de mettre ces adresses sur liste blanche :",
	"MODAL_CONNECTION_PORTS" : "L'administrateur réseau doit également débloquer les ports 80, 8080, 443 et 8443.",
	"MODAL_CONNECTION_BACK" : "Retour au diagnostic",
	"MODAL_CONNECTION_SERVER" : "Serveur :",
	"MODAL_CONNECTION_SERVER_SEARCHING" : "recherche",
	"MODAL_CONNECTION_SERVER_NONE" : "AUCUN SERVEUR TROUVÉ",
	"MODAL_CONNECTION_COMIPLE_TEST" : "Test de compilation :",
	"MODAL_CONNECTION_COMIPLE_TEST_WORKING" : "fonctionne",
	"MODAL_CONNECTION_COMIPLE_TEST_ERROR" : "erreur de compilation",
	"MODAL_CONNECTION_COMIPLE_TEST_COMPLETE" : "Compilation complète en",
	"MODAL_STATUS_TITLE" : "Corriger le micrologiciel",
	"MODAL_STATUS_BUTTON" : "Connecter Edison",
	"MODAL_STATUS_STATUS_LABEL" : "Statut :",
	"MODAL_STATUS_STATUS_NOT_CONNECTED" : "non connecté",
	"MODAL_STATUS_STATUS_CONNECTED" : "connecté",
	"MODAL_STATUS_FIRMWARE_LABEL" : "Version du micrologiciel :",
	"MODAL_STATUS_FIRMWARE_BOOT_MODE" : "mode bootloader",
	"MODAL_STATUS_FIRMWARE_FACTORY_MODE" : "mode d'application d'usine",
	"MODAL_STATUS_FIRMWARE_USER_MODE" : "mode d'application utilisateur",
	"MODAL_STATUS_FIRMWARE_TAG" : "firmware",
	"MODAL_STATUS_BOOT_TAG" : "boot",
	"MODAL_STATUS_FIRMWARE_UPDATE" : "Une mise à jour du micrologiciel",
	"MODAL_STATUS_FIRMWARE_UPDATE_AVAILABLE" : "est disponible",
	"MODAL_STATUS_BOOT_UPDATE" : "Une mise à jour de l'amorçage",
	"MODAL_STATUS_FIRMWARE_UPDATE_BUTTON" : "Forcer la mise à jour du micrologiciel",
	"MODAL_STATUS_FIRMWARE_UP_TO_DATE" : "Ton Edison est à jour.",
	"MODAL_PROGRAMING_METHOD_TITLE" : "Méthode de programmation",
	"MODAL_PROGRAMING_METHOD_BODY" : "La programmation flash de l'écran a été développée pour les iPads d'Apple. En effet, Apple n'autorise pas l'accès normal au port de données de l'iPad. Par conséquent, la programmation par flashage d'écran n'est entièrement prise en charge que pour les iPads. Cependant, le flash d'écran fonctionne avec certains appareils Android. L'option ci-dessous permet d'activer la programmation du flash d'écran sur cet appareil. Si cet appareil n'est pas un iPad, son fonctionnement n'est pas garanti.",
	"MODAL_PROGRAMING_METHOD_CURRENT_LABEL" : "Utilise actuellement",
	"MODAL_PROGRAMING_METHOD_CURRENT_LABEL_USB" : "USB",
	"MODAL_PROGRAMING_METHOD_CURRENT_LABEL_FLASH" : "FLASH",
	"MODAL_PROGRAMING_METHOD_CURRENT_LABEL_METHOD" : "méthode.",
	"MODAL_PROGRAMING_METHOD_BUTTON_USB" : "Régler sur la méthode USB",
	"MODAL_PROGRAMING_METHOD_BUTTON_FLASH" : "Régler sur la méthode FLASH",
	"MODAL_PROGRAMING_METHOD_ACCORD_BUTTON_FLASH_GUARANTEE" : "Pourquoi le flashage d'écran n'est-il pas garanti avec les appareils Android ?",
	"MODAL_PROGRAMING_METHOD_ACCORD_BODY_FLASH_GUARANTEE" : "Les appareils Android sont fabriqués par de nombreux fabricants différents et il existe des milliers de modèles différents. Cela signifie qu'il existe également un grand nombre de technologies d'écran différentes. Il n'est pas possible de tester et de personnaliser le flashage d'écran pour tous les appareils Android.",
	"MODAL_PROGRAMING_METHOD_ACCORD_BUTTON_FLASH_SETTINGS" : "Existe-t-il des paramètres qui pourraient aider mon appareil Android à fonctionner avec le flashage d'écran ?",
	"MODAL_PROGRAMING_METHOD_ACCORD_BODY_FLASH_SETTINGS" : "Oui, dans la fenêtre contextuelle du flash d'écran, il y a un réglage fiable/rapide qui a quatre positions. Essaie chacune des quatre positions. Essaie aussi de régler la luminosité de l'écran. Essaie avec une luminosité de 50 %, 75 %, 90 % et 100 %.",
	"MODAL_PROGRAMING_METHOD_ACCORD_BUTTON_FLASH_FAIL" : "Que dois-je faire si le clignotement de l'écran ne fonctionne pas sur mon appareil Android ?",
	"MODAL_PROGRAMING_METHOD_ACCORD_BODY_FLASH_FAIL" : "Pour programmer, tu devras brancher le câble Edison V3 sur le port de données de l'appareil Android par l'intermédiaire d'un câble adaptateur. Ceux-ci sont courants et disponibles à bas prix sur ebay, Amazon, etc.",
	"MODAL_PROGRAMING_METHOD_BACK" : "Retour au diagnostic",
	"MODAL_PROGRAMING_TITLE" : "Programmation",
	"MODAL_PROGRAMING_TITLE_COMPLETE" : "Programmation terminée",
	"MODAL_PROGRAMING_TITLE_ERROR" : "Erreur de programmation",
	"MODAL_PROGRAMING_TIP_1_TITLE" : "Conseil : Ne regroupe pas les robots Edison sur un hub USB !",
	"MODAL_PROGRAMING_TIP_1_TEXT" : "Utilise plutôt un EdCharger.",
	"MODAL_PROGRAMING_TIP_2_TITLE" : "Conseil : Ne laisse pas Edison suspendu !",
	"MODAL_PROGRAMING_TIP_2_TEXT" : "Garde Edison appuyé sur une surface solide.",
	"MODAL_PROGRAMING_TIP_3_TITLE" : "Conseil : Ne laisse pas Edison suspendu !",
	"MODAL_PROGRAMING_TIP_3_TEXT" : "Utilise une rallonge lorsque tu le recharges à partir d'une prise de courant.",
	"MODAL_PROGRAMING_TIP_4_TITLE" : "Conseil : Ne tire pas sur Edison !",
	"MODAL_PROGRAMING_TIP_4_TEXT" : "Débranche-le en tirant sur le câble USB, pas sur le robot.",
	"MODAL_PROGRAMING_ERROR_NO_BLOCK" : "Téléchargement impossible si aucun bloc n'est connecté au bloc de départ.",
	"MODAL_PROGRAMING_ERROR_RED" : "Impossible de télécharger avec des erreurs rouges.",
	"MODAL_PROGRAMING_UPDATE_FIRMWARE" : "Pour programmer ton Edison, tu devras mettre à jour le micrologiciel à la version la plus récente",
	"MODAL_PROGRAMING_UPDATE_FIRMWARE_BUTTON" : "Mettre à jour le micrologiciel",
	"MODAL_PROGRAMING_UPDATE_FIRMWARE_NOW" : "Mise à jour du micrologiciel requise. Mise à jour maintenant...",
	"MODAL_PROGRAMING_FIRMWARE_UPDATED" : "Firmware updated.",
	"MODAL_PROGRAMING_FIRMWARE_UPDATED_NOW_PROGRAMMING" : "Programmation de l'Edison en cours...",
	"MODAL_PROGRAMING_FIRMWARE_UPDATE_INCOMPLETE" : "Mise à jour incomplète du micrologiciel.",
	"MODAL_PROGRAMING_DONE" : "OK ! Le programme a été chargé sur ton Edison.",
	"MODAL_PROGRAMING_ERROR_JSON" : "La réponse n'est pas JSON !",
	"MODAL_PROGRAMING_ERROR_UNKNOWN" : "Erreur inconnue !",
	"MODAL_FIRMWARE_UPDATE_TITLE" : "Mise à jour du micrologiciel",
	"MODAL_FIRMWARE_UPDATE_LATEST" : "La dernière version du micrologiciel de l'Edison V3 est :",
	"MODAL_FIRMWARE_UPDATE_POPUP" : "Utilise cette fenêtre contextuelle pour mettre à jour le micrologiciel de ton Edison.",
	"MODAL_FIRMWARE_UPDATE_TO_UPDATE1" : "Pour mettre à jour le micrologiciel Edison V3 :",
	"MODAL_FIRMWARE_UPDATE_TO_UPDATE2" : "Branche ton Edison et clique sur le bouton Mettre à jour le micrologiciel ci-dessous puis suis les invites.",
	"MODAL_FIRMWARE_UPDATE_TO_UPDATE_BUTTON" : "Mettre à jour le micrologiciel",
	"MODAL_FIRMWARE_UPDATE_TO_RECONNECT_BUTTON" : "Reconnecte l'Edison",
	"MODAL_FIRMWARE_UPDATE_FEEDBACK_START" : "Prêt...",
	"MODAL_FIRMWARE_UPDATE_TWO_STEP_START" : "Une mise à jour du micrologiciel en deux étapes commence",
	"MODAL_FIRMWARE_UPDATE_BOOT_COMPLETE" : "Mise à jour du chargeur de démarrage terminée.",
	"MODAL_FIRMWARE_UPDATE_PLEASE_CLICK" : "Clique sur",
	"MODAL_FIRMWARE_UPDATE_ISSUE_LOADING" : "Problème de chargement du micrologiciel",
	"MODAL_FIRMWARE_UPDATE_ONE_STEP_START" : "La mise à jour du micrologiciel commence",
	"MODAL_FIRMWARE_UPDATE_ERROR_ISSUE_LOADING" : "Erreur : Problème de chargement du micrologiciel.",
	"MODAL_FIRMWARE_UPDATE_ERROR_ISSUE_DOWNLOADING" : "Erreur : Problème de téléchargement du micrologiciel.",
	"MODAL_FIRMWARE_UPDATE_FIRM_COMPLETE" : "Mise à jour du micrologiciel terminée.",
	"MODAL_FIRMWARE_UPDATE_NONE_NEEDED" : "Aucune mise à jour n'est nécessaire : le micrologiciel de ton Edison est à jour.",
	"MODAL_FIRMWARE_UPDATE_PROBLEMS" : "Tu as des problèmes ?",
	"MODAL_FIRMWARE_UPDATE_SEE_DIAG" : "Voir les diagnostics",
	"MODAL_USB_CONTROL" : "Contrôles USB",
	"MODAL_USB_RUN_BUTTON" : "Exécuter USB",
	"MODAL_USB_CONNECTED_STATUS" : "CONNECTE",
	"MODAL_USB_DISCONNECTED_STATUS" : "DÉBRANCHÉ",
	"MODAL_USB_RUNNING_STATUS" : "EN COURS D'EXÉCUTION",
	"MODAL_USB_DATA_TO" : "Données vers USB",
	"MODAL_USB_DATA_TO_BUTTON" : "Envoyer à l'USB",
	"MODAL_USB_DATA_FROM" : "Données de l'USB",
	"MODAL_USB_DATA_FROM_CLEAR" : "Effacer",
	"MODAL_USB_DATA_FROM_COPY" : "Copier dans le presse-papiers",
	"MODAL_USB_DATA_FROM_COPIED" : "Copié !",
	"MODAL_BAD_BROWSER_TITLE" : "Navigateur non supporté",
	"MODAL_BAD_BROWSER_USING" : "Tu sembles utiliser :",
	"MODAL_BAD_BROWSER_WEB_USB" : "L'Edison V3 est programmé directement à partir de ton navigateur Web via USB. Pour cela, il faut que ton navigateur Web prenne en charge les connexions USB.",
	"MODAL_BAD_BROWSER_UNFORTUNATLY" : "Malheureusement",
	"MODAL_BAD_BROWSER_UNSUPORTED" : "ne prend pas actuellement en charge les connexions USB, et ne peut donc pas programmer ton robot Edison V3.",
	"MODAL_BAD_BROWSER_USE_CHROME" : "Nous recommandons d'utiliser Google Chrome.",
	"MODAL_BAD_BROWSER_GET_CHROME" : "Obtenir Chrome.",
	"MODAL_LOADING" : "Chargement de l'espace de travail...",
	"MODAL_FLASHER_TITLE" : "Clignotant",
	"MODAL_FLASHER_STEP_1" : "Place Edison au-dessus de l'image",
	"MODAL_FLASHER_STEP_2" : "Appuie une fois sur le bouton rond de l'Edison",
	"MODAL_FLASHER_STEP_3" : "Appuie sur le programme de téléchargement",
	"MODAL_FLASHER_RELIABLE" : "Fiable",
	"MODAL_FLASHER_FAST" : "Rapide",
	"MODAL_FLASHER_ADJUST_SPEED" : "Si le téléchargement ne fonctionne pas ou n'est pas assez rapide, essaie d'ajuster la vitesse ci-dessus. La vitesse la plus basse est généralement la plus fiable.",
	"MODAL_FLASHER_DOWNLOAD" : "Télécharger le programme",
	"MODAL_FLASHER_CANCEL" : "Annuler",
	"MODAL_FLASHER_TIPS_HEADING" : "Conseils",
	"MODAL_FLASHER_TIPS_BODY_1" : "Règle la luminosité de l'écran entre 80 et 90 %.",
	"MODAL_FLASHER_TIPS_BODY_2" : "Éloigne-toi de la lumière directe et ininterrompue du soleil ou des lumières vives.",
	"MODAL_FLASHER_TIPS_BODY_3" : "Assure-toi d'avoir mis à jour l'Edison V3 avec le dernier micrologiciel.",
	"MODAL_FLASHER_DOWNLOADING" : "Télécharger...",
	"MODAL_FLASHER_COMPLETE" : "Complet",
	"MODAL_FLASHER_BYTES" : "bytes in",
	"MODAL_FLASHER_SECONDS" : "secondes",
	"ERROR_RED_OBS_SETTING" : "Les blocs de détection d'obstacles ne fonctionnent pas à moins que le faisceau de détection d'obstacles ne soit activé à l'aide du bloc de faisceau de détection d'obstacles de la catégorie Détection.",
	"ERROR_RED_OBS_SETTING_EVENT" : "Les événements de détection d'obstacles ne fonctionnent pas à moins que le faisceau de détection d'obstacles ne soit activé à l'aide du bloc de faisceau de détection d'obstacles de la catégorie Détection dans le programme principal.",
	"ERROR_RED_LINE_SETTING" : "Les blocs de détection de ligne ne fonctionnent pas si la DEL de détection de ligne n'est pas activée à l'aide du bloc de DEL de suivi de ligne de la catégorie Capteurs.",
	"ERROR_RED_LINE_SETTING_EVENT" : "Les événements de détection de ligne ne fonctionnent pas à moins que la DEL de détection de ligne ne soit activée à l'aide du bloc de DEL de suivi de ligne de la catégorie Détection dans le programme principal.",
	"ERROR_RED_DRIVE_CLAP" : "Edison ne peut pas détecter les claps pendant la conduite parce que les moteurs sont trop bruyants.",
	"ERROR_RED_EMPTY_IN_FORWARDS" : "En avant jusqu'à ce que les blocs aient besoin d'une entrée de condition.",
	"ERROR_RED_EMPTY_IN_BACKWARDS" : "En arrière jusqu'à ce que les blocs aient besoin d'une entrée de condition.",
	"ERROR_RED_EMPTY_IN_LEFT" : "Vers la gauche jusqu'à ce que les blocs aient besoin d'une entrée de condition.",
	"ERROR_RED_EMPTY_IN_RIGHT" : "A droite jusqu'à ce que les blocs aient besoin d'une entrée de condition.",
	"ERROR_RED_EMPTY_IN_SET_VAR" : "Les blocs Set variable ont besoin d'une variable.",
	"ERROR_RED_EMPTY_IN_INC_VAR" : "Les blocs d'incrémentation de variables ont besoin d'une variable.",
	"ERROR_RED_EMPTY_IN_DEC_VAR" : "Les blocs d'incrémentation de variables ont besoin d'une variable.",
	"ERROR_RED_EMPTY_IN_IF" : "Les blocs If nécessitent une entrée de condition.",
	"ERROR_RED_EMPTY_IN_IF_ELSE" : "Les blocs If-else ont besoin d'une condition d'entrée.",
	"ERROR_RED_EMPTY_IN_WAIT" : "Les blocs Wait until (attendre jusqu'à) ont besoin d'une condition d'entrée.",
	"ERROR_RED_EMPTY_IN_WAIT_MILLI" : "Les blocs Wait milliseconds ont besoin d'une valeur d'entrée.",
	"ERROR_RED_EMPTY_IN_REP" : "Répéter jusqu'à ce que les blocs aient besoin d'une condition d'entrée.",
	"ERROR_RED_EMPTY_IN_BS_RIGHT" : "Les blocs Bit shift right ont besoin d'une variable.",
	"ERROR_RED_EMPTY_IN_BS_LEFT" : "Les blocs de décalage de bits vers la gauche ont besoin d'une variable.",
	"ERROR_RED_EMPTY_IN_OPERATOR_NOT" : "Les blocs Not ont besoin d'une condition d'entrée.",
	"ERROR_RED_EMPTY_IN_OPERATOR_AND" : "Et les blocs ont besoin d'une condition d'entrée.",
	"ERROR_RED_EMPTY_IN_OPERATOR_OR" : "Ou les blocs ont besoin d'une condition d'entrée.",
	"ERROR_RED_EMPTY_BACKGROUND_MUSIC" : "Les blocs de regroupement Play music in background doivent contenir au moins un bloc de note.",
	"ERROR_RED_NO_START" : "Les programmes doivent avoir un événement de démarrage pour fonctionner correctement. Si tu vois ce message d'erreur, démarre un nouveau programme en allant dans le menu et en sélectionnant nouveau.",
	"ERROR_RED_NOT_BACKGROUND_MUSIC" : "Play music in background (Jouer de la musique en arrière-plan) Les blocs de regroupement ne peuvent accepter que des blocs de notes.",
	"ERROR_RED_NO_MAIN_BLOCKS" : "Il n'y a pas de blocs connectés à l'événement de démarrage, donc il n'y a pas de programme principal à exécuter pour Edison.",
	"ERROR_RED_EMPTY_IN_USB_RECEIVED" : "Les blocs de données usb ont besoin d'une variable.",
	"ERROR_RED_DEVIDE_BY_ZERO" : "Les blocs d'opérateur de déviation ne peuvent pas dévier par zéro.",
	"ERROR_RED_FUNCTION_IN_FUNCTION" : "Les blocs d'appel de fonction ne peuvent pas être placés sous un bloc de démarrage de fonction.",
	"ERROR_YELLOW_RECEIVE_MESSAGE_OBS_ON" : "Edison ne peut pas recevoir de messages lorsque la détection d'obstacles est activée. Veille à désactiver la détection d'obstacles dans le programme avant d'essayer de recevoir un message.",
	"ERROR_YELLOW_RECEIVE_REMOTE_OBS_ON" : "Edison ne peut pas recevoir de codes de télécommande lorsque la détection d'obstacles est activée. Veille à désactiver la détection d'obstacles dans le programme avant d'essayer de recevoir un code de télécommande.",
	"ERROR_YELLOW_RECEIVE_MESSAGE_EVENT_OBS_ON" : "Edison ne peut pas recevoir de messages lorsque la détection d'obstacles est activée. Veille à désactiver la détection d'obstacles dans le programme principal avant d'essayer de recevoir un message.",
	"ERROR_YELLOW_RECEIVE_REMOTE_EVENT_OBS_ON" : "Edison ne peut pas recevoir de codes de télécommande lorsque la détection d'obstacles est activée. Veille à désactiver la détection d'obstacles dans le programme principal avant d'essayer de recevoir un code à distance.",
	"ERROR_YELLOW_READ_LIGHT_LINE_OFF" : "Envisage d'activer la DEL de détection de ligne à l'aide du bloc DEL de suivi de ligne de la catégorie Détection si tu mesures la réflectivité de la surface de conduite.",
	"ERROR_YELLOW_OPPERATOR_WAIT_UNTIL" : "Un bloc opérateur à l'intérieur d'un bloc attendre jusqu'à peut faire en sorte qu'Edison attende pour toujours ou saute le bloc d'attente.",
	"ERROR_YELLOW_OPPERATOR_REPEAT_UNTIL" : "Un bloc opérateur à l'intérieur d'un bloc répéter jusqu'à peut faire en sorte qu'Edison boucle pour toujours ou saute le bloc répéter.",
	"ERROR_YELLOW_OPPERATOR_WAIT" : "Un bloc opérateur à l'intérieur d'un bloc d'attente peut amener Edison à sauter le bloc d'attente.",
	"ERROR_YELLOW_OPPERATOR_REPEAT" : "Un bloc opérateur à l'intérieur d'un bloc de répétition peut amener Edison à sauter le bloc de répétition.",
	"ERROR_YELLOW_OPPERATOR_DRIVE_FOR_UNTIL" : "Un bloc opérateur à l'intérieur d'un bloc d'entraînement en avant jusqu'au bloc peut amener Edison à conduire pour toujours ou à sauter le bloc d'entraînement.",
	"ERROR_YELLOW_OPPERATOR_DRIVE_BACK_UNTIL" : "Un blocage de l'opérateur à l'intérieur d'un bloc de conduite vers l'arrière jusqu'à ce qu'il soit bloqué peut amener Edison à conduire pour toujours ou à sauter le bloc de conduite.",
	"ERROR_YELLOW_OPPERATOR_DRIVE_LEFT_UNTIL" : "Un blocage de l'opérateur à l'intérieur d'un bloc de conduite à gauche jusqu'à ce qu'il soit bloqué peut amener Edison à conduire pour toujours ou à sauter le bloc de conduite.",
	"ERROR_YELLOW_OPPERATOR_DRIVE_RIGHT_UNTIL" : "Un blocage de l'opérateur à l'intérieur d'un bloc d'entraînement à droite jusqu'à peut amener Edison à conduire pour toujours ou à sauter le bloc d'entraînement.",
	"ERROR_YELLOW_OPPERATOR_DRIVE_FOR_DIST" : "Un blocage de l'opérateur à l'intérieur d'un bloc d'entraînement vers l'avant peut amener Edison à sauter le bloc d'entraînement.",
	"ERROR_YELLOW_OPPERATOR_DRIVE_BACK_DIST" : "Un blocage de l'opérateur à l'intérieur d'un bloc d'entraînement vers l'arrière peut amener Edison à sauter le bloc d'entraînement.",
	"ERROR_YELLOW_OPPERATOR_DRIVE_LEFT_DIST" : "Un blocage de l'opérateur à l'intérieur d'un bloc d'entraînement à gauche peut amener Edison à sauter le bloc d'entraînement.",
	"ERROR_YELLOW_OPPERATOR_DRIVE_RIGHT_DIST" : "Un blocage de l'opérateur à l'intérieur d'un bloc d'entraînement à droite peut amener Edison à sauter le bloc d'entraînement.",
	"ERROR_YELLOW_DRIVE_LIGHT" : "Un bloc de niveau lumineux à l'intérieur d'un bloc d'entraînement peut faire en sorte qu'Edison conduise indéfiniment ou saute le bloc d'entraînement.",
	"ERROR_YELLOW_OPPERATOR_IR_MESSAGE" : "Un bloc opérateur à l'intérieur d'un bloc d'envoi de message IR ne pourra pas envoyer une valeur supérieure à 255.",
	"ERROR_YELLOW_FOREVER_LOOP_IN" : "Une boucle infinie continuera à tourner en boucle jusqu'à ce que tu appuies sur le bouton carré de l'Edison.",
	"ERROR_YELLOW_SET_MOTOR_LEFT" : "Le bloc d'activation du moteur gauche n'activera que le moteur gauche. Assure-toi que d'autres blocs sont utilisés dans le programme pour contrôler la durée du moteur gauche.",
	"ERROR_YELLOW_SET_MOTOR_RIGHT" : "Le bloc du moteur droit n'activera que le moteur droit. Assure-toi que d'autres blocs sont utilisés dans le programme pour contrôler la durée du moteur droit.",
	"ERROR_YELLOW_SET_MOTOR_BOTH" : "Le bloc set both motors (définir les deux moteurs) n'activera que les moteurs. Assure-toi que d'autres blocs sont utilisés dans le programme pour contrôler la durée du moteur.",
	"ERROR_YELLOW_CLAP_EVENT_DRIVE" : "L'entraînement des moteurs crée un bruit qui peut entraîner le déclenchement de l'événement clap. Cela peut entraîner le déclenchement répété des blocs d'événement clap pendant qu'Edison est en train de conduire.",
	"ERROR_YELLOW_FLOAT_BLOCKS" : "Les blocs qui ne sont pas connectés à un bloc d'événement jaune ou à un bloc de définition de fonction ne seront pas programmés dans Edison.",
	"ERROR_YELLOW_WAIT_TIME_LIGHT" : "Le niveau d'éclairage renvoie une valeur très élevée, ce qui peut entraîner une attente prolongée pour Edison.",
	"ERROR_YELLOW_REPEAT_LOOP_LIGHT" : "Le niveau d'éclairage renvoie une valeur très élevée qui peut faire tourner Edison en boucle pendant un long moment.",
	"ERROR_YELLOW_DRIVE_STRAIN" : "Le bloc de détection de déformation de l'entraînement ne détecte la déformation que lorsque les moteurs sont en marche.",
	"ERROR_YELLOW_DRIVE_STRAIN_EVENT" : "L'événement ''drive strained'' ne peut se déclencher que lorsque les moteurs sont en marche.",
	"ERROR_YELLOW_COMMENT" : "Les commentaires sont des notes qui permettent de garder une trace des choses. Les blocs de commentaires ne seront pas programmés dans Edison.",
	"ERROR_YELLOW_USB_USED" : "Les blocs USB nécessitent qu'Edison soit branché sur un périphérique pour fonctionner",
	"ERROR_YELLOW_CLEAR_SENSOR" : "Certaines données des capteurs sont stockées dans la mémoire d'Edison. Il se peut que tu doives effacer les données du capteur pour que ton programme fonctionne correctement.",
	"ERROR_YELLOW_CLEAR_LEARN_MORE" : "En savoir plus",
	"MODAL_FIRMWARE_ERROR_TITLE" : "Erreur de micrologiciel",
	"MODAL_FIRMWARE_ERROR_BODY_1" : "Un fichier de micrologiciel corrompu a été détecté dans ton robot Edison.",
	"MODAL_FIRMWARE_ERROR_BODY_2" : "Cela a pu se produire lors d'une mise à jour du micrologiciel qui a été interrompue.",
	"MODAL_FIRMWARE_ERROR_BODY_3" : "Pas de panique ! Cela peut être réparé en cliquant sur le bouton Réparer le micrologiciel ci-dessous.",
	"MODAL_FIRMWARE_ERROR_CANCEL_BODY_1" : "Attention !",
	"MODAL_FIRMWARE_ERROR_CANCEL_BODY_2" : "L'annulation de ce processus signifie que ton robot Edison ne peut pas être programmé.",
	"MODAL_FIRMWARE_ERROR_CANCEL_BODY_3" : "Il est recommandé de réparer le micrologiciel maintenant en cliquant sur le bouton Réparer le micrologiciel.",
	"MODAL_FIRMWARE_ERROR_CANCEL_BODY_4" : "Si tu choisis d'annuler, tu pourras réparer le micrologiciel plus tard.",
	"MODAL_FIRMWARE_ERROR_BUTTON_FIX" : "Corriger le micrologiciel",
	"MODAL_FIRMWARE_ERROR_BUTTON_CANCEL" : "Annuler",
	"MODAL_FIRMWARE_ERROR_BUTTON_CANCEL_CONFIRM" : "Confirmer l'annulation",
	"MODAL_NEW_CONFIRM_HEADING" : "Es-tu sûr ?",
	"MODAL_NEW_CONFIRM_BODY_TEXT_1" : "Es-tu sûr de vouloir commencer un nouveau programme ?",
	"MODAL_NEW_CONFIRM_BODY_TEXT_2" : "Toutes les modifications risquent d'être perdues !",
	"MODAL_NEW_CONFIRM_BUTTON_CANCEL" : "Annuler",
	"MODAL_NEW_CONFIRM_BUTTON_PROCEED" : "Poursuivre",
	"CHANGELANG" : "Changer de langue",
	"HELP_TEXT_ALL_TITLE" : "Bloquer l'aide",
	"HELP_TEXT_ALL_BLOCKS_EXAMPLE_USES" : "Exemple d'utilisation :",
	"HELP_TEXT_ALL_BLOCKS_EXAMPLE_LOAD" : "Ouvrir un programme",
	"HELP_TEXT_ALL_BLOCKS_WATCH_FOR" : "Attention :",
	"HELP_TEXT_DRIVE_FORWARD_FOR_TITLE" : "en avant pour",
	"HELP_TEXT_DRIVE_FORWARD_FOR_BODY_1" : "Le bloc forwards for entraîne les roues pour déplacer le robot dans le sens de la marche avant.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_BODY_2" : "Le bloc a trois paramètres :",
	"HELP_TEXT_DRIVE_FORWARD_FOR_BODY_3" : "Valeur - Elle peut être une constante (tapée dans l'entrée et ne varie pas), une variable, une détection ou un bloc opérateur.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_BODY_4" : "Unités - Trois options peuvent être sélectionnées : cm, pouces et secondes.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_BODY_5" : "Vitesse - La vitesse peut être sélectionnée entre 1 et 10 (en tant que valeur constante), une variable, une détection ou un bloc opérateur.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_BODY_6" : "L'avancement du bloc se terminera avant que le bloc suivant ne s'exécute. Par exemple, l'utilisation du bloc de marche avant ne permet pas d'exécuter d'autres blocs du programme en même temps. Pour ce faire, voir le bloc des deux moteurs.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_1_TITLE" : "Exemple 1 : émettre un bip, puis faire avancer le robot Edison de 15 cm à la vitesse 1, puis émettre à nouveau un bip.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_1_BODY_1" : "Dans cet exemple de programme, Edison émet un bip, mais ne commence pas à rouler tant que le bip n'a pas fini de jouer. De même, le deuxième bip ne commence pas tant qu'Edison n'a pas arrêté de rouler.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_2_TITLE" : "Exemple 2 : Réglage de la distance de conduite à l'aide d'une variable et des données d'un capteur",
	"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_2_BODY_1" : "Dans cet exemple de programme, l'Edison règle la variable Distance sur le niveau de lumière du capteur de lumière gauche (une valeur comprise entre 1 et 1 000) divisé par 50. L'Edison avance ensuite pour la valeur de la variable (Distance) à la vitesse 5. Le résultat est que l'Edison roule plus loin lorsque la lumière est plus forte et roule plus court lorsque la lumière est plus faible.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_3_TITLE" : "Exemple 3 : modification de la vitesse d'entraînement à l'aide d'une variable.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_3_BODY_1" : "Dans cet exemple de programme, la variable Vitesse est réglée sur 1. Le programme entre ensuite dans une boucle de répétition pendant 10 fois. À chaque boucle, l'Edison avance de 5 cm à la vitesse indiquée dans la variable. Initialement, la valeur de la variable Vitesse est 1, l'Edison avance donc de 5 cm à la vitesse 1. Le bloc suivant de la répétition incrémente (+1) la variable Vitesse. Lors de la deuxième répétition du bloc avant, la valeur de la variable Vitesse est 2, l'Edison avance donc de 5 cm à la vitesse 2.",
	"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_3_BODY_2" : "Ce processus se répète les 10 fois de la boucle de répétition, ce qui fait que l'Edison roule de plus en plus vite jusqu'à ce qu'il s'arrête à la fin du programme.",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_TITLE" : "en arrière pour",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_BODY_1" : "Le bloc de marche arrière entraîne les roues pour déplacer le robot dans le sens inverse.",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_BODY_2" : "Le bloc a trois paramètres :",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_BODY_3" : "Valeur - Elle peut être une constante (tapée dans l'entrée et ne varie pas), une variable, une détection ou un bloc opérateur.",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_BODY_4" : "Unités - Trois options peuvent être sélectionnées : cm, pouces et secondes.",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_BODY_5" : "Vitesse - La vitesse peut être sélectionnée entre 1 et 10 (en tant que valeur constante), une variable, une détection ou un bloc opérateur.",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_BODY_6" : "Le bloc de marche arrière pour se termine avant que le bloc suivant ne s'exécute. Par exemple, l'utilisation du bloc de retour en arrière pour n'exécutera pas d'autres blocs du programme en même temps. Pour ce faire, vois le bloc set both motors to block.",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_EXAMPLE_1_TITLE" : "Exemple 1 : Voyants LED allumés pendant la conduite",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_EXAMPLE_1_BODY_1" : "Dans cet exemple de programme, la DEL de gauche s'allume et reste allumée pendant que l'Edison roule en marche arrière pendant une seconde. La DEL gauche s'éteint une fois que l'Edison a cessé de rouler. Le programme attend ensuite une seconde avant de se terminer.",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_EXAMPLE_2_TITLE" : "Exemple 2 : Lorsqu'il y a un obstacle, conduire en arrière",
	"HELP_TEXT_DRIVE_BACKWARD_FOR_EXAMPLE_2_BODY_1" : "Dans cet exemple de programme, le faisceau de détection d'obstacle est d'abord activé. Le programme entre ensuite dans une boucle infinie. À l'intérieur de la boucle, le bloc wait until (attendre jusqu'à) empêche le programme de progresser jusqu'à ce qu'un obstacle soit détecté quelque part, lorsque cela se produit, l'Edison recule d'un pouce à la vitesse 10. Ce comportement se répète indéfiniment dans une boucle. L'Edison recule donc devant les objets placés devant lui.",
	"HELP_TEXT_DRIVE_LEFT_FOR_TITLE" : "gauche pour",
	"HELP_TEXT_DRIVE_LEFT_FOR_BODY_1" : "Le bloc gauche pour entraîne les roues pour déplacer le robot dans la direction gauche.",
	"HELP_TEXT_DRIVE_LEFT_FOR_BODY_2" : "Ce bloc a quatre paramètres :",
	"HELP_TEXT_DRIVE_LEFT_FOR_BODY_3" : "Mouvement - Trois options peuvent être sélectionnées : tourner, tourner vers l'avant et tourner vers l'arrière.",
	"HELP_TEXT_DRIVE_LEFT_FOR_BODY_4" : "Valeur - Elle peut être une constante (tapée dans l'entrée et ne varie pas), une variable, une détection ou un bloc opérateur.",
	"HELP_TEXT_DRIVE_LEFT_FOR_BODY_5" : "Unités - Deux options peuvent être sélectionnées : degrés et secondes.",
	"HELP_TEXT_DRIVE_LEFT_FOR_BODY_6" : "Vitesse - La vitesse peut être sélectionnée entre 1 et 10 (en tant que valeur constante), une variable, une détection ou un bloc opérateur.",
	"HELP_TEXT_DRIVE_LEFT_FOR_BODY_7" : "Les virages et les rotations sont plus précis à des vitesses plus faibles. En effet, les roues peuvent perdre de l'adhérence et glisser à grande vitesse. La vitesse 1 est la meilleure lorsqu'il faut tourner avec précision.",
	"HELP_TEXT_DRIVE_LEFT_FOR_BODY_8" : "Le bloc de gauche doit être terminé avant que le bloc suivant ne s'exécute. Par exemple, l'utilisation du bloc gauche pour n'exécutera pas d'autres blocs du programme en même temps. Pour ce faire, consulte la section ''Régler les deux moteurs pour bloquer''.",
	"HELP_TEXT_DRIVE_LEFT_FOR_EXAMPLE_1_TITLE" : "Exemple de programme 1 : bip, rotation, bip",
	"HELP_TEXT_DRIVE_LEFT_FOR_EXAMPLE_1_BODY_1" : "Dans cet exemple de programme, Edison émet un bip, mais ne commence pas à tourner avant la fin du bip. De même, le deuxième bip ne démarre pas tant qu'Edison n'a pas arrêté de tourner.",
	"HELP_TEXT_DRIVE_LEFT_FOR_EXAMPLE_2_TITLE" : "Exemple de programme 2 : rouler en carré",
	"HELP_TEXT_DRIVE_LEFT_FOR_EXAMPLE_2_BODY_1" : "Dans cet exemple de programme, la boucle de répétition répète la conduite vers l'avant sur 10 cm à la vitesse 1 et la rotation vers l'avant à gauche sur 90 degrés quatre fois. Cela permet à Edison de rouler en carré.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_TITLE" : "droite pour",
	"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_1" : "Le bloc de droite pour entraîne les roues pour déplacer le robot dans la direction gauche.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_2" : "Ce bloc a quatre paramètres :",
	"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_3" : "Mouvement - Trois options peuvent être sélectionnées : tourner, tourner vers l'avant et tourner vers l'arrière.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_4" : "Valeur - Elle peut être une constante (tapée dans l'entrée et ne varie pas), une variable, une détection ou un bloc opérateur.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_5" : "Unités - Deux options peuvent être sélectionnées : degrés et secondes.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_6" : "Vitesse - La vitesse peut être sélectionnée entre 1 et 10 (en tant que valeur constante), une variable, une détection ou un bloc opérateur.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_7" : "Les virages et les rotations sont plus précis à des vitesses plus faibles. En effet, les roues peuvent perdre de l'adhérence et glisser à grande vitesse. La vitesse 1 est la meilleure lorsqu'il faut tourner avec précision.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_8" : "Le bloc de droite doit être terminé avant que le bloc suivant ne s'exécute. Par exemple, l'utilisation du bloc de droite ne permet pas d'exécuter d'autres blocs du programme en même temps. Pour ce faire, consulte la rubrique régler les deux moteurs pour bloquer.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_EXAMPLE_1_TITLE" : "Exemple de programme 1 : Bip, rotation, bip",
	"HELP_TEXT_DRIVE_RIGHT_FOR_EXAMPLE_1_BODY_1" : "Dans cet exemple de programme, Edison émet un bip, mais ne commence pas à tourner avant la fin du bip. De même, le deuxième bip ne commence pas tant qu'Edison n'a pas arrêté de tourner.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_EXAMPLE_2_TITLE" : "Exemple 2 : tourner à droite avec la vitesse contrôlée par le niveau de lumière",
	"HELP_TEXT_DRIVE_RIGHT_FOR_EXAMPLE_2_BODY_1" : "Dans cet exemple de programme, Edison tourne à droite à l'intérieur d'une boucle infinie. Chaque fois que le bloc de droite s'exécute, Edison tourne d'un degré. La vitesse est définie par le niveau de lumière relevé par le capteur de lumière gauche (1 à 1 000) et est divisée par 100 (résultat 0 à 10). Le résultat est qu'Edison tourne plus vite lorsque la lumière est plus forte et plus lentement lorsque la lumière est plus faible.",
	"HELP_TEXT_DRIVE_RIGHT_FOR_EXAMPLE_3_TITLE" : "Exemple de programme 3 : éviter les obstacles",
	"HELP_TEXT_DRIVE_RIGHT_FOR_EXAMPLE_3_BODY_1" : "Dans cet exemple de programme, le faisceau de détection des obstacles est activé. Le programme entre ensuite dans une boucle sans fin où les deux moteurs sont réglés pour avancer. Le programme attend ensuite qu'un obstacle soit détecté n'importe où. Lorsque cela se produit, le programme passe au bloc suivant et le robot Edison tourne à droite sur 180 degrés à la vitesse 1. Edison s'éloigne ainsi des obstacles qui se trouvent sur son chemin.",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_TITLE" : "vers l'avant jusqu'à",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_BODY_1" : "Le bloc ''en avant jusqu'à'' entraîne les roues pour déplacer le robot en avant jusqu'à ce que la condition spécifiée soit remplie. Une fois que la condition spécifiée est vraie, les roues s'arrêtent et le programme passe au bloc suivant.",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_BODY_2" : "Le bloc a deux paramètres :",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_BODY_3" : "Entrée conditionnelle - L'entrée conditionnelle accepte un bloc en forme de diamant qui peut être un bloc de détection ou d'opérateur.",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_BODY_4" : "Vitesse - La vitesse peut être sélectionnée entre 1 et 10 (en tant que valeur constante), une variable, un bloc de détection ou un bloc opérateur.",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_BODY_5" : "Le bloc de marche avant doit être terminé avant que le bloc suivant ne s'exécute. Par exemple, l'utilisation de ce bloc ne permet pas d'exécuter d'autres blocs du programme en même temps. Pour ce faire, vois le blocage des deux moteurs.",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_EXAMPLE_1_TITLE" : "Exemple de programme 1 : s'arrêter pour un obstacle",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_EXAMPLE_1_BODY_1" : "Dans cet exemple de programme, le faisceau de détection d'obstacle est activé, puis le robot avance à la vitesse 5 jusqu'à ce qu'un obstacle soit détecté. À ce moment-là, le robot s'arrête de bouger et le programme se termine.",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_EXAMPLE_2_TITLE" : "Exemple de programme 2 : Rebondir dans les bordures",
	"HELP_TEXT_DRIVE_FORWARD_UNTIL_EXAMPLE_2_BODY_1" : "Dans cet exemple de programme, le voyant du suiveur de ligne est allumé, puis le programme entre dans une boucle sans fin. À l'intérieur de la boucle, le bloc forward until fait avancer le robot à la vitesse 1 jusqu'à ce que le line tracker se trouve sur une surface non réfléchissante (c'est-à-dire noire). Lorsque cela se produit, le bloc suivant s'exécute et fait tourner le robot vers la gauche de 180 degrés à la vitesse 5. Le programme revient ensuite au bloc ''en avant jusqu'à''. Edison s'éloigne alors des lignes noires détectées.",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_TITLE" : "en arrière jusqu'à",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_BODY_1" : "Le bloc de marche arrière jusqu'à ce que entraîne les roues pour faire reculer le robot jusqu'à ce que la condition spécifiée soit remplie. Une fois que la condition spécifiée est vraie, les roues s'arrêtent et le programme passe au bloc suivant.",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_BODY_2" : "Le bloc a deux paramètres :",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_BODY_3" : "Entrée conditionnelle - L'entrée conditionnelle accepte un bloc en forme de diamant qui peut être un bloc de détection ou d'opérateur.",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_BODY_4" : "Vitesse - La vitesse peut être sélectionnée entre 1 et 10 (en tant que valeur constante), une variable, une détection ou un bloc opérateur.",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_BODY_5" : "Le bloc de retour en arrière jusqu'à doit être terminé avant que le bloc suivant ne s'exécute. Par exemple, l'utilisation du bloc de retour en arrière jusqu'à n'exécutera pas d'autres blocs du programme en même temps. Pour ce faire, voir le bloc Régler les deux moteurs.",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_EXAMPLE_1_TITLE" : "Exemple de programme 1 : Arrêter lorsque l'entraînement est sollicité",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_EXAMPLE_1_BODY_1" : "Dans cet exemple de programme, le robot recule à la vitesse 10 jusqu'à ce que les roues soient sollicitées (incapables de tourner ou bloquées). Lorsque cela se produit, les moteurs s'arrêtent et le programme se termine.",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_EXAMPLE_2_TITLE" : "Exemple de programme 2 : Contrôle de l'entraînement avec des boutons",
	"HELP_TEXT_DRIVE_BACKWARD_UNTIL_EXAMPLE_2_BODY_1" : "Dans cet exemple, le programme commence par une boucle infinie. Le premier bloc de la boucle attend que le bouton triangulaire soit enfoncé. À ce moment-là, le robot recule à la vitesse 1 jusqu'à ce que le bouton rond soit enfoncé. À ce moment-là, les roues du robot s'arrêtent et le programme recommence à attendre que le bouton triangulaire soit enfoncé.",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_TITLE" : "à gauche jusqu'à",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_BODY_1" : "Le bloc left until (gauche jusqu'à) entraîne les roues pour déplacer le robot dans la direction gauche jusqu'à ce que la condition spécifiée soit vraie. Une fois que la condition spécifiée est vraie, les roues s'arrêtent et le programme passe au bloc suivant.",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_BODY_2" : "Le bloc a trois paramètres :",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_BODY_3" : "Mouvement - Trois options peuvent être sélectionnées : tourner, tourner vers l'avant et tourner vers l'arrière.",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_BODY_4" : "Entrée conditionnelle - L'entrée conditionnelle accepte un bloc en forme de diamant qui peut être un bloc de détection ou d'opérateur.",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_BODY_5" : "Vitesse - La vitesse peut être sélectionnée entre 1 et 10 (en tant que valeur constante), une variable, une détection ou un bloc opérateur.",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_BODY_6" : "Le bloc de rotation à gauche jusqu'à doit être terminé avant que le bloc suivant ne s'exécute. Par exemple, l'utilisation de la séquence ''tourner à gauche jusqu'à'' n'entraînera pas l'exécution simultanée d'autres séquences du programme. Pour ce faire, consulte le bloc Régler les deux moteurs.",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_EXAMPLE_1_TITLE" : "Exemple de programme 1 : Arrêter lorsque l'entraînement est sollicité",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_EXAMPLE_1_BODY_1" : "Dans cet exemple de programme, le robot avance vers la gauche (la roue droite se déplace) à la vitesse 1 jusqu'à ce que la roue devienne tendue (incapable de tourner ou se bloque). Lorsque cela se produit, le moteur s'arrête et le programme se termine.",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_EXAMPLE_2_TITLE" : "Exemple de programme 2 : suivre la lumière",
	"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_EXAMPLE_2_BODY_1" : "Dans cet exemple, le programme commence par une boucle infinie. Le premier bloc de la boucle fait tourner le robot vers la gauche à la vitesse 5 jusqu'à ce que le niveau de lumière gauche soit inférieur au niveau de lumière droit. Lorsque cela se produit, le moteur s'arrête et le bloc suivant s'exécute. Le bloc suivant fait tourner le robot vers la droite à la vitesse 5 jusqu'à ce que le niveau de lumière à gauche soit supérieur au niveau de lumière à droite. Le résultat est que le robot Edison se dirige vers la lumière.",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_TITLE" : "droite jusqu'à",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_BODY_1" : "Le bloc right until entraîne les roues pour déplacer le robot dans la bonne direction jusqu'à ce que la condition spécifiée soit vraie. Une fois que la condition spécifiée est vraie, les roues s'arrêtent et le programme passe au bloc suivant.",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_BODY_2" : "Le bloc a trois paramètres :",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_BODY_3" : "Mouvement - Trois options peuvent être sélectionnées : tourner, tourner vers l'avant et tourner vers l'arrière.",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_BODY_4" : "Entrée conditionnelle - L'entrée conditionnelle accepte un bloc en forme de diamant qui peut être un bloc de détection ou d'opérateur.",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_BODY_5" : "Vitesse - La vitesse peut être sélectionnée entre 1 et 10 (en tant que valeur constante), une variable, une détection ou un bloc opérateur.",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_BODY_6" : "Le bloc de droite jusqu'à doit se terminer avant que le bloc suivant ne s'exécute. Par exemple, l'utilisation du bloc spin right until ne permettra pas d'exécuter d'autres blocs du programme en même temps. Pour ce faire, reporte-toi à l'option régler les deux moteurs sur le bloc.",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_EXAMPLE_1_TITLE" : "Exemple de programme 1 : arrêt sur une surface noire",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_EXAMPLE_1_BODY_1" : "Dans cet exemple de programme, le robot tourne à droite à la vitesse 5 jusqu'à ce que le traceur de ligne détecte une surface non réfléchissante (noire). Lorsque cela se produit, le moteur s'arrête et le programme se termine.",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_EXAMPLE_2_TITLE" : "Exemple de programme 2 : suivre la lumière",
	"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_EXAMPLE_2_BODY_1" : "Dans cet exemple, le programme commence par une boucle infinie. Le premier bloc de la boucle fait tourner le robot vers la gauche à la vitesse 5 jusqu'à ce que le niveau de lumière gauche soit inférieur au niveau de lumière droit. Lorsque cela se produit, le moteur s'arrête et le bloc suivant s'exécute. Le bloc suivant fait tourner le robot vers la droite à la vitesse 5 jusqu'à ce que le niveau de lumière à gauche soit supérieur au niveau de lumière à droite. Le résultat est que le robot Edison se dirige vers la lumière.",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_TITLE" : "Régler les deux moteurs sur",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_BODY_1" : "Le bloc Régler les deux moteurs sur entraîne les roues pour déplacer le robot dans la direction et à la vitesse sélectionnées. Comme ce bloc d'entraînement règle les moteurs, le programme peut passer directement au bloc suivant. Ceci est différent des blocs d'entraînement qui ont une distance, un temps ou un angle à compléter avant que le programme ne passe au bloc suivant.",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_BODY_2" : "Le bloc a deux paramètres :",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_BODY_3" : "Mouvement - Six options peuvent être sélectionnées : avancer, reculer, faire tourner le robot à gauche, faire tourner le robot à droite, tourner le robot à gauche et tourner le robot à droite.",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_BODY_4" : "Vitesse - La vitesse peut être sélectionnée entre 1 et 10 (en tant que valeur constante), une variable, une détection ou un bloc opérateur.",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_EXAMPLE_1_TITLE" : "Exemple de programme 1 : Musique pendant la conduite",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_EXAMPLE_1_BODY" : "Dans cet exemple de programme, le robot Edison est réglé pour avancer, puis trois notes sont jouées pendant que le robot roule encore. Une fois que la dernière note a fini d'être jouée, le programme se termine et le robot Edison s'arrête de rouler.",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_EXAMPLE_2_TITLE" : "Exemple de programme 2 : Rouler jusqu'à un obstacle",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_EXAMPLE_2_BODY" : "Dans cet exemple de programme, le faisceau de détection d'obstacles est activé, puis les deux moteurs sont réglés pour avancer à la vitesse 8. Le bloc suivant attend jusqu'à ce qu'un obstacle soit détecté. Lorsque cela se produit, le programme se termine et le robot s'arrête de rouler.",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_EXAMPLE_3_TITLE" : "Exemple de programme 3 : Suivre une ligne",
	"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_EXAMPLE_3_BODY" : "Dans cet exemple de programme, la DEL du suiveur de ligne est allumée et le programme entre dans une boucle sans fin. À l'intérieur de la boucle, les deux moteurs sont réglés pour faire tourner le robot vers la gauche à la vitesse 1, puis le bloc wait until maintient le programme jusqu'à ce que le traceur de ligne détecte une surface réfléchissante (blanche). Lorsque cela se produit, les deux moteurs sont alors réglés pour faire tourner le robot vers la droite à la vitesse 1 et le bloc d'attente maintient le programme jusqu'à ce que le traceur de ligne détecte une surface non réfléchissante (noire). Lorsque cela se produit, le programme revient au début de la boucle infinie et recommence. Edison suit ainsi une ligne non réfléchissante.",
	"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_TITLE" : "régler le moteur droit sur",
	"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_BODY_1" : "Le bloc ''set right motor to'' entraîne les roues pour déplacer le robot dans la direction et à la vitesse choisies. Comme ce bloc d'entraînement règle les moteurs, le programme peut passer directement au bloc suivant. Ceci est différent des blocs d'entraînement qui ont une distance, un temps ou un angle à compléter avant que le programme ne passe au bloc suivant.",
	"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_BODY_2" : "Le bloc a deux paramètres :",
	"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_BODY_3" : "Mouvement - Deux options peuvent être sélectionnées : vers l'avant et vers l'arrière.",
	"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_BODY_4" : "Vitesse - La vitesse peut être sélectionnée entre 1 et 10 (en tant que valeur constante), une variable, une détection ou un bloc opérateur.",
	"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_EXAMPLE_1_TITLE" : "Exemple de programme 1 : le moteur s'allume et s'éteint en appuyant sur un bouton",
	"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_EXAMPLE_1_BODY" : "Dans cet exemple, le programme entre dans une boucle sans fin. Le premier bloc de la boucle attend que le bouton rond soit pressé. Lorsque cela se produit, le moteur droit est réglé sur la marche avant à la vitesse 5. Le programme passe ensuite à un autre bloc d'attente jusqu'à ce que le bouton rond soit enfoncé. Lorsque cela se produit, le moteur droit est arrêté et le programme revient au début de la boucle infinie.",
	"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_TITLE" : "Régler le moteur gauche sur",
	"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_BODY_1" : "Le bloc ''set left motor to'' entraîne les roues pour déplacer le robot dans la direction et à la vitesse sélectionnées. Comme ce bloc d'entraînement règle les moteurs, le programme peut passer directement au bloc suivant. Ceci est différent des blocs d'entraînement qui ont une distance, un temps ou un angle à respecter avant que le programme ne passe au bloc suivant.",
	"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_BODY_2" : "Le bloc a deux paramètres :",
	"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_BODY_3" : "Mouvement - Deux options peuvent être sélectionnées : vers l'avant et vers l'arrière.",
	"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_BODY_4" : "Vitesse - La vitesse peut être sélectionnée entre 1 et 10 (en tant que valeur constante), une variable, une détection ou un bloc opérateur.",
	"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_EXAMPLE_1_TITLE" : "Exemple de programme 1 : suivre la lumière",
	"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_EXAMPLE_1_BODY" : "Dans cet exemple, le programme entre dans une boucle infinie. Le premier bloc de la boucle fait avancer le moteur gauche à une vitesse calculée. La vitesse calculée est le niveau de lumière du capteur de droite moins le niveau de lumière du capteur de gauche divisé par 100. On ajoute également 3 au résultat pour fixer une vitesse minimale. Le bloc suivant règle le moteur droit sur la marche avant à une vitesse calculée. La vitesse calculée est le niveau de lumière du capteur gauche moins le niveau de lumière du capteur droit divisé par 100, 3 est également ajouté au résultat pour définir une vitesse minimale. Le programme revient ensuite au début de la boucle infinie. Les résultats calculés contrôlent la vitesse de façon à ce que le côté qui a le moins de lumière roule le plus vite. Ainsi, le robot Edison essaie toujours de faire face à la lumière la plus brillante et de s'y diriger.",
	"HELP_TEXT_DRIVE_STOP_TITLE" : "arrêter",
	"HELP_TEXT_DRIVE_STOP_BODY_1" : "Le bloc d'arrêt empêche les moteurs d'entraîner les roues.",
	"HELP_TEXT_DRIVE_STOP_BODY_2" : "Le bloc d'arrêt n'a qu'un seul paramètre pour sélectionner le(s) moteur(s) arrêté(s). Les options sont les deux moteurs, le moteur gauche et le moteur droit.",
	"HELP_TEXT_DRIVE_STOP_EXAMPLE_1_TITLE" : "Exemple de programme 1 : le moteur s'allume et s'éteint en appuyant sur un bouton",
	"HELP_TEXT_DRIVE_STOP_EXAMPLE_1_BODY" : "Dans cet exemple, le programme entre dans une boucle sans fin. Le premier bloc de la boucle attend que le bouton rond soit pressé. Lorsque cela se produit, le moteur droit est réglé sur la marche avant à la vitesse 5. Le programme passe ensuite à un autre bloc d'attente jusqu'à ce que le bouton rond soit enfoncé. Lorsque cela se produit, le moteur droit est arrêté et le programme revient au début de la boucle infinie.",
	"HELP_TEXT_LEDS_LEFT_TITLE" : "tourner à gauche LED",
	"HELP_TEXT_LEDS_LEFT_BODY_1" : "Le bloc d'allumage de la DEL gauche contrôle la DEL gauche. Il y a deux options : marche ou arrêt.",
	"HELP_TEXT_LEDS_LEFT_EXAMPLE_1_TITLE" : "Exemple de programme 1 : faire clignoter une fois la DEL gauche",
	"HELP_TEXT_LEDS_LEFT_EXAMPLE_1_BODY" : "Dans cet exemple, le programme commence par allumer le voyant gauche, puis attend une seconde avant de l'éteindre.",
	"HELP_TEXT_LEDS_LEFT_EXAMPLE_2_TITLE" : "Exemple de programme 2 : Faire clignoter le voyant gauche pour toujours",
	"HELP_TEXT_LEDS_LEFT_EXAMPLE_2_BODY" : "Dans cet exemple, le programme commence par entrer dans une boucle infinie. À l'intérieur de la boucle, le voyant gauche est allumé, puis le programme attend une seconde, puis le voyant gauche est éteint, puis le programme attend une seconde, puis le programme saute au début de la boucle et recommence indéfiniment.",
	"HELP_TEXT_LEDS_RIGHT_TITLE" : "tourner la DEL droite",
	"HELP_TEXT_LEDS_RIGHT_BODY_1" : "Le bloc turn right LED contrôle le voyant droit. Il y a deux options : on ou off.",
	"HELP_TEXT_LEDS_RIGHT_EXAMPLE_1_TITLE" : "Exemple de programme 1 : faire clignoter une fois la DEL de droite",
	"HELP_TEXT_LEDS_RIGHT_EXAMPLE_1_BODY" : "Dans cet exemple, le programme commence par allumer la DEL de droite, puis attend une seconde avant d'éteindre la DEL de droite.",
	"HELP_TEXT_LEDS_RIGHT_EXAMPLE_2_TITLE" : "Exemple de programme 2 : Faire clignoter le voyant de droite pour toujours",
	"HELP_TEXT_LEDS_RIGHT_EXAMPLE_2_BODY" : "Dans cet exemple, le programme commence par entrer dans une boucle infinie. À l'intérieur de la boucle, le voyant droit est allumé, puis le programme attend une seconde, puis le voyant droit est éteint, puis le programme attend une seconde, puis le programme revient au début de la boucle et recommence indéfiniment.",
	"HELP_TEXT_LEDS_SEND_MESSAGE_TITLE" : "envoie un message IR",
	"HELP_TEXT_LEDS_SEND_MESSAGE_BODY_1" : "Le bloc d'envoi de messages IR envoie des données par l'intermédiaire de la lumière infrarouge (IR). Les données qui peuvent être envoyées sont des valeurs comprises entre 0 et 255. La valeur peut être une constante (tapée dans l'entrée et qui ne varie pas), une variable, une détection ou un bloc opérateur.",
	"HELP_TEXT_LEDS_SEND_MESSAGE_BODY_2" : "Les données envoyées peuvent être reçues par n'importe quel autre robot Edison qui se trouve à portée du signal lumineux IR. La portée maximale peut atteindre 10 mètres dans des conditions idéales (c'est-à-dire à l'intérieur, sans lumière directe du soleil, avec un plafond et des murs blancs sur lesquels la lumière infrarouge peut rebondir).",
	"HELP_TEXT_LEDS_SEND_MESSAGE_BODY_3" : "Si tu utilises une variable, le nombre qu'elle contient peut dépasser la limite de 255 (8 bits). Dans ce cas, le nombre envoyé par IR s'enroulera autour de la variable (256 envoie 0, 257 envoie 1, 258 envoie 2...).",
	"HELP_TEXT_LEDS_SEND_MESSAGE_EXAMPLE_1_TITLE" : "Exemple de programme 1 : Envoi du message IR 1 lorsque le bouton rond est enfoncé",
	"HELP_TEXT_LEDS_SEND_MESSAGE_EXAMPLE_1_BODY" : "Dans cet exemple, le programme commence par entrer dans une boucle infinie. À l'intérieur de la boucle, le programme attend que le bouton rond soit enfoncé. Lorsque cela se produit, le message IR 1 est envoyé. Le programme revient ensuite au début de la boucle infinie.",
	"HELP_TEXT_LEDS_SEND_MESSAGE_EXAMPLE_2_TITLE" : "Exemple de programme 2 : envoi du niveau de luminosité toutes les secondes",
	"HELP_TEXT_LEDS_SEND_MESSAGE_EXAMPLE_2_BODY" : "Dans cet exemple, le programme commence par entrer dans une boucle infinie. À l'intérieur de la boucle, le programme envoie la lecture du niveau de lumière du capteur de lumière gauche divisée par quatre. La valeur est divisée par quatre car la sortie du capteur de lumière est de 1 à 1 000, mais le nombre le plus élevé qui peut être envoyé avec IR est 255 (1 000/4 = 250). Ce calcul supplémentaire permet d'envoyer toute la portée du capteur de lumière. Le programme attend ensuite une seconde, puis revient au début de la boucle éternelle.",
	"HELP_TEXT_SOUND_BEEP_TITLE" : "bip",
	"HELP_TEXT_SOUND_BEEP_BODY_1" : "Le bloc bip émet un bip sonore de 3,5 kHz pendant 125 mS (0,125 seconde).",
	"HELP_TEXT_SOUND_BEEP_EXAMPLE_1_TITLE" : "Exemple de programme 1 : Bip lorsque le bouton rond est pressé",
	"HELP_TEXT_SOUND_BEEP_EXAMPLE_1_BODY" : "Dans cet exemple, le programme commence par entrer dans une boucle perpétuelle. À l'intérieur de la boucle, le programme attend que le bouton rond soit enfoncé. Lorsque cela se produit, le signal sonore est émis. Le programme revient ensuite au début de la boucle infinie et recommence.",
	"HELP_TEXT_SOUND_PLAY_NOTE_TITLE" : "jouer une note",
	"HELP_TEXT_SOUND_PLAY_NOTE_BODY_1" : "Le bloc play a note joue une note de musique. Les paramètres du bloc permettent de sélectionner la longueur, la note et le type de note.",
	"HELP_TEXT_SOUND_PLAY_NOTE_BODY_2" : "Le bloc a trois paramètres :",
	"HELP_TEXT_SOUND_PLAY_NOTE_BODY_3" : "Longueur - Il y a quatre options : entier, moitié, quart et huitième.",
	"HELP_TEXT_SOUND_PLAY_NOTE_BODY_4" : "Note - Il y a dix options : Do, si, la, sol, fa, mi, ré, do moyen, si grave et repos.",
	"HELP_TEXT_SOUND_PLAY_NOTE_BODY_5" : "Modificateur de note - Il y a trois options : - (non modifiée), dièse et bémol.",
	"HELP_TEXT_SOUND_PLAY_NOTE_BODY_6" : "Le bloc jouer une note doit être terminé avant que le bloc suivant ne s'exécute. Par exemple, l'utilisation du bloc jouer une note n'exécutera pas d'autres blocs du programme en même temps. Pour ce faire, vois le bloc jouer de la musique en arrière-plan.",
	"HELP_TEXT_SOUND_PLAY_NOTE_EXAMPLE_1_TITLE" : "Exemple de programme 1 : Marie avait un petit agneau",
	"HELP_TEXT_SOUND_PLAY_NOTE_EXAMPLE_1_BODY" : "Dans cet exemple, le programme commence par définir le tempo des notes de musique, puis joue les notes de la comptine Mary had a little lamb dans l'ordre, en jouant chaque note entièrement avant de passer à la suivante.",
	"HELP_TEXT_SOUND_SET_TEMPO_TITLE" : "règle le tempo de la musique sur",
	"HELP_TEXT_SOUND_SET_TEMPO_BODY_1" : "Le bloc set music temp to définit le tempo auquel les notes suivantes sont jouées.",
	"HELP_TEXT_SOUND_SET_TEMPO_BODY_2" : "Il existe cinq options : très lent, lent, moyen, rapide et très rapide.",
	"HELP_TEXT_SOUND_SET_TEMPO_EXAMPLE_1_TITLE" : "Exemple de programme 1 : Marie avait un petit agneau",
	"HELP_TEXT_SOUND_SET_TEMPO_EXAMPLE_1_BODY" : "Dans cet exemple, le programme commence par définir le tempo des notes de musique, puis joue les notes de la comptine Marie avait un petit agneau à cette vitesse, en jouant chaque note entièrement avant de passer à la suite.",
	"HELP_TEXT_SOUND_PLAYINBACKGROUND_TITLE" : "Jouer de la musique en arrière-plan",
	"HELP_TEXT_SOUND_PLAYINBACKGROUND_BODY_1" : "Le bloc play music in background permet aux notes de musique placées à l'intérieur du bloc d'être jouées pendant que le robot Edison exécute d'autres parties du programme.",
	"HELP_TEXT_SOUND_PLAYINBACKGROUND_EXAMPLE_1_TITLE" : "Exemple de programme 1 : Mary had a little lamb while dancing (Marie avait un petit agneau en dansant)",
	"HELP_TEXT_SOUND_PLAYINBACKGROUND_EXAMPLE_1_BODY" : "Dans cet exemple de programme, le programme commence par définir le tempo des notes de musique, puis les notes à l'intérieur du bloc play music in background commencent à jouer, le programme entre dans la boucle de répétition et les blocs spin left et spin right s'exécutent quatre fois avec la mélodie toujours jouée en arrière-plan. Cela permet à Edison de danser tout en jouant de la musique.",
	"HELP_TEXT_VARIABLE_TITLE" : "Variable",
	"HELP_TEXT_VARIABLE_BODY_1" : "Un bloc variable est un endroit où des données peuvent être stockées et utilisées par un programme. Les données d'une variable peuvent varier et changer pendant l'exécution du programme. C'est pourquoi on l'appelle une variable.",
	"HELP_TEXT_VARIABLE_BODY_2" : "Les données d'une variable sont des nombres qui peuvent être compris entre -1 073 741 824 et 1 073 741 823 (signé sur 32 bits).",
	"HELP_TEXT_VARIABLE_BODY_3" : "Les variables doivent être personnalisées en leur donnant un nom qui a du sens pour le programme. Par exemple :",
	"HELP_TEXT_VARIABLE_BODY_4" : "Si le nombre d'une variable dépasse la plage de -1 073 741 824 à 1 073 741 823, le programme s'arrête et Edison émet une tonalité d'échec.",
	"HELP_TEXT_VARIABLE_EXAMPLE_1_TITLE" : "Exemple de programme 1 : une fréquence de clignotement aléatoire définie au début du programme.",
	"HELP_TEXT_VARIABLE_EXAMPLE_1_BODY_1" : "Dans cet exemple de programme, la variable 'FlashRate' est réglée sur un nombre aléatoire compris entre 10 et 100. Le programme entre ensuite dans une boucle infinie. À l'intérieur de la boucle, les DEL gauche et droite sont allumées, puis le programme attend la valeur en millisecondes de 'FlashRate', puis éteint les DEL gauche et droite, puis le programme attend à nouveau la valeur en millisecondes de 'FlashRate'. Le programme revient ensuite au début de la boucle infinie et recommence. Ainsi, Edison fait clignoter ses DEL à des vitesses différentes à chaque fois que le programme est exécuté",
	"HELP_TEXT_VARIABLE_EXAMPLE_2_TITLE" : "Exemple de programme 2 : compter les lignes noires parcourues",
	"HELP_TEXT_VARIABLE_EXAMPLE_2_BODY_1" : "Dans cet exemple de programme, la DEL du suiveur de ligne est d'abord allumée, puis le robot Edison avance de 30 cm à la vitesse 5. En avançant, toute surface non réfléchissante (noire) détectée par le suiveur de ligne amènera le programme à passer au bloc d'événements Suiveur de ligne sur une surface non réfléchissante. Dans ce cas, la variable ''LineCount'' est incrémentée (+1). Lorsque la conduite sur 30 cm est terminée, le programme répète les blocs d'attente pendant 1 seconde et de bip pour le nombre de fois indiqué dans la variable 'LineCount'.",
	"HELP_TEXT_VARIABLE_EXAMPLE_3_TITLE" : "Exemple de programme 3 : compteur de rayonnement lumineux",
	"HELP_TEXT_VARIABLE_EXAMPLE_3_BODY_1" : "Dans cet exemple de programme, le tempo de la musique est d'abord réglé sur très rapide. Le programme entre ensuite dans une boucle infinie. À l'intérieur de la boucle, le programme règle la variable 'Delay' sur 1000 moins le niveau de lumière gauche (en inversant la lecture du niveau de lumière). Le bloc suivant attend la valeur de la variable 'Delay'. Le programme joue ensuite la note C et revient au début de la boucle infinie, puis recommence. Le résultat de ce programme est que l'Edison émet un bip lent lorsqu'il est dans l'obscurité et plus rapide lorsque le niveau de luminosité est plus élevé.",
	"HELP_TEXT_DATA_SETVARIABLETO_TITLE" : "set to",
	"HELP_TEXT_DATA_SETVARIABLETO_BODY_1" : "Le bloc set to est utilisé pour définir une valeur dans une variable.",
	"HELP_TEXT_DATA_SETVARIABLETO_BODY_2" : "Il y a deux entrées :",
	"HELP_TEXT_DATA_SETVARIABLETO_BODY_3" : "Variable - C'est l'endroit où le bloc variable est placé.",
	"HELP_TEXT_DATA_SETVARIABLETO_BODY_4" : "Valeur - Elle peut être une constante (tapée dans l'entrée et ne varie pas), une variable, une détection ou un bloc opérateur.",
	"HELP_TEXT_DATA_SETVARIABLETO_EXAMPLE_1_TITLE" : "Exemple de programme 1 : Définir le nombre de bips",
	"HELP_TEXT_DATA_SETVARIABLETO_EXAMPLE_1_BODY_1" : "Dans cet exemple de programme, la variable '' Nombre de bips '' est réglée sur 5, puis le bloc de répétition répète les bips pour la valeur 5 contenue dans la variable '' Nombre de bips ''.",
	"HELP_TEXT_DATA_SETVARIABLETO_EXAMPLE_2_TITLE" : "Exemple de programme 2 : une fréquence de clignotement aléatoire définie au début du programme",
	"HELP_TEXT_DATA_SETVARIABLETO_EXAMPLE_2_BODY_1" : "Dans cet exemple de programme, la variable 'FlashRate' est réglée sur un nombre aléatoire compris entre 10 et 1000. Le programme entre ensuite dans une boucle infinie. À l'intérieur de la boucle, les DEL gauche et droite sont allumées, puis le programme attend la valeur en millisecondes de 'FlashRate', puis éteint les DEL gauche et droite, puis le programme attend à nouveau la valeur en millisecondes de 'FlashRate'. Le programme revient ensuite au début de la boucle infinie et recommence. Ainsi, Edison fait clignoter ses DEL à des vitesses différentes à chaque fois que le programme est exécuté",
	"HELP_TEXT_DATA_SETVARIABLETO_EXAMPLE_3_TITLE" : "Exemple de programme 3 : Suis la lumière",
	"HELP_TEXT_DATA_SETVARIABLETO_EXAMPLE_3_BODY_1" : "Dans cet exemple, le programme commence par entrer dans une boucle infinie. À l'intérieur de la boucle, le programme définit la variable ''LightLeftvsRight'' comme étant le niveau d'éclairage gauche moins le niveau d'éclairage droit. Le bloc if else teste ensuite si la valeur de la variable 'LightLeftvsRight' est supérieure à 0. Si le résultat est vrai, le moteur droit est réglé pour avancer et le moteur gauche est arrêté. Si le résultat est faux, le moteur gauche est réglé pour avancer et le moteur droit est arrêté. Le programme revient ensuite au début de la boucle infinie et recommence. Ainsi, Edison se dirige vers la source de lumière la plus brillante.",
	"HELP_TEXT_DATA_INCVARIABLE_TITLE" : "incrémenter",
	"HELP_TEXT_DATA_INCVARIABLE_BODY_1" : "Le bloc d'incrémentation incrémente (ajoute 1) la variable placée dans le bloc.",
	"HELP_TEXT_DATA_INCVARIABLE_EXAMPLE_1_TITLE" : "Exemple de programme 1 : décélération du clignotement",
	"HELP_TEXT_DATA_INCVARIABLE_EXAMPLE_1_BODY_1" : "Dans cet exemple de programme, la variable 'Delay' est fixée à 0. Le programme entre ensuite dans une boucle infinie. À l'intérieur de la boucle, la variable 'Delay' est incrémentée (+1), puis la DEL droite est allumée et la DEL gauche est éteinte, puis le programme attend la valeur de la variable 'Delay' en millisecondes, puis la DEL droite est éteinte et la DEL gauche est allumée, puis à nouveau, le programme attend la valeur de la variable 'Delay' en millisecondes. Le programme revient ensuite au début de la boucle infinie et recommence. Au fur et à mesure que le programme répète la boucle éternelle, la variable 'Delay' est incrémentée à chaque fois, ce qui allonge de plus en plus la durée d'allumage et d'extinction des diodes électroluminescentes. Après 1 000 boucles, la durée d'allumage et d'extinction des DEL est d'une seconde.",
	"HELP_TEXT_DATA_DECVARIABLE_TITLE" : "décrémenter",
	"HELP_TEXT_DATA_DECVARIABLE_BODY_1" : "Le bloc de décrémentation décrémente (moins 1) la variable placée dans le bloc.",
	"HELP_TEXT_DATA_DECVARIABLE_EXAMPLE_1_TITLE" : "Exemple de programme 1 : Accélérer le clignotement",
	"HELP_TEXT_DATA_DECVARIABLE_EXAMPLE_1_BODY_1" : "Dans cet exemple de programme, la variable 'Delay' est fixée à 100. Le programme entre ensuite dans une boucle infinie. À l'intérieur de la boucle, la variable 'Delay' est décrémentée (-1), puis la DEL droite est allumée et la DEL gauche est éteinte, puis le programme attend la valeur de la variable 'Delay' en millisecondes, puis la DEL droite est éteinte et la DEL gauche est allumée, puis à nouveau, le programme attend la valeur de la variable 'Delay' en millisecondes. Le programme revient ensuite au début de la boucle infinie et recommence. Au fur et à mesure que le programme répète la boucle éternelle, la variable 'Delay' est décrémentée à chaque fois, ce qui réduit la durée d'allumage et d'extinction des DEL. Après 100 boucles, la durée d'allumage des DEL est d'une milliseconde et la durée d'extinction des DEL est d'une milliseconde.",
	"HELP_TEXT_BIT_SHIFT_RIGHT_TITLE" : "décalage des bits vers la droite",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_1" : "Le décalage de bits vers la droite par bloc ajuste mathématiquement le bloc variable connecté dans sa forme binaire en décalant les bits vers la droite de la valeur définie.",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_2" : "Le format des nombres utilisé par les ordinateurs est appelé binaire. Il s'agit d'un système de numération qui ne comprend que les chiffres 0 et 1. Chaque chiffre à l'intérieur d'un ordinateur est une chaîne de 1 et de 0. Voici quelques exemples de nombres binaires de 8 bits :",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_HUMAN" : "Humain/décimal",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_COMPUTER" : "Ordinateur/8 bits binaires",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_3" : "Voici quelques exemples de nombres binaires de 32 bits :",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_4" : "Edison V3 utilise à la fois des nombres binaires de 8 bits et de 32 bits. Par exemple, les blocs variables sont capables de stocker de grands nombres de 32 bits (en réalité signés sur 31 bits), mais seuls des nombres de 8 bits peuvent être envoyés via le bloc de message IR d'envoi. En outre, certains capteurs, tels que les capteurs de lumière, ont une plage de 1 à 1000. Comme le nombre de 8 bits le plus élevé possible est 255, toute la plage de lecture du capteur de lumière ne peut pas être envoyée par le biais du bloc de messages d'envoi IR. C'est là que le bloc de décalage de bits vers la droite peut t'aider !",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_5" : "La lecture du capteur de lumière est un nombre binaire de 10 bits. Voici les valeurs minimales et maximales :",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_6" : "Si le nombre 1000 est envoyé avec le bloc de messages IR, le nombre reçu ne correspondra qu'aux 8 derniers bits. Ce serait 11111010 (binaire) ou 232 (humain/décimal). Il s'agit d'un nombre très différent du niveau d'éclairage réel de 1000.",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_7" : "Pour envoyer les données relatives au niveau de luminosité via le bloc de message IR, le bloc de décalage des bits vers la droite peut être utilisé pour raccourcir le nombre en un nombre de 8 bits (décalage vers la droite de 2) sans perdre une trop grande partie des données. Ensuite, à la réception, le bloc de décalage des bits vers la gauche peut être utilisé pour rétablir la lecture du niveau de luminosité sur 10 bits (décalage vers la gauche de 2).",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_4_LINE_1_BOX_1" : "Étape",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_4_LINE_2_BOX_1" : "Lecture de la lumière",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_4_LINE_3_BOX_1" : "Décalage des bits vers la droite (2)",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_4_LINE_4_BOX_1" : "Envoi/réception des données IR",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_4_LINE_5_BOX_1" : "Décalage des bits vers la gauche (2)",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_BIT" : "bit",
	"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_8" : "Dans ce scénario, le nombre obtenu n'est pas parfaitement identique, car certaines informations ont été perdues. Cependant, les bits les plus significatifs contenant plus de 99 % des données d'origine ont été conservés grâce à ce processus.",
	"HELP_TEXT_BIT_SHIFT_LEFT_TITLE" : "décalage des bits vers la gauche",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_1" : "Le décalage des bits vers la gauche par bloc ajuste mathématiquement le bloc variable connecté dans sa forme binaire en décalant les bits vers la gauche de la valeur définie.",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_2" : "Le format des nombres utilisé par les ordinateurs est appelé binaire. Il s'agit d'un système de numération qui ne comprend que les chiffres 0 et 1. Chaque chiffre à l'intérieur d'un ordinateur est une chaîne de 1 et de 0. Voici quelques exemples de nombres binaires de 8 bits :",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_HUMAN" : "Humain/décimal",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_COMPUTER" : "Ordinateur/8 bits binaires",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_3" : "Voici quelques exemples de nombres binaires de 32 bits :",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_4" : "Edison V3 utilise à la fois des nombres binaires de 8 bits et de 32 bits. Par exemple, les blocs variables sont capables de stocker de grands nombres de 32 bits (en réalité signés sur 31 bits), mais seuls des nombres de 8 bits peuvent être envoyés via le bloc de message IR d'envoi. En outre, certains capteurs, tels que les capteurs de lumière, ont une plage de 1 à 1000. Comme le nombre de 8 bits le plus élevé possible est 255, toute la plage de lecture du capteur de lumière ne peut pas être envoyée par le biais du bloc de messages d'envoi IR. C'est là que le bloc de décalage de bits vers la droite peut t'aider !",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_5" : "La lecture du capteur de lumière est un nombre binaire de 10 bits. Voici les valeurs minimales et maximales :",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_6" : "Si le nombre 1000 est envoyé avec le bloc de messages IR, le nombre reçu ne correspondra qu'aux 8 derniers bits. Ce serait 11111010 (binaire) ou 232 (humain/décimal). Il s'agit d'un nombre très différent du niveau d'éclairage réel de 1000.",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_7" : "Pour envoyer les données relatives au niveau de luminosité via le bloc de message IR, le bloc de décalage des bits vers la droite peut être utilisé pour raccourcir le nombre en un nombre de 8 bits (décalage vers la droite de 2) sans perdre une trop grande partie des données. Ensuite, à la réception, le bloc de décalage des bits vers la gauche peut être utilisé pour rétablir la lecture du niveau de luminosité sur 10 bits (décalage vers la gauche de 2).",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_4_LINE_1_BOX_1" : "Étape",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_4_LINE_2_BOX_1" : "Lecture de la lumière",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_4_LINE_3_BOX_1" : "Décalage des bits vers la droite (2)",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_4_LINE_4_BOX_1" : "Envoi/réception des données IR",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_4_LINE_5_BOX_1" : "Décalage des bits vers la gauche (2)",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_BIT" : "bit",
	"HELP_TEXT_BIT_SHIFT_LEFT_BODY_8" : "Dans ce scénario, le nombre obtenu n'est pas parfaitement identique, car certaines informations ont été perdues. Cependant, les bits les plus significatifs contenant plus de 99 % des données d'origine ont été conservés grâce à ce processus.",
	"HELP_TEXT_EVENT_ANYOBSTACLE_TITLE" : "Obstacle détecté",
	"HELP_TEXT_EVENT_ANYOBSTACLE_BODY_1" : "Le bloc d'événement Tout obstacle détecté fait en sorte que le programme passe à ce bloc lorsqu'un obstacle est détecté par le détecteur d'obstacles.",
	"HELP_TEXT_EVENT_ANYOBSTACLE_BODY_2" : "Assure-toi toujours que le faisceau du détecteur d'obstacles est activé dans le programme principal.",
	"HELP_TEXT_EVENT_ANYOBSTACLE_EXAMPLE_1_TITLE" : "Exemple de programme 1 : Bip lorsqu'un obstacle est détecté.",
	"HELP_TEXT_EVENT_ANYOBSTACLE_EXAMPLE_1_BODY_1" : "Dans cet exemple de programme, le détecteur d'obstacles est d'abord allumé, le programme entre ensuite dans le bloc de la boucle pour toujours. Lorsqu'un obstacle est détecté, le programme sort de la boucle éternelle et passe au bloc d'événement Tout obstacle détecté. Cela entraîne l'exécution du bloc de bip et le robot Edison émet un bip. Le programme revient ensuite à l'endroit où il s'est arrêté dans le programme principal.",
	"HELP_TEXT_EVENT_ANYOBSTACLE_EXAMPLE_2_TITLE" : "Exemple de programme 2 : arrêter de rouler lorsqu'il y a un obstacle",
	"HELP_TEXT_EVENT_ANYOBSTACLE_EXAMPLE_2_BODY_1" : "Dans cet exemple de programme, le détecteur d'obstacles est d'abord activé, puis les deux moteurs sont réglés pour rouler en avant à la vitesse 5. Le programme entre ensuite dans le bloc de la boucle pour toujours. Lorsqu'un obstacle est détecté, le programme sort de la boucle éternelle et passe au bloc d'événement Tout obstacle détecté. Cela entraîne l'exécution du bloc d'arrêt des deux moteurs et arrête le fonctionnement des deux moteurs. Le programme revient ensuite à l'endroit où il s'est arrêté dans le programme principal.",
	"HELP_TEXT_EVENT_ANYOBSTACLE_EXAMPLE_3_TITLE" : "Exemple de programme 3 : éviter les obstacles",
	"HELP_TEXT_EVENT_ANYOBSTACLE_EXAMPLE_3_BODY_1" : "Dans cet exemple de programme, le détecteur d'obstacles est d'abord activé, puis le programme entre dans une boucle infinie, à l'intérieur de laquelle les deux moteurs sont réglés pour avancer à la vitesse 5. Lorsqu'un obstacle est détecté, le programme sort de la boucle infinie et passe au bloc d'événement Tout obstacle détecté. Les blocs situés sous le bloc d'événement Tout obstacle détecté font reculer l'Edison de 1 cm à la vitesse 1, puis le font tourner à gauche de 120 degrés à la vitesse 1. Le programme revient ensuite à l'endroit où il s'est arrêté dans la boucle sans fin et les deux moteurs sont de nouveau réglés pour avancer à la vitesse 5. Edison s'éloigne ainsi des obstacles qui se trouvent sur son chemin.",
	"HELP_TEXT_OBSTACLE_LEFT_EVENT_TITLE" : "Obstacle détecté à gauche",
	"HELP_TEXT_OBSTACLE_LEFT_EVENT_BODY_1" : "Le bloc d'événement Obstacle détecté à gauche fait en sorte que le programme passe à ce bloc lorsqu'un obstacle est détecté à gauche par le détecteur d'obstacles.",
	"HELP_TEXT_OBSTACLE_LEFT_EVENT_BODY_2" : "Assure-toi toujours que le faisceau du détecteur d'obstacles est activé dans le programme principal.",
	"HELP_TEXT_OBSTACLE_LEFT_EVENT_EXAMPLE_1_TITLE" : "Exemple de programme 1 : Bip lorsqu'un obstacle est détecté sur la gauche",
	"HELP_TEXT_OBSTACLE_LEFT_EVENT_EXAMPLE_1_BODY_1" : "Dans cet exemple de programme, le détecteur d'obstacles est d'abord mis en marche, le programme entre ensuite dans le bloc de la boucle pour toujours. Lorsqu'un obstacle est détecté à gauche, le programme saute de la boucle éternelle et passe au bloc d'événement Obstacle détecté à gauche. Cela entraîne l'exécution du bloc de bip et le robot Edison émet un bip. Le programme revient ensuite à l'endroit où il s'est arrêté dans le bloc de la boucle éternelle.",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_TITLE" : "Obstacle détecté à droite",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_BODY_1" : "Le bloc d'événement Obstacle détecté à droite fait en sorte que le programme passe à ce bloc lorsqu'un obstacle est détecté à droite par le détecteur d'obstacles.",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_BODY_2" : "Assure-toi toujours que le faisceau du détecteur d'obstacles est activé dans le programme principal.",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_1_TITLE" : "Exemple de programme 1 : Bip lorsqu'un obstacle est détecté sur la droite",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_1_BODY_1" : "Dans cet exemple de programme, le détecteur d'obstacles est d'abord mis en marche, le programme entre ensuite dans le bloc de la boucle pour toujours. Lorsqu'un obstacle est détecté à droite, le programme sort de la boucle éternelle et passe au bloc d'événement Obstacle détecté à droite. Cela entraîne l'exécution du bloc de bip et le robot Edison émet un bip. Le programme revient ensuite à l'endroit où il s'est arrêté dans le bloc de la boucle perpétuelle.",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_2_TITLE" : "Exemple de programme 2 : Détecteur d'obstacles",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_2_BODY_1" : "Dans cet exemple de programme, le détecteur d'obstacles est d'abord activé, le programme entre ensuite dans le bloc de boucle éternelle. Lorsque...",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_2_BODY_2" : "...un obstacle est détecté à l'avant, le programme passe au bloc d'événements Obstacle détecté à l'avant et le robot Edison recule pendant 0,25 seconde à la vitesse 10, puis revient à l'endroit où il est parti dans le bloc de la boucle sans fin.",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_2_BODY_3" : "...un obstacle est détecté à droite le programme saute au bloc d'événement Obstacle détecté à droite et le robot Edison tourne à gauche en arrière pendant 0,25 seconde à la vitesse de 10 et revient ensuite à l'endroit où il est parti dans le bloc de la boucle sans fin.",
	"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_2_BODY_4" : "...un obstacle est détecté à gauche, le programme passe au bloc d'événement Obstacle détecté à gauche et le robot Edison tourne à droite en arrière pendant 0,25 seconde à la vitesse de 10, puis revient à l'endroit où il est parti dans le bloc de la boucle sans fin.",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_TITLE" : "Obstacle détecté devant",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_BODY_1" : "Le bloc d'événement Obstacle détecté devant fait en sorte que le programme saute à ce bloc lorsqu'un obstacle est détecté devant par le détecteur d'obstacles. Cela signifie qu'au même moment, les détecteurs d'obstacles gauche et droit ont détecté un obstacle.",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_BODY_2" : "Assure-toi toujours que le faisceau du détecteur d'obstacles est activé dans le programme principal.",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_1_TITLE" : "Exemple de programme 1 : Bip lorsqu'un obstacle est détecté à l'avant.",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_1_BODY_1" : "Dans cet exemple de programme, le détecteur d'obstacles est d'abord mis en marche, le programme entre ensuite dans le bloc de la boucle pour toujours. Lorsqu'un obstacle est détecté à droite, le programme sort de la boucle éternelle et passe au bloc d'événement Obstacle détecté à droite. Cela entraîne l'exécution du bloc de bip et le robot Edison émet un bip. Le programme revient ensuite à l'endroit où il s'est arrêté dans le bloc de la boucle perpétuelle.",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_2_TITLE" : "Exemple de programme 2 : Le détecteur d'obstacles",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_2_BODY_1" : "Dans cet exemple de programme, le détecteur d'obstacles est d'abord activé, le programme entre ensuite dans le bloc de boucle éternelle. Lorsque...",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_2_BODY_2" : "...un obstacle est détecté à l'avant, le programme passe au bloc d'événements Obstacle détecté à l'avant et le robot Edison recule pendant 0,25 seconde à la vitesse 10, puis revient à l'endroit où il est parti dans le bloc de la boucle sans fin.",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_2_BODY_3" : "...un obstacle est détecté à droite le programme saute au bloc d'événement Obstacle détecté à droite et le robot Edison tourne à gauche en arrière pendant 0,25 seconde à la vitesse de 10 et revient ensuite à l'endroit où il est parti dans le bloc de la boucle sans fin.",
	"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_2_BODY_4" : "...un obstacle est détecté à gauche, le programme passe au bloc d'événement Obstacle détecté à gauche et le robot Edison tourne à droite en arrière pendant 0,25 seconde à la vitesse de 10, puis revient à l'endroit où il est parti dans le bloc de la boucle sans fin.",
	"HELP_TEXT_CLAP_EVENT_TITLE" : "Clap détecté",
	"HELP_TEXT_CLAP_EVENT_BODY_1" : "Le bloc d'événement Clap détecté fait en sorte que le programme passe à ce bloc lorsqu'un clap est détecté.",
	"HELP_TEXT_CLAP_EVENT_BODY_2" : "Lorsqu'Edison roule, le bruit du moteur et les chocs provoquent le déclenchement du capteur de clap, il est donc préférable de ne pas utiliser le capteur de clap lorsqu'on roule. De même, s'il est probable qu'il y ait des détections de bruit fausses ou indésirables, les données du capteur de claquement peuvent être effacées avec le bloc d'effacement des données du capteur réglé sur le détecteur de claquement (voir l'exemple de programme).",
	"HELP_TEXT_CLAP_EVENT_EXAMPLE_1_TITLE" : "Exemple de programme : Edison a peur des bruits forts",
	"HELP_TEXT_CLAP_EVENT_EXAMPLE_1_BODY_1" : "Dans cet exemple, le programme commence par entrer dans une boucle forever vide et rien ne se passe. Lorsqu'un clap (ou un autre son fort et effrayant) est détecté, le programme sort de la boucle infinie et passe au bloc d'événement Clap détecté. Les blocs situés sous le bloc d'événement Clap détecté s'exécutent alors, reculant de 5 cm à la vitesse 10 (saut de peur), puis entrant dans une boucle de répétition réglée sur 25 fois où les blocs de rotation à gauche et de rotation à droite s'exécutent à plusieurs reprises, faisant vibrer l'Edison (frisson de peur). Enfin, (lorsque l'Edison se remet de sa frayeur), le bloc d'effacement des données du capteur efface toutes les fausses détections d'applaudissements qui ont pu se produire pendant la conduite. Le programme retourne maintenant à la boucle perpétuelle.",
	"HELP_TEXT_TRIANGLEBUTTON_EVENT_TITLE" : "Bouton triangulaire enfoncé",
	"HELP_TEXT_TRIANGLEBUTTON_EVENT_BODY_1" : "Le bloc d'événement Bouton triangle enfoncé fait en sorte que le programme saute à ce bloc lorsque le bouton triangle est enfoncé.",
	"HELP_TEXT_TRIANGLEBUTTON_EVENT_EXAMPLE_1_TITLE" : "Exemple de programme : Contrôler le réglage de la vitesse du flash des DEL à l'aide de boutons",
	"HELP_TEXT_TRIANGLEBUTTON_EVENT_EXAMPLE_1_BODY_1" : "Dans cet exemple, le programme commence par régler la variable appelée ''Délai'' sur 100, puis il entre dans une boucle infinie. À l'intérieur de cette boucle, les DEL gauche et droite sont allumées et éteintes en attendant la valeur de la variable ''Delay'' en millisecondes. Ainsi, les DEL sont allumées pendant 100 millisecondes (0,1 seconde) et éteintes pendant 100 millisecondes (0,1 seconde).",
	"HELP_TEXT_TRIANGLEBUTTON_EVENT_EXAMPLE_1_BODY_2" : "Lorsque tu appuies sur le bouton triangle, le programme passe au bloc d'événement Bouton triangle enfoncé. Les blocs situés en dessous du bloc d'événement Bouton triangle enfoncé s'exécutent alors, en réglant la variable appelée ''Délai'' sur 50, puis en émettant un signal sonore. Le programme revient ensuite à la boucle infinie, mais la valeur de la variable appelée ''Delay'' est maintenant de 50, de sorte que le temps entre l'allumage et l'extinction des DEL est maintenant de 50 millisecondes (0,05 seconde). Elles s'allument et s'éteignent donc plus rapidement.",
	"HELP_TEXT_TRIANGLEBUTTON_EVENT_EXAMPLE_1_BODY_3" : "Lorsque le bouton rond est enfoncé, le programme passe au bloc d'événement Bouton rond enfoncé. Les blocs situés sous le bloc d'événement Bouton rond enfoncé s'exécutent alors, réglant la variable appelée ''Délai'' sur 200, puis émettant un signal sonore. Le programme revient ensuite à la boucle infinie, mais la valeur de la variable appelée ''Delay'' est maintenant de 200, de sorte que le temps entre l'allumage et l'extinction des DEL est maintenant de 200 millisecondes (0,2 seconde). Elles s'allument et s'éteignent donc plus lentement.",
	"HELP_TEXT_ROUNDBUTTON_EVENT_TITLE" : "Bouton rond enfoncé",
	"HELP_TEXT_ROUNDBUTTON_EVENT_BODY_1" : "Le bloc d'événements Bouton rond enfoncé fait en sorte que le programme passe à ce bloc lorsque le bouton rond est enfoncé.",
	"HELP_TEXT_ROUNDBUTTON_EVENT_EXAMPLE_1_TITLE" : "Exemple de programme : Contrôler le réglage de la vitesse du flash des DEL à l'aide de boutons",
	"HELP_TEXT_ROUNDBUTTON_EVENT_EXAMPLE_1_BODY_1" : "Dans cet exemple, le programme commence par régler la variable appelée ''Délai'' sur 100, puis il entre dans une boucle infinie. À l'intérieur de cette boucle, les DEL gauche et droite sont allumées et éteintes en attendant la valeur de la variable ''Delay'' en millisecondes. Ainsi, les DEL sont allumées pendant 100 millisecondes (0,1 seconde) et éteintes pendant 100 millisecondes (0,1 seconde).",
	"HELP_TEXT_ROUNDBUTTON_EVENT_EXAMPLE_1_BODY_2" : "Lorsque tu appuies sur le bouton triangle, le programme passe au bloc d'événement Bouton triangle enfoncé. Les blocs situés en dessous du bloc d'événement Bouton triangle enfoncé s'exécutent alors, en réglant la variable appelée ''Délai'' sur 50, puis en émettant un signal sonore. Le programme revient ensuite à la boucle infinie, mais la valeur de la variable appelée ''Delay'' est maintenant de 50, de sorte que le temps entre l'allumage et l'extinction des DEL est maintenant de 50 millisecondes (0,05 seconde). Elles s'allument et s'éteignent donc plus rapidement.",
	"HELP_TEXT_ROUNDBUTTON_EVENT_EXAMPLE_1_BODY_3" : "Lorsque le bouton rond est enfoncé, le programme passe au bloc d'événement Bouton rond enfoncé. Les blocs situés sous le bloc d'événement Bouton rond enfoncé s'exécutent alors, réglant la variable appelée ''Délai'' sur 200, puis émettant un signal sonore. Le programme revient ensuite à la boucle infinie, mais la valeur de la variable appelée ''Delay'' est maintenant de 200, de sorte que le temps entre l'allumage et l'extinction des DEL est maintenant de 200 millisecondes (0,2 seconde). Elles s'allument et s'éteignent donc plus lentement.",
	"HELP_TEXT_LINEREFLECTIVE_EVENT_TITLE" : "Traceur de ligne sur une surface réfléchissante",
	"HELP_TEXT_LINEREFLECTIVE_EVENT_BODY_1" : "Le bloc d'événements Line tracker on reflective surface fait passer le programme à ce bloc lorsque le capteur line tracker détecte le passage d'une surface non réfléchissante (c'est-à-dire noire) à une surface réfléchissante (c'est-à-dire blanche).",
	"HELP_TEXT_LINEREFLECTIVE_EVENT_BODY_2" : "La DEL du suiveur de ligne doit être allumée pour que le bloc d'événement Suiveur de ligne sur surface réfléchissante fonctionne.",
	"HELP_TEXT_LINEREFLECTIVE_EVENT_EXAMPLE_1_TITLE" : "Exemple de programme : Suivre le bord d'une ligne",
	"HELP_TEXT_LINEREFLECTIVE_EVENT_EXAMPLE_1_BODY_1" : "Dans cet exemple, le programme commence par allumer la DEL de suivi de ligne, le programme fait ensuite tourner le robot vers la droite (à la recherche du bord d'une ligne).",
	"HELP_TEXT_LINEREFLECTIVE_EVENT_EXAMPLE_1_BODY_2" : "Lorsque le traceur de ligne détecte un passage d'une surface réfléchissante (blanche) à une surface non réfléchissante (noire), le programme saute au bloc Traceur de ligne sur surface non réfléchissante et exécute le bloc d'entraînement pour que le robot tourne à gauche (en revenant vers la surface réfléchissante (blanche)).",
	"HELP_TEXT_LINEREFLECTIVE_EVENT_EXAMPLE_1_BODY_3" : "Lorsque le traceur de ligne détecte le passage d'une surface non réfléchissante à une surface réfléchissante, le programme passe au bloc d'événement Traceur de ligne sur surface réfléchissante et exécute le bloc d'entraînement pour que le robot tourne à droite (en se retournant vers la surface non réfléchissante (noire)).",
	"HELP_TEXT_LINEREFLECTIVE_EVENT_EXAMPLE_1_BODY_4" : "Chaque fois que le robot tourne à gauche ou à droite, il avance en suivant le bord de la ligne.",
	"HELP_TEXT_LINENONREFLECTIVE_EVENT_TITLE" : "Traceur de ligne sur une surface non réfléchissante",
	"HELP_TEXT_LINENONREFLECTIVE_EVENT_BODY_1" : "Le bloc d'événements Line tracker on non-reflective surface fait sauter le programme à ce bloc lorsque le capteur line tracker détecte un changement d'une surface réfléchissante (c'est-à-dire blanche) à une surface non réfléchissante (c'est-à-dire noire).",
	"HELP_TEXT_LINENONREFLECTIVE_EVENT_BODY_2" : "La DEL du traceur de ligne doit être allumée pour que le bloc d'événement Traceur de ligne sur surface non réfléchissante fonctionne.",
	"HELP_TEXT_LINENONREFLECTIVE_EVENT_EXAMPLE_1_TITLE" : "Exemple de programme : Suivre le bord d'une ligne",
	"HELP_TEXT_LINENONREFLECTIVE_EVENT_EXAMPLE_1_BODY_1" : "Dans cet exemple, le programme commence par allumer la DEL de suivi de ligne, le programme fait ensuite tourner le robot vers la droite (à la recherche du bord d'une ligne).",
	"HELP_TEXT_LINENONREFLECTIVE_EVENT_EXAMPLE_1_BODY_2" : "Lorsque le traceur de ligne détecte un passage d'une surface réfléchissante (blanche) à une surface non réfléchissante (noire), le programme saute au bloc Traceur de ligne sur surface non réfléchissante et exécute le bloc d'entraînement pour que le robot tourne à gauche (en revenant vers la surface réfléchissante (blanche)).",
	"HELP_TEXT_LINENONREFLECTIVE_EVENT_EXAMPLE_1_BODY_3" : "Lorsque le traceur de ligne détecte le passage d'une surface non réfléchissante à une surface réfléchissante, le programme passe au bloc Traceur de ligne sur surface réfléchissante et exécute le bloc d'entraînement pour que le robot tourne à droite (en revenant vers la surface non réfléchissante (noire)).",
	"HELP_TEXT_LINENONREFLECTIVE_EVENT_EXAMPLE_1_BODY_4" : "Chaque fois que le robot tourne à gauche ou à droite, il avance en suivant le bord de la ligne.",
	"HELP_TEXT_LINECHANGE_EVENT_TITLE" : "Le traceur de ligne change de surface",
	"HELP_TEXT_LINECHANGE_EVENT_BODY_1" : "Le bloc d'événement Line tracker changes surface fait sauter le programme à ce bloc lorsque le capteur du traceur de ligne détecte soit un changement d'une surface non réfléchissante (c'est-à-dire noire) à une surface réfléchissante (c'est-à-dire blanche), soit un changement d'une surface réfléchissante (c'est-à-dire blanche) à une surface non réfléchissante (c'est-à-dire noire).",
	"HELP_TEXT_LINECHANGE_EVENT_BODY_2" : "Le voyant du suiveur de ligne doit être allumé pour que le bloc d'événement Le suiveur de ligne change de surface fonctionne.",
	"HELP_TEXT_LINECHANGE_EVENT_EXAMPLE_1_TITLE" : "Exemple de programme : S'arrêter pour changer",
	"HELP_TEXT_LINECHANGE_EVENT_EXAMPLE_1_BODY_1" : "Dans cet exemple, le programme commence par allumer la DEL du suiveur de ligne, le robot avance ensuite à la vitesse 1 et entre dans une boucle sans fin. Le robot continuera ensuite à avancer jusqu'à ce que le capteur du suiveur de ligne détecte un changement dans la réflectivité de la surface (du blanc au noir ou du noir au blanc). Lorsque cela se produit, le programme passe au bloc Line tracker changes surface. Le code situé sous le bloc Line tracker changes surface s'exécute alors, en arrêtant les deux moteurs, en émettant un bip, en attendant 1 seconde, en émettant à nouveau un bip, puis en réglant les deux moteurs pour qu'ils avancent à nouveau.",
	"HELP_TEXT_MESSAGE_EVENT_TITLE" : "Message IR reçu",
	"HELP_TEXT_MESSAGE_EVENT_BODY_1" : "Le bloc d'événement de réception d'un message IR fait en sorte que le programme passe à ce bloc lorsqu'il reçoit un message infrarouge (IR) d'un autre robot Edison.",
	"HELP_TEXT_MESSAGE_EVENT_BODY_3" : "Le bloc d'événement de réception d'un message IR ne fonctionne pas lorsque le récepteur IR est utilisé pour détecter des obstacles.",
	"HELP_TEXT_MESSAGE_EVENT_BODY_4" : "Le programme passe au bloc d'événement de réception de message IR lorsqu'un message IR est reçu d'un autre robot Edison. Le bloc d'événement de réception de message IR ne décode pas les données du message IR. Le décodage du message nécessite que les données du message soient placées dans une variable, puis décodées à l'aide d'un bloc if then.",
	"HELP_TEXT_MESSAGE_EVENT_EXAMPLE_1_TITLE" : "Exemple de programme : Réception d'un message IR pour émettre un ou deux bips",
	"HELP_TEXT_MESSAGE_EVENT_EXAMPLE_1_BODY_1" : "Dans cet exemple, le programme commence par entrer dans une boucle forever vide et rien ne se passe. Lorsqu'un message IR est reçu, le programme passe au bloc d'événement de réception de message IR. Le code situé sous le bloc d'événement de réception du message IR s'exécute alors. Tout d'abord, les données du message reçu sont stockées dans la variable ''ReceivedMessage''. Cela est nécessaire car chaque fois que les données du message IR reçu sont lues, elles sont également effacées. Maintenant que les données du message sont dans une variable, celle-ci est testée pour savoir si elle est égale à 1. Si c'est le cas, le signal sonore est joué une fois. Ensuite, la variable est testée si elle est égale à 2, si c'est vrai, le bloc de bips est joué deux fois. Le programme retourne maintenant à la boucle infinie.",
	"HELP_TEXT_MESSAGE_EVENT_EXAMPLE_2_TITLE" : "Programme d'envoi de messages IR :",
	"HELP_TEXT_MESSAGE_EVENT_EXAMPLE_2_BODY_1" : "Le programme ci-dessus est utilisé dans le robot Edison qui envoie le message IR. Le programme entre d'abord dans une boucle éternelle vide. Lorsque le bouton triangle est enfoncé, le programme passe au bloc d'événement Bouton triangle enfoncé et un message IR est envoyé avec le numéro 1. Lorsque le bouton rond est enfoncé, le programme passe au bloc d'événement Bouton rond enfoncé et un message IR est envoyé avec le numéro 2.",
	"HELP_TEXT_DRIVESTRAIN_EVENT_TITLE" : "Entraînement tendu",
	"HELP_TEXT_DRIVESTRAIN_EVENT_BODY_1" : "Le bloc d'événement Entraînement tendu fait en sorte que le programme passe à ce bloc lorsqu'un ou les deux moteurs sont entraînés, mais qu'ils ne peuvent pas tourner (sous contrainte).",
	"HELP_TEXT_DRIVESTRAIN_EVENT_EXAMPLE_1_TITLE" : "Exemple de programme : Alarme lorsque la roue gauche ne peut pas tourner",
	"HELP_TEXT_DRIVESTRAIN_EVENT_EXAMPLE_1_BODY_1" : "Dans cet exemple, le programme commence par régler le moteur gauche pour qu'il avance, puis entre dans une boucle sans fin. Lorsque la roue ne peut pas tourner parce qu'elle est soumise à des contraintes, le programme passe au bloc d'événements Entraînement soumis à des contraintes et exécute le code ci-dessous. Le code situé sous le bloc d'événement Entraînement sous contrainte est le bloc de bip qui émet un bip. Le programme retourne ensuite à la boucle infinie.",
	"HELP_TEXT_REMOTE_EVENT_TITLE" : "Code à distance reçu",
	"HELP_TEXT_REMOTE_EVENT_BODY_1" : "Le bloc d'événement Code à distance reçu fait en sorte que le programme passe à ce bloc lorsqu'un code de télécommande est reçu.",
	"HELP_TEXT_REMOTE_EVENT_BODY_3" : "Assure-toi d'appuyer sur le bouton triangle pour démarrer ton programme. Il est facile de l'oublier car le robot Edison réagira comme un robot télécommandé et ne fera pas ce pour quoi tu l'as programmé.",
	"HELP_TEXT_REMOTE_EVENT_BODY_4" : "Pour utiliser les blocs de la télécommande, il faut d'abord apprendre au robot Edison quels boutons de ta télécommande correspondent à quel code de télécommande. Tu trouveras plus d'informations à ce sujet ici :",
	"HELP_TEXT_REMOTE_EVENT_BODY_5" : "Si le programme se comporte de manière inattendue, tu devras peut-être utiliser le bloc d'effacement des données du capteur pour effacer le contenu du bloc de réception du code à distance. Voir l'exemple du programme 1 ci-dessous.",
	"HELP_TEXT_REMOTE_EVENT_BODY_6" : "La réception de codes de télécommande infrarouge fonctionnera avec environ 90 % des télécommandes de télévision standard, mais chaque marque utilise des formats de données légèrement différents. Lors du décodage des données, cela peut entraîner des comportements inattendus d'une marque de télécommande à l'autre. Le décodage avancé des télécommandes fonctionne mieux avec l'EdRemote (disponible mi 2025).",
	"HELP_TEXT_REMOTE_EVENT_EXAMPLE_1_TITLE" : "Exemple de programme : Conduite de la télécommande en avant ou en arrière.",
	"HELP_TEXT_REMOTE_EVENT_EXAMPLE_1_BODY" : "Dans cet exemple, le programme commence par entrer dans une boucle forever vide. Lorsqu'un code de télécommande est reçu, le programme saute au bloc d'événement Code à distance reçu. Le code situé sous le bloc d'événements Code distant reçu s'exécute, le code distant est testé pour voir s'il est égal à 1. Si c'est le cas, les deux moteurs sont réglés pour rouler en avant, et cela continue jusqu'à ce que le code reçu ne soit plus égal à 1. Ensuite, le code reçu est testé pour voir s'il est égal à 2. Si c'est le cas, les deux moteurs sont réglés pour rouler en arrière. Cette opération se poursuit jusqu'à ce que le code reçu ne soit plus égal à 2. Enfin, une fois que les codes à distance ont été testés et ne sont plus reçus, le bloc d'arrêt stoppe les deux moteurs. Le programme retourne à la boucle infinie vide.",
	"HELP_TEXT_CONTROL_WAIT_TITLE" : "Attendre sec",
	"HELP_TEXT_CONTROL_WAIT_BODY_1" : "Le bloc wait sec met le programme en pause pendant un certain temps en secondes. La durée peut être comprise entre 0,001 seconde (1 milliseconde) et 1 073 741 secondes (12,4 jours).",
	"HELP_TEXT_CONTROL_WAIT_BODY_2" : "Le bloc d'attente n'a qu'un seul paramètre :",
	"HELP_TEXT_CONTROL_WAIT_BODY_3" : "Valeur - Elle peut être une constante (tapée dans l'entrée et ne varie pas), une variable, une détection ou un bloc opérateur.",
	"HELP_TEXT_CONTROL_WAIT_EXAMPLE_1_TITLE" : "Exemple de programme 1 : faire clignoter la DEL gauche",
	"HELP_TEXT_CONTROL_WAIT_EXAMPLE_1_BODY" : "Dans cet exemple, le programme commence par entrer dans une boucle infinie. À l'intérieur de la boucle, le voyant gauche est allumé, puis le programme fait une pause et attend 0,5 seconde, puis le voyant gauche est éteint, puis le programme fait à nouveau une pause et attend 0,5 seconde, puis fait une boucle jusqu'au début.",
	"HELP_TEXT_CONTROL_WAIT_EXAMPLE_2_TITLE" : "Exemple de programme 2 : cricket robotique nocturne",
	"HELP_TEXT_CONTROL_WAIT_EXAMPLE_2_BODY" : "Dans cet exemple, le programme commence par entrer dans une boucle forever. À l'intérieur de la boucle, il y a un bloc wait until qui met en pause la progression du programme jusqu'à ce que le niveau de lumière sur le capteur de lumière gauche soit inférieur à 100. Lorsque cela se produit, le programme progresse pour attendre un nombre aléatoire de secondes entre 20 et 300. À la fin de cette attente, le haut-parleur joue une note. Le programme revient ensuite au début de la boucle infinie. Il en résulte un comportement similaire à celui d'un criquet la nuit, de sorte qu'il est impossible de le trouver.",
	"HELP_TEXT_CONTROL_REPEAT_TITLE" : "Répéter",
	"HELP_TEXT_CONTROL_REPEAT_BODY_1" : "Le bloc répéter est un type de boucle qui ne boucle qu'un nombre défini de fois. Tous les blocs à l'intérieur du bloc de répétition ne s'exécutent que pendant ce nombre de fois.",
	"HELP_TEXT_CONTROL_REPEAT_BODY_2" : "Le bloc de répétition n'a qu'un seul paramètre :",
	"HELP_TEXT_CONTROL_REPEAT_BODY_3" : "Valeur - Elle peut être une constante (tapée dans l'entrée et ne varie pas), une variable, une détection ou un bloc opérateur.",
	"HELP_TEXT_CONTROL_REPEAT_EXAMPLE_1_TITLE" : "Exemple de programme 1 : Conduire dans un carré",
	"HELP_TEXT_CONTROL_REPEAT_EXAMPLE_1_BODY" : "Dans cet exemple, le programme commence par entrer dans un bloc de répétition qui est réglé pour se répéter quatre fois. À l'intérieur du bloc de répétition, le robot avance de 10 cm, puis tourne à droite de 90 degrés. Ces deux blocs à l'intérieur du bloc de répétition s'exécutent quatre fois. Le résultat est que le robot Edison se déplace en forme de carré.",
	"HELP_TEXT_CONTROL_FOREVER_TITLE" : "Le bloc Forever",
	"HELP_TEXT_CONTROL_FOREVER_BODY_1" : "Le bloc forever est un type de bloc de boucle qui boucle inconditionnellement pour toujours (à moins que le programme ne soit arrêté). Les blocs placés à l'intérieur du bloc forever s'exécutent, puis s'exécutent encore et encore et....",
	"HELP_TEXT_CONTROL_FOREVER_EXAMPLE_1_TITLE" : "Exemple de programme : Faire clignoter une DEL",
	"HELP_TEXT_CONTROL_FOREVER_EXAMPLE_1_BODY" : "Dans cet exemple, le programme commence par entrer dans une boucle infinie. À l'intérieur de la boucle éternelle, la DEL gauche est allumée, puis le bloc d'attente met le programme en pause pendant 0,25 seconde, puis la DEL gauche est éteinte, puis le bloc d'attente met le programme en pause pendant 0,25 seconde. Le programme revient ensuite au bloc d'allumage de la DEL de gauche et la séquence se répète indéfiniment.",
	"HELP_TEXT_CONTROL_IF_TITLE" : "Si alors",
	"HELP_TEXT_CONTROL_IF_BODY_1" : "Le bloc if then exécute les blocs si la condition d'entrée est vraie. Si la condition n'est pas vraie, le programme passe au bloc suivant.",
	"HELP_TEXT_CONTROL_IF_BODY_2" : "Ce bloc a un paramètre d'entrée :",
	"HELP_TEXT_CONTROL_IF_BODY_3" : "Entrée conditionnelle - L'entrée conditionnelle accepte des blocs en forme de losange qui peuvent être soit un bloc opérateur, soit un bloc de détection.",
	"HELP_TEXT_CONTROL_IF_BODY_4" : "Le bloc if then est généralement utilisé à l'intérieur d'une boucle sans fin, de sorte que la condition if then puisse être testée plusieurs fois. Si un programme ne comporte qu'un bloc if then, le test sera exécuté une seule fois et le programme se terminera.",
	"HELP_TEXT_CONTROL_IF_EXAMPLE_1_TITLE" : "Exemple de programme 1 : faire clignoter la DEL en cas d'applaudissements",
	"HELP_TEXT_CONTROL_IF_EXAMPLE_1_BODY" : "Dans cet exemple, le programme commence par entrer dans une boucle infinie. Le premier bloc de cette boucle est le bloc if then qui teste s'il y a eu un applaudissement. S'il est faux, le contenu du bloc if then est ignoré et le programme revient au début de la boucle infinie. Si un clap a été détecté (vrai), les blocs à l'intérieur du bloc if then sont exécutés. D'abord, le voyant gauche est allumé, puis le programme fait une pause d'une seconde, puis le voyant gauche est éteint. Le programme revient alors au début de la boucle infinie. Le résultat est que le robot Edison fait clignoter sa DEL gauche pendant une seconde chaque fois qu'il détecte un applaudissement.",
	"HELP_TEXT_CONTROL_IF_EXAMPLE_2_TITLE" : "Exemple de programme 2 : dessiner une alarme ouverte",
	"HELP_TEXT_CONTROL_IF_EXAMPLE_2_BODY" : "Dans cet exemple, le programme commence par entrer dans une boucle infinie. Le premier bloc de la boucle forever est le bloc if then qui teste si le niveau de lumière sur le capteur de lumière gauche est supérieur à 100. Si c'est le cas (le niveau de lumière est supérieur à 100), le bloc beep s'exécute et le robot Edison émet un bip comme une alarme. Si ce n'est pas le cas (le niveau de lumière est inférieur à 100), le bloc de bip est ignoré et le programme revient au début de la boucle infinie. Le résultat est que l'Edison émet un bip rapide chaque fois qu'il détecte un niveau de lumière supérieur à 100.",
	"HELP_TEXT_CONTROL_IF_ELSE_TITLE" : "Si puis autrement",
	"HELP_TEXT_CONTROL_IF_ELSE_BODY_1" : "Le bloc if then else exécute la première série de blocs si la condition d'entrée est vraie. Si la condition est fausse, la deuxième série de blocs s'exécute.",
	"HELP_TEXT_CONTROL_IF_ELSE_BODY_2" : "Ce bloc a un paramètre d'entrée :",
	"HELP_TEXT_CONTROL_IF_ELSE_BODY_3" : "Entrée conditionnelle - L'entrée conditionnelle accepte des blocs en forme de losange qui peuvent être soit un bloc opérateur, soit un bloc de détection.",
	"HELP_TEXT_CONTROL_IF_ELSE_BODY_4" : "Le bloc if then else est généralement utilisé à l'intérieur d'une boucle infinie, de sorte que la condition if then else puisse être testée plusieurs fois. Si un programme ne comporte qu'un bloc if then else, le test sera exécuté une seule fois et le programme se terminera.",
	"HELP_TEXT_CONTROL_IF_ELSE_EXAMPLE_1_TITLE" : "Exemple de programme 1 : Rebondir dans les frontières",
	"HELP_TEXT_CONTROL_IF_ELSE_EXAMPLE_1_BODY" : "Dans cet exemple, le programme commence par allumer le voyant du capteur de suivi de ligne, puis entre dans une boucle infinie. Le premier bloc de la boucle infinie est le bloc if then else qui teste si le capteur du traceur de ligne se trouve sur une surface non réfléchissante (noire). Si c'est le cas, la première série de blocs s'exécute en faisant reculer le robot, puis en le faisant tourner de 90 degrés. Le programme saute par-dessus le bloc else et revient en arrière pour tester à nouveau si le capteur du traceur de ligne se trouve sur une surface non réfléchissante (noire), si c'est faux (sur le blanc), le bloc else s'exécute, ce qui fait avancer les deux moteurs. Le robot Edison ''rebondit'' alors sur une ligne noire et fait demi-tour. Edison s'éloigne ainsi des lignes noires détectées.",
	"HELP_TEXT_CONTROL_IF_ELSE_EXAMPLE_2_TITLE" : "Exemple de programme 2 : Suivre la lumière",
	"HELP_TEXT_CONTROL_IF_ELSE_EXAMPLE_2_BODY" : "Dans cet exemple, le programme commence par entrer dans une boucle infinie. Le premier bloc de cette boucle est le bloc if then else qui teste si le niveau de lumière sur le capteur de droite est inférieur au niveau de lumière sur le capteur de gauche. Si le résultat est vrai (la lumière est plus forte à gauche), le bloc suivant à exécuter est le réglage des deux moteurs pour que le robot tourne à gauche (le robot tourne à gauche vers la lumière). Sinon, si le résultat est faux (la lumière est plus brillante à droite), le bloc suivant à exécuter est le bloc else. Maintenant, le bloc set both motors to turn robot right run (le robot se tourne vers la lumière). Le résultat est que le robot Edison se dirige vers la source de lumière la plus brillante (essaie d'utiliser une lampe de poche pour contrôler l'endroit où Edison se déplace).",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_TITLE" : "Attendre jusqu'à",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_BODY_1" : "Le bloc attendre jusqu'à met le programme en pause jusqu'à ce que la condition d'entrée soit vraie.",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_BODY_2" : "Ce bloc a un paramètre d'entrée :",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_BODY_3" : "Entrée conditionnelle - L'entrée conditionnelle accepte des blocs en forme de losange qui peuvent être soit un bloc opérateur, soit un bloc de détection.",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_BODY_4" : "Ce bloc est généralement utilisé à l'intérieur d'une boucle infinie, de sorte que la condition d'attente puisse être testée plusieurs fois. Si un programme n'a qu'un bloc attendre jusqu'à, le test sera exécuté une fois et le programme se terminera.",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_EXAMPLE_1_TITLE" : "Exemple de programme 1 : faire clignoter la DEL en cas d'applaudissements",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_EXAMPLE_1_BODY" : "Dans cet exemple, le programme commence en entrant dans une boucle forever. Le premier bloc de la boucle éternelle est le bloc d'effacement des données du capteur qui efface toutes les données de claquement erronées. Vient ensuite le bloc ''attendre jusqu'à'' avec un bloc d'entrée conditionnelle ''clap détecté''. Le programme se met en pause ici et attend qu'un clap soit détecté. Lorsqu'un clap est détecté, le programme progresse pour allumer le voyant gauche, puis attendre une seconde, puis éteindre le voyant gauche. Le programme revient maintenant en boucle au bloc ''attendre jusqu'à''. À chaque fois qu'il y a un applaudissement, le voyant gauche s'allume pendant une seconde. Le résultat est que le robot Edison fait clignoter sa DEL gauche pendant une seconde chaque fois qu'il détecte un battement de mains.",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_EXAMPLE_2_TITLE" : "Exemple de programme 2 : Détecteur de la source de lumière la plus brillante",
	"HELP_TEXT_CONTROL_WAIT_UNTIL_EXAMPLE_2_BODY" : "Dans cet exemple, le programme commence en entrant dans une boucle éternelle. Le premier bloc de la boucle forever est le bloc wait until avec une entrée conditionnelle utilisant un opérateur exigeant que le niveau de lumière sur le capteur de lumière droit soit égal au niveau de lumière sur le capteur de lumière gauche. Si la condition n'est pas vraie (les niveaux de lumière ne sont pas égaux), le programme s'arrête ici. Lorsque le niveau d'éclairage des deux capteurs de lumière est égal, le programme passe au bloc de signal sonore. Le programme revient alors en boucle au bloc attendre jusqu'à et le programme se répète. Le robot Edison émet donc un signal sonore lorsqu'il est dirigé vers la source de lumière la plus brillante",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_TITLE" : "Répéter jusqu'à",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_BODY_1" : "Le bloc répéter jusqu'à exécute les blocs qu'il contient jusqu'à ce que la condition d'entrée soit vraie.",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_BODY_2" : "Ce bloc a un paramètre d'entrée :",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_BODY_3" : "Entrée conditionnelle - L'entrée conditionnelle accepte des blocs en forme de losange qui peuvent être soit un bloc opérateur, soit un bloc de détection.",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_BODY_4" : "Le bloc répéter jusqu'à est souvent utilisé à l'intérieur d'une boucle infinie, de sorte que la condition répéter jusqu'à peut être testée plusieurs fois. Si un programme ne comporte qu'un bloc répéter jusqu'à, le test sera exécuté une fois et le programme se terminera.",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_EXAMPLE_1_TITLE" : "Exemple de programme 1 : Empêcher l'alarme de se déclencher",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_EXAMPLE_1_BODY" : "Dans cet exemple, le programme commence par activer le détecteur d'obstacles (ce qui déclenche l'alarme), puis entre dans une boucle infinie. Le premier bloc de la boucle éternelle est un bloc d'attente avec une entrée conditionnelle d'obstacle détecté n'importe où (le détecteur d'intrus). Le programme se met en pause et attend ici jusqu'à ce qu'un obstacle (intrus) soit détecté. Lorsqu'un obstacle est détecté, le programme passe au bloc répéter jusqu'à, ce qui entraîne l'exécution et la répétition du bloc bip (le son de l'alarme), ''jusqu'à'' ce que le bouton rond soit pressé (arrêt et réinitialisation de l'alarme).",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_EXAMPLE_2_TITLE" : "Exemple de programme 2 : Edison frissonne de froid sans lumière chaude",
	"HELP_TEXT_CONTROL_REPEAT_UNTIL_EXAMPLE_2_BODY" : "Dans cet exemple, le programme commence par entrer dans une boucle infinie. Le premier bloc de la boucle éternelle est le bloc répéter jusqu'à avec une entrée conditionnelle utilisant un opérateur exigeant que le niveau de lumière du capteur de lumière gauche soit supérieur à 980 (très lumineux/lumière du soleil). Si ce n'est pas le cas, les blocs ci-dessous s'exécutent, faisant rapidement tourner le robot Edison de gauche à droite (il tremble). Si le niveau de luminosité du capteur de lumière gauche dépasse 980 (Edison se déplace vers une lumière très vive), la condition devient vraie et le programme s'arrête (le robot Edison est chaud et heureux).",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_TITLE" : "Attendre les millisecondes",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_BODY_1" : "Le bloc d'attente en millisecondes met le programme en pause pendant un certain temps en millisecondes (ms). Une milliseconde correspond à un millième (1/1000) de seconde ou 0,001 seconde.",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_BODY_2" : "1500 millisecondes = 1,5 seconde",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_BODY_3" : "100 millisecondes = 0,1 seconde",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_BODY_4" : "25 millisecondes = 0,025 seconde",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_BODY_5" : "Le bloc wait milliseconds n'a qu'un seul paramètre :",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_BODY_6" : "Valeur - Peut être une variable, une détection ou un bloc opérateur.",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_EXAMPLE_1_TITLE" : "Exemple de programme 1 : clignotement rapide d'une LED",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_EXAMPLE_1_BODY" : "Dans cet exemple, le programme commence par fixer la variable 'Delay' à 50, puis entre dans une boucle infinie. À l'intérieur de la boucle infinie, la DEL gauche est allumée, puis le bloc wait milliseconds fait une pause pour la valeur en millisecondes de 'Delay', dans ce cas 50 millisecondes. Ensuite, le voyant gauche est éteint, puis le bloc wait milliseconds fait une pause de 50 millisecondes. Le programme revient maintenant en boucle au début de la boucle forever.",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_EXAMPLE_2_TITLE" : "Exemple de programme 2 : lumières folles",
	"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_EXAMPLE_2_BODY" : "Dans cet exemple, le programme commence par entrer dans une boucle infinie. À l'intérieur de cette boucle, les DEL de gauche et de droite sont allumées et éteintes. Les temps d'attente entre l'allumage et l'extinction sont contrôlés par les blocs wait milliseconds. Le temps en millisecondes est défini par les blocs de nombres aléatoires qui se trouvent à l'intérieur. Ceux-ci sont réglés pour générer des nombres aléatoires entre 30 et 300 millisecondes. Le résultat est un clignotement aléatoire des diodes électroluminescentes du robot Edison.",
	"HELP_TEXT_SENSING_TURNLINETRACKINGLED_TITLE" : "Activation/désactivation de la DEL de suivi de ligne de virage",
	"HELP_TEXT_SENSING_TURNLINETRACKINGLED_BODY_1" : "Le bloc d'activation/désactivation de la DEL de suivi de ligne permet d'activer ou de désactiver la DEL de suivi de ligne.",
	"HELP_TEXT_SENSING_TURNLINETRACKINGLED_BODY_2" : "La DEL de suivi de ligne doit être allumée pour que le capteur de suivi de ligne fonctionne.",
	"HELP_TEXT_SENSING_TURNLINETRACKINGLED_EXAMPLE_1_TITLE" : "Exemple de programme : Arrêt sur une surface noire",
	"HELP_TEXT_SENSING_TURNLINETRACKINGLED_EXAMPLE_1_BODY" : "Dans cet exemple, le programme commence par allumer la DEL de suivi de ligne, puis les deux moteurs sont réglés pour avancer. Le programme attend ensuite que le capteur de suivi de ligne détecte une surface non réfléchissante (noire), lorsque cela se produit, le programme se termine et les moteurs s'arrêtent.",
	"HELP_TEXT_SENSING_TURNOBSTACLEBEAM_TITLE" : "Activation/désactivation du faisceau de détection d'obstacles",
	"HELP_TEXT_SENSING_TURNOBSTACLEBEAM_BODY_1" : "Le bloc activer/désactiver le faisceau de détection d'obstacle permet d'activer ou de désactiver le faisceau de détection d'obstacle.",
	"HELP_TEXT_SENSING_TURNOBSTACLEBEAM_BODY_2" : "Le faisceau de détection d'obstacle doit être allumé pour que la détection d'obstacle fonctionne.",
	"HELP_TEXT_SENSING_TURNOBSTACLEBEAM_EXAMPLE_1_TITLE" : "Exemple de programme : S'arrêter pour un obstacle",
	"HELP_TEXT_SENSING_TURNOBSTACLEBEAM_EXAMPLE_1_BODY" : "Dans cet exemple, le programme commence par activer le faisceau de détection d'obstacle, puis les deux moteurs sont réglés pour avancer. Le programme attend ensuite qu'un obstacle soit détecté n'importe où, lorsque cela se produit, le programme se termine et les moteurs s'arrêtent.",
	"HELP_TEXT_SENSING_CLEARSENSOR_TITLE" : "Effacer les données du capteur",
	"HELP_TEXT_SENSING_CLEARSENSOR_BODY_1" : "Le bloc d'effacement des données du capteur efface toutes les données du capteur (détections) du capteur sélectionné. Ce bloc est utilisé lorsqu'il peut y avoir des détections fausses ou indésirables qui empêchent le programme de fonctionner comme tu le souhaites. Un exemple est celui d'un programme qui conduit le robot Edison suite à la détection d'un applaudissement. En général, la conduite est assez bruyante et peut redéclencher une détection supplémentaire d'un clap. Le programme détecte alors un deuxième battement de mains qui n'a pas eu lieu. Le bloc d'effacement des données du capteur est utilisé pour effacer les données du capteur de toute détection indésirable de ce type.",
	"HELP_TEXT_SENSING_CLEARSENSOR_BODY_2" : "Le bloc d'effacement des données du capteur a cinq options d'entrée :",
	"HELP_TEXT_SENSING_CLEARSENSOR_BODY_3" : "détecteur de claquement",
	"HELP_TEXT_SENSING_CLEARSENSOR_BODY_4" : "clavier",
	"HELP_TEXT_SENSING_CLEARSENSOR_BODY_5" : "détecteur d'obstacles",
	"HELP_TEXT_SENSING_CLEARSENSOR_BODY_6" : "code à distance",
	"HELP_TEXT_SENSING_CLEARSENSOR_BODY_7" : "message IR",
	"HELP_TEXT_SENSING_CLEARSENSOR_EXAMPLE_1_TITLE" : "Exemple de programme 1 : Frapper des mains et tourner",
	"HELP_TEXT_SENSING_CLEARSENSOR_EXAMPLE_1_BODY" : "Dans cet exemple, le programme commence par entrer dans une boucle infinie. À l'intérieur de cette boucle, le bloc d'effacement des données du capteur est configuré pour effacer le détecteur de claquement, puis le programme attend qu'un claquement soit détecté, lorsque cela se produit, le programme progresse et le robot tourne vers la gauche pendant deux secondes. Pendant la rotation, les moteurs, les roues et le patin font du bruit, ce bruit redéclenche le détecteur de claquement, de sorte que le détecteur de claquement pense maintenant qu'il y a eu un deuxième claquement. Le programme revient au début de la boucle infinie (en conservant la détection du clap), mais le bloc d'effacement des données du capteur efface la détection et le bloc d'attente ne sera pas déclenché tant qu'il n'y aura pas de clap.",
	"HELP_TEXT_SENSING_CLAPDETECTED_TITLE" : "Clap détecté",
	"HELP_TEXT_SENSING_CLAPDETECTED_BODY_1" : "Le bloc de détection de claquement est un bloc d'entrée de capteur qui indique si un claquement a été détecté ou non. Il s'agit d'un bloc en forme de diamant dont les données ne peuvent être que vraies (le clap a été détecté) ou fausses (le clap n'a pas été détecté).",
	"HELP_TEXT_SENSING_CLAPDETECTED_BODY_2" : "D'autres bruits, tels que l'entraînement des moteurs, peuvent provoquer un faux déclenchement du bloc de détection de clap. Utilise le bloc d'effacement des données du capteur pour effacer les détections de clap fausses ou indésirables.",
	"HELP_TEXT_SENSING_CLAPDETECTED_EXAMPLE_1_TITLE" : "Exemple de programme 1 : faire clignoter la DEL en cas d'applaudissements",
	"HELP_TEXT_SENSING_CLAPDETECTED_EXAMPLE_1_BODY" : "Dans cet exemple, le programme commence par entrer dans une boucle infinie. À l'intérieur de cette boucle, il y a un bloc if then qui teste si un clap a été détecté. Lorsqu'un clap est détecté, le voyant gauche s'allume, le programme attend une seconde, puis le voyant gauche s'éteint. Le programme revient ensuite au début de la boucle infinie. Le résultat est que le robot Edison fait clignoter sa DEL gauche pendant une seconde chaque fois qu'il détecte un applaudissement.",
	"HELP_TEXT_SENSING_BUTTONPRESSED_TITLE" : "Bouton enfoncé",
	"HELP_TEXT_SENSING_BUTTONPRESSED_BODY_1" : "Le bloc bouton enfoncé est une entrée de capteur qui indique si un bouton a été enfoncé ou non. Il existe deux options de bouton :",
	"HELP_TEXT_SENSING_BUTTONPRESSED_BODY_2" : "rond",
	"HELP_TEXT_SENSING_BUTTONPRESSED_BODY_3" : "triangle",
	"HELP_TEXT_SENSING_BUTTONPRESSED_BODY_4" : "Le bloc bouton enfoncé est un bloc en forme de diamant, de sorte que les données du bloc ne peuvent être que vraies (le bouton a été enfoncé) ou fausses (le bouton n'a pas été enfoncé).",
	"HELP_TEXT_SENSING_BUTTONPRESSED_EXAMPLE_1_TITLE" : "Exemple de programme : Bip lors de l'appui sur un bouton",
	"HELP_TEXT_SENSING_BUTTONPRESSED_EXAMPLE_1_BODY" : "Dans cet exemple, le programme commence par entrer dans une boucle infinie. À l'intérieur de cette boucle, il y a un bloc if then qui teste si le bouton rond a été enfoncé. Lorsque le bouton rond est enfoncé, le programme exécute le bloc de bip et revient ensuite au début de la boucle forever.",
	"HELP_TEXT_SENSING_OBSTACLE_TITLE" : "Obstacle détecté",
	"HELP_TEXT_SENSING_OBSTACLE_BODY_1" : "Le bloc de détection d'obstacle est un bloc d'entrée de capteur qui indique si un obstacle a été détecté ou non. Il existe quatre options de détection :",
	"HELP_TEXT_SENSING_OBSTACLE_BODY_2" : "n'importe où",
	"HELP_TEXT_SENSING_OBSTACLE_BODY_3" : "devant",
	"HELP_TEXT_SENSING_OBSTACLE_BODY_4" : "à gauche",
	"HELP_TEXT_SENSING_OBSTACLE_BODY_5" : "à droite",
	"HELP_TEXT_SENSING_OBSTACLE_BODY_6" : "Le bloc de détection d'obstacle est un bloc en forme de diamant, de sorte que les données qu'il contient ne peuvent être que vraies (l'obstacle a été détecté) ou fausses (l'obstacle n'a pas été détecté).",
	"HELP_TEXT_SENSING_OBSTACLE_BODY_7" : "Pour utiliser le bloc de détection d'obstacle, il faut utiliser le bloc d'activation/désactivation du faisceau de détection d'obstacle.",
	"HELP_TEXT_SENSING_OBSTACLE_EXAMPLE_1_TITLE" : "Exemple de programme : Éviter les obstacles",
	"HELP_TEXT_SENSING_OBSTACLE_EXAMPLE_1_BODY" : "Dans cet exemple, le programme commence par activer le faisceau de détection d'obstacles, puis entre dans une boucle infinie. À l'intérieur de cette boucle, les moteurs sont réglés pour avancer tous les deux, puis il y a un bloc if then qui teste si un obstacle a été détecté quelque part. Si c'est le cas, le robot tourne de 180 degrés et revient au début de la boucle infinie. Au début de la boucle éternelle, les deux moteurs sont à nouveau réglés pour avancer. Edison s'éloigne ainsi des obstacles qui se trouvent sur son chemin.",
	"HELP_TEXT_SENSING_LINETRACKER_TITLE" : "Traceur de ligne en surface",
	"HELP_TEXT_SENSING_LINETRACKER_BODY_1" : "Le bloc de suivi de ligne sur la surface est un bloc d'entrée de capteur qui indique si la surface est réfléchissante ou non. Une surface réfléchissante est une surface qui renvoie la lumière de la DEL du traceur de ligne vers le capteur de lumière. Il s'agit généralement d'une surface blanche, mais une surface rouge réfléchira également la lumière rouge de la DEL rouge du traceur de ligne. Une surface non réfléchissante est une surface qui ne réfléchit pas la lumière de la DEL du traceur de ligne vers le capteur de lumière. Il s'agit généralement d'une surface noire, mais une surface bleue ou verte ne réfléchira pas non plus la lumière rouge de la DEL rouge du traceur de ligne.",
	"HELP_TEXT_SENSING_LINETRACKER_BODY_2" : "Il existe deux options de détection :",
	"HELP_TEXT_SENSING_LINETRACKER_BODY_3" : "réfléchissante (blanche)",
	"HELP_TEXT_SENSING_LINETRACKER_BODY_4" : "non réfléchissante (noire)",
	"HELP_TEXT_SENSING_LINETRACKER_BODY_5" : "Le bloc de suivi de ligne sur surface est un bloc en forme de diamant, de sorte que les données qu'il contient ne peuvent être que vraies (le type de surface a été détecté) ou fausses (le type de surface n'a pas été détecté).",
	"HELP_TEXT_SENSING_LINETRACKER_BODY_6" : "Pour utiliser le bloc de suivi de ligne en surface, il faut utiliser le bloc d'activation/désactivation de la DEL de suivi de ligne pour activer la DEL de suivi de ligne.",
	"HELP_TEXT_SENSING_LINETRACKER_EXAMPLE_1_TITLE" : "Exemple de programme : Rebondir dans les bordures",
	"HELP_TEXT_SENSING_LINETRACKER_EXAMPLE_1_BODY" : "Dans cet exemple, le programme commence par allumer la DEL de suivi de ligne, puis entre dans une boucle infinie. À l'intérieur de cette boucle, les moteurs sont réglés pour avancer tous les deux, puis il y a un bloc if then qui teste si la surface n'est pas réfléchissante. Si c'est le cas, le robot tourne de 180 degrés et revient au début de la boucle infinie. Au début de la boucle infinie, les deux moteurs sont à nouveau réglés pour avancer. Edison s'éloigne ainsi des lignes noires détectées.",
	"HELP_TEXT_SENSING_REMOTE_BOOL_TITLE" : "Code à distance reçu",
	"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_1" : "Le bloc de réception du code à distance est un bloc d'entrée de capteur qui indique si un code de télécommande particulier a été reçu ou non.",
	"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_2" : "Il existe huit options de code de télécommande, de 0 à 7.",
	"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_3" : "Le bloc de réception du code à distance est un bloc en forme de diamant, de sorte que les données qu'il contient ne peuvent être que vraies (le code a été reçu) ou fausses (le code n'a pas été reçu).",
	"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_4" : "Assure-toi d'appuyer sur le bouton triangle pour démarrer ton programme. Il est facile de l'oublier car le robot Edison réagira comme un robot télécommandé et ne fera pas ce pour quoi tu l'as programmé.",
	"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_5" : "Pour utiliser le bloc de réception du code de la télécommande, il faut d'abord apprendre au robot Edison quels boutons de ta télécommande correspondent à quel code de la télécommande. Tu trouveras plus d'informations à ce sujet ici :",
	"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_6" : "Si le programme se comporte de manière inattendue, tu devras peut-être utiliser le bloc clear sensor data pour effacer le contenu du bloc remote code received. Voir l'exemple du programme 1 ci-dessous.",
	"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_7" : "Le bloc de réception du code de la télécommande fonctionnera avec environ 90 % des télécommandes infrarouges (IR) standard des téléviseurs, mais chaque marque de téléviseur utilise des formats de données IR légèrement différents. Lorsqu'Edison décode les données IR, ces différences peuvent entraîner des comportements inattendus d'une marque de télécommande à l'autre. Le décodage avancé des télécommandes fonctionne mieux avec l'EdRemote (disponible mi 2025).",
	"HELP_TEXT_SENSING_REMOTE_BOOL_EXAMPLE_1_TITLE" : "Exemple de programme 1 : un bip ou deux ?",
	"HELP_TEXT_SENSING_REMOTE_BOOL_EXAMPLE_1_BODY" : "Dans cet exemple, le programme commence en entrant dans une boucle forever. À l'intérieur de la boucle forever, il y a deux blocs if then qui testent le code de la télécommande reçu. Le premier bloc if then teste si le code à distance reçu est le code à distance 1. Si c'est le cas, le bloc de signal sonore joue une fois et les données du capteur sont ensuite effacées. S'il est faux, le programme passe au bloc if then suivant et teste si le code à distance reçu est le code à distance 2. Si c'est le cas, le signal sonore retentit deux fois et les données du capteur sont effacées. Le programme revient ensuite au début de la boucle infinie.",
	"HELP_TEXT_SENSING_REMOTE_BOOL_EXAMPLE_2_TITLE" : "Exemple de programme 2 : rotation sur commande de la télécommande (fonctionne mieux avec l'EdRemote).",
	"HELP_TEXT_SENSING_REMOTE_BOOL_EXAMPLE_2_BODY" : "Dans cet exemple, le programme commence par entrer dans une boucle infinie. À l'intérieur de cette boucle, le bloc if then teste si le code 0 de la télécommande a été reçu. Si c'est le cas, les deux moteurs sont réglés pour faire tourner le robot à droite. Cette opération se poursuit jusqu'à ce que la condition du bloc wait until (attendre jusqu'à ce que) soit remplie. Pour réussir, le code à distance reçu ne doit pas être le code à distance 0 (le bouton de la télécommande n'est plus enfoncé). Lorsque cela se produit, le programme progresse pour arrêter les deux moteurs, puis boucle jusqu'au début de la boucle éternelle. Il en résulte qu'Edison tourne pendant que le bouton de la télécommande est maintenu enfoncé.",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_TITLE" : "message IR détecté",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_BODY_1" : "Le bloc de détection de message IR est une entrée de capteur qui indique si un message IR a été détecté (reçu) depuis un autre robot Edison. Le terme ''IR'' est l'abréviation de ''infrarouge''. L'infrarouge fait référence à une bande de lumière qui n'est pas visible pour les humains. C'est pourquoi il est utile pour communiquer des données sur de courtes distances.",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_BODY_2" : "Le bloc de détection du message IR est un bloc en forme de diamant, de sorte que les données qu'il contient ne peuvent être que vraies (le message IR a été reçu) ou fausses (le message IR n'a pas été reçu).",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_BODY_4" : "Le bloc de détection du message IR ne connaît pas le contenu du message IR qui a été reçu. Il indique seulement au programme si un message IR a été reçu. Pour lire les données du message IR, utilise le bloc du message IR reçu. Voir l'exemple de programme.",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_BODY_5" : "La messagerie infrarouge entre les robots Edison fonctionne mieux à l'intérieur, à l'abri de la lumière directe du soleil. La portée typique peut atteindre 10 mètres (30 pieds).",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_EXAMPLE_1_TITLE" : "Exemple de programme : Allumer et éteindre la lumière à distance Edison",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_EXAMPLE_1_BODY" : "Dans cet exemple, le programme commence en entrant dans une boucle forever. À l'intérieur de cette boucle, le premier bloc if then teste si un message IR a été reçu. Si c'est le cas, la variable 'IRMessage' est mise à la valeur du bloc de message IR reçu. Cela permet au message reçu d'être lu/testé plusieurs fois sans être effacé ou perdu. L'instruction suivante if then teste si les données de 'IRMessage' sont égales à 1. Si c'est le cas, la DEL de gauche s'allume. Si ce n'est pas le cas, le programme passe au bloc if then suivant. Ce bloc if then teste si les données de 'IR Message' sont égales à 2, si c'est le cas, le voyant gauche est éteint. Le programme revient ensuite au début de la boucle infinie.",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_EXAMPLE_2_TITLE" : "Le robot Edison qui envoie des messages IR exécute ce programme.",
	"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_EXAMPLE_2_BODY" : "En appuyant sur le bouton triangulaire, tu envoies un message IR portant le numéro 1 (allumer la DEL) et en appuyant sur le bouton rond, tu envoies un message IR portant le numéro 2 (éteindre la DEL).",
	"HELP_TEXT_SENSING_DRIVESTRAINED_TITLE" : "Détection de l'allongement de l'entraînement",
	"HELP_TEXT_SENSING_DRIVESTRAINED_BODY_1" : "Le bloc de détection de l'effort d'entraînement est un bloc d'entrée de capteur qui indique si l'une ou les deux roues se sont arrêtées de tourner parce qu'elles sont soumises à un effort d'entraînement (physiquement empêchées de tourner lorsqu'elles essaient de rouler).",
	"HELP_TEXT_SENSING_DRIVESTRAINED_BODY_2" : "Le bloc de détection de l'effort d'entraînement est un bloc en forme de diamant, de sorte que les données qu'il contient ne peuvent être que vraies (la roue est soumise à un effort) ou fausses (la roue n'est pas soumise à un effort).",
	"HELP_TEXT_SENSING_DRIVESTRAINED_EXAMPLE_1_TITLE" : "Exemple de programme : Alarme de roue soumise à une contrainte",
	"HELP_TEXT_SENSING_DRIVESTRAINED_EXAMPLE_1_BODY" : "Dans cet exemple, le programme commence par régler la roue gauche pour qu'elle avance, puis il entre dans une boucle infinie. À l'intérieur de la boucle, il y a un bloc if then qui teste si la roue est soumise à une contrainte. Si c'est le cas, le bloc de signal sonore est exécuté. Ce bloc continuera à fonctionner jusqu'à ce que la contrainte soit éliminée et que la roue puisse tourner.",
	"HELP_TEXT_SENSING_REMOTE_NUM_TITLE" : "Code à distance reçu",
	"HELP_TEXT_SENSING_REMOTE_NUM_BODY_1" : "Le bloc de code à distance reçu est un bloc d'entrée de capteur qui contient des données reçues d'une télécommande. Les données sont des nombres compris entre 0 et 7.",
	"HELP_TEXT_SENSING_REMOTE_NUM_BODY_2" : "Lorsqu'un programme exécute ce bloc, son contenu est effacé. Il est toujours préférable de placer les données du bloc code distant reçu dans une variable avant de les tester avec un bloc conditionnel (if then). Voir l'exemple de programme.",
	"HELP_TEXT_SENSING_REMOTE_NUM_EXAMPLE_1_TITLE" : "Exemple de programme : Commande à distance de l'allumage et de l'extinction de la lumière",
	"HELP_TEXT_SENSING_REMOTE_NUM_EXAMPLE_1_BODY" : "Dans cet exemple, le programme commence par entrer dans une boucle forever. Le premier bloc à l'intérieur de la boucle infinie place les données du bloc de code à distance reçu dans la variable 'Codeàdistance'. La variable 'RemoteCode' peut maintenant être testée. Le premier bloc if then teste si le contenu de 'RemoteCode' est égal à 1. Si c'est le cas, la DEL de gauche est allumée. Si c'est faux, le bloc suivant if then teste si le contenu de 'RemoteCode' est égal à 2. Si c'est vrai, le voyant gauche est éteint. Le programme revient ensuite au début de la boucle infinie.",
	"HELP_TEXT_SENSING_IRMESSAGE_TITLE" : "Message IR reçu",
	"HELP_TEXT_SENSING_IRMESSAGE_BODY_1" : "Le bloc de message IR reçu est un bloc d'entrée de capteur qui contient des données reçues d'un autre robot Edison. Le terme ''IR'' est l'abréviation de ''infrarouge''. L'infrarouge fait référence à une bande de lumière qui n'est pas visible pour les humains. C'est donc un moyen utile pour communiquer des données sur de courtes distances. Les données sont basées sur un nombre binaire de 8 bits et sont comprises entre 0 et 255.",
	"HELP_TEXT_SENSING_IRMESSAGE_BODY_2" : "Lorsqu'un programme exécute ce bloc, son contenu est effacé. Il est toujours préférable de placer les données du code distant reçu dans une variable avant de les tester avec un bloc conditionnel (bloc if then).",
	"HELP_TEXT_SENSING_IRMESSAGE_BODY_3" : "La messagerie infrarouge entre les robots Edison fonctionne mieux à l'intérieur, à l'abri de la lumière directe du soleil. La portée typique peut atteindre 10 mètres (30 pieds).",
	"HELP_TEXT_SENSING_IRMESSAGE_EXAMPLE_1_TITLE" : "Exemple de programme : Commencer une révolution de danse",
	"HELP_TEXT_SENSING_IRMESSAGE_EXAMPLE_1_BODY" : "Dans cet exemple, le programme commence par entrer dans une boucle infinie. Le premier bloc à l'intérieur de la boucle forever efface les données du capteur de messages IR, le programme attend ensuite de recevoir un message IR égal à 3. Lorsque cela se produit, le programme entre dans une boucle repeat pour quatre fois. À l'intérieur de la boucle de répétition se trouvent les manœuvres de danse du robot Edison. Chacun de ces mouvements est basé sur le temps et non sur la distance. C'est très important s'il y a toute une classe de robots Edison qui dansent en synchronisation sur de la musique. Les manœuvres de danse se répètent quatre fois, puis le programme revient au début de la boucle éternelle.",
	"HELP_TEXT_SENSING_IRMESSAGE_EXAMPLE_2_TITLE" : "Exemple de programme : Envoi du message IR 3",
	"HELP_TEXT_SENSING_IRMESSAGE_EXAMPLE_2_BODY" : "Dans cet exemple, le programme commence par entrer dans une boucle infinie. Le premier bloc à l'intérieur de la boucle éternelle attend que le bouton rond soit pressé, lorsque cela se produit, le message numéro 3 est transmis par lumière infrarouge. Le programme revient ensuite au début de la boucle infinie.",
	"HELP_TEXT_SENSING_LIGHTLEVEL_TITLE" : "Niveau de luminosité du capteur",
	"HELP_TEXT_SENSING_LIGHTLEVEL_BODY_1" : "Le bloc niveau de lumière du capteur est un bloc d'entrée de capteur qui contient les données des capteurs de lumière. Le niveau de luminosité est un nombre compris entre 1 et 1000. Les données du bloc niveau de lumière du capteur sont constamment mises à jour.",
	"HELP_TEXT_SENSING_LIGHTLEVEL_BODY_2" : "Tu peux choisir entre trois entrées de capteur de lumière :",
	"HELP_TEXT_SENSING_LIGHTLEVEL_BODY_3" : "- lumière gauche (capteur à l'avant gauche)",
	"HELP_TEXT_SENSING_LIGHTLEVEL_BODY_4" : "- lumière droite (capteur à l'avant du côté droit)",
	"HELP_TEXT_SENSING_LIGHTLEVEL_BODY_5" : "- suivi de ligne (capteur utilisé pour détecter les lignes sous le robot).",
	"HELP_TEXT_SENSING_LIGHTLEVEL_EXAMPLE_1_TITLE" : "Exemple de programme : Veilleuse",
	"HELP_TEXT_SENSING_LIGHTLEVEL_EXAMPLE_1_BODY" : "Dans cet exemple, le programme commence par entrer dans une boucle infinie. Le premier bloc à l'intérieur de la boucle forever teste si la lecture du niveau de lumière sur le capteur de lumière gauche est inférieure à 50. Si c'est le cas, les DEL gauche et droite s'allument. Si c'est faux, le programme passe à else et les DEL gauche et droite s'éteignent. Le programme boucle ensuite jusqu'au début de la boucle infinie et recommence. Ainsi, les DEL d'Edison s'allument alors qu'il se trouve dans une lumière faible.",
	"HELP_TEXT_ADDITION_TITLE" : "Addition",
	"HELP_TEXT_ADDITION_BODY" : "Le bloc d'opérateurs d'addition additionne deux valeurs. Les valeurs peuvent être une constante (tapée dans l'entrée et qui ne varie pas), une variable, un sens ou un bloc opérateur.",
	"HELP_TEXT_ADDITION_EXAMPLE_1_TITLE" : "La valeur constante 2 est ajoutée à la valeur constante 2.",
	"HELP_TEXT_ADDITION_EXAMPLE_2_TITLE" : "La variable 'Compteur' est ajoutée à la valeur constante 2.",
	"HELP_TEXT_ADDITION_EXAMPLE_3_TITLE" : "Le niveau de luminosité de l'entrée capteur est ajouté à la valeur constante 10.",
	"HELP_TEXT_SUBTRACTION_TITLE" : "Soustraction",
	"HELP_TEXT_SUBTRACTION_BODY" : "Le bloc opérateur de soustraction soustrait une valeur d'une autre. Les valeurs peuvent être une constante (tapée dans l'entrée et qui ne varie pas), une variable, une détection ou un bloc opérateur.",
	"HELP_TEXT_SUBTRACTION_EXAMPLE_1_TITLE" : "La valeur constante 10 est soustraite de la valeur constante 200.",
	"HELP_TEXT_SUBTRACTION_EXAMPLE_2_TITLE" : "La valeur constante 100 est soustraite de la variable 'Compteur'.",
	"HELP_TEXT_SUBTRACTION_EXAMPLE_3_TITLE" : "La valeur constante 10 est soustraite de l'entrée capteur niveau de luminosité du capteur.",
	"HELP_TEXT_SUBTRACTION_EXAMPLE_4_TITLE" : "Exemple de programme : Compteur de rayonnement lumineux",
	"HELP_TEXT_SUBTRACTION_EXAMPLE_4_BODY" : "Dans cet exemple de programme, le tempo de la musique est d'abord réglé sur très rapide. Le programme entre ensuite dans une boucle infinie. À l'intérieur de la boucle, le programme règle la variable (Delay) sur 1000 moins le niveau de lumière gauche (en inversant la lecture du niveau de lumière). Le bloc suivant attend la valeur de la variable (Delay). Le programme joue ensuite la note C et revient au début de la boucle infinie, puis recommence. Ainsi, l'Edison émet un bip lent lorsqu'il est dans l'obscurité et un bip plus rapide lorsque le niveau de luminosité est plus élevé.",
	"HELP_TEXT_MULTIPLICATION_TITLE" : "Multiplication",
	"HELP_TEXT_MULTIPLICATION_BODY" : "Le bloc de l'opérateur de multiplication multiplie deux valeurs. Les valeurs peuvent être une constante (saisie dans l'entrée et qui ne varie pas), une variable, une détection ou un bloc opérateur.",
	"HELP_TEXT_MULTIPLICATION_EXAMPLE_1_TITLE" : "La valeur constante 2 est multipliée par la valeur constante 4.",
	"HELP_TEXT_MULTIPLICATION_EXAMPLE_2_TITLE" : "La variable 'Compteur' est multipliée par la valeur constante 2.",
	"HELP_TEXT_MULTIPLICATION_EXAMPLE_3_TITLE" : "Le niveau de luminosité de l'entrée capteur est multiplié par la valeur constante 4.",
	"HELP_TEXT_DIVISION_TITLE" : "Division",
	"HELP_TEXT_DIVISION_BODY_1" : "Le bloc opérateur de division divise une valeur par une autre valeur. Les valeurs peuvent être une constante (tapée dans l'entrée et qui ne varie pas), une variable, un capteur ou un bloc opérateur.",
	"HELP_TEXT_DIVISION_BODY_2" : "Il n'est pas possible de diviser par zéro, Edison fera l'expérience d'une erreur si l'entrée la plus à droite est zéro.",
	"HELP_TEXT_DIVISION_EXAMPLE_1_TITLE" : "La valeur constante 10 est divisée par la valeur constante 2.",
	"HELP_TEXT_DIVISION_EXAMPLE_2_TITLE" : "La variable 'Counter' est divisée par la valeur constante 2.",
	"HELP_TEXT_DIVISION_EXAMPLE_3_TITLE" : "Le niveau de luminosité de l'entrée du capteur est divisé par 10.",
	"HELP_TEXT_DIVISION_EXAMPLE_4_TITLE" : "Exemple de programme : Réglage de la distance d'entraînement à l'aide d'une variable et des données d'un capteur",
	"HELP_TEXT_DIVISION_EXAMPLE_4_BODY" : "Dans cet exemple de programme, l'Edison règle la variable (Distance) sur le niveau de lumière du capteur de lumière gauche (une valeur de 1 à 1 000) divisé par 50. L'Edison avance ensuite pour la valeur de la variable (Distance) à la vitesse 5. L'Edison roule ainsi plus loin en cas de forte luminosité, jusqu'à une distance maximale de 20 cm.",
	"HELP_TEXT_RANDOM_NUMBER_TITLE" : "Nombre aléatoire",
	"HELP_TEXT_RANDOM_NUMBER_BODY" : "Le bloc nombre aléatoire entre génère un nombre aléatoire entre deux valeurs. Les valeurs peuvent être une constante (tapée dans l'entrée et qui ne varie pas), une variable, une détection ou un bloc opérateur.",
	"HELP_TEXT_RANDOM_NUMBER_EXAMPLE_1_TITLE" : "Génère un nombre aléatoire entre la valeur constante 10 et la valeur constante 100.",
	"HELP_TEXT_RANDOM_NUMBER_EXAMPLE_2_TITLE" : "Génère un nombre aléatoire entre la variable 'Compteur' et la valeur constante 5000.",
	"HELP_TEXT_RANDOM_NUMBER_EXAMPLE_3_TITLE" : "Génère un nombre aléatoire entre la valeur constante 10 et le niveau de luminosité du capteur.",
	"HELP_TEXT_RANDOM_NUMBER_EXAMPLE_4_TITLE" : "Exemple de programme : Lumières folles",
	"HELP_TEXT_RANDOM_NUMBER_EXAMPLE_4_BODY" : "Dans cet exemple, le programme commence par entrer dans une boucle infinie. À l'intérieur de cette boucle, les DEL gauche et droite sont allumées et éteintes. Les temps d'attente entre l'allumage et l'extinction sont contrôlés par les blocs wait milliseconds. Le temps en millisecondes est défini par les blocs de nombres aléatoires qui se trouvent à l'intérieur. Ceux-ci sont réglés pour générer des nombres aléatoires entre 30 et 300 millisecondes. Le résultat est un clignotement fou et incohérent des lumières LED du robot Edison.",
	"HELP_TEXT_ABS_VAL_TITLE" : "abs",
	"HELP_TEXT_ABS_VAL_BODY" : "Le bloc abs (valeur absolue) convertit une valeur en valeur absolue. Une valeur absolue est une valeur qui est toujours positive. La valeur peut être une constante (tapée en entrée et qui ne varie pas), une variable, une détection ou un bloc opérateur.",
	"HELP_TEXT_ABS_VAL_EXAMPLE_1_BODY" : "A un résultat de la valeur 3.",
	"HELP_TEXT_ABS_VAL_EXAMPLE_2_BODY" : "A un résultat de la valeur 3.",
	"HELP_TEXT_ABS_VAL_EXAMPLE_3_TITLE" : "Exemple de programme : signaler la différence entre les niveaux de luminosité",
	"HELP_TEXT_ABS_VAL_EXAMPLE_3_BODY" : "Dans cet exemple, le programme commence par entrer dans une boucle forever. Le premier bloc de la boucle forever définit la variable 'Différence' à la valeur absolue du niveau de lumière du capteur de lumière droit moins le niveau de lumière du capteur de lumière gauche. Le bloc abs garantit que le résultat est toujours positif (pas de nombres négatifs). Le programme attend ensuite une seconde, puis envoie la valeur de la variable ''Différence'' par USB. Cette valeur est toujours une valeur positive (absolue).",
	"HELP_TEXT_LESS_THAN_TITLE" : "Moins que",
	"HELP_TEXT_LESS_THAN_BODY_1" : "Le bloc moins que compare deux valeurs d'entrée pour déterminer si la première valeur est inférieure à la seconde et renvoie un résultat qui est soit vrai, soit faux. Les valeurs peuvent être une constante (saisie dans l'entrée et qui ne varie pas), une variable, un sens ou un bloc opérateur.",
	"HELP_TEXT_LESS_THAN_BODY_2" : "Le bloc moins que est un bloc en forme de diamant, de sorte que le résultat du bloc ne peut être que vrai ou faux.",
	"HELP_TEXT_LESS_THAN_EXAMPLE_1_BODY" : "Résultat : vrai",
	"HELP_TEXT_LESS_THAN_EXAMPLE_2_BODY" : "Résultat : faux",
	"HELP_TEXT_LESS_THAN_EXAMPLE_3_TITLE" : "La variable 'Compteur' est-elle inférieure à la valeur constante 120.",
	"HELP_TEXT_LESS_THAN_EXAMPLE_4_TITLE" : "Le niveau de luminosité du capteur de gauche est-il inférieur à la valeur constante 500.",
	"HELP_TEXT_LESS_THAN_EQUAL_TITLE" : "Moins que ou égal à",
	"HELP_TEXT_LESS_THAN_EQUAL_BODY_1" : "Le bloc inférieur ou égal à compare deux valeurs d'entrée pour déterminer si la première valeur est inférieure ou égale à la seconde et renvoie un résultat qui est soit vrai, soit faux. Les valeurs peuvent être une constante (tapée dans l'entrée et qui ne varie pas), une variable, un sens ou un bloc opérateur.",
	"HELP_TEXT_LESS_THAN_EQUAL_BODY_2" : "Le bloc inférieur ou égal à est un bloc en forme de diamant, de sorte que le résultat du bloc ne peut être que vrai ou faux.",
	"HELP_TEXT_LESS_THAN_EQUAL_EXAMPLE_1_BODY" : "Résultat : vrai",
	"HELP_TEXT_LESS_THAN_EQUAL_EXAMPLE_2_BODY" : "Résultat : faux",
	"HELP_TEXT_LESS_THAN_EQUAL_EXAMPLE_3_BODY" : "Résultat : vrai",
	"HELP_TEXT_LESS_THAN_EQUAL_EXAMPLE_4_TITLE" : "La variable ''Compteur'' est-elle inférieure ou égale à la valeur constante 120.",
	"HELP_TEXT_LESS_THAN_EQUAL_EXAMPLE_5_TITLE" : "Le niveau de lumière du capteur de gauche est-il inférieur ou égal à la valeur constante 500.",
	"HELP_TEXT_EQUAL_TITLE" : "Égal à",
	"HELP_TEXT_EQUAL_BODY_1" : "Le bloc égal à compare deux valeurs d'entrée pour déterminer si la première valeur est égale à la seconde et renvoie un résultat qui est soit vrai, soit faux. Les valeurs peuvent être une constante (saisie dans l'entrée et qui ne varie pas), une variable, un sens ou un bloc opérateur.",
	"HELP_TEXT_EQUAL_BODY_2" : "Le bloc égal à est un bloc en forme de diamant, de sorte que le résultat du bloc ne peut être que vrai ou faux.",
	"HELP_TEXT_EQUAL_EXAMPLE_1_BODY" : "Résultat : vrai",
	"HELP_TEXT_EQUAL_EXAMPLE_2_BODY" : "Résultat : faux",
	"HELP_TEXT_EQUAL_EXAMPLE_3_TITLE" : "La variable 'Compteur' est-elle égale à la valeur constante 60.",
	"HELP_TEXT_EQUAL_EXAMPLE_4_TITLE" : "Le code à distance reçu est-il égal à la valeur constante 3 ?",
	"HELP_TEXT_GREATER_THAN_EQUAL_TITLE" : "Plus grand que ou égal à",
	"HELP_TEXT_GREATER_THAN_EQUAL_BODY_1" : "Le bloc supérieur ou égal à compare deux valeurs d'entrée pour déterminer si la première valeur est supérieure ou égale à la seconde et renvoie un résultat qui est soit vrai, soit faux. Les valeurs peuvent être une constante (tapée dans l'entrée et qui ne varie pas), une variable, un sens ou un bloc opérateur.",
	"HELP_TEXT_GREATER_THAN_EQUAL_BODY_2" : "Le bloc supérieur ou égal à est un bloc en forme de diamant, donc le résultat du bloc ne peut être que vrai ou faux.",
	"HELP_TEXT_GREATER_THAN_EQUAL_EXAMPLE_1_BODY" : "Résultat : vrai",
	"HELP_TEXT_GREATER_THAN_EQUAL_EXAMPLE_2_BODY" : "Résultat : faux",
	"HELP_TEXT_GREATER_THAN_EQUAL_EXAMPLE_3_BODY" : "Résultat : vrai",
	"HELP_TEXT_GREATER_THAN_EQUAL_EXAMPLE_4_TITLE" : "La variable 'Compteur' est-elle supérieure ou égale à la valeur constante 120.",
	"HELP_TEXT_GREATER_THAN_EQUAL_EXAMPLE_5_TITLE" : "Le niveau de lumière du capteur de gauche est-il supérieur ou égal à la valeur constante 500.",
	"HELP_TEXT_GREATER_THAN_TITLE" : "Plus grand que",
	"HELP_TEXT_GREATER_THAN_BODY_1" : "Le bloc plus grand que compare deux valeurs d'entrée pour déterminer si la première valeur est supérieure à la seconde et renvoie un résultat qui est soit vrai, soit faux. Les valeurs peuvent être une constante (saisie dans l'entrée et qui ne varie pas), une variable, un sens ou un bloc opérateur.",
	"HELP_TEXT_GREATER_THAN_BODY_2" : "Le bloc plus grand que est un bloc en forme de diamant, de sorte que le résultat du bloc ne peut être que vrai ou faux.",
	"HELP_TEXT_GREATER_THAN_EXAMPLE_1_BODY" : "Résultat : vrai",
	"HELP_TEXT_GREATER_THAN_EXAMPLE_2_BODY" : "Résultat : faux",
	"HELP_TEXT_GREATER_THAN_EXAMPLE_3_TITLE" : "La variable ''Compteur'' est-elle supérieure à la valeur constante 120.",
	"HELP_TEXT_GREATER_THAN_EXAMPLE_4_TITLE" : "Le niveau de lumière du capteur de gauche est-il supérieur à la valeur constante 500.",
	"HELP_TEXT_NOT_EQUAL_TITLE" : "Non égal à",
	"HELP_TEXT_NOT_EQUAL_BODY_1" : "Le bloc non égal à compare deux valeurs d'entrée pour déterminer si la première valeur n'est pas égale à la seconde et renvoie un résultat qui est soit vrai, soit faux. Les valeurs peuvent être une constante (saisie dans l'entrée et qui ne varie pas), une variable, un sens ou un bloc opérateur.",
	"HELP_TEXT_NOT_EQUAL_BODY_2" : "Le bloc non égal à est un bloc en forme de diamant, de sorte que le résultat du bloc ne peut être que vrai ou faux.",
	"HELP_TEXT_NOT_EQUAL_EXAMPLE_1_BODY" : "Résultat : vrai",
	"HELP_TEXT_NOT_EQUAL_EXAMPLE_2_BODY" : "Résultat : faux",
	"HELP_TEXT_NOT_EQUAL_EXAMPLE_3_TITLE" : "La variable 'Compteur' est-elle différente de la valeur constante 120 ?",
	"HELP_TEXT_NOT_EQUAL_EXAMPLE_4_TITLE" : "Le code à distance reçu est-il différent de la valeur constante 3 ?",
	"HELP_TEXT_IS_BETWEEN_TITLE" : "Est entre",
	"HELP_TEXT_IS_BETWEEN_BODY_1" : "Le bloc is between détermine si une valeur est comprise dans un intervalle de deux autres valeurs. Les valeurs peuvent être une constante (saisie dans l'entrée et qui ne varie pas), une variable, une détection ou un bloc opérateur.",
	"HELP_TEXT_IS_BETWEEN_BODY_2" : "Le bloc is between est un bloc en forme de diamant, de sorte que le résultat du bloc ne peut être que vrai ou faux.",
	"HELP_TEXT_IS_BETWEEN_EXAMPLE_1_BODY" : "Résultat : vrai",
	"HELP_TEXT_IS_BETWEEN_EXAMPLE_2_BODY" : "Résultat : faux",
	"HELP_TEXT_IS_BETWEENL_EXAMPLE_3_TITLE" : "La variable 'Compteur' est-elle comprise entre la valeur constante 60 et la valeur constante 120.",
	"HELP_TEXT_IS_BETWEEN_EXAMPLE_4_TITLE" : "Le niveau de luminosité du capteur de lumière gauche est-il compris entre la valeur constante 250 et la valeur constante 750.",
	"HELP_TEXT_AND_TITLE" : "Et",
	"HELP_TEXT_AND_BODY_1" : "Le bloc et détermine si deux entrées sont toutes les deux vraies. Si les deux entrées sont vraies, le résultat sera également vrai. Si l'une des entrées ou les deux sont fausses, le résultat est faux. Les entrées acceptent des blocs en forme de losange qui peuvent être soit un bloc opérateur, soit un bloc détecteur.",
	"HELP_TEXT_AND_BODY_2" : "Le bloc et est un bloc en forme de diamant, donc le résultat du bloc ne peut être que vrai ou faux.",
	"HELP_TEXT_AND_EXAMPLE_1_BODY" : "Résultat : vrai",
	"HELP_TEXT_AND_EXAMPLE_2_BODY" : "Résultat : faux",
	"HELP_TEXT_AND_EXAMPLE_3_TITLE" : "Le traceur de ligne est-il sur la surface réfléchissante ''et'' l'effort d'entraînement est-il détecté.",
	"HELP_TEXT_AND_EXAMPLE_4_TITLE" : "La variable 'Counter' est-elle supérieure à 50 ''et'' le code à distance reçu est égal à la valeur constante 3.",
	"HELP_TEXT_OR_TITLE" : "Ou",
	"HELP_TEXT_OR_BODY_1" : "Le bloc ou détermine si la première entrée ''ou'' la deuxième entrée sont vraies. Si l'une des entrées ou les deux sont vraies, le résultat sera vrai. Si les deux entrées sont fausses, le résultat sera faux. Les entrées acceptent des blocs en forme de losange qui peuvent être soit un bloc opérateur, soit un bloc détecteur.",
	"HELP_TEXT_OR_BODY_2" : "Le bloc ou est un bloc en forme de losange, donc le résultat du bloc ne peut être que vrai ou faux.",
	"HELP_TEXT_OR_EXAMPLE_1_BODY" : "Résultat : vrai",
	"HELP_TEXT_OR_EXAMPLE_2_BODY" : "Résultat : vrai",
	"HELP_TEXT_OR_EXAMPLE_3_BODY" : "Résultat : faux",
	"HELP_TEXT_OR_EXAMPLE_4_TITLE" : "Le traceur de ligne est-il sur la surface réfléchissante ''ou'' la contrainte d'entraînement est-elle détectée.",
	"HELP_TEXT_OR_EXAMPLE_5_TITLE" : "Soit la variable 'Counter' est inférieure à la valeur constante 50 ''soit'' le code à distance reçu est égal à la valeur constante 3.",
	"HELP_TEXT_NOT_TITLE" : "Non",
	"HELP_TEXT_NOT_BODY_1" : "Le bloc not détermine si l'entrée n'est pas vraie. Si l'entrée est fausse, la sortie sera vraie. Si l'entrée est vraie, la sortie sera fausse. L'entrée accepte des blocs en forme de losange qui peuvent être soit un bloc opérateur, soit un bloc de détection.",
	"HELP_TEXT_NOT_BODY_2" : "Le bloc not est un bloc en forme de diamant, de sorte que le résultat du bloc ne peut être que vrai ou faux.",
	"HELP_TEXT_NOT_EXAMPLE_1_BODY" : "Résultat : faux",
	"HELP_TEXT_NOT_EXAMPLE_2_BODY" : "Résultat : vrai",
	"HELP_TEXT_NOT_EXAMPLE_3_TITLE" : "Le code à distance 0 n'est pas reçu.",
	"HELP_TEXT_NOT_EXAMPLE_4_TITLE" : "Exemple de programme : Tourner sur la commande de la télécommande (fonctionne mieux avec l'EdRemote).",
	"HELP_TEXT_NOT_EXAMPLE_4_BODY" : "Dans cet exemple, le programme commence par entrer dans une boucle infinie. À l'intérieur de cette boucle, le bloc if then teste si le code 0 de la télécommande a été reçu. Si c'est le cas, les deux moteurs sont réglés pour faire tourner le robot à droite. Cette opération se poursuit jusqu'à ce que la condition du bloc wait until (attendre jusqu'à ce que) soit remplie. Pour réussir, le code à distance reçu ne doit pas être le code à distance 0 (le bouton de la télécommande n'est plus enfoncé). Lorsque cela se produit, le programme progresse pour arrêter les deux moteurs, puis boucle jusqu'au début de la boucle éternelle. Il en résulte qu'Edison tourne pendant que le bouton de la télécommande est maintenu enfoncé.",
	"HELP_TEXT_COMMENT_TITLE" : "commentaire",
	"HELP_TEXT_COMMENT_BODY_1" : "Le bloc commentaire est utilisé pour ajouter des notes à un programme. Les notes décrivent en langage clair comment le programme est censé fonctionner. Faire des commentaires dans un programme est utile lorsque quelqu'un d'autre doit modifier ton programme ou que tu dois modifier ton programme longtemps après l'avoir écrit.",
	"HELP_TEXT_COMMENT_BODY_2" : "Les commentaires ne sont pas programmés dans Edison et ne modifient donc pas le comportement de ton programme.",
	"HELP_TEXT_COMMENT_EXAMPLE_1_TITLE" : "Exemple de programme : Les commentaires expliquent le fonctionnement du programme en langage clair",
	"HELP_TEXT_SEND_USB_TITLE" : "envoyer via USB",
	"HELP_TEXT_SEND_USB_BODY_1" : "Le bloc send via USB transmet une valeur à un ordinateur via la connexion USB. La valeur peut être soit une constante (tapée en entrée et qui ne varie pas), soit une variable, soit une détection, soit un bloc opérateur.",
	"HELP_TEXT_SEND_USB_BODY_2" : "Pour voir le nombre sur l'ordinateur, clique sur le bouton USB dans EdScratch et une fenêtre contextuelle apparaîtra. Clique sur Run USB pour te connecter au robot Edison V3. Les données reçues de l'Edison V3 apparaîtront dans la fenêtre Data from USB.",
	"HELP_TEXT_SEND_USB_BODY_3" : "Le bloc d'envoi à l'USB peut également être utilisé pour aider à déboguer un programme.",
	"HELP_TEXT_SEND_USB_BODY_4" : "Les roues de l'Edison V3 ne roulent pas lorsqu'elles sont connectées à l'USB. Ceci est dû aux normes de sécurité internationales qui n'autorisent pas les produits destinés aux enfants à pouvoir entraîner un moteur lorsqu'ils sont connectés à un port USB.",
	"HELP_TEXT_SEND_USB_EXAMPLE_1_TITLE" : "Exemple de programme : Mesurer le niveau de luminosité",
	"HELP_TEXT_SEND_USB_EXAMPLE_1_BODY" : "Dans cet exemple, le programme commence par entrer dans une boucle infinie. Le premier bloc à l'intérieur de la boucle envoie le niveau de lumière du capteur de lumière gauche via USB. Le programme attend ensuite une seconde et recommence.",
	"HELP_TEXT_SAVE_USB_TITLE" : "attendre les données de l'USB et les sauvegarder sur",
	"HELP_TEXT_SAVE_USB_BODY_1" : "Le bloc Wait for USB data and save to met le programme en pause jusqu'à ce que les données soient reçues par USB, puis place les données dans une variable.",
	"HELP_TEXT_SAVE_USB_BODY_2" : "Les roues de l'Edison V3 ne roulent pas lorsqu'elles sont connectées à l'USB. Ceci est dû aux normes de sécurité internationales qui n'autorisent pas les produits destinés aux enfants à pouvoir entraîner un moteur lorsqu'ils sont connectés à un port USB.",
	"HELP_TEXT_SAVE_USB_EXAMPLE_1_TITLE" : "Exemple de programme : Nombre de bips provenant de l'USB",
	"HELP_TEXT_SAVE_USB_EXAMPLE_1_BODY_1" : "Dans cet exemple, le programme commence par entrer dans une boucle infinie. Le premier bloc à l'intérieur de la boucle attend que les données soient reçues de l'USB. Lorsque les données sont reçues, elles sont enregistrées dans la variable 'Count'. Le programme passe ensuite au bloc de répétition qui se répète pour la valeur de la variable 'Count'. À l'intérieur du bloc de répétition, les blocs beep et wait sec s'exécutent. Le résultat est que l'Edison émet un bip le nombre de fois qu'il est envoyé par USB.",
	"HELP_TEXT_SAVE_USB_EXAMPLE_1_BODY_2" : "Pour tester ce programme, clique sur le bouton USB dans l'application EdScratch et une fenêtre contextuelle apparaît. Clique sur Run USB pour te connecter au robot Edison V3. Pour envoyer des données à l'Edison V3, tape un nombre dans la case Data to USB et clique sur le bouton Send to USB.",
	"HELP_TEXT_FUNCTION_START_TITLE" : "Démarrage de la fonction",
	"HELP_TEXT_FUNCTION_START_BODY_1" : "Le bloc de démarrage de fonction est l'endroit où ta fonction commence. Connecte des blocs au bloc de début de fonction pour créer une fonction personnalisée.",
	"HELP_TEXT_FUNCTION_START_BODY_2" : "Les blocs de fonction permettent de simplifier un programme car le code peut être regroupé, ce qui le rend plus facile à lire. Les fonctions permettent également de réduire la taille d'un programme car les parties répétitives d'un programme n'ont besoin d'être écrites qu'une seule fois.",
	"HELP_TEXT_FUNCTION_START_BODY_3" : "Les blocs d'appel de fonction ne peuvent pas être placés sous des blocs de démarrage de fonction.",
	"HELP_TEXT_FUNCTION_START_EXAMPLE_1_TITLE" : "Exemple de programme 1 : entraînement en forme de carré",
	"HELP_TEXT_FUNCTION_START_EXAMPLE_1_BODY" : "Dans cet exemple, le programme commence par entrer dans une boucle répéter pour quatre fois. À l'intérieur du bloc de répétition se trouve un appel de fonction appelé ''Conduire et tourner''. Lorsque le programme arrive à ce bloc, il saute au bloc de démarrage de la fonction correspondante. Dans ce bloc, le robot doit avancer de 10 cm, puis tourner à droite de 90 degrés. Cette fonction est appelée quatre fois à l'intérieur de la boucle de répétition. Le résultat est qu'Edison roule dans un carré.",
	"HELP_TEXT_FUNCTION_START_EXAMPLE_2_TITLE" : "Exemple de programme 2 : éviter les lignes et les obstacles",
	"HELP_TEXT_FUNCTION_START_EXAMPLE_2_BODY" : "Dans cet exemple, le programme commence par allumer le détecteur d'obstacles et la DEL de suivi de ligne, puis entre dans une boucle infinie. À l'intérieur de cette boucle, les deux moteurs sont réglés pour avancer. Ensuite, le bloc if then teste si un obstacle a été détecté. S'il est vrai, le bloc d'appel de fonction 'TurnAround' fait sauter le programme au bloc de démarrage de fonction 'TurnAround'. Le programme arrête alors les moteurs, allume la lumière LED, émet un bip, recule, tourne de 175 degrés et éteint les LED, puis retourne au programme principal où il s'était arrêté. Le bloc suivant if then teste si la surface est non réfléchissante (noire), si c'est le cas, le bloc d'appel de fonction 'TurnAround' fait sauter le programme au bloc de démarrage de fonction 'TurnAround'. Le programme arrête alors les moteurs, allume la lumière LED, émet un bip, recule, tourne de 175 degrés et éteint les LED, puis retourne au programme principal où il s'était arrêté. Edison s'éloigne ainsi des lignes et des objets qu'il détecte.",
	"HELP_TEXT_FUNCTION_CALL_TITLE" : "Appel de fonction",
	"HELP_TEXT_FUNCTION_CALL_BODY_1" : "Le bloc d'appel de fonction indique au programme de passer au bloc de démarrage de la fonction.",
};

Blockly.ScratchMsgs.locales['cs'] = {
"CONTROL_FOREVER" : 'opakuj stále',
"CONTROL_REPEAT" : 'opakuj',
"CONTROL_IF" : 'když',
"CONTROL_THAN" : 'potom',
"CONTROL_ELSE" : 'jinak',
"CONTROL_STOP" : 'stop',
"CONTROL_STOP_ALL" : 'all',
"CONTROL_WAIT" : 'čekej',
"CONTROL_WAIT_SEC" : 'sekund',
"CONTROL_WAIT_MILLISECONDS" : 'milisekund',
"CONTROL_WAITUNTIL" : 'čekej dokud nenastane',
"CONTROL_REPEATUNTIL" : 'opakuj dokud nenastane',
"DATA_BUTTONCREATE" : 'Vytvoř proměnnou',
"DATA_BUTTONMANAGE" : 'Spravuj proměnné',
"DATA_SET" : "nastav",
"DATA_TO" : "na",
"DATA_INCVARIABLE" : 'zvyš o jedna',
"DATA_DECVARIABLE" : 'sniž o jedna',
"DATA_BITSHIFT" : "udělej bitový posun proměnné",
"DATA_BITSHIFTLEFT" : 'doleva o',
"DATA_BITSHIFTRIGHT" : 'doprava o',
"EVENT_ANY_OBSTACLE" : 'Zjištěna překážka',
"EVENT_OBSTACLE_AHEAD" : 'Zjištěna překážka vepředu',
"EVENT_OBSTACLE_LEFT" : 'Zjištěna překážka vlevo',
"EVENT_OBSTACLE_RIGHT" : 'Zjištěna překážka vpravo',
"EVENT_CLAP" : 'Tlesknutí',
"EVENT_BUTTON_TRIANGLE" : 'Trojúhelníkové tlačítko zmáčknuto',
"EVENT_BUTTON_ROUND" : 'Kulaté tlačítko zmáčknuto',
"EVENT_LINE_REFLECTIVE" : 'Senzor sledování čáry na odrazivém povrchu',
"EVENT_LINE_NON_REFLECTIVE" : 'Senzor sledování čáry na neodrazivém povrchu',
"EVENT_LINE_CHANGE" : 'Senzor sledování čáry zaznamenal změnu povrchu',
"EVENT_MESSAGE" : 'IR zpráva přijata',
"EVENT_REMOTE" : 'Kód z ovladače přijat',
"EVENT_DRIVE_STRAIN" : 'Motory zablokovány',
"EVENT_START" : 'Start',
"OPERATORS_ADD" : '%1 + %2',
"OPERATORS_SUBTRACT" : '%1 - %2',
"OPERATORS_MULTIPLY" : '%1 * %2',
"OPERATORS_DIVIDE" : '%1 / %2',
"OPERATORS_RANDOM" : 'náhodné číslo mezi',
"OPERATORS_LT" : '%1 < %2',
"OPERATORS_LT_EQUAL" : '%1 <= %2',
"OPERATORS_EQUALS" : '%1" : %2',
"OPERATORS_GT_EQUAL" : '%1 >= %2',
"OPERATORS_GT" : '%1 > %2',
"OPERATORS_AND" : 'a',
"OPERATORS_OR" : 'nebo',
"OPERATORS_NOT_EQUALS" : '%1 != %2',
"OPERATORS_NOT" : 'neplatí, že',
"OPERATORS_ABS" : 'absolutní hodnota z',
"OPERATORS_BETWEEN" : 'je mezi',
"SENSING_TURN_LINE_TRACKING_LED" : 'senzor sledování čáry',
"SENSING_TURN_OBSTACLE_BEAM" : 'paprsek pro zjišťování překážek',
"SENSING_CLEAR" : 'smaž data',
"SENSING_SENSOR" : '',
"SENSING_CLAP_DETECTED" : 'tlesknutí',
"SENSING_BUTTON_PRESSED" : 'tlačítko zmáčknuto',
"SENSING_OBSTACLE" : 'překážka zjištěna',
"SENSING_LINE_TRACKER" : 'senzor sledování čáry na',
"SENSING_LINE_SURFACE" : "povrchu",
"SENSING_REMOTE_NUM" : 'kód z ovladače',
"SENSING_REMOTE_BOOL" : 'kód z ovladače',
"SENSING_REMOTE_RECEIVED" : 'přijat',
"SENSING_IR_MESSAGE_DETECTED" : 'přijata IR zpráva',
"SENSING_IR_MESSAGE" : 'číslo přijaté IR zprávy',
"SENSING_LIGHT_LEVEL" : 'úroveň osvětlení z',
"SENSING_LIGHT_SENSOR" : 'senzoru',
"SENSING_DRIVE_STRAIN" : 'zjištěno zablokování motorů',
"SENSING_DROPDOWN_ON" : "zapnout",
"SENSING_DROPDOWN_OFF" : "vypnout",
"SENSING_CLEAR_DROPDOWN_CLAP" : "detektoru tlesknutí",
"SENSING_CLEAR_DROPDOWN_KEY" : "zmáčknuté klávesy",
"SENSING_CLEAR_DROPDOWN_OBS" : "detektoru překážek",
"SENSING_CLEAR_DROPDOWN_REMOTE" : "kódu z ovladače",
"SENSING_CLEAR_DROPDOWN_IR" : "IR zprávy",
"SENSING_KEY_DROPDOWN_ROUND" : "kulaté",
"SENSING_KEY_DROPDOWN_TRIANGLE" : "trojúhelníkové",
"SENSING_OBS_DROPDOWN_ANY" : "kdekoliv",
"SENSING_OBS_DROPDOWN_AHEAD" : "vepředu",
"SENSING_OBS_DROPDOWN_LEFT" : "vlevo",
"SENSING_OBS_DROPDOWN_RIGHT" : "vpravo",
"SENSING_LINE_DROPDOWN_WHITE" : "odrazivém",
"SENSING_LINE_DROPDOWN_BLACK" : "neodrazivém",
"SENSING_LIGHT_DROPDOWN_LEFT" : "levého světelného",
"SENSING_LIGHT_DROPDOWN_RIGHT" : "pravého světelného",
"SENSING_LIGHT_DROPDOWN_LINE" : "sledování čáry",
"COMMENT_USER_COMMENT" : 'komentář:',
"ADVANCED_USB_SEND_DATA" : 'pošli',
"ADVANCED_USB_SEND_VIA" : 'přes USB',
"ADVANCED_USB_RECEIVED_DATA" : 'data received from USB',
"ADVANCED_USB_RECEIVED_DATA_VAR" : 'čekej na data z USB a ulož je do',
"SOUND_BEEP" : "pípni",
"SOUND_PLAY_NOTE" : 'zahraj',
"SOUND_PLAY_NOTE_DROP_DURATION_WHOLE" : "celou notu",
"SOUND_PLAY_NOTE_DROP_DURATION_HALF" : "půlovou notu",
"SOUND_PLAY_NOTE_DROP_DURATION_QUARTER" : "čtvrťovou notu",
"SOUND_PLAY_NOTE_DROP_DURATION_EIGHTH" : "osminovou notu",
"SOUND_PLAY_NOTE_DROP_NOTE_C" : "C",
"SOUND_PLAY_NOTE_DROP_NOTE_B" : "H",
"SOUND_PLAY_NOTE_DROP_NOTE_A" : "A",
"SOUND_PLAY_NOTE_DROP_NOTE_G" : "G",
"SOUND_PLAY_NOTE_DROP_NOTE_F" : "F",
"SOUND_PLAY_NOTE_DROP_NOTE_E" : "E",
"SOUND_PLAY_NOTE_DROP_NOTE_D" : "D",
"SOUND_PLAY_NOTE_DROP_NOTE_MID_C" : "střední C",
"SOUND_PLAY_NOTE_DROP_NOTE_LOW_B" : "nízké H",
"SOUND_PLAY_NOTE_DROP_NOTE_REST" : "pomlku",
"SOUND_PLAY_NOTE_DROP_MOD_NORMAL" : " - ",
"SOUND_PLAY_NOTE_DROP_MOD_SHARP" : "křížek",
"SOUND_PLAY_NOTE_DROP_MOD_FLAT" : "béčko",
"SOUND_SET_TEMPO" : "nastav tempo na",
"SOUND_SET_TEMPO_DROP_VERY_SLOW" : "velmi pomalé",
"SOUND_SET_TEMPO_DROP_SLOW" : "pomalé",
"SOUND_SET_TEMPO_DROP_MEDIUM" : "střední",
"SOUND_SET_TEMPO_DROP_FAST" : "rychlé",
"SOUND_SET_TEMPO_DROP_VERY_FAST" : "velmi rychlé",
"SOUND_PLAY_IN_BACKGROUND" : "hraj hudbu na pozadí",
"CATEGORY_SOUND" : 'Zvuk', "CATEGORY_EVENTS" : 'Události', "CATEGORY_CONTROL" : 'Ovládání', "CATEGORY_SENSING" : 'Vnímání', "CATEGORY_OPERATORS" : 'Operátory', "CATEGORY_VARIABLES" : 'Proměnné', "CATEGORY_MYBLOCKS" : 'Funkce', 
"CATEGORY_DRIVE" : 'Pohyb', "CATEGORY_COMMENT" : 'Komentář', "CATEGORY_LED" : 'Světla', "CATEGORY_ADVANCED" : 'Pokročilé', 
"DUPLICATE" : 'Duplikuj',
"DELETE" : 'Delete',
"DELETE_BLOCK" : 'Smaž blok',
"DELETE_X_BLOCKS" : 'Delete %1 Blocks',
"DELETE_ALL_BLOCKS" : 'Delete all %1 blocks?',
"CONTEXT_DELETE" : 'Smaž bloky (',
"CONTEXT_DELETE_ALL" : 'Delete all',
"CONTEXT_BLOCKS" : ')',
"CLEAN_UP" : 'Zarovnej bloky',
"HELP" : 'Nápověda',
"UNDO" : 'Zpět',
"REDO" : 'Znovu',
"CHANGE_VALUE_TITLE" : 'Change value:',
"RENAME_VARIABLE" : 'Rename variable',
"RENAME_VARIABLE_MODAL_TITLE" : 'Rename Variable',
"NEW_VARIABLE" : 'Make a Variable',
"NEW_VARIABLE_TITLE" : 'New variable name:',
"VARIABLE_MODAL_TITLE" : 'New Variable',
"NEW_PROCEDURE" : 'Vytvoř funkci',
"MANAGE_PROCEDURE" : 'Spravuj funkce',
"PROCEDURE_DEFAULT_NAME" : 'block name',
"PROCEDURE_USED" : 'To delete a block definition, first remove all uses of the block',
"DRIVE_FORWARDS_DISTANCE" : "jeď vpřed",
"DRIVE_BACKWARDS_DISTANCE" : "jeď vzad",
"DRIVE_LEFT_DISTANCE" : "doleva o",
"DRIVE_RIGHT_DISTANCE" : "doprava o",
"DRIVE_DISTANCE_DROPDOWN_CM" : "cm",
"DRIVE_DISTANCE_DROPDOWN_INCH" : "palců",
"DRIVE_DISTANCE_DROPDOWN_SECONDS" : "sekund",
"DRIVE_DISTANCE_DROPDOWN_DEGREES" : "stupňů",
"DRIVE_TURN_DROPDOWN_SPIN" : "otoč se",
"DRIVE_TURN_DROPDOWN_FORWARDS" : "zatoč dopředu",
"DRIVE_TURN_DROPDOWN_BACKWARDS" : "zatoč dozadu",
"DRIVE_FORWARDS_UNTIL" : "jeď vpřed dokud nenastane",
"DRIVE_BACKWARDS_UNTIL" : "jeď vzad dokud nenastane",
"DRIVE_LEFT_UNTIL" : "doleva dokud nenastane",
"DRIVE_RIGHT_UNTIL" : "doprava dokud nenastane",
"DRIVE_SET_LEFT_MOTOR" : "nastav levý motor na jízdu",
"DRIVE_SET_RIGHT_MOTOR" : "nastav pravý motor na jízdu",
"DRIVE_SET_MOTOR_DROPDOWN_FORWARDS" : "vpřed",
"DRIVE_SET_MOTOR_DROPDOWN_BACKWARDS" : "vzad",
"DRIVE_SET_BOTH_MOTOR" : "nastav oba motory na",
"DRIVE_SET_BOTH_MOTOR_DROPDOWN_FORWARDS" : "jízdu vpřed",
"DRIVE_SET_BOTH_MOTOR_DROPDOWN_BACKWARDS" : "jízdu vzad",
"DRIVE_SET_BOTH_MOTOR_DROPDOWN_SPIN_LEFT" : "otáčení doleva",
"DRIVE_SET_BOTH_MOTOR_DROPDOWN_SPIN_RIGHT" : "otáčení doprava",
"DRIVE_SET_BOTH_MOTOR_DROPDOWN_TURN_LEFT" : "zatáčení doleva",
"DRIVE_SET_BOTH_MOTOR_DROPDOWN_TURN_RIGHT" : "zatáčení doprava",
"DRIVE_AT_SPEED" : "rychlostí",
"DRIVE_STOP" : "zastav",
"DRIVE_STOP_DROPDOWN_BOTH" : "oba motory",
"DRIVE_STOP_DROPDOWN_LEFT" : "levý motor",
"DRIVE_STOP_DROPDOWN_RIGHT" : "pravý motor",
"LED_LEFT" : "levou LED",
"LED_RIGHT" : "pravou LED",
"LED_DROPDOWN_ON" : "zapni",
"LED_DROPDOWN_OFF" : "vypni",
"LED_SEND_MESSAGE" : "pošli IR zprávu s číslem",
"DEMO_TEST_PROGRAM" : "Testovací program",
"DEMO_TEST_PROGRAM_DISC" : "Otestuje jízdu, LED a reproduktor",
"DEMO_MOVE_WITH_MUSIC" : "Hýbej se s muzikou",
"DEMO_MOVE_WITH_MUSIC_DISC" : "Jede při přehrávání hudby",
"DEMO_FOLLOW_A_LINE" : "Sleduj čáru",
"DEMO_FOLLOW_A_LINE_DISC" : "Použije senzor čáry k jízdě po černé čáře",
"DEMO_BOUNCE_IN_BORDERS" : "Zůstaň v ohraničeném prostoru",
"DEMO_BOUNCE_IN_BORDERS_DISC" : "Použije senzor čáry k tomu, aby zůstal uvnitř prostoru ohraničeného černou čárou",
"DEMO_WARNINGS" : "Ukázkový program s varovnými hláškami",
"DEMO_WARNINGS_DISC" : "Ukazuje červené chybové zprávy a žluté varovné hlášky",
"DEMO_CLAP_CONTROL" : "Jízda ovládaná tleskáním",
"DEMO_CLAP_CONTROL_DISC" : "Tleskni jednou pro otočení, tleskni dvakrát pro jízdu dopředu",
"DEMO_AVOID_OBSTACLES" : "Vyhni se překážkám",
"DEMO_AVOID_OBSTACLES_DISC" : "Použije senzor překážek, aby se vyhnul nárazu do překážky",
"DEMO_FOLLOW_TORCH" : "Následuj světlo",
"DEMO_FOLLOW_TORCH_DISC" : "Použije senzor světla k následování baterky",
"DEMO_FOLLOW_A_LINE_IF" : "Sleduj čáru pomocí příkazu když",
"DEMO_FOLLOW_A_LINE_IF_DISC" : "Jiný způsob, jak použít senzor čáry k jízdě po čáře za použití bloku ‘když’",
"MENU_DROP_MENU" : "Menu", "MENU_DROP_NEW" : "Nový", "MENU_DROP_LOAD_DEMO" : "Otevři demo", "MENU_DROP_LOAD_LOCAL" : "Otevři z počítače", "MENU_DROP_SAVE_LOCAL" : "Ulož do počítače", "MENU_DROP_UPDATE_FIRMWARE" : "Aktualizuj firmware", 
"MENU_DROP_DIAGNOSTICS" : "Diagnostika", 
"MENU_DROP_LANGUAGE_LABEL" : "Jazyk",
"MENU_DROP_ABOUT" : "O EdScratch", "MENU_DROP_TERMS" : "Podmínky užití", 
"MENU_USB" : "USB", "MENU_SAVE" : " Uložit", 
"MENU_VERSION_MAIN" : " Edison V3", "MENU_VERSION_SWITCH" : "Přepni na Edison V1/V2", "MENU_VERSION_WHICH_VERSION" : "Jakou mám verzi?", "MENU_PROGRAM" : " Programuj", "MENU_PROGRAM_FLASH" : " Programuj", 
"MODAL_CREATE_VAR" : "Vytvoř proměnnou", "MODAL_CREATE_VAR_NAME" : "Název proměnné", "MODAL_CREATE_VAR_BUTTON" : "Vytvoř proměnnou", "MODAL_CREATE_VAR_EXIT" : "Odejít", "MODAL_CREATE_VAR_SUCCESS" : "Nová proměnná úspěšně vytvořena.", 
"MODAL_MANAGE_VAR" : "Proměnné ", "MODAL_MANAGE_VAR_NAME" : "Název proměnné", "MODAL_MANAGE_VAR_ACTION" : "Akce", "MODAL_MANAGE_VAR_BUTTON_DELETE" : "smazat", "MODAL_MANAGE_VAR_BUTTON_RENAME" : "přejmenovat", "MODAL_MANAGE_VAR_BUTTON_CONFIRM" : "potvrdit", "MODAL_MANAGE_VAR_BUTTON_CANCEL" : "zrušit", "MODAL_MANAGE_VAR_CONFIRM_NOT_CHANGED" : "Nezměnil jsi název proměnné. Zkus to znovu.", "MODAL_MANAGE_VAR_CONFIRM_SUCCESS" : "Proměnná úspěšně přejmenována!", 
"MODAL_MANAGE_VAR_NAME_NONE" : "Zadej prosím název proměnné.", "MODAL_MANAGE_VAR_NAME_IN_USE" : "Už máš proměnnou s tímto názvem.", "MODAL_MANAGE_VAR_NAME_UNSUPPORTED" : "Název proměnné obsahuje nepodporované znaky. Názvy proměnných mohou obsahovat pouze malá a velká písmena anglické abecedy, čísla a podtržítka ( _ ).", "MODAL_MANAGE_VAR_NAME_NUMBER_START" : "Název proměnné nemůže začínat číslem.", 
"MODAL_MANAGE_VAR_DELETE_IN_USE" : "Tato proměnná je používaná ve tvém programu. Chceš ji opravdu smazat?", "MODAL_MANAGE_VAR_DELETE_CONFIRM" : "Ano", "MODAL_MANAGE_VAR_DELETE_DECLINE" : "Ne", 
"MODAL_CREATE_FUNCT" : "Vytvoř funkci", "MODAL_CREATE_FUNCT_NAME" : "Název funkce", "MODAL_CREATE_FUNCT_WARNING" : "Název funkce může obsahovat pouze alfanumerické znaky a nesmí začínat číslem.", "MODAL_CREATE_FUNCT_BUTTON" : "Vytvoř funkci", "MODAL_CREATE_FUNCT_BUTTON_EXIT" : "Odejít", "MODAL_CREATE_FUNCT_SUCCESS" : "Nová funkce úspěšně vytvořena.",
"MODAL_MANAGE_FUNCT" : "Funkce ", "MODAL_MANAGE_FUNCT_NAME" : "Název funkce", "MODAL_MANAGE_FUNCT_ACTION" : "Akce", "MODAL_MANAGE_FUNCT_BUTTON_DELETE" : "smazat", "MODAL_MANAGE_FUNCT_BUTTON_RENAME" : "přejmenovat", "MODAL_MANAGE_FUNCT_BUTTON_CONFIRM" : "potvrdit", "MODAL_MANAGE_FUNCT_BUTTON_CANCEL" : "zrušit", "MODAL_MANAGE_FUNCT_CONFIRM_NOT_CHANGED" : "Nezměnil jsi název funkce. Zkus to znovu.", "MODAL_MANAGE_FUNCT_CONFIRM_SUCCESS" : "Funkce úspěšně přejmenována!", 
"MODAL_MANAGE_FUNCT_NAME_NONE" : "Zadej prosím název funkce.", "MODAL_MANAGE_FUNCT_NAME_IN_USE" : "Už máš funkci s tímto názvem.", "MODAL_MANAGE_FUNCT_NAME_START_WITH" : "Název funkce nesmí začínat",
"MODAL_MANAGE_FUNCT_NAME_UNSUPPORTED" : "Název funkce obsahuje nepodporované znaky. Názvy funkcí mohou obsahovat pouze malá a velká písmena anglické abecedy, čísla a podtržítka ( _ ).", "MODAL_MANAGE_FUNCT_NAME_NUMBER_START" : "Název funkce nesmí začínat číslem.", 
"MODAL_MANAGE_FUNCT_DELETE_IN_USE" : "Tato funkce je používaná ve tvém programu. Chceš ji opravdu smazat?", "MODAL_MANAGE_FUNCT_DELETE_CONFIRM" : "Ano", "MODAL_MANAGE_FUNCT_DELETE_DECLINE" : "Ne", 
"MODAL_SAVE_TITLE" : "Ulož do počítače", "MODAL_SAVE_PROG_TITLE" : "Název programu", "MODAL_SAVE_BUTTON" : "Ulož do počítače", "MODAL_SAVE_ERROR_NO_NAME" : "Zadej prosím název tvého programu. Abys mohl program uložit, musíš mu dát nějaký název.", "MODAL_SAVE_ERROR_LONG_NAME" : "Ups, nastal problém s názvem programu. Název programu nesmí být delší než 255 znaků.", "MODAL_SAVE_SAVING" : "OK! Tvůj program se ukládá. Stahování tvého programu brzy začne.", 
"MODAL_LOAD_PC_TITLE" : "Otevři z počítače", "MODAL_LOAD_PC_FILE_ERROR_1" : "Vyber prosím EdScratch soubor.", "MODAL_LOAD_PC_FILE_ERROR_2" : "Všechny EdScratch soubory jsou typu", "MODAL_LOAD_PC_FILE_ERROR_3" : ".edscratch", "MODAL_LOAD_PC_FILE_BUTTON" : "Vyber soubor k načtení...", "MODAL_LOAD_PC_BUTTON" : "Načti program", "MODAL_LOAD_PC_NO_FILE_ERROR_1" : "Nevybral jsi soubor. Vyber prosím nejdřív EdScratch soubor z tvého počítače, potom klikni na Načti program. [Všechny EdScratch soubory jsou typu (.edscratch).]", "MODAL_LOAD_PC_FILE_DATA_ERROR_1" : "Ouvej. Data v souboru nejsou správná.", "MODAL_LOAD_PC_FILE_DATA_ERROR_2" : "Načti prosím jiný EdScratch soubor. [Všechny EdScratch soubory jsou typu (.edscratch).]", "MODAL_LOAD_PC_FILE_TYPE_ERROR_1" : "Ouvej. Načetl jsi nesprávný typ souboru.", "MODAL_LOAD_PC_FILE_TYPE_ERROR_2" : "Načti prosím EdScratch soubor. [Všechny EdScratch soubory jsou typu (.edscratch).]", "MODAL_LOAD_PC_FILE_READY" : "Tento program je připraven k načtení:",
"MODAL_LOAD_DEMO_TITLE" : "Načti demo", "MODAL_LOAD_DEMO_BUTTON" : "Načti program", 
"MODAL_COOKIES_TITLE" : "Cookies",
"MODAL_COOKIES_BODY_1" : "We use Google Analytics to measure how visitors use this web app so we can improve it based on user needs. For instance, which options visitors use most often, and if they get error messages from the web app. These cookies don't collect information that identifies a visitor.",
"MODAL_COOKIES_BODY_2" : "We do not allow Google to use or share the data about how you use this site and all information these cookies collect is aggregated and therefore anonymous. It is only used to improve how the web app works. This cookie is stored for a period of one year.",
"MODAL_COOKIES_ACCEPT" : "Accept cookies",
"MODAL_COOKIES_BUTTON_YES" : "Yes",
"MODAL_COOKIES_BUTTON_NO" : "No",
"MODAL_ABOUT_TITLE" : "About EdScratch", 
"MODAL_ABOUT_COPYRIGHT" : "Copyright 2023 Microbric Pty Ltd", 
"MODAL_ABOUT_BODY_1" : "The EdScratch app was developed using the Scratch Blocks code base developed by MIT. Scratch Blocks was built on the Blockly code base developed by Google.",
"MODAL_ABOUT_BODY_2" : "Contributions and credits:", 
"MODAL_ABOUT_BODY_3" : "EdScratch programming language and block compiler developed by Ben Hayton, Microbric",
"MODAL_ABOUT_BODY_4" : "EdScratch user interface developed by Sean Killian, Killian Web Development",
"MODAL_ABOUT_BODY_5" : "Edison V3 firmware developed by Damien George, George Robotics (MicroPython code base)",
"MODAL_LANGUAGE" : "Jazyk", 
"MODAL_DIAGNOSTICS" : "Diagnostics", "MODAL_DIAGNOSTICS_CONNECT_ISSUES_TITLE" : "Connectivity issues", "MODAL_DIAGNOSTICS_CONNECT_ISSUES_BODY" : "To ensure that your program can be compiled and sent to the Edison robot, it is a good idea to check your connection with the EdScratch compiler.", "MODAL_DIAGNOSTICS_CONNECT_ISSUES_BUTTON" : "Run the connection checker", "MODAL_DIAGNOSTICS_FIRMWARE_TITLE" : "Firmware", "MODAL_DIAGNOSTICS_FIRMWARE_BODY" : "The firmware version in your Edison can be useful to know when talking to our tech support team. Check that here:", "MODAL_DIAGNOSTICS_FIRMWARE_BUTTON" : "Get firmware version", "MODAL_DIAGNOSTICS_PROGRAMMING_TITLE" : "Programming method", "MODAL_DIAGNOSTICS_PROGRAMMING_BODY" : "This option enables you to swtich between USB and screen flash programming on this device.", "MODAL_DIAGNOSTICS_PROGRAMMING_BUTTON" : "Change programming method", "MODAL_DIAGNOSTICS_IR_TITLE" : "Clear learned IR remote commands", "MODAL_DIAGNOSTICS_IR_BODY" : "This option allows you to clear all learned IR remote control commands from an Edison V3 robot.", "MODAL_DIAGNOSTICS_IR_BUTTON" : "Clear remote codes", "MODAL_DIAGNOSTICS_IR_SUCCESS" : "Remote codes have been cleared.", "MODAL_DIAGNOSTICS_IR_ERROR" : "An error has occurred.", 
"MODAL_CONNECTION" : "Connection", "MODAL_CONNECTION_TEST_1" : "If the test above has the result ", "MODAL_CONNECTION_TEST_EXAMPLE" : "NO SERVER FOUND", "MODAL_CONNECTION_TEST_2" : " then a firewall may be blocking access to the compiler.", "MODAL_CONNECTION_TEST_3" : "To rectify this, ask your network administrator to whitelist these addresses:", "MODAL_CONNECTION_PORTS" : "The network administrator also needs to unblock ports 80, 8080, 443 and 8443.", "MODAL_CONNECTION_BACK" : "Back to diagnostics", "MODAL_CONNECTION_SERVER" : "Server: ", "MODAL_CONNECTION_SERVER_SEARCHING" : "searching",
"MODAL_CONNECTION_SERVER_NONE" : "NO SERVER FOUND", "MODAL_CONNECTION_COMIPLE_TEST" : "Compile Test: ", "MODAL_CONNECTION_COMIPLE_TEST_WORKING" : "working",
"MODAL_CONNECTION_COMIPLE_TEST_ERROR" : "compile error", "MODAL_CONNECTION_COMIPLE_TEST_COMPLETE" : "compile complete in ", 
"MODAL_STATUS_TITLE" : "Firmware version",
"MODAL_STATUS_BUTTON" : "Connect Edison",
"MODAL_STATUS_STATUS_LABEL" : "Status:", 
"MODAL_STATUS_STATUS_NOT_CONNECTED" : "not connected",
"MODAL_STATUS_STATUS_CONNECTED" : "connected", 
"MODAL_STATUS_FIRMWARE_LABEL" : "Firmware version:", 
"MODAL_STATUS_FIRMWARE_BOOT_MODE" : "bootloader mode",
"MODAL_STATUS_FIRMWARE_FACTORY_MODE" : "factory application mode",
"MODAL_STATUS_FIRMWARE_USER_MODE" : "user application mode",
"MODAL_STATUS_FIRMWARE_TAG" : "firmware",
"MODAL_STATUS_BOOT_TAG" : "boot",
"MODAL_STATUS_FIRMWARE_UPDATE" : "A firmware update",
"MODAL_STATUS_FIRMWARE_UPDATE_AVAILABLE" : "is available", 
"MODAL_STATUS_BOOT_UPDATE" : "A boot update",
"MODAL_STATUS_FIRMWARE_UPDATE_BUTTON" : "Update Firmware",
"MODAL_STATUS_FIRMWARE_UP_TO_DATE" : "Your Edison is up to date.",
"MODAL_PROGRAMING_METHOD_TITLE" : "Programming method", 
"MODAL_PROGRAMING_METHOD_BODY" : "Screen flash programming has been developed for Apple iPads. This is because Apple do not allow normal access to the iPad's data port. Therefore, screen flash programming is only fully supported for iPads. However, the screen flasher does work with some Android devices. The option below enables screen flash programming on this device. If this device is not an iPad then it is not guaranteed to work.","MODAL_PROGRAMING_METHOD_CURRENT_LABEL" : "Currently using", "MODAL_PROGRAMING_METHOD_CURRENT_LABEL_USB" : "USB", "MODAL_PROGRAMING_METHOD_CURRENT_LABEL_FLASH" : "FLASH", "MODAL_PROGRAMING_METHOD_CURRENT_LABEL_METHOD" : "method.", "MODAL_PROGRAMING_METHOD_BUTTON_USB" : "Set to USB method", "MODAL_PROGRAMING_METHOD_BUTTON_FLASH" : "Set to FLASH method", "MODAL_PROGRAMING_METHOD_ACCORD_BUTTON_FLASH_GUARANTEE" : "Why is screen flashing not guaranteed to work with Android devices?", "MODAL_PROGRAMING_METHOD_ACCORD_BODY_FLASH_GUARANTEE" : "Android devices are made by many different manufacturers and there are thousands of different models. This means there is also a lot of different screen technologies. It is not possible to test and customise screen flashing for all Android devices.", "MODAL_PROGRAMING_METHOD_ACCORD_BUTTON_FLASH_SETTINGS" : "Are there settings that might help my Android device work with screen flashing?", "MODAL_PROGRAMING_METHOD_ACCORD_BODY_FLASH_SETTINGS" : "Yes, on the screen flash popup window there is a 'reliable/fast' setting that has four positions. Try each one of the four positions. Also, try adjusting the screen brightness. Test with 50%, 75%, 90% and 100% brightness.", "MODAL_PROGRAMING_METHOD_ACCORD_BUTTON_FLASH_FAIL" : "What do I do if screen flashing does not work on my Android device?", "MODAL_PROGRAMING_METHOD_ACCORD_BODY_FLASH_FAIL" : "To program you will need to plug the Edison V3 cable into the Android device's data port via an adaptor cable. These are common and cheaply available from ebay, Amazon etc.", "MODAL_PROGRAMING_METHOD_BACK" : "Back to diagnostics", 
"MODAL_PROGRAMING_TITLE" : "Programming", "MODAL_PROGRAMING_TITLE_COMPLETE" : "Programming complete",
"MODAL_PROGRAMING_TITLE_ERROR" : "Programming error",
"MODAL_PROGRAMING_TIP_1_TITLE" : "Tip: Don't cluster Edison robots on a USB hub!",
"MODAL_PROGRAMING_TIP_1_TEXT" : "Use an EdCharger instead.",
"MODAL_PROGRAMING_TIP_2_TITLE" : "Tip: Don't leave Edison hanging!",
"MODAL_PROGRAMING_TIP_2_TEXT" : "Keep Edison supported on a solid surface.",
"MODAL_PROGRAMING_TIP_3_TITLE" : "Tip: Don't leave Edison hanging!",
"MODAL_PROGRAMING_TIP_3_TEXT" : "Use an extension cable when charging from a power outlet.",
"MODAL_PROGRAMING_TIP_4_TITLE" : "Tip: Don't pull on Edison!",
"MODAL_PROGRAMING_TIP_4_TEXT" : "Unplug by pulling on the USB cable, not the robot.",
"MODAL_PROGRAMING_ERROR_NO_BLOCK" : "Cannot download with no blocks connected to the start block.","MODAL_PROGRAMING_ERROR_RED" : "Cannot download with Red Errors.",
"MODAL_PROGRAMING_UPDATE_FIRMWARE" : "To program your Edison you will need to update the firmware to the latest version", "MODAL_PROGRAMING_UPDATE_FIRMWARE_BUTTON" : "Update firmware",
"MODAL_PROGRAMING_UPDATE_FIRMWARE_NOW" : "Firmware updated required. Updating now...",
"MODAL_PROGRAMING_FIRMWARE_UPDATED" : "Firmware updated.",
"MODAL_PROGRAMING_FIRMWARE_UPDATE_INCOMPLETE" : "Incomplete firmware update.",
"MODAL_PROGRAMING_DONE" : "OK! The program has loaded to your Edison.",
"MODAL_PROGRAMING_ERROR_JSON" : "Response is not JSON!",
"MODAL_PROGRAMING_ERROR_UNKNOWN" : "Unknown Error!",
"MODAL_FIRMWARE_UPDATE_TITLE" : "Firmware update", "MODAL_FIRMWARE_UPDATE_LATEST" : "The latest Edison V3 firmware version is: ", "MODAL_FIRMWARE_UPDATE_POPUP" : "Use this pop-up to update the firmware in your Edison.", "MODAL_FIRMWARE_UPDATE_TO_UPDATE1" : "To update Edison V3 firmware:", "MODAL_FIRMWARE_UPDATE_TO_UPDATE2" : "Plug in your Edison and click the 'Update firmware' button below then follow the prompts.", "MODAL_FIRMWARE_UPDATE_TO_UPDATE_BUTTON" : "Update firmware ", "MODAL_FIRMWARE_UPDATE_TO_RECONNECT_BUTTON" : "Reconnect Edison ", "MODAL_FIRMWARE_UPDATE_FEEDBACK_START" : "Ready...", "MODAL_FIRMWARE_UPDATE_TWO_STEP_START" : "A two step firmware update is starting",
"MODAL_FIRMWARE_UPDATE_BOOT_COMPLETE" : "Bootloader update complete.",
"MODAL_FIRMWARE_UPDATE_PLEASE_CLICK" : "Please click",
"MODAL_FIRMWARE_UPDATE_ISSUE_LOADING" : "Issue loading firmware",
"MODAL_FIRMWARE_UPDATE_ONE_STEP_START" : "A firmware update is starting",
"MODAL_FIRMWARE_UPDATE_ERROR_ISSUE_LOADING" : "Error: Issue loading firmware.",
"MODAL_FIRMWARE_UPDATE_ERROR_ISSUE_DOWNLOADING" : "Error: Issue downloading firmware.",
"MODAL_FIRMWARE_UPDATE_FIRM_COMPLETE" : "Firmware update complete.",
"MODAL_FIRMWARE_UPDATE_NONE_NEEDED" : "No update required: the firmware on your Edison is up to date.",
"MODAL_FIRMWARE_UPDATE_PROBLEMS" : "Having problems? ",
"MODAL_FIRMWARE_UPDATE_SEE_DIAG" : "See diagnostics",
"MODAL_USB_CONTROL" : "USB Ovládání", "MODAL_USB_RUN_BUTTON" : "Spusť USB", "MODAL_USB_CONNECTED_STATUS" : "PŘIPOJENO", "MODAL_USB_DISCONNECTED_STATUS" : "ODPOJENO", "MODAL_USB_RUNNING_STATUS" : "PROBÍHÁ", "MODAL_USB_DATA_TO" : "Data do USB", "MODAL_USB_DATA_TO_BUTTON" : "Pošli přes USB", "MODAL_USB_DATA_FROM" : "Data z USB", "MODAL_USB_DATA_FROM_CLEAR" : "Vyčistit", "MODAL_USB_DATA_FROM_COPY" : "Zkopírovat do schránky", "MODAL_USB_DATA_FROM_COPIED" : "Zkopírováno!", 
"MODAL_BAD_BROWSER_TITLE" : "Unsupported browser", "MODAL_BAD_BROWSER_USING" : "You appear to be using: ", "MODAL_BAD_BROWSER_WEB_USB" : "The Edison V3 is programmed directly from your web browser via USB. This requires that your web browser supports USB connections.",
"MODAL_BAD_BROWSER_UNFORTUNATLY" : "Unfortunately", "MODAL_BAD_BROWSER_UNSUPORTED" : "does not currently support USB connections, so cannot program your Edison V3 robot.",
"MODAL_BAD_BROWSER_USE_CHROME" : "We recommend using Google Chrome.", "MODAL_BAD_BROWSER_GET_CHROME" : "Get Chrome.", 
"MODAL_LOADING" : "Načítání prostředí...", 
"MODAL_FLASHER_TITLE" : "Flasher", "MODAL_FLASHER_STEP_1" : "Place Edison over image", "MODAL_FLASHER_STEP_2" : "Press Edison's round button once", "MODAL_FLASHER_STEP_3" : "Press 'Download program'", "MODAL_FLASHER_RELIABLE" : "Reliable", "MODAL_FLASHER_FAST" : "Fast", "MODAL_FLASHER_ADJUST_SPEED" : "If the download does not work or is not fast enough, try adjusting the speed above. The lowest speed is usually the most reliable.", "MODAL_FLASHER_DOWNLOAD" : "Download program", "MODAL_FLASHER_CANCEL" : "Cancel", "MODAL_FLASHER_TIPS_HEADING" : "Tips", "MODAL_FLASHER_TIPS_BODY_1" : "Adjust screen brightness between 80% to 90%.", "MODAL_FLASHER_TIPS_BODY_2" : "Move away from direct and in-direct sunlight or bright lights. ", "MODAL_FLASHER_TIPS_BODY_3" : "Ensure you have updated Edison V3 to the latest firmware.", "MODAL_FLASHER_DOWNLOADING" : "Downloading...",
"MODAL_FLASHER_COMPLETE" : "Complete",
"MODAL_FLASHER_BYTES" : "bytes in",
"MODAL_FLASHER_SECONDS" : "seconds",
"ERROR_RED_OBS_SETTING" : "Bloky zjišťování překážek nefungují, dokud není zapnutý paprsek pro zjišťování překážek pomocí bloku 'paprsek pro zjišťování překážek' z kategorie 'Vnímání'.",
"ERROR_RED_OBS_SETTING_EVENT" : "Události zjišťování překážek nefungují, dokud není v hlavním programu zapnutý paprsek pro zjišťování překážek pomocí bloku 'paprsek pro zjišťování překážek' z kategorie 'Vnímání'.",
"ERROR_RED_LINE_SETTING" : "Bloky sledování čáry nefungují, dokud není zapnutý senzor sledování čáry pomocí bloku 'senzor sledování čáry' z katogorie 'Vnímání'.",
"ERROR_RED_LINE_SETTING_EVENT" : "Události sledování čáry nefungují, dokud není v hlavním programu zapnutý senzor sledování čáry pomocí bloku 'senzor sledování čáry' z katogorie 'Vnímání'.",
"ERROR_RED_DRIVE_CLAP" : "Edison nemůže detekovat tlesknutí během jízdy, protože motory jsou příliš hlučné.",
"ERROR_RED_EMPTY_IN_FORWARDS" : "Bloky 'jeď vpřed dokud nenastane' vyžadují podmínku.",
"ERROR_RED_EMPTY_IN_BACKWARDS" : "Bloky 'jeď vzad dokud nenastane' vyžadují podmínku.",
"ERROR_RED_EMPTY_IN_LEFT" : "Bloky 'doleva dokud nenastane' vyžadují podmínku.",
"ERROR_RED_EMPTY_IN_RIGHT" : "Bloky 'doprava dokud nenastane' vyžadují podmínku.",
"ERROR_RED_EMPTY_IN_SET_VAR" : "Bloky 'nastav proměnnou' vyžadují proměnnou.",
"ERROR_RED_EMPTY_IN_INC_VAR" : "Bloky 'zvyš proměnnou o 1' vyžadují proměnnou.",
"ERROR_RED_EMPTY_IN_DEC_VAR" : "Bloky 'sniž proměnnou o 1' vyžadují proměnnou.",
"ERROR_RED_EMPTY_IN_IF" : "Bloky 'když' vyžadují podmínku.",
"ERROR_RED_EMPTY_IN_IF_ELSE" : "Bloky 'když-jinak' vyžadují podmínku.",
"ERROR_RED_EMPTY_IN_WAIT" : "Bloky 'čekej dokud nenastane' vyžadují podmínku.",
"ERROR_RED_EMPTY_IN_WAIT_MILLI" : "Bloky 'čekej millisekund' vyžadují vstupní hodnotu.",
"ERROR_RED_EMPTY_IN_REP" : "Bloky 'opakuj dokud nenastane' vyžadují podmínku.",
"ERROR_RED_EMPTY_IN_BS_RIGHT" : "Bloky 'bitový posun doprava' vyžadují proměnnou.",
"ERROR_RED_EMPTY_IN_BS_LEFT" : "Bloky 'bitový posun doleva' vyžadují proměnnou.",
"ERROR_RED_EMPTY_IN_OPERATOR_NOT" : "Bloky 'ne' vyžadují podmínku.",
"ERROR_RED_EMPTY_IN_OPERATOR_AND" : "Bloky 'a' vyžadují podmínku.",
"ERROR_RED_EMPTY_IN_OPERATOR_OR" : "Bloky 'nebo' vyžadují podmínku.",
"ERROR_RED_EMPTY_BACKGROUND_MUSIC" : "Bloky 'hraj hudbu na pozadí' musí obsahovat alespoň jednu notu.",
"ERROR_RED_NO_START" : "Programy musí obsahovat událost 'Start', aby správně fungovaly. Pokud vidíš tuto chybu, otevři menu, vyber 'Nový' a začni vytvářet nový program.",
"ERROR_RED_NOT_BACKGROUND_MUSIC" : "Bloky 'hraj hudbu na pozadí' mohou obsahovat pouze noty.",
"ERROR_RED_NO_MAIN_BLOCKS" : "Žádné bloky nejsou připojeny k události 'Start'.",
"ERROR_RED_EMPTY_IN_USB_RECEIVED" : "Bloky 'čekej na data USB' vyžadují proměnnou.",
"ERROR_RED_DEVIDE_BY_ZERO" : "Bloky 'operátor dělení' nemohou dělit nulou.",
"ERROR_RED_FUNCTION_IN_FUNCTION" : "Bloky volání funkce nemohou být umístěny v bloku začátku funkce.",
"ERROR_YELLOW_RECEIVE_MESSAGE_OBS_ON" : "Edison nemůže přijímat zprávy, pokud je zapnuté zjišťování překážek. Ujisti se, že je před přijímáním zprávy v programu zjišťování překážek vypnuté.",
"ERROR_YELLOW_RECEIVE_REMOTE_OBS_ON" : "Edison nemůže přijímat kódy z dálkového ovladače, pokud je zjišťování překážek zapnuté. Ujisti se, že je před přijímáním kódu z ovladače v programu zjišťování překážek vypnuté.",
"ERROR_YELLOW_RECEIVE_MESSAGE_EVENT_OBS_ON" : "Edison nemůže přijímat zprávy, pokud je zapnuté zjišťování překážek. Ujisti se, že je před přijímáním zprávy v hlavním programu zjišťování překážek vypnuté.",
"ERROR_YELLOW_RECEIVE_REMOTE_EVENT_OBS_ON" : "Edison nemůže přijímat kódy z dálkového ovladače, pokud je zjišťování překážek zapnuté. Ujisti se, že je před přijímáním kódu z ovladače v hlavním programu zjišťování překážek vypnuté.",
"ERROR_YELLOW_READ_LIGHT_LINE_OFF" : "Zvaž zapnutí zjišťování čáry použitím bloku 'sledování čáry' z kategorie 'Vnímání', pokud měříš odrazivost povrchu.",
"ERROR_YELLOW_OPPERATOR_WAIT_UNTIL" : "Blok 'operátor' v bloku 'čekej dokud nenastane' může způsobit, že Edison bude čekat nekonečně dlouho nebo blok 'čekej' přeskočí.",
"ERROR_YELLOW_OPPERATOR_REPEAT_UNTIL" : "Blok 'operátor' v bloku 'opakuj dokud nenastane' může způsobit, že Edison bude provádět cyklus nekonečně dlouho nebo blok 'opakuj' přeskočí.",
"ERROR_YELLOW_OPPERATOR_WAIT" : "Blok 'operátor' v bloku 'čekej' může způsobit, že Edison blok 'čekej' přeskočí.",
"ERROR_YELLOW_OPPERATOR_REPEAT" : "Blok 'operátor' v bloku 'opakuj' může způsobit, že Edison blok 'opakuj' přeskočí.",
"ERROR_YELLOW_OPPERATOR_DRIVE_FOR_UNTIL" : "Blok 'operátor' v bloku 'jeď vpřed dokud nenastane' může způsobit, že Edison pojede nekonečně dlouho nebo blok 'jeď vpřed' přeskočí.",
"ERROR_YELLOW_OPPERATOR_DRIVE_BACK_UNTIL" : "Blok 'operátor' v bloku 'jeď vzad dokud nenastane' může způsobit, že Edison pojede nekonečně dlouho nebo blok 'jeď vzad' přeskočí.",
"ERROR_YELLOW_OPPERATOR_DRIVE_LEFT_UNTIL" : "Blok 'operátor' v bloku 'doleva dokud nenastane' může způsobit, že Edison pojede nekonečně dlouho nebo blok 'doleva' přeskočí.",
"ERROR_YELLOW_OPPERATOR_DRIVE_RIGHT_UNTIL" : "ABlok 'operátor' v bloku 'doprava dokud nenastane' může způsobit, že Edison pojede nekonečně dlouho nebo blok 'doprava' přeskočí.",
"ERROR_YELLOW_OPPERATOR_DRIVE_FOR_DIST" : "Blok 'operátor' v bloku 'jeď vpřed' může způsobit, že Edison blok 'jeď vpřed' přeskočí.",
"ERROR_YELLOW_OPPERATOR_DRIVE_BACK_DIST" : "Blok 'operátor' v bloku 'jeď vzad' může způsobit, že Edison blok 'jeď vzad' přeskočí.",
"ERROR_YELLOW_OPPERATOR_DRIVE_LEFT_DIST" : "Blok 'operátor' v bloku 'jeď doleva' může způsobit, že Edison blok 'jeď doleva' přeskočí.",
"ERROR_YELLOW_OPPERATOR_DRIVE_RIGHT_DIST" : "Blok 'operátor' v bloku 'jeď doprava' může způsobit, že Edison blok 'jeď doprava' přeskočí.",
"ERROR_YELLOW_DRIVE_LIGHT" : "Blok 'úroveň světla' v bloku 'jeď' může způsobit, že Edison pojede nekonečně dlouho nebo blok 'jeď' přeskočí.",
"ERROR_YELLOW_OPPERATOR_IR_MESSAGE" : "Blok 'operátor' v bloku 'pošli IR zprávu' nebude schopen poslat hodnotu větší než 255.",
"ERROR_YELLOW_FOREVER_LOOP_IN" : "Blok 'opakuj stále' bude pokračovat, dokud nezmáčkneš na Edisonu čtvercové tlačítko.",
"ERROR_YELLOW_SET_MOTOR_LEFT" : "Blok 'nastav levý motor' jen zapne levý motor. Ujisti se, že používáš další bloky v programu k ovládání délky běhu motoru.",
"ERROR_YELLOW_SET_MOTOR_RIGHT" : "Blok 'nastav pravý motor' jen zapne pravý motor. Ujisti se, že používáš další bloky v programu k ovládání délky běhu motoru.",
"ERROR_YELLOW_SET_MOTOR_BOTH" : "Blok 'nastav oba motory' jen zapne motory. Ujisti se, že používáš další bloky v programu k ovládání délky běhu motorů.",
"ERROR_YELLOW_CLAP_EVENT_DRIVE" : "Jízda motorů vytváří hluk, který může způsobit spuštění události tlesknutí. To může způsobit opakované spuštění bloků události tlesknutí při Edisonově jízdě.",
"ERROR_YELLOW_FLOAT_BLOCKS" : "Bloky nepřipojené ke žlutým blokům událostí nebudou nahrány do Edisona.",
"ERROR_YELLOW_WAIT_TIME_LIGHT" : "Úroveň světla bude nastavena na vysokou hodnotu, což může způsobit, že Edison bude čekat dlouho.",
"ERROR_YELLOW_REPEAT_LOOP_LIGHT" : "Úroveň světla bude nastavena na vysokou hodnotu, což může způsobit, že Edison bude opakovat cyklus dlouho.",
"ERROR_YELLOW_DRIVE_STRAIN" : "Blok 'zablokované motory' zjistí zablokování motorů, jen pokud jsou motory spuštěny.",
"ERROR_YELLOW_DRIVE_STRAIN_EVENT" : "K události 'motory zablokovány' může dojít, jen pokud jsou motory spuštěny.",
"ERROR_YELLOW_COMMENT" : "Komentáře jsou pomocné poznámky. Bloky komentářů nebudou nahrány do Edisona.",
"ERROR_YELLOW_USB_USED" : "USB bloky vyžadují, aby byl Edison připojen k zařízení.",
"ERROR_YELLOW_CLEAR_SENSOR" : "Nějaká data senzorů jsou uložena v Edisonově paměti. Může být nezbytné smazat tato data, aby tvůj program fungoval správně.",
"ERROR_YELLOW_CLEAR_LEARN_MORE" : "Zjisti více",
"MODAL_FIRMWARE_ERROR_TITLE" : "Firmware error", 
"MODAL_FIRMWARE_ERROR_BODY_1" : "A corrupted firmware file has been detected in your Edison robot.",
"MODAL_FIRMWARE_ERROR_BODY_2" : "This may have occurred during a firmware update that was interrupted.",
"MODAL_FIRMWARE_ERROR_BODY_3" : "Don't panic! This can be fixed by clicking the 'Fix firmware' button below.",
"MODAL_FIRMWARE_ERROR_CANCEL_BODY_1" : "Warning!", "MODAL_FIRMWARE_ERROR_CANCEL_BODY_2" : "Canceling this process means that your Edison robot can not be programmed.", "MODAL_FIRMWARE_ERROR_CANCEL_BODY_3" : "It is recommended that you fix the firmware now by clicking the Fix firmware button.", "MODAL_FIRMWARE_ERROR_CANCEL_BODY_4" : "If you choose to cancel you can fix the firmware at a later time.", 
"MODAL_FIRMWARE_ERROR_BUTTON_FIX" : "Fix firmware", "MODAL_FIRMWARE_ERROR_BUTTON_CANCEL" : "Cancel", "MODAL_FIRMWARE_ERROR_BUTTON_CANCEL_CONFIRM" : "Confirm cancel", 
"MODAL_NEW_CONFIRM_HEADING" : "Jsi si jistý?",
"MODAL_NEW_CONFIRM_BODY_TEXT_1" : "Jsti si jistý, že chceš otevřít nový program?",
"MODAL_NEW_CONFIRM_BODY_TEXT_2" : "Všechny změny mohou být ztraceny!", 
"MODAL_NEW_CONFIRM_BUTTON_CANCEL" : "Zrušit", 
"MODAL_NEW_CONFIRM_BUTTON_PROCEED" : "Pokračovat", 
"CHANGELANG" : "Change language",
"HELP_TEXT_ALL_TITLE" : "Block help",
"HELP_TEXT_ALL_BLOCKS_EXAMPLE_USES" : "Example uses:",
"HELP_TEXT_ALL_BLOCKS_EXAMPLE_LOAD" : "Open program",
"HELP_TEXT_ALL_BLOCKS_WATCH_FOR" : "Watch out for:",
"HELP_TEXT_DRIVE_FORWARD_FOR_TITLE" : "forwards for",
"HELP_TEXT_DRIVE_FORWARD_FOR_BODY_1" : "The forwards for block drives the wheels to move the robot in the forward direction.",
"HELP_TEXT_DRIVE_FORWARD_FOR_BODY_2" : "The block has three parameters:",
"HELP_TEXT_DRIVE_FORWARD_FOR_BODY_3" : "Value - Can be a constant (typed into the input and does not vary), a variable, a sensing or an operator block.",
"HELP_TEXT_DRIVE_FORWARD_FOR_BODY_4" : "Units - There are three options that can be selected: cm, inch and seconds.",
"HELP_TEXT_DRIVE_FORWARD_FOR_BODY_5" : "Speed - The speed can be either selected from 1 to 10 (as a constant value), a variable, a sensing or an operator block. ",
"HELP_TEXT_DRIVE_FORWARD_FOR_BODY_6" : "The forwards for block will complete before the next block will run. For example, using the forwards for block will not run other blocks in the program at the same time. To do this see the set both motors to block.  ",
"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_1_TITLE" : "Example 1: Beep, then drive the Edison robot forward 15 cm at speed 1, then beep again. ",
"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_1_BODY_1" : "In this example program, Edison beeps, but does not start driving until the beep has finished playing. Also, the second beep does not start until Edison has stopped driving.",
"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_2_TITLE" : "Example 2: Setting the drive distance using a variable and data from a sensor",
"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_2_BODY_1" : "In this example program Edison sets the Distance variable to the light level from the left light sensor (a value from 1 to 1,000) divided by 50. The Edison then drives forward for the value in the (Distance) variable at speed 5.  The result is that Edison drives further under brighter light and drives shorter under dimmer light.",
"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_3_TITLE" : "Example 3: Changing the drive speed using a variable.",
"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_3_BODY_1" : "In this example program, the variable Speed is set to 1. The program then enters a repeat loop for 10 times. Through each loop the Edison drives forward 5 cm at the speed in the variable. Initially, the value in the Speed variable is 1, so the Edison drives forward for 5cm at speed 1. The next block in the repeat increments (+1) the Speed variable. In the second repeat of the forwards block the value in the Speed variable is 2, so the Edison drives forward for 5cm at speed 2.",
"HELP_TEXT_DRIVE_FORWARD_FOR_EXAMPLE_3_BODY_2" : "This process repeats the full 10 times of the repeat loop, causing Edison to drive faster and faster until stopping when the program ends.",
"HELP_TEXT_DRIVE_BACKWARD_FOR_TITLE" : "backwards for ",
"HELP_TEXT_DRIVE_BACKWARD_FOR_BODY_1" : "The backwards for block drives the wheels to move the robot in the backward direction.",
"HELP_TEXT_DRIVE_BACKWARD_FOR_BODY_2" : "The block has three parameters:",
"HELP_TEXT_DRIVE_BACKWARD_FOR_BODY_3" : "Value - Can be a constant (typed into the input and does not vary), a variable, a sensing or an operator block.",
"HELP_TEXT_DRIVE_BACKWARD_FOR_BODY_4" : "Units - There are three options that can be selected: cm, inch and seconds.",
"HELP_TEXT_DRIVE_BACKWARD_FOR_BODY_5" : "Speed - The speed can be either selected from 1 to 10 (as a constant value), a variable, a sensing or an operator block.",
"HELP_TEXT_DRIVE_BACKWARD_FOR_BODY_6" : "The backwards for block will complete before the next block will run. For example, using the backwards for block will not run other blocks in the program at the same time. To do this see the set both motors to block.  ",
"HELP_TEXT_DRIVE_BACKWARD_FOR_EXAMPLE_1_TITLE" : "Example 1: LED lights on while driving",
"HELP_TEXT_DRIVE_BACKWARD_FOR_EXAMPLE_1_BODY_1" : "In this example program, the left LED turns on and stays on while the Edison drives backwards for one second. The left LED turns off after the Edison has stopped driving. The program then waits for one second before ending.  ",
"HELP_TEXT_DRIVE_BACKWARD_FOR_EXAMPLE_2_TITLE" : "Example 2: When there is an obstacle drive backwards",
"HELP_TEXT_DRIVE_BACKWARD_FOR_EXAMPLE_2_BODY_1" : "In this example program, the obstacle detection beam is first turned on. The program then enters a forever loop. Inside the loop the wait until block stops the program from progressing until an obstacle is detected anywhere, when this happens the Edison drives backwards one inch at speed 10. This behaviour repeats forever in a loop. This results in Edison backing away from objects placed in front of it.",
"HELP_TEXT_DRIVE_LEFT_FOR_TITLE" : "left for",
"HELP_TEXT_DRIVE_LEFT_FOR_BODY_1" : "The left for block drives the wheels to move the robot in the left direction. ",
"HELP_TEXT_DRIVE_LEFT_FOR_BODY_2" : "The block has four parameters:",
"HELP_TEXT_DRIVE_LEFT_FOR_BODY_3" : "Movement - There are three options that can be selected: spin, turn forwards and turn backwards.",
"HELP_TEXT_DRIVE_LEFT_FOR_BODY_4" : "Value - Can be a constant (typed into the input and does not vary), a variable, a sensing or an operator block.",
"HELP_TEXT_DRIVE_LEFT_FOR_BODY_5" : "Units - There are two options that can be selected: degrees and seconds.",
"HELP_TEXT_DRIVE_LEFT_FOR_BODY_6" : "Speed - The speed can be either selected from 1 to 10 (as a constant value), a variable, a sensing or an operator block. ",
"HELP_TEXT_DRIVE_LEFT_FOR_BODY_7" : "Turning and spinning is more accurate at lower speeds. This is because the wheels can lose traction and slip at high speeds. Speed 1 is best when accurate turning is needed.",
"HELP_TEXT_DRIVE_LEFT_FOR_BODY_8" : "The left for block must complete before the next block will run. For example, using the left for block will not run other blocks in the program at the same time. To do this see the set both motors to block.",
"HELP_TEXT_DRIVE_LEFT_FOR_EXAMPLE_1_TITLE" : "Example program 1: beep, spin, beep",
"HELP_TEXT_DRIVE_LEFT_FOR_EXAMPLE_1_BODY_1" : "In this example program, Edison beeps, but does not start spinning until the beep has finished playing. Also, the second beep does not start until Edison has stopped spinning.",
"HELP_TEXT_DRIVE_LEFT_FOR_EXAMPLE_2_TITLE" : "Example program 2: Drive in a square",
"HELP_TEXT_DRIVE_LEFT_FOR_EXAMPLE_2_BODY_1" : "In this example program, the repeat loop repeats driving forwards for 10cm at speed 1 and turning forward left for 90 degrees four times. This results in Edison driving in a square pattern.",
"HELP_TEXT_DRIVE_RIGHT_FOR_TITLE" : "right for",
"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_1" : "The right for block drives the wheels to move the robot in the left direction. ",
"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_2" : "The block has four parameters:",
"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_3" : "Movement - There are three options that can be selected: spin, turn forwards and turn backwards.",
"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_4" : "Value - Can be a constant (typed into the input and does not vary), a variable, a sensing or an operator block.",
"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_5" : "Units - There are two options that can be selected: degrees and seconds. ",
"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_6" : "Speed - The speed can be either selected from 1 to 10 (as a constant value), a variable, a sensing or an operator block.",
"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_7" : "Turning and spinning is more accurate at lower speeds. This is because the wheels can lose traction and slip at high speeds. Speed 1 is best when accurate turning is needed.    ",
"HELP_TEXT_DRIVE_RIGHT_FOR_BODY_8" : "The right for block must complete before the next block will run. For example, using the right for block will not run other blocks in the program at the same time. To do this see the set both motors to block.",
"HELP_TEXT_DRIVE_RIGHT_FOR_EXAMPLE_1_TITLE" : "Example program 1: Beep, spin, beep",
"HELP_TEXT_DRIVE_RIGHT_FOR_EXAMPLE_1_BODY_1" : "In this example program Edison beeps, but does not start spinning until the beep has finished playing. Also, the second beep does not start until Edison has stopped spinning.",
"HELP_TEXT_DRIVE_RIGHT_FOR_EXAMPLE_2_TITLE" : "Example 2: Spin right with the speed controlled by the light level",
"HELP_TEXT_DRIVE_RIGHT_FOR_EXAMPLE_2_BODY_1" : "In this example program Edison spins right inside a forever loop. Each time the right for block runs Edison spins 1 degree. The speed is set by the light level reading from the left light sensor (1 to 1,000) and is divided by 100 (result 0 to 10). The result is that Edison spins faster under brighter light and slower under dimmer light. ",
"HELP_TEXT_DRIVE_RIGHT_FOR_EXAMPLE_3_TITLE" : "Example program 3: Avoid obstacles",
"HELP_TEXT_DRIVE_RIGHT_FOR_EXAMPLE_3_BODY_1" : "In this example program, the obstacle detection beam is turned on. The program then enters a forever loop where both motors are set to drive forwards. The program then waits until an obstacle is detected anywhere. When this happens, the program progresses to the next block and the Edison robot spins right for 180 degrees at speed 1. This results in Edison driving away from obstacles in its path.",
"HELP_TEXT_DRIVE_FORWARD_UNTIL_TITLE" : "forwards until",
"HELP_TEXT_DRIVE_FORWARD_UNTIL_BODY_1" : "The forwards until block drives the wheels to move the robot in the forwards direction until the specified condition is true. Once the specified condition is true the wheels stop and the program progresses to the next block.",
"HELP_TEXT_DRIVE_FORWARD_UNTIL_BODY_2" : "The block has two parameters:",
"HELP_TEXT_DRIVE_FORWARD_UNTIL_BODY_3" : "Conditional input - The conditional input accepts a diamond shaped block that can be either a sensing or operator block. ",
"HELP_TEXT_DRIVE_FORWARD_UNTIL_BODY_4" : "Speed - The speed can be either selected from 1 to 10 (as a constant value) a variable, a sensing or an operator block. ",
"HELP_TEXT_DRIVE_FORWARD_UNTIL_BODY_5" : "The forwards until block must complete before the next block will run. For example, using the forwards until block will not run other blocks in the program at the same time. To do this see the set both motors to block.",
"HELP_TEXT_DRIVE_FORWARD_UNTIL_EXAMPLE_1_TITLE" : "Example program 1: Stop for an obstacle",
"HELP_TEXT_DRIVE_FORWARD_UNTIL_EXAMPLE_1_BODY_1" : "In this example program, the obstacle detection beam is turned on, then the robot drives forward at speed 5 until an obstacle is detected. When this happens, the robot stops moving and the program ends.  ",
"HELP_TEXT_DRIVE_FORWARD_UNTIL_EXAMPLE_2_TITLE" : "Example program 2: Bounce in borders",
"HELP_TEXT_DRIVE_FORWARD_UNTIL_EXAMPLE_2_BODY_1" : "In this example program, the line tracker LED is turned on, then the program enters a forever loop. Inside the loop the forwards until block drives the robot forward at speed 1 until the line tracker is on a non-reflective surface (i.e. black). When this happens, the next block runs which spins the robot left for 180 degrees at speed 5. The program then loops back to the forwards until block.  This results in Edison driving away from detected black lines.",
"HELP_TEXT_DRIVE_BACKWARD_UNTIL_TITLE" : "backwards until",
"HELP_TEXT_DRIVE_BACKWARD_UNTIL_BODY_1" : "The backwards until block drives the wheels to move the robot in the backwards direction until the specified condition is true. Once the specified condition is true the wheels stop and the program progresses to the next block.",
"HELP_TEXT_DRIVE_BACKWARD_UNTIL_BODY_2" : "The block has two parameters:",
"HELP_TEXT_DRIVE_BACKWARD_UNTIL_BODY_3" : "Conditional input - The conditional input accepts a diamond shaped block that can be either a sensing or operator block. ",
"HELP_TEXT_DRIVE_BACKWARD_UNTIL_BODY_4" : "Speed - The speed can be either selected from 1 to 10 (as a constant value), a variable, a sensing or an operator block.",
"HELP_TEXT_DRIVE_BACKWARD_UNTIL_BODY_5" : "The backwards until block must complete before the next block will run. For example, using the backwards until block will not run other blocks in the program at the same time. To do this see the set both motors to block.",
"HELP_TEXT_DRIVE_BACKWARD_UNTIL_EXAMPLE_1_TITLE" : "Example program 1: Stop when drive is strained",
"HELP_TEXT_DRIVE_BACKWARD_UNTIL_EXAMPLE_1_BODY_1" : "In this example program, the robot drives backwards at speed 10 until the wheels are strained (are unable to rotate or become stuck). When this happens, the motors stop and the program ends.",
"HELP_TEXT_DRIVE_BACKWARD_UNTIL_EXAMPLE_2_TITLE" : "Example program 2: Drive control with buttons",
"HELP_TEXT_DRIVE_BACKWARD_UNTIL_EXAMPLE_2_BODY_1" : "In this example, the program starts with a forever loop. The first block in the loop waits until the triangle button is pushed. When this happens, the robot drives backwards at speed 1 until the round button is pressed. When this happened the robot's wheels stop and the program loops back to waiting for the triangle button to be pressed. ",
"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_TITLE" : "left until ",
"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_BODY_1" : "The left until block drives the wheels to move the robot in the left direction until the specified condition is true. Once the specified condition is true the wheels stop and the program progresses to the next block. ",
"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_BODY_2" : "The block has three parameters: ",
"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_BODY_3" : "Movement - There are three options that can be selected: spin, turn forwards and turn backwards. ",
"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_BODY_4" : "Conditional input - The conditional input accepts a diamond shaped block that can be either a sensing or operator block.  ",
"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_BODY_5" : "Speed - The speed can be either selected from 1 to 10 (as a constant value), a variable, a sensing or an operator block. ",
"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_BODY_6" : "The spin left until block must complete before the next block will run. For example, using the spin left until block will not run other blocks in the program at the same time. To do this see the set both motors to block. ",
"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_EXAMPLE_1_TITLE" : "Example program 1: Stop when drive is strained ",
"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_EXAMPLE_1_BODY_1" : "In this example program, the robot drives forward left (right wheel moving) at speed 1 until the wheel becomes strained (unable to rotate or becomes stuck). When this happens, the motor stops and the program ends. ",
"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_EXAMPLE_2_TITLE" : "Example program 2: Follow light ",
"HELP_TEXT_DRIVE_LEFT_UNTIL_FOR_EXAMPLE_2_BODY_1" : "In this example, the program starts with a forever loop. The first block in the loop turns the robot left at speed 5 until the left light level is less than the right light level. When this happens the motor stops and the next block runs. The next block turns the robot right at speed 5 until the left light level is greater than the right light level. The result of this is that the Edison robot drives towards light.   ",
"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_TITLE" : "right until ",
"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_BODY_1" : "The right until block drives the wheels to move the robot in the right direction until the specified condition is true. Once the specified condition is true the wheels stop and the program progresses to the next block. ",
"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_BODY_2" : "The block has three parameters: ",
"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_BODY_3" : "Movement - There are three options that can be selected: spin, turn forwards and turn backwards. ",
"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_BODY_4" : "Conditional input - The conditional input accepts a diamond shaped block that can be either a sensing or operator block.  ",
"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_BODY_5" : "Speed - The speed can be either selected from 1 to 10 (as a constant value), a variable, a sensing or an operator block. ",
"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_BODY_6" : "The right until block must complete before the next block will run. For example, using the spin right until block will not run other blocks in the program at the same time. To do this see the set both motors to block. ",
"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_EXAMPLE_1_TITLE" : "Example program 1: Stop on black surface ",
"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_EXAMPLE_1_BODY_1" : "In this example, program the robot spins right at speed 5 until the line tracker detects a non-reflective surface (black). When this happens that motor stops and the program ends. ",
"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_EXAMPLE_2_TITLE" : "Example program 2: Follow light",
"HELP_TEXT_DRIVE_RIGHT_UNTIL_FOR_EXAMPLE_2_BODY_1" : "In this example, the program starts with a forever loop. The first block in the loop turns the robot left at speed 5 until the left light level is less than the right light level. When this happens the motor stops and the next block runs. The next block turns the robot right at speed 5 until the left light level is greater than the right light level. The result of this is that the Edison robot drives towards light. ",
"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_TITLE" : "Set both motors to ",
"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_BODY_1" : "The set both motors to block drives the wheels to move the robot in the selected direction and speed. As this drive block sets the motors, the program can continue straight to the next block. This is different to the drive blocks that have a distance, time or angle to complete before the program continues to the next block.  ",
"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_BODY_2" : "The block has two parameters: ",
"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_BODY_3" : "Movement - There are six options that can be selected: drive forwards, drive backwards, spin robot left, spin robot right, turn robot left and turn robot right. ",
"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_BODY_4" : "Speed - The speed can be either selected from 1 to 10 (as a constant value), a variable, a sensing or an operator block. ",
"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_EXAMPLE_1_TITLE" : "Example program 1: Music while driving ",
"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_EXAMPLE_1_BODY" : "In this example program the Edison robot is set to drive forward, then three notes are played while the robot is still driving. After the last note finishes playing the program ends and the Edison robot stops driving. ",
"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_EXAMPLE_2_TITLE" : "Example program 2: Drive until an obstacle  ",
"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_EXAMPLE_2_BODY" : "In this example program the obstacle detection beam is turned on, then both motors are set to drive forwards at speed 8. The next block waits until any obstacle is detected. When this happens, the program ends and the robot stops driving.  ",
"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_EXAMPLE_3_TITLE" : "Example program 3: Follow a line ",
"HELP_TEXT_DRIVE_SET_BOTH_MOTOR_EXAMPLE_3_BODY" : "In this example program, the line tracker LED is turned on and the program enters a forever loop. Inside the loop both motors are set to turn robot left at speed 1, then the wait until block holds the program there until the line tracker detects a reflective surface (white). When that happens, both motors are then set to turn robot right at speed 1 and the wait until block hold the program there until the line tracker detects a non-reflective surface (black). When that happens the program loops back to the start of the forever loop and repeats. This results in Edison following a non-reflective line. ",
"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_TITLE" : "set right motor to ",
"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_BODY_1" : "The set right motor to block drives the wheels to move the robot in the selected direction and speed. As this drive block sets the motors the program can continue straight to the next block. This is different to the drive blocks that have a distance, time or angle to complete before the program moves to the next block.  ",
"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_BODY_2" : "The block has two parameters: ",
"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_BODY_3" : "Movement - There are two options that can be selected: forwards and backwards. ",
"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_BODY_4" : "Speed - The speed can be either selected from 1 to 10 (as a constant value), a variable, a sensing or an operator block. ",
"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_EXAMPLE_1_TITLE" : "Example program 1: Motor on and off with a button press ",
"HELP_TEXT_DRIVE_SET_RIGHT_MOTOR_EXAMPLE_1_BODY" : "In this example, the program enters a forever loop. The first block in the loop waits until the round button is pressed. When this happens, the right motor is set to forwards at speed 5, the program then progresses to another wait until round button pressed block. When this happens, the right motor is stopped and the program loops back to the start of the forever loop.  ",
"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_TITLE" : "set left motor to ",
"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_BODY_1" : "The set left motor to block drives the wheels to move the robot in the selected direction and speed. As this drive block sets the motors the program can continue straight to the next block. This is different to the drive blocks that have a distance, time or angle to complete before the program moves to the next block.  ",
"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_BODY_2" : "The block has two parameters: ",
"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_BODY_3" : "Movement - There are two options that can be selected: forwards and backwards. ",
"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_BODY_4" : "Speed - The speed can be either selected from 1 to 10 (as a constant value), a variable, a sensing or an operator block. ",
"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_EXAMPLE_1_TITLE" : "Example program 1: Light following ",
"HELP_TEXT_DRIVE_SET_LEFT_MOTOR_EXAMPLE_1_BODY" : "In this example, the program enters a forever loop. The first block in the loop sets the left motor forwards at a calculated speed. The calculated speed is the light level from the right sensor minus the light level from the left sensor divided by 100, 3 is also added to the result to set a minimum speed. The next block sets the right motor to forwards at a calculated speed. The calculated speed is the light level from the left sensor minus the light level from the right sensor divided by 100, 3 is also added to the result to set a minimum speed. The program then loops back to the start of the forever loop. The calculated results control the speed so that the side that has the least amount of light drives the fastest. This results in the Edison robot always trying to face and drive towards the brightest light.  ",
"HELP_TEXT_DRIVE_STOP_TITLE" : "stop ",
"HELP_TEXT_DRIVE_STOP_BODY_1" : "The stop block stops the motors from driving the wheels.  ",
"HELP_TEXT_DRIVE_STOP_BODY_2" : "The stop block has only one parameter for selecting which motor/s are stopped. The options are both motors, left motor and right motor. ",
"HELP_TEXT_DRIVE_STOP_EXAMPLE_1_TITLE" : "Example program 1: Motor on and off with a button press ",
"HELP_TEXT_DRIVE_STOP_EXAMPLE_1_BODY" : "In this example, the program enters a forever loop. The first block in the loop waits until the round button is pressed. When this happens, the right motor is set to forwards at speed 5, the program then progresses to another wait until round button pressed block. When this happens, the right motor is stopped and the program loops back to the start of the forever loop. ",
"HELP_TEXT_LEDS_LEFT_TITLE" : "turn left LED  ",
"HELP_TEXT_LEDS_LEFT_BODY_1" : "The turn left LED block controls the left LED. There are two options on or off.  ",
"HELP_TEXT_LEDS_LEFT_EXAMPLE_1_TITLE" : "Example program 1: Blink left LED once ",
"HELP_TEXT_LEDS_LEFT_EXAMPLE_1_BODY" : "In this example the program begins by turning the left LED on, then waits for one second, then turns the left LED off. ",
"HELP_TEXT_LEDS_LEFT_EXAMPLE_2_TITLE" : "Example program 2: Blink left LED forever ",
"HELP_TEXT_LEDS_LEFT_EXAMPLE_2_BODY" : "In this example, the program begins by entering a forever loop. Inside the loop the left LED is turned on, then the program waits for one second, then the left LED is turned off, then the program waits for one second, then the program jumps to the beginning of the loop and repeats forever. ",
"HELP_TEXT_LEDS_RIGHT_TITLE" : "turn right LED ",
"HELP_TEXT_LEDS_RIGHT_BODY_1" : "The turn right LED block controls the right LED. There are two options on or off.  ",
"HELP_TEXT_LEDS_RIGHT_EXAMPLE_1_TITLE" : "Example program 1: Blink right LED once ",
"HELP_TEXT_LEDS_RIGHT_EXAMPLE_1_BODY" : "In this example, the program begins by turning the right LED on, then waits for one second, then turns the right LED off. ",
"HELP_TEXT_LEDS_RIGHT_EXAMPLE_2_TITLE" : "Example program 2: Blink right LED forever ",
"HELP_TEXT_LEDS_RIGHT_EXAMPLE_2_BODY" : "In this example, the program begins by entering a forever loop. Inside the loop the right LED is turned on, then the program waits for one second, then the right LED is turned off, then the program waits for one second, then the program jumps to the beginning of the loop and repeats forever. ",
"HELP_TEXT_LEDS_SEND_MESSAGE_TITLE" : "send IR message ",
"HELP_TEXT_LEDS_SEND_MESSAGE_BODY_1" : "The send IR message block sends data via infrared (IR) light. The data that can be sent is a value from 0 to 255. The value can be a constant (typed into the input and does not vary), a variable, a sensing or an operator block. ",
"HELP_TEXT_LEDS_SEND_MESSAGE_BODY_2" : "The sent data can be received by any other Edison robot that is in range of the IR light signal. The maximum range can be up to 10 meter/30 feet under ideal conditions (i.e. indoors, no direct sunlight, white ceiling and walls for the IR light to bounce off). ",
"HELP_TEXT_LEDS_SEND_MESSAGE_BODY_3" : "If you use a variable, the number in the variable could exceed the 255 limit (8-bits). When this happens, the number sent via IR will 'wrap around' (i.e. 256 sends 0, 257 sends 1, 258 sends 2...). ",
"HELP_TEXT_LEDS_SEND_MESSAGE_EXAMPLE_1_TITLE" : "Example program 1: Send IR message 1 when round button pressed ",
"HELP_TEXT_LEDS_SEND_MESSAGE_EXAMPLE_1_BODY" : "In this example, the program begins by entering a forever loop. Inside the loop the program waits for the round button to be pressed. When this happens, the IR message 1 is sent. The program then loops back to the beginning of the forever loop. ",
"HELP_TEXT_LEDS_SEND_MESSAGE_EXAMPLE_2_TITLE" : "Example program 2: Send light level every one second ",
"HELP_TEXT_LEDS_SEND_MESSAGE_EXAMPLE_2_BODY" : 'In this example, the program begins by entering a forever loop. Inside the loop the program sends the light level reading from the left light sensor divided by four. The value is divided by four as the output from the light sensor is 1 to 1,000, but the highest number that can be sent with IR is 255 (1,000/4" : 250). This additional calculation allows the full range of the light sensor to be sent. The program then waits for one second and then loops back to the start of the forever loop. ',
"HELP_TEXT_SOUND_BEEP_TITLE" : "beep",
"HELP_TEXT_SOUND_BEEP_BODY_1" : " The beep block plays a 3.5kHz beep sound for 125mS (0.125 seconds). ",
"HELP_TEXT_SOUND_BEEP_EXAMPLE_1_TITLE" : "Example program 1: Beep when round button is pressed",
"HELP_TEXT_SOUND_BEEP_EXAMPLE_1_BODY" : "In this example, the program begins by entering a forever loop. Inside the loop the program waits for the round button to be pressed. When this happens, the beep is played. The program then loops back to the start of the forever loop and repeats. ",
"HELP_TEXT_SOUND_PLAY_NOTE_TITLE" : "play a note",
"HELP_TEXT_SOUND_PLAY_NOTE_BODY_1" : "The play a note block plays a musical note. The block parameters allow the length, note and type of note to be selected.",
"HELP_TEXT_SOUND_PLAY_NOTE_BODY_2" : "The block has three parameters:",
"HELP_TEXT_SOUND_PLAY_NOTE_BODY_3" : "Length - There are four options: whole, half, quarter and eighth. ",
"HELP_TEXT_SOUND_PLAY_NOTE_BODY_4" : "Note - There are ten options: C, B, A, G, F, E, D, middle C, low B and rest.",
"HELP_TEXT_SOUND_PLAY_NOTE_BODY_5" : "Note modifier - There are three options: - (not modified), sharp and flat. ",
"HELP_TEXT_SOUND_PLAY_NOTE_BODY_6" : "The play a note block must complete before the next block will run. For example, using the play a note block will not run other blocks in the program at the same time. To do this see the play music in background block.",
"HELP_TEXT_SOUND_PLAY_NOTE_EXAMPLE_1_TITLE" : "Example program 1: Mary had a little lamb",
"HELP_TEXT_SOUND_PLAY_NOTE_EXAMPLE_1_BODY" : "In this example, the program begins by setting the tempo for the music notes, then plays the notes for the nursery rhyme Mary had a little lamb in order, playing each note fully before moving on.",
"HELP_TEXT_SOUND_SET_TEMPO_TITLE" : "set music tempo to",
"HELP_TEXT_SOUND_SET_TEMPO_BODY_1" : "The set music temp to block sets the tempo that following notes are played at. ",
"HELP_TEXT_SOUND_SET_TEMPO_BODY_2" : "There are five options: very slow, slow, medium, fast and very fast.",
"HELP_TEXT_SOUND_SET_TEMPO_EXAMPLE_1_TITLE" : "Example program 1: Mary had a little lamb",
"HELP_TEXT_SOUND_SET_TEMPO_EXAMPLE_1_BODY" : "In this example, the program begins by setting the tempo for the music notes, then plays the notes for the nursery rhyme Mary had a little lamb at that speed, playing each note fully before moving on.",
"HELP_TEXT_SOUND_PLAYINBACKGROUND_TITLE" : "Play music in background",
"HELP_TEXT_SOUND_PLAYINBACKGROUND_BODY_1" : "The play music in background block allows musical notes placed inside the block to play while the Edison robot is running other parts of the program. ",
"HELP_TEXT_SOUND_PLAYINBACKGROUND_EXAMPLE_1_TITLE" : "Example program 1: Mary had a little lamb while dancing",
"HELP_TEXT_SOUND_PLAYINBACKGROUND_EXAMPLE_1_BODY" : "In this example program, the program begins by setting the tempo for the music notes, then the notes inside the play music in background block start to play, the program enters the repeat loop and the spin left and spin right blocks run four times with the tune still playing in the background. This results in Edison dancing while playing music.",
"HELP_TEXT_VARIABLE_TITLE" : "Variable",
"HELP_TEXT_VARIABLE_BODY_1" : "A variable block is a place where data can be stored and used by a program. The data in a variable can vary and change while the program is running. This is why it is called a variable. ",
"HELP_TEXT_VARIABLE_BODY_2" : "The data in a variable is a number that can range from -1,073,741,824 to 1,073,741,823 (signed 32-bit).",
"HELP_TEXT_VARIABLE_BODY_3" : "Variables should be customised by naming them something that makes sense to the program. For example: ",
"HELP_TEXT_VARIABLE_BODY_4" : "If the number in a variable exceeds the range of -1,073,741,824 to 1,073,741,823, then the program will halt and Edison will play a failure tone. ",
"HELP_TEXT_VARIABLE_EXAMPLE_1_TITLE" : "Example program 1: A random flash rate set at the program start",
"HELP_TEXT_VARIABLE_EXAMPLE_1_BODY_1" : "In this example program, the variable 'FlashRate' is set to a random number between 10 and 100. The program then enters a forever loop. Inside the loop the left and right LEDs are turned on, then the program waits for the millisecond value in 'FlashRate', then turns off the left and right LEDs, then the program again waits for the millisecond value in 'FlashRate'. The program then loops back to the start of the forever loop and repeats. This results in Edison flashing its LEDs at different speeds each time the program is run",
"HELP_TEXT_VARIABLE_EXAMPLE_2_TITLE" : "Example program 2: Count black lines driven over",
"HELP_TEXT_VARIABLE_EXAMPLE_2_BODY_1" : "In this example program, the line tracker LED is first turned on, then the Edison robot drives forwards for 30cm at speed 5. While driving forward any detected non-reflective (black) surfaces by the line tracker will trigger the program to jump to the event block Line tracker on non-reflective surface. When this happens, the variable 'LineCount' is incremented (+1). When driving for 30 cm has completed the program repeats the wait for 1 second and beep blocks for the number of times in the variable 'LineCount'. ",
"HELP_TEXT_VARIABLE_EXAMPLE_3_TITLE" : "Example program 3: Light radiation counter",
"HELP_TEXT_VARIABLE_EXAMPLE_3_BODY_1" : "In this example program, the music tempo is first set to very fast. The program then enters a forever loop. Inside the loop the program sets the variable 'Delay' to 1000 minus the left light level (inverting the light level reading). The next block waits for the value in the 'Delay' variable. The program then plays the note C and loops back to the start of the forever loop and repeats. The result of this program is that Edison will beep slow when in darkness and faster when the light level is brighter. ",
"HELP_TEXT_DATA_SETVARIABLETO_TITLE" : "set to",
"HELP_TEXT_DATA_SETVARIABLETO_BODY_1" : "The set to block is used to set a value in a variable. ",
"HELP_TEXT_DATA_SETVARIABLETO_BODY_2" : "There are two inputs:",
"HELP_TEXT_DATA_SETVARIABLETO_BODY_3" : "Variable - This is where the variable block is placed.",
"HELP_TEXT_DATA_SETVARIABLETO_BODY_4" : "Value - Can be a constant (typed into the input and does not vary), a variable, a sensing or an operator block.",
"HELP_TEXT_DATA_SETVARIABLETO_EXAMPLE_1_TITLE" : "Example program 1: Set the number of beeps",
"HELP_TEXT_DATA_SETVARIABLETO_EXAMPLE_1_BODY_1" : "In this example program, the variable 'NumberOfBeeps' is set to 5, then the repeat block repeats the beeping for the value 5 held in the variable 'NumberOfBeeps'.",
"HELP_TEXT_DATA_SETVARIABLETO_EXAMPLE_2_TITLE" : "Example program 2: A random flash rate set at the program start",
"HELP_TEXT_DATA_SETVARIABLETO_EXAMPLE_2_BODY_1" : "In this example program, the variable 'FlashRate' is set to a random number between 10 and 1000. The program then enters a forever loop. Inside the loop the left and right LEDs are turned on, then the program waits for the millisecond value in 'FlashRate', then turns off the left and right LEDs, then the program again waits for the millisecond value in 'FlashRate'. The program then loops back to the start of the forever loop and repeats. This results in Edison flashing its LEDs at different speeds each time the program is run",
"HELP_TEXT_DATA_SETVARIABLETO_EXAMPLE_3_TITLE" : "Example program 3: Follow the light",
"HELP_TEXT_DATA_SETVARIABLETO_EXAMPLE_3_BODY_1" : "In this example, the program begins by entering a forever loop. Inside the loop the program sets the variable 'LightLeftvsRight' to the left light level minus the right light level. The if else block then tests whether the value in the variable 'LightLeftvsRight' is greater than 0. If the result is true, then the right motor is set to drive forwards and the left motor is stopped. If the result is false, then the left motor is set to drive forward and the right motor is stopped. The program then loops back to the start of the forever loop and repeats. This results in Edison driving towards the brightest light source.",
"HELP_TEXT_DATA_INCVARIABLE_TITLE" : "increment",
"HELP_TEXT_DATA_INCVARIABLE_BODY_1" : "The increment block increments (adds 1) to the variable placed in the block.",
"HELP_TEXT_DATA_INCVARIABLE_EXAMPLE_1_TITLE" : "Example program 1: Decelerating flashing ",
"HELP_TEXT_DATA_INCVARIABLE_EXAMPLE_1_BODY_1" : "In this example program, the variable 'Delay' is set to 0 the program then enters a forever loop. Inside the loop the variable 'Delay' is incremented (+1), then the right LED is turned on and the left LED is turned off, then the program waits for the value in the variable 'Delay' in milliseconds, then the right LED is turned off and the left LED is turned on and then again, the program waits for the value in the variable 'Delay' in milliseconds. The program then loops back to the start of the forever loop and repeats. As the program repeats through the forever loop, the variable 'Delay' is incremented each time making the time that the LEDs spend on and off longer and longer. After 1,000 loops the time the LEDs are on is one second and the time the LEDs are off is one second. ",
"HELP_TEXT_DATA_DECVARIABLE_TITLE" : "decrement",
"HELP_TEXT_DATA_DECVARIABLE_BODY_1" : "The decrement block decrements (minus 1) to the variable placed in the block.",
"HELP_TEXT_DATA_DECVARIABLE_EXAMPLE_1_TITLE" : "Example program 1: Accelerating flashing ",
"HELP_TEXT_DATA_DECVARIABLE_EXAMPLE_1_BODY_1" : "In this example program, the variable 'Delay' is set to 100 the program then enters a forever loop. Inside the loop the variable 'Delay' is decremented (-1), then the right LED is turned on and the left LED is turned off, then the program waits for the value in the variable 'Delay' in milliseconds, then the right LED is turned off and the left LED is turned on and then again, the program waits for the value in the variable 'Delay' in milliseconds. The program then loops back to the start of the forever loop and repeats. As the program repeats through the forever loop, the variable 'Delay' is decremented each time making the time that the LEDs spend on and off less. After 100 loops the time the LEDs are on is one millisecond and the time the LEDs are off is one millisecond. ",
"HELP_TEXT_BIT_SHIFT_RIGHT_TITLE" : "bit shift right",
"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_1" : "The bit shift right by block mathematically adjusts the connected variable block in its binary form by shifting the bits right by the set value.",
"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_2" : "The number format that computers use is called binary. It is a number system that is only comprised of the numbers 0 and 1. Each number inside a computer is a string of 1s and 0s. Here are some examples of binary numbers that are 8-bits long:",
"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_HUMAN" : "Human/decimal",
"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_COMPUTER" : "Computer/8-bit Binary",
"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_3" : "Here are some examples of binary numbers that are 32-bits long:",
"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_4" : "Edison V3 uses both 8-bit and 32-bit binary numbers. For example, variable blocks are able to store large 32-bit numbers (actually 31-bit signed), but only 8-bit numbers can be sent via the send IR message block. Further, some sensors, such as the light sensors have a range of 1 to 1000. As the highest possible 8-bit number is 255, then the full range of the light sensor reading cannot be sent via the send IR message block. This is where the bit shift right block can help!",
"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_5" : "The light sensor reading is 10-bit binary. Here are the minimum and maximum values:",
"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_6" : "If the number 1000 was sent with the send IR message block the received number would only be the last 8-bits. This would be 11111010 (binary) or 232 (human/decimal). This is a very different number to the actual light reading of 1000.   ",
"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_7" : "To send the light level data via the send IR message block, the bit shift right block can be used to shorten the number into an 8-bit number (shift right by 2) without losing too much of the data. Then, on the receiving end the bit shift left block can be used to restore the light level reading back to 10-bits (shift left by 2). ",
"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_4_LINE_1_BOX_1" : "Stage",
"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_4_LINE_2_BOX_1" : "Light reading",
"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_4_LINE_3_BOX_1" : "Bit shift right (2)",
"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_4_LINE_4_BOX_1" : "IR data send/receive",
"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_4_LINE_5_BOX_1" : "Bit shift left (2)",
"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_ARRAY_BIT" : "bit",
"HELP_TEXT_BIT_SHIFT_RIGHT_BODY_8" : "In this scenario the resulting number is not perfectly the same, as some information has been lost. However, the most significant bits containing more than 99% of the original data has been retained through this process.",
"HELP_TEXT_BIT_SHIFT_LEFT_TITLE" : "bit shift left",
"HELP_TEXT_BIT_SHIFT_LEFT_BODY_1" : "The bit shift left by block mathematically adjusts the connected variable block in its binary form by shifting the bits left by the set value.",
"HELP_TEXT_BIT_SHIFT_LEFT_BODY_2" : "The number format that computers use is called binary. It is a number system that is only comprised of the numbers 0 and 1. Each number inside a computer is a string of 1s and 0s. Here are some examples of binary numbers that are 8-bits long:",
"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_HUMAN" : "Human/decimal",
"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_COMPUTER" : "Computer/8-bit Binary",
"HELP_TEXT_BIT_SHIFT_LEFT_BODY_3" : "Here are some examples of binary numbers that are 32-bits long:",
"HELP_TEXT_BIT_SHIFT_LEFT_BODY_4" : "Edison V3 uses both 8-bit and 32-bit binary numbers. For example, variable blocks are able to store large 32-bit numbers (actually 31-bit signed), but only 8-bit numbers can be sent via the send IR message block. Further, some sensors, such as the light sensors have a range of 1 to 1000. As the highest possible 8-bit number is 255, then the full range of the light sensor reading cannot be sent via the send IR message block. This is where the bit shift right block can help!",
"HELP_TEXT_BIT_SHIFT_LEFT_BODY_5" : "The light sensor reading is 10-bit binary. Here are the minimum and maximum values:",
"HELP_TEXT_BIT_SHIFT_LEFT_BODY_6" : "If the number 1000 was sent with the send IR message block the received number would only be the last 8-bits. This would be 11111010 (binary) or 232 (human/decimal). This is a very different number to the actual light reading of 1000.   ",
"HELP_TEXT_BIT_SHIFT_LEFT_BODY_7" : "To send the light level data via the send IR message block, the bit shift right block can be used to shorten the number into an 8-bit number (shift right by 2) without losing too much of the data. Then, on the receiving end the bit shift left block can be used to restore the light level reading back to 10-bits (shift left by 2). ",
"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_4_LINE_1_BOX_1" : "Stage",
"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_4_LINE_2_BOX_1" : "Light reading",
"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_4_LINE_3_BOX_1" : "Bit shift right (2)",
"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_4_LINE_4_BOX_1" : "IR data send/receive",
"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_4_LINE_5_BOX_1" : "Bit shift left (2)",
"HELP_TEXT_BIT_SHIFT_LEFT_BODY_ARRAY_BIT" : "bit",
"HELP_TEXT_BIT_SHIFT_LEFT_BODY_8" : "In this scenario the resulting number is not perfectly the same, as some information has been lost. However, the most significant bits containing more than 99% of the original data has been retained through this process.",
"HELP_TEXT_EVENT_ANYOBSTACLE_TITLE" : "Any obstacle detected ",
"HELP_TEXT_EVENT_ANYOBSTACLE_BODY_1" : "The Any obstacle detected event block causes the program to jump to this block when any obstacle is detected by the obstacle detector.",
"HELP_TEXT_EVENT_ANYOBSTACLE_BODY_2" : "Always ensure that the obstacle detector beam is turned on in the main program.",
"HELP_TEXT_EVENT_ANYOBSTACLE_EXAMPLE_1_TITLE" : "Example program 1: Beep when any obstacle is detected.",
"HELP_TEXT_EVENT_ANYOBSTACLE_EXAMPLE_1_BODY_1" : "In this example program, the obstacle detector is first turned on, the program then enters the forever loop block. When any obstacle is detected, the program jumps out of the forever loop and goes to the Any obstacle detected event block. This causes the beep block to run and the Edison robot beeps. The program then returns to where it left from in the main program.",
"HELP_TEXT_EVENT_ANYOBSTACLE_EXAMPLE_2_TITLE" : "Example program 2: Stop driving when there is an obstacle",
"HELP_TEXT_EVENT_ANYOBSTACLE_EXAMPLE_2_BODY_1" : "In this example program, the obstacle detector is first turned on, then both motors are set to drive forwards at speed 5, the program then enters the forever loop block. When any obstacle is detected, the program jumps out of the forever loop and goes to the Any obstacle detected event block. This causes the stop both motors block to run and stops both motors from running. The program then returns to where it left from in the main program.",
"HELP_TEXT_EVENT_ANYOBSTACLE_EXAMPLE_3_TITLE" : "Example program 3: Avoid obstacles",
"HELP_TEXT_EVENT_ANYOBSTACLE_EXAMPLE_3_BODY_1" : "In this example program, the obstacle detector is first turned on, then the program enters a forever loop, inside the loop both motors are set to drive forwards at speed 5. When any obstacle is detected, the program jumps out of the forever loop and goes to the Any obstacle detected event block. The blocks under the Any obstacle detected event block drive the Edison backwards for 1 cm at speed 1, then spin left for 120 degrees at speed 1. The program then returns to where it left in the forever loop and both motors are set to drive forward at speed 5 again.  This results in Edison driving away from obstacles in its path.",
"HELP_TEXT_OBSTACLE_LEFT_EVENT_TITLE" : "Obstacle detected left",
"HELP_TEXT_OBSTACLE_LEFT_EVENT_BODY_1" : "The Obstacle detected left event block causes the program to jump to this block when an obstacle is detected on the left by the obstacle detector.",
"HELP_TEXT_OBSTACLE_LEFT_EVENT_BODY_2" : "Always ensure that the obstacle detector beam is turned on in the main program.",
"HELP_TEXT_OBSTACLE_LEFT_EVENT_EXAMPLE_1_TITLE" : "Example program 1: Beep when an obstacle is detected on the left",
"HELP_TEXT_OBSTACLE_LEFT_EVENT_EXAMPLE_1_BODY_1" : "In this example program, the obstacle detector is first turned on, the program then enters the forever loop block. When an obstacle is detected to the left, the program jumps out of the forever loop and goes to the Obstacle detected left event block. This causes the beep block to run and the Edison robot beeps. The program then returns to where it left in the forever loop block.",
"HELP_TEXT_OBSTACLE_RIGHT_EVENT_TITLE" : "Obstacle detected right",
"HELP_TEXT_OBSTACLE_RIGHT_EVENT_BODY_1" : "The Obstacle detected right event block causes the program to jump to this block when an obstacle is detected on the right by the obstacle detector.",
"HELP_TEXT_OBSTACLE_RIGHT_EVENT_BODY_2" : "Always ensure that the obstacle detector beam is turned on in the main program.",
"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_1_TITLE" : "Example program 1: Beep when an obstacle is detected on the right",
"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_1_BODY_1" : "In this example program, the obstacle detector is first turned on, the program then enters the forever loop block. When an obstacle is detected to the right, the program jumps out of the forever loop and goes to the Obstacle detected right event block. This causes the beep block to run and the Edison robot beeps. The program then returns to where it left in the forever loop block.",
"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_2_TITLE" : "Example program 2: Obstacle evader",
"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_2_BODY_1" : "In this example program, the obstacle detector is first turned on, the program then enters the forever loop block. When…",
"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_2_BODY_2" : "…an obstacle is detected ahead the program jumps to the Obstacle detected ahead event block and the Edison robot drives backwards for 0.25 seconds at speed 10 and then returns to where it left in the forever loop block.",
"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_2_BODY_3" : "…an obstacle is detected to the right the program jumps to the Obstacle detected right event block and the Edison robot turns left backwards for 0.25 seconds at speed 10 and then returns to where it left in the forever loop block.",
"HELP_TEXT_OBSTACLE_RIGHT_EVENT_EXAMPLE_2_BODY_4" : "…an obstacle is detected to the left the program jumps to the Obstacle detected left event block and the Edison robot turns right backwards for 0.25 seconds at speed 10 and then returns to where it left in the forever loop block.",
"HELP_TEXT_OBSTACLE_AHEAD_EVENT_TITLE" : "Obstacle detected ahead",
"HELP_TEXT_OBSTACLE_AHEAD_EVENT_BODY_1" : "The Obstacle detected ahead event block causes the program to jump to this block when an obstacle is detected ahead by the obstacle detector. This means that, at the same time, both the left and right obstacle detectors have detected an obstacle. ",
"HELP_TEXT_OBSTACLE_AHEAD_EVENT_BODY_2" : "Always ensure that the obstacle detector beam is turned on in the main program.",
"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_1_TITLE" : "Example program 1: Beep when an obstacle is detected ahead",
"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_1_BODY_1" : "In this example program, the obstacle detector is first turned on, the program then enters the forever loop block. When an obstacle is detected to the right, the program jumps out of the forever loop and goes to the Obstacle detected right event block. This causes the beep block to run and the Edison robot beeps. The program then returns to where it left in the forever loop block.",
"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_2_TITLE" : "Example program 2: The obstacle evader",
"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_2_BODY_1" : "In this example program, the obstacle detector is first turned on, the program then enters the forever loop block. When…",
"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_2_BODY_2" : "…an obstacle is detected ahead the program jumps to the Obstacle detected ahead event block and the Edison robot drives backwards for 0.25 seconds at speed 10 and then returns to where it left in the forever loop block.",
"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_2_BODY_3" : "…an obstacle is detected to the right the program jumps to the Obstacle detected right event block and the Edison robot turns left backwards for 0.25 seconds at speed 10 and then returns to where it left in the forever loop block.",
"HELP_TEXT_OBSTACLE_AHEAD_EVENT_EXAMPLE_2_BODY_4" : "…an obstacle is detected to the left the program jumps to the Obstacle detected left event block and the Edison robot turns right backwards for 0.25 seconds at speed 10 and then returns to where it left in the forever loop block.",
"HELP_TEXT_CLAP_EVENT_TITLE" : "Clap detected",
"HELP_TEXT_CLAP_EVENT_BODY_1" : "The Clap detected event block causes the program to jump to this block when a clap is detected.",
"HELP_TEXT_CLAP_EVENT_BODY_2" : "When Edison is driving the motor noise and bumping cause the clap sensor to trigger, so it's best not to use the clap sensor when driving. Also, if there are likely to be false or unwanted noise detections, then the clap sensor data can be cleared with the clear sensor data block set to clap detector (see example program). ",
"HELP_TEXT_CLAP_EVENT_EXAMPLE_1_TITLE" : "Example program: Edison is scared of loud noises",
"HELP_TEXT_CLAP_EVENT_EXAMPLE_1_BODY_1" : "In this example, the program begins by entering an empty forever loop and nothing happens. When a clap (or other loud scary sound) is detected, the program jumps out of the forever loop and goes to the Clap detected event block. The blocks below the Clap detected event block then run, driving backwards 5 cm at speed 10 (jump in fright), then entering a repeat loop set to 25 times where the spin left and spin right blocks repeatedly run causing the Edison to vibrate (shiver in fright).  Finally, (when Edison recovers from its fright) the clear sensor data block clears out any false clap detections that may have occurred while driving. The program now returns to the forever loop.  ",
"HELP_TEXT_TRIANGLEBUTTON_EVENT_TITLE" : "Triangle button pressed",
"HELP_TEXT_TRIANGLEBUTTON_EVENT_BODY_1" : "The Triangle button pressed event block causes the program to jump to this block when the triangle button is pressed.",
"HELP_TEXT_TRIANGLEBUTTON_EVENT_EXAMPLE_1_TITLE" : "Example program: Control LED flash speed setting with buttons",
"HELP_TEXT_TRIANGLEBUTTON_EVENT_EXAMPLE_1_BODY_1" : "In this example, the program begins by setting the variable called 'Delay' to 100, the program then enters a forever loop. Inside the forever loop, the left and right LEDs are turned on and off with a wait for the value in the 'Delay' variable in milliseconds. This results in the LEDs being on for 100 milliseconds (0.1 seconds) and off for 100 milliseconds (0.1 seconds). ",
"HELP_TEXT_TRIANGLEBUTTON_EVENT_EXAMPLE_1_BODY_2" : "When the triangle button is pressed, the program jumps to the Triangle button pressed event block. The blocks below the Triangle button pressed event block then run, setting the variable called 'Delay' to 50, then playing a beep. The program then returns to the forever loop, but now the value in the variable called 'Delay' is 50, so the time between the LEDs being on and off is now 50 milliseconds (0.05 seconds). This makes them flash on and off faster.    ",
"HELP_TEXT_TRIANGLEBUTTON_EVENT_EXAMPLE_1_BODY_3" : "When the round button is pressed, the program jumps to the Round button pressed event block. The blocks below the Round button pressed event block then run, setting the variable called 'Delay' to 200, then playing a beep. The program then returns to the forever loop, but now the value in the variable called 'Delay' is 200, so the time between the LEDs being on and off is now 200 milliseconds (0.2 seconds). This makes them flash on and off slower.    ",
"HELP_TEXT_ROUNDBUTTON_EVENT_TITLE" : "Round button pressed",
"HELP_TEXT_ROUNDBUTTON_EVENT_BODY_1" : "The Round button pressed event block causes the program to jump to this block when the round button is pressed.",
"HELP_TEXT_ROUNDBUTTON_EVENT_EXAMPLE_1_TITLE" : "Example program: Control LED flash speed setting with buttons",
"HELP_TEXT_ROUNDBUTTON_EVENT_EXAMPLE_1_BODY_1" : "In this example, the program begins by setting the variable called 'Delay' to 100, the program then enters a forever loop. Inside the forever loop, the left and right LEDs are turned on and off with a wait for the value in the 'Delay' variable in milliseconds. This results in the LEDs being on for 100 milliseconds (0.1 seconds) and off for 100 milliseconds (0.1 seconds). ",
"HELP_TEXT_ROUNDBUTTON_EVENT_EXAMPLE_1_BODY_2" : "When the triangle button is pressed, the program jumps to the Triangle button pressed event block. The blocks below the Triangle button pressed event block then run, setting the variable called 'Delay' to 50, then playing a beep. The program then returns to the forever loop, but now the value in the variable called 'Delay' is 50, so the time between the LEDs being on and off is now 50 milliseconds (0.05 seconds). This makes them flash on and off faster.    ",
"HELP_TEXT_ROUNDBUTTON_EVENT_EXAMPLE_1_BODY_3" : "When the round button is pressed, the program jumps to the Round button pressed event block. The blocks below the Round button pressed event block then run, setting the variable called 'Delay' to 200, then playing a beep. The program then returns to the forever loop, but now the value in the variable called 'Delay' is 200, so the time between the LEDs being on and off is now 200 milliseconds (0.2 seconds). This makes them flash on and off slower.     ",
"HELP_TEXT_LINEREFLECTIVE_EVENT_TITLE" : "Line tracker on reflective surface",
"HELP_TEXT_LINEREFLECTIVE_EVENT_BODY_1" : "The Line tracker on reflective surface event block causes the program to jump to this block when the line tracker sensor detects a change from a non-reflective surface (i.e. black) to a reflective surface (i.e. white).  ",
"HELP_TEXT_LINEREFLECTIVE_EVENT_BODY_2" : "The line tracker LED must be turned on for the Line tracker on reflective surface event block to work. ",
"HELP_TEXT_LINEREFLECTIVE_EVENT_EXAMPLE_1_TITLE" : "Example program: Follow the edge of a line",
"HELP_TEXT_LINEREFLECTIVE_EVENT_EXAMPLE_1_BODY_1" : "In this example, the program begins by turning on the line tracking LED, the program then causes the robot to turn right (looking for the edge of a line). ",
"HELP_TEXT_LINEREFLECTIVE_EVENT_EXAMPLE_1_BODY_2" : "When the line tracker detects a change from a reflective (white) to non-reflective (black) surface, the program jumps to the Line tracker on non-reflective surface block and runs the drive block to set the robot to turn left (turning back towards the reflective (white) surface).  ",
"HELP_TEXT_LINEREFLECTIVE_EVENT_EXAMPLE_1_BODY_3" : "When the line tracker detects a change from a non-reflective to reflective surface, the program jumps to the Line tracker on reflective surface event block and runs the drive block to set the robot to turn right (turning back towards the non-reflective (black) surface).  ",
"HELP_TEXT_LINEREFLECTIVE_EVENT_EXAMPLE_1_BODY_4" : "Each time the robot turns either left or right it moves forward following the edge of the line.",
"HELP_TEXT_LINENONREFLECTIVE_EVENT_TITLE" : "Line tracker on non-reflective surface",
"HELP_TEXT_LINENONREFLECTIVE_EVENT_BODY_1" : "The Line tracker on non-reflective surface event block causes the program to jump to this block when the line tracker sensor detects a change from a reflective surface (i.e. white) to a non-reflective surface (i.e. black).   ",
"HELP_TEXT_LINENONREFLECTIVE_EVENT_BODY_2" : "The line tracker LED must be turned on for the Line tracker on non-reflective surface event block to work. ",
"HELP_TEXT_LINENONREFLECTIVE_EVENT_EXAMPLE_1_TITLE" : "Example program: Follow the edge of a line",
"HELP_TEXT_LINENONREFLECTIVE_EVENT_EXAMPLE_1_BODY_1" : "In this example, the program begins by turning on the line tracking LED, the program then causes the robot to turn right (looking for the edge of a line). ",
"HELP_TEXT_LINENONREFLECTIVE_EVENT_EXAMPLE_1_BODY_2" : "When the line tracker detects a change from a reflective (white) to non-reflective (black) surface, the program jumps to the Line tracker on non-reflective surface block and runs the drive block to set the robot to turn left (turning back towards the reflective (white) surface).  ",
"HELP_TEXT_LINENONREFLECTIVE_EVENT_EXAMPLE_1_BODY_3" : "When the line tracker detects a change from a non-reflective to reflective surface, the program jumps to the Line tracker on reflective surface block and runs the drive block to set the robot to turn right (turning back towards the non-reflective (black) surface).  ",
"HELP_TEXT_LINENONREFLECTIVE_EVENT_EXAMPLE_1_BODY_4" : "Each time the robot turns either left or right it moves forward following the edge of the line.",
"HELP_TEXT_LINECHANGE_EVENT_TITLE" : "Line tracker changes surface",
"HELP_TEXT_LINECHANGE_EVENT_BODY_1" : "The Line tracker changes surface event block causes the program to jump to this block when the line tracker sensor detects either a change from a non-reflective (i.e. black) surface to reflective (i.e. white) surface or a from a reflective (i.e. white) surface to a non-reflective (i.e. black) surface. ",
"HELP_TEXT_LINECHANGE_EVENT_BODY_2" : "The line tracker LED must be turned on for the Line tracker changes surface event block to work.",
"HELP_TEXT_LINECHANGE_EVENT_EXAMPLE_1_TITLE" : "Example program: Stopping for change",
"HELP_TEXT_LINECHANGE_EVENT_EXAMPLE_1_BODY_1" : "In this example, the program begins by turning on the line tracker LED, the robot then drives forward at speed 1 and enters a forever loop. The robot will then continue to drive forwards until the line tracker sensor detects a change in the reflectivity of the surface (white to black or black to white). When this happens, the program jumps to the Line tracker changes surface block. The code below the Line tracker changes surface then runs, stopping both motors, beeping, waiting 1 second, beeping again, then setting both motors to again drive forward. ",
"HELP_TEXT_MESSAGE_EVENT_TITLE" : "IR message received",
"HELP_TEXT_MESSAGE_EVENT_BODY_1" : "The IR message received event block causes the program to jump to this block when an Infrared (IR) message from another Edison robot is received.",
"HELP_TEXT_MESSAGE_EVENT_BODY_3" : "The IR message received event block will not work when the IR receiver is being used to detect obstacles.   ",
"HELP_TEXT_MESSAGE_EVENT_BODY_4" : "The program will jump to the IR message received event block when any IR message is received from another Edison robot. The IR message received event block does not decode the data in the IR message. Decoding the message requires that the message data be put into a variable and then decoded using an if then block.  ",
"HELP_TEXT_MESSAGE_EVENT_EXAMPLE_1_TITLE" : "Example program: Receive IR message to beep once or twice",
"HELP_TEXT_MESSAGE_EVENT_EXAMPLE_1_BODY_1" : "In this example, the program begins by entering an empty forever loop and nothing happens. When an IR message is received the program jumps to the IR message received event block. The code below the IR message received event block then runs. First the received message data is stored in the variable 'ReceivedMessage'. This is required as each time the data from the received IR message is read it is also cleared. Now that the message data is in a variable the variable is tested if it is equal to 1, if true, then the beep block is played once. Next, the variable is tested if it is equal to 2, if true, then the beep block plays twice. The program now returns to the forever loop.",
"HELP_TEXT_MESSAGE_EVENT_EXAMPLE_2_TITLE" : "IR message sending program:",
"HELP_TEXT_MESSAGE_EVENT_EXAMPLE_2_BODY_1" : "The above program is used in the Edison robot that is sending the IR message. The program first enters an empty forever loop. When the triangle button is pressed, the program jumps to the Triangle button pressed event block and an IR message is sent with the number 1. When the round button is pressed, the program jumps to the Round button pressed event block and an IR message is sent with the number 2.",
"HELP_TEXT_DRIVESTRAIN_EVENT_TITLE" : "Drive strained",
"HELP_TEXT_DRIVESTRAIN_EVENT_BODY_1" : "The Drive strained event block causes the program to jump to this block when one or both motors are being driven, but are unable to rotate (under strain). ",
"HELP_TEXT_DRIVESTRAIN_EVENT_EXAMPLE_1_TITLE" : "Example program: Alarm when the left wheel cannot rotate",
"HELP_TEXT_DRIVESTRAIN_EVENT_EXAMPLE_1_BODY_1" : "In this example, the program begins by setting the left motor to drive forwards, then enters a forever loop. When the wheel cannot rotate due to being under strain, the program jumps to the Drive strained event block and runs the code below. The code below the Drive strained event block is the beep block which plays a beep. The program then returns to the forever loop.  ",
"HELP_TEXT_REMOTE_EVENT_TITLE" : "Remote code received",
"HELP_TEXT_REMOTE_EVENT_BODY_1" : "The Remote code received event block causes the program to jump to this block when a remote-control code is received.",
"HELP_TEXT_REMOTE_EVENT_BODY_3" : "Make sure you press the triangle button to start your program. This is easy to forget as the Edison robot will respond as a remote-control robot and not do what you have programmed it to. ",
"HELP_TEXT_REMOTE_EVENT_BODY_4" : "To use the remote control blocks the Edison robot must first be taught which buttons of your remote control correspond to which remote code. Learn more about this here: ",
"HELP_TEXT_REMOTE_EVENT_BODY_5" : "If the program behaves unexpectantly, you may need to use the clear sensor data block to clear the contents of the remote code received block. See example program 1 below.",
"HELP_TEXT_REMOTE_EVENT_BODY_6" : "Receiving infrared remote codes will work with approximately 90% of standard TV remote controls, however each brand uses slightly different data formats. When decoding data, this can cause some unexpected behaviour from one remote control brand to another. Advanced remote-control decoding works best with the EdRemote (available mid 2025).",
"HELP_TEXT_REMOTE_EVENT_EXAMPLE_1_TITLE" : "Example program: Remote control drive forwards or backwards ",
"HELP_TEXT_REMOTE_EVENT_EXAMPLE_1_BODY" : "In this example, the program begins by entering an empty forever loop. When a remote-control code is received the program jumps to the Remote code received event block. The code below the Remote code received event block runs, the remote code is tested to see if it is equal to 1, if true, then both motors are set to drive forwards, this continues until the code being received no longer equals 1. Next, the received code is tested to see if it is equal to 2, if true, then both motors are set to drive backwards. This continues until the code being received no longer equals 2. Finally, after the remote codes have been tested and are no longer being received the stop block stops both motors. The program returns to the empty forever loop.",
"HELP_TEXT_CONTROL_WAIT_TITLE" : "Wait sec",
"HELP_TEXT_CONTROL_WAIT_BODY_1" : "The wait sec block pauses the program for an amount of time in seconds. The amount of time can be from 0.001 seconds (1 millisecond) to 1,073,741 seconds (12.4 days).",
"HELP_TEXT_CONTROL_WAIT_BODY_2" : "The wait block has just one parameter:",
"HELP_TEXT_CONTROL_WAIT_BODY_3" : "Value - Can be a constant (typed into the input and does not vary), a variable, a sensing or an operator block.",
"HELP_TEXT_CONTROL_WAIT_EXAMPLE_1_TITLE" : "Example program 1: Blink the left LED ",
"HELP_TEXT_CONTROL_WAIT_EXAMPLE_1_BODY" : "In this example, the program begins by entering a forever loop. Inside the loop the left LED is turned on, then the program pauses and waits for 0.5 seconds, then the left LED is turned off, then the program again pauses and waits for 0.5 seconds and then loops to the start. ",
"HELP_TEXT_CONTROL_WAIT_EXAMPLE_2_TITLE" : "Example program 2: Nighttime robot cricket ",
"HELP_TEXT_CONTROL_WAIT_EXAMPLE_2_BODY" : "In this example, the program begins by entering a forever loop. Inside the loop there is a wait until block that pauses the progression of the program until the level of light on the left light sensor is less than 100. When this happens, the program progresses to wait for a random number of seconds between 20 and 300. When this wait ends the speaker plays a note. The program then loops back to the beginning of the forever loop. This results in behaviour similar to a cricket at nighttime, so it can't be found.",
"HELP_TEXT_CONTROL_REPEAT_TITLE" : "Repeat",
"HELP_TEXT_CONTROL_REPEAT_BODY_1" : "The repeat block is a type of loop that only loops a set number of times. All the blocks inside the repeat block run for only this set number of times. ",
"HELP_TEXT_CONTROL_REPEAT_BODY_2" : "The repeat block has just one parameter: ",
"HELP_TEXT_CONTROL_REPEAT_BODY_3" : "Value - Can be a constant (typed into the input and does not vary), a variable, a sensing or an operator block.",
"HELP_TEXT_CONTROL_REPEAT_EXAMPLE_1_TITLE" : "Example program 1: Drive in a square",
"HELP_TEXT_CONTROL_REPEAT_EXAMPLE_1_BODY" : "In this example, the program begins by entering into a repeat block that is set to repeat four times. Inside the repeat block the robot drives forward 10cm, then spins right 90 degrees. These two blocks inside the repeat block run four times. The result is that the Edison robot drives in the shape of a square.",
"HELP_TEXT_CONTROL_FOREVER_TITLE" : "Forever",
"HELP_TEXT_CONTROL_FOREVER_BODY_1" : "The forever block is a type of loop block that loops unconditionally forever (unless the program is stopped). The blocks placed inside the forever block run and then run again and again and…",
"HELP_TEXT_CONTROL_FOREVER_EXAMPLE_1_TITLE" : "Example program: Blink a LED",
"HELP_TEXT_CONTROL_FOREVER_EXAMPLE_1_BODY" : "In this example, the program begins by entering a forever loop. Inside the forever loop the left LED is turned on, then the wait block pauses the program for 0.25 seconds, then the left LED is turned off, then the wait block pauses the program for 0.25 seconds. The program then loops back to the turn left LED on block and the sequence repeats forever.",
"HELP_TEXT_CONTROL_IF_TITLE" : "If then",
"HELP_TEXT_CONTROL_IF_BODY_1" : "The if then block runs the blocks if the input condition is true. If the condition is not true, then the program continues to the next block in the program.",
"HELP_TEXT_CONTROL_IF_BODY_2" : "This block has one input parameter:",
"HELP_TEXT_CONTROL_IF_BODY_3" : "Conditional input - The conditional input accepts diamond shaped blocks that can be either an operator block or sensing block.",
"HELP_TEXT_CONTROL_IF_BODY_4" : "The if then block is usually used inside a forever loop, so that the if then condition can be tested multiple times. If a program has just an if then block, then the test will be run once and the program will exit. ",
"HELP_TEXT_CONTROL_IF_EXAMPLE_1_TITLE" : "Example program 1: Blink LED if there is a clap",
"HELP_TEXT_CONTROL_IF_EXAMPLE_1_BODY" : "n this example, the program begins by entering a forever loop. The first block in the forever loop is the if then block that tests if there has been a clap. If false, then the contents of the if then block is skipped and the program loops back to start of the forever loop. If a clap has been detected (true), then the blocks inside the if then block run. First the left LED is turned on, then the program pauses for one second, then the left LED is turned off. The program now loops back to the start of the forever loop.  The result is that the Edison robot blinks its left LED for one second whenever it detects a clap. ",
"HELP_TEXT_CONTROL_IF_EXAMPLE_2_TITLE" : "Example program 2: Draw open alarm",
"HELP_TEXT_CONTROL_IF_EXAMPLE_2_BODY" : "In this example, the program begins by entering a forever loop. The first block in the forever loop is the if then block that tests if the level of light on the left light sensor is greater than 100. If this is true (light level is greater than 100) then the beep block runs and the Edison robot beeps like an alarm. If it is not true (light level is less than 100), then the beep block is skipped and the program loops back to the start of the forever loop.  The result is that the Edison beeps rapidly whenever it detects a light level above 100.",
"HELP_TEXT_CONTROL_IF_ELSE_TITLE" : "If then else",
"HELP_TEXT_CONTROL_IF_ELSE_BODY_1" : "The if then else block runs the first set of blocks if the input condition is true. If the condition is false, then the second set of blocks run.",
"HELP_TEXT_CONTROL_IF_ELSE_BODY_2" : "This block has one input parameter:",
"HELP_TEXT_CONTROL_IF_ELSE_BODY_3" : "Conditional input - The conditional input accepts diamond shaped blocks that can be either an operator block or sensing block.",
"HELP_TEXT_CONTROL_IF_ELSE_BODY_4" : "The if then else block is usually used inside a forever loop, so that the if then else condition can be tested multiple times. If a program has just an if then else block, then the test will be run once and the program will exit.",
"HELP_TEXT_CONTROL_IF_ELSE_EXAMPLE_1_TITLE" : "Example program 1: Bounce in borders",
"HELP_TEXT_CONTROL_IF_ELSE_EXAMPLE_1_BODY" : "In this example, the program begins by turning the line tracker sensor LED on, then enters a forever loop. The first block in the forever loop is the if then else block that tests if the line tracker sensor is on a non-reflective surface (black). If this is true then the first set of blocks run driving the robot backwards and then spinning 90 degrees. The program jumps over the else block and then loops back to once again test if the line tracker sensor is on a non-reflective surface (black), if this is false (on white), then the else block runs, setting both motors to drive forward. This results in the Edison robot 'bouncing' off a black line and turning around. This results in Edison driving away from detected black lines.",
"HELP_TEXT_CONTROL_IF_ELSE_EXAMPLE_2_TITLE" : "Example program 2: Follow the light",
"HELP_TEXT_CONTROL_IF_ELSE_EXAMPLE_2_BODY" : "In this example, the program begins by entering a forever loop. The first block in the forever loop is the if then else block that tests if the light level on the right sensor is less than the light level on the left sensor. If this is true (light is brighter on the left) then the next block to run is the set both motors to turn robot left (the robot turns left towards the light). Alternatively, if the result is false (light is brighter on the right), then the next block to run are the else blocks. Now the block set both motors to turn robot right run (the robot turns towards the light). The result is that the Edison robot drives towards the brightest light source (try using a flashlight to control where Edison drives).",
"HELP_TEXT_CONTROL_WAIT_UNTIL_TITLE" : "Wait until",
"HELP_TEXT_CONTROL_WAIT_UNTIL_BODY_1" : "The wait until block pauses the program until the input condition is true.",
"HELP_TEXT_CONTROL_WAIT_UNTIL_BODY_2" : "This block has one input parameter:",
"HELP_TEXT_CONTROL_WAIT_UNTIL_BODY_3" : "Conditional input - The conditional input accepts diamond shaped blocks that can be either an operator block or sensing block.",
"HELP_TEXT_CONTROL_WAIT_UNTIL_BODY_4" : "The wait until block is usually used inside a forever loop, so that the wait until condition can be tested multiple times. If a program has just a wait until block, then the test will be run once and the program will exit.",
"HELP_TEXT_CONTROL_WAIT_UNTIL_EXAMPLE_1_TITLE" : "Example program 1: Blink LED if there is a clap",
"HELP_TEXT_CONTROL_WAIT_UNTIL_EXAMPLE_1_BODY" : "In this example, the program begins by entering a forever loop. The first block in the forever loop is the clear sensor data block that clears any false clap data. Next is the wait until block with a conditional input clap detected block. The program will pause here and wait until a clap is detected. When a clap is detected, the program progresses to turn the left LED on, then wait for one second, then turn the left LED off. The program now loops back to the wait until block. Each time there is a clap the left LED turns on for one second. The result is that the Edison robot blinks its left LED for one second whenever it detects a clap. ",
"HELP_TEXT_CONTROL_WAIT_UNTIL_EXAMPLE_2_TITLE" : "Example program 2: Source of brightest light detector",
"HELP_TEXT_CONTROL_WAIT_UNTIL_EXAMPLE_2_BODY" : "In this example, the program begins by entering a forever loop. The first block in the forever loop is the wait until block with a conditional input using an operator requiring the light level on the right light sensor to equal the light level on the left light sensor. If the condition is not true (the light levels are not equal), then the program pauses here. When the light level on both light sensors is equal, then the program progresses to the beep block. The program now loops back to the wait until block and the program repeats. This results in the Edison robot beeping when it is pointing towards the brightest source of light",
"HELP_TEXT_CONTROL_REPEAT_UNTIL_TITLE" : "Repeat until",
"HELP_TEXT_CONTROL_REPEAT_UNTIL_BODY_1" : "The repeat until block runs the blocks inside it, until the input condition is true.",
"HELP_TEXT_CONTROL_REPEAT_UNTIL_BODY_2" : "This block has one input parameter:",
"HELP_TEXT_CONTROL_REPEAT_UNTIL_BODY_3" : "Conditional input - The conditional input accepts diamond shaped blocks that can be either an operator block or sensing block.",
"HELP_TEXT_CONTROL_REPEAT_UNTIL_BODY_4" : "The repeat until block is often used inside a forever loop, so that the repeat until condition can be tested multiple times. If a program has just a repeat until block, then the test will be run once and the program will exit. ",
"HELP_TEXT_CONTROL_REPEAT_UNTIL_EXAMPLE_1_TITLE" : "Example program 1: Stop the alarm from sounding",
"HELP_TEXT_CONTROL_REPEAT_UNTIL_EXAMPLE_1_BODY" : "In this example, the program begins by tuning on the obstacle detector (setting the alarm) and then enters a forever loop. The first block in the forever loop is a wait until block with a conditional input of obstacle detected anywhere (the intruder detector). The program will pause and wait here until an obstacle (intruder) is detected. When an obstacle is detected, the program progresses to the repeat until block, this causes the beep block to be run and repeat over and over (the alarm sound), 'until' the round button is pressed (stopping and resetting the alarm).",
"HELP_TEXT_CONTROL_REPEAT_UNTIL_EXAMPLE_2_TITLE" : "Example program 2: Edison shivers cold without warm light",
"HELP_TEXT_CONTROL_REPEAT_UNTIL_EXAMPLE_2_BODY" : "In this example, the program begins by entering a forever loop. The first block in the forever loop is the repeat until block with a conditional input using an operator requiring the light level of the left light sensor to be greater than 980 (very bright/sunlight). If this is not true, then the blocks below run, quickly spinning the Edison robot left and right (shivering). If the light level of the left light sensor increases above 980 (Edison moves into very bright light), then the condition becomes true and the program pauses (The Edison robot is warm and happy).",
"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_TITLE" : "Wait Milliseconds",
"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_BODY_1" : "The wait milliseconds block pauses the program for an amount of time in milliseconds (ms). A millisecond is one one-thousandths (1/1000) of a second or 0.001 seconds.",
"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_BODY_2" : '1500 milliseconds" : 1.5 seconds',
"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_BODY_3" : '100 milliseconds" : 0.1 seconds',
"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_BODY_4" : '25 milliseconds" : 0.025 seconds',
"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_BODY_5" : "The wait milliseconds block has just one parameter:",
"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_BODY_6" : "Value - Can be a variable, a sensing or an operator block",
"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_EXAMPLE_1_TITLE" : "Example program 1: Fast blinking LED",
"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_EXAMPLE_1_BODY" : "In this example, the program begins by setting the variable 'Delay' to 50, then enters a forever loop. Inside the forever loop the left LED is turned on, then the wait milliseconds block pauses for the value in 'Delay' milliseconds, in this case 50 milliseconds. Then the left LED is turned off, then the wait milliseconds block pauses for 50 milliseconds. The program now loops back to the start of the forever loop. ",
"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_EXAMPLE_2_TITLE" : "Example program 2: Crazy lights",
"HELP_TEXT_CONTROL_WAIT_MILLISECONDS_EXAMPLE_2_BODY" : "In this example, the program begins by entering a forever loop. Inside the forever loop, the left and right LEDs are turned on and off. The wait times between turning on and off are controlled by the wait milliseconds blocks. The time in milliseconds is set by the random number blocks inside them. These are set to generate random numbers between 30 and 300 milliseconds. The result is a randomised flashing of the Edison robot's LED lights.",
"HELP_TEXT_SENSING_TURNLINETRACKINGLED_TITLE" : "Turn line tracking LED on/off",
"HELP_TEXT_SENSING_TURNLINETRACKINGLED_BODY_1" : "The turn line tracker LED on/off block sets the line tracker LED to either on or off. ",
"HELP_TEXT_SENSING_TURNLINETRACKINGLED_BODY_2" : "The line tracker LED must be on for the line tracking sensor to work. ",
"HELP_TEXT_SENSING_TURNLINETRACKINGLED_EXAMPLE_1_TITLE" : "Example program: Stop on black surface",
"HELP_TEXT_SENSING_TURNLINETRACKINGLED_EXAMPLE_1_BODY" : "In this example, the program begins by turning the line tracking LED on, then both motors are set to drive forwards. The program then waits until the line tracker sensor detects a non-reflective surface (black), when this happens the program ends and the motors stop. ",
"HELP_TEXT_SENSING_TURNOBSTACLEBEAM_TITLE" : "Turn obstacle detection beam on/off",
"HELP_TEXT_SENSING_TURNOBSTACLEBEAM_BODY_1" : "The turn obstacle detection beam on/off block sets the obstacle detection beam to either on or off.",
"HELP_TEXT_SENSING_TURNOBSTACLEBEAM_BODY_2" : "The obstacle detection beam must be on for obstacle detection to work.",
"HELP_TEXT_SENSING_TURNOBSTACLEBEAM_EXAMPLE_1_TITLE" : "Example program: Stop for an obstacle",
"HELP_TEXT_SENSING_TURNOBSTACLEBEAM_EXAMPLE_1_BODY" : "In this example, the program begins by turning the obstacle detection beam on, then both motors are set to drive forwards. The program then waits until an obstacle is detected anywhere, when this happens the program ends and the motors stop. ",
"HELP_TEXT_SENSING_CLEARSENSOR_TITLE" : "Clear sensor data",
"HELP_TEXT_SENSING_CLEARSENSOR_BODY_1" : "The clear sensor data block clears any sensor data (detections) from the selected sensor. This block is used when there might be false or unwanted detections that stop the program from working in the way that you want. An example is when a program drives the Edison robot as a result of detecting a clap. Generally, driving is quite noisy and can re-trigger an additional detection of a clap. This causes the program to detect a second clap that didn't happen. The clear sensor data block is used to clear the sensor data of any unwanted detections like this. ",
"HELP_TEXT_SENSING_CLEARSENSOR_BODY_2" : "The clear sensor data block has five input options:",
"HELP_TEXT_SENSING_CLEARSENSOR_BODY_3" : "clap detector",
"HELP_TEXT_SENSING_CLEARSENSOR_BODY_4" : "keypad",
"HELP_TEXT_SENSING_CLEARSENSOR_BODY_5" : "obstacle detector",
"HELP_TEXT_SENSING_CLEARSENSOR_BODY_6" : "remote code",
"HELP_TEXT_SENSING_CLEARSENSOR_BODY_7" : "IR message",
"HELP_TEXT_SENSING_CLEARSENSOR_EXAMPLE_1_TITLE" : "Example program 1: Clap and spin",
"HELP_TEXT_SENSING_CLEARSENSOR_EXAMPLE_1_BODY" : "In this example, the program begins by entering a forever loop. Inside the forever loop, the clear sensor data block is set to clear the clap detector, next the program waits until a clap is detected, when this happens the program progresses and the robot spins left for two seconds. During the spinning the motors, wheels and skid make noise, this noise re-triggers the clap detector, so now the clap detector thinks that there was a second clap. The program loops back to the start of the forever loop (still holding onto the clap detection), but then the clear sensor data block clears the detection and the wait until block will not be triggered until there actually is a clap. ",
"HELP_TEXT_SENSING_CLAPDETECTED_TITLE" : "Clap detected",
"HELP_TEXT_SENSING_CLAPDETECTED_BODY_1" : "The clap detected block is a sensor input block that indicates whether or not a clap has been detected. It is a diamond shaped block so the data in the block can only be either true (clap has been detected) or false (clap has not been detected).",
"HELP_TEXT_SENSING_CLAPDETECTED_BODY_2" : "Other noises such as the motors driving can cause the clap detected block to false trigger. Use the clear sensor data block to clear false or unwanted clap detections.",
"HELP_TEXT_SENSING_CLAPDETECTED_EXAMPLE_1_TITLE" : "Example program 1: Blink LED if there is a clap",
"HELP_TEXT_SENSING_CLAPDETECTED_EXAMPLE_1_BODY" : "In this example, the program begins by entering a forever loop. Inside the forever loop there is an if then block that tests if a clap has been detected. When a clap is detected, the left LED turns on, then the program waits for one second, then the left LED turns off. The program then loops back to the start of the forever loop.  The result is that the Edison robot blinks its left LED for one second whenever it detects a clap. ",
"HELP_TEXT_SENSING_BUTTONPRESSED_TITLE" : "Button Pressed",
"HELP_TEXT_SENSING_BUTTONPRESSED_BODY_1" : "The button pressed block is a sensor input that indicates whether or not a button has been pressed. There are two button options:",
"HELP_TEXT_SENSING_BUTTONPRESSED_BODY_2" : "round",
"HELP_TEXT_SENSING_BUTTONPRESSED_BODY_3" : "triangle",
"HELP_TEXT_SENSING_BUTTONPRESSED_BODY_4" : "The button pressed block is a diamond shaped block so the data in the block can only be either true (button has been pressed) or false (button has not been pressed).",
"HELP_TEXT_SENSING_BUTTONPRESSED_EXAMPLE_1_TITLE" : "Example program: Beep on button press",
"HELP_TEXT_SENSING_BUTTONPRESSED_EXAMPLE_1_BODY" : "In this example, the program begins by entering a forever loop. Inside the forever loop there is an if then block that tests if the round button has been pressed. When the round button is pressed, the program runs the beep block and then loops back to the start of the forever loop.",
"HELP_TEXT_SENSING_OBSTACLE_TITLE" : "Obstacle Detected",
"HELP_TEXT_SENSING_OBSTACLE_BODY_1" : "The obstacle detected block is a sensor input block that indicates whether or not an obstacle has been detected. There are four detection options:",
"HELP_TEXT_SENSING_OBSTACLE_BODY_2" : "anywhere",
"HELP_TEXT_SENSING_OBSTACLE_BODY_3" : "ahead",
"HELP_TEXT_SENSING_OBSTACLE_BODY_4" : "left",
"HELP_TEXT_SENSING_OBSTACLE_BODY_5" : "right",
"HELP_TEXT_SENSING_OBSTACLE_BODY_6" : "The obstacle detected block is a diamond shaped block so the data in the block can only be either true (obstacle has been detected) or false (obstacle has not been detected).",
"HELP_TEXT_SENSING_OBSTACLE_BODY_7" : "To use the obstacle detected block the turn obstacle detection beam on/off block must be used to turn the obstacle detection beam on. ",
"HELP_TEXT_SENSING_OBSTACLE_EXAMPLE_1_TITLE" : "Example program: Avoid obstacles",
"HELP_TEXT_SENSING_OBSTACLE_EXAMPLE_1_BODY" : "In this example, the program begins by setting the obstacle detection beam to on, then enters a forever loop. Inside the forever loop the motors are set to both drive forwards, then there is an if then block that tests if an obstacle has been detected anywhere. When this happens, the robot spins 180 degrees and loops back to the start of the forever loop. At the beginning of the forever loop both motors are again set to drive forwards.  This results in Edison driving away from obstacles in its path.",
"HELP_TEXT_SENSING_LINETRACKER_TITLE" : "Line tracker on surface",
"HELP_TEXT_SENSING_LINETRACKER_BODY_1" : "The line tracker on surface block is a sensor input block that indicates whether or not the surface is reflective. A reflective surface is a surface that reflects the line tracker LED's light back to the light sensor. This is usually a white surface, but a red surface will also reflect the red light from the line tracker's red LED. A non-reflective surface is a surface that does not reflect the line tracker LED's light back to the light sensor. This is usually black, but a blue or green surface will also not reflect the red light from the line tracker's red LED.",
"HELP_TEXT_SENSING_LINETRACKER_BODY_2" : "There are two detection options:",
"HELP_TEXT_SENSING_LINETRACKER_BODY_3" : "reflective (white)",
"HELP_TEXT_SENSING_LINETRACKER_BODY_4" : "non-reflective (black)",
"HELP_TEXT_SENSING_LINETRACKER_BODY_5" : "The line tracker on surface block is a diamond shaped block so the data in the block can only be either true (surface type has been detected) or false (surface type has not been detected).",
"HELP_TEXT_SENSING_LINETRACKER_BODY_6" : "To use the line tracker on surface block the turn line tracking LED on/off block must be used to turn the line tracking LED on.",
"HELP_TEXT_SENSING_LINETRACKER_EXAMPLE_1_TITLE" : "Example program: Bounce in borders",
"HELP_TEXT_SENSING_LINETRACKER_EXAMPLE_1_BODY" : "In this example, the program begins by turning the line tracking LED on, then enters a forever loop. Inside the forever loop the motors are set to both drive forwards, then there is an if then block that tests if the surface is non-reflective. When this is true, the robot spins 180 degrees and loops back to the start of the forever loop. At the beginning of the forever loop both motors are again set to drive forwards. This results in Edison driving away from detected black lines.",
"HELP_TEXT_SENSING_REMOTE_BOOL_TITLE" : "Remote code received",
"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_1" : "The remote code received block is a sensor input block that indicates whether or not a particular remote-control code has been received.",
"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_2" : "There are eight remote code options from 0 to 7.",
"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_3" : "The remote code received block is a diamond shaped block so the data in the block can only be either true (code has been received) or false (code has not been received).",
"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_4" : "Make sure you press the triangle button to start your program. This is easy to forget as the Edison robot will respond as a remote-control robot and not do what you have programmed it to.",
"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_5" : "To use the remote code received block the Edison robot must first be taught which buttons of your remote control correspond to which remote code. Learn more about this here: ",
"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_6" : "If the program behaves unexpectedly, you may need to use the clear sensor data block to clear the contents of the remote code received block. See example program 1 below.",
"HELP_TEXT_SENSING_REMOTE_BOOL_BODY_7" : "The remote code received block will work with approximately 90% of standard TV infrared (IR) remote controls, however each TV brand uses slightly different IR data formats. When Edison is decoding IR data, these differences can cause some unexpected behaviour from one remote control brand to another. Advanced remote-control decoding works best with the EdRemote (available mid 2025).",
"HELP_TEXT_SENSING_REMOTE_BOOL_EXAMPLE_1_TITLE" : "Example program 1: One beep or two?",
"HELP_TEXT_SENSING_REMOTE_BOOL_EXAMPLE_1_BODY" : "In this example, the program begins by entering a forever loop. Inside the forever loop there are two if then blocks that test the received remote code. The first if then tests if the received remote code is remote code 1. If this is true then the beep block plays once and the sensor data is then cleared. If it is false, the program progresses to the next if then block and tests if the received remote code is remote code 2. If this is true then the beep block plays twice and the sensor data is then cleared. The program then loops back to the beginning of the forever loop. ",
"HELP_TEXT_SENSING_REMOTE_BOOL_EXAMPLE_2_TITLE" : "Example program 2: Spin on remote control command (works best with the EdRemote)",
"HELP_TEXT_SENSING_REMOTE_BOOL_EXAMPLE_2_BODY" : "In this example, the program begins by entering a forever loop. Inside the forever loop the if then block tests if remote code 0 has been received. If this is true, then both motors are set to spin the robot right. This continues until the wait until block condition passes. To pass the received remote code must not be remote code 0 (the remote-control button is no longer being pressed). When this happens, the program progresses to stop both motors and then loop to the start of the forever loop. This results in Edison spinning while the remote button is held down.",
"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_TITLE" : "IR message detected",
"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_BODY_1" : "The IR message detected block is a sensor input that indicates whether or not an IR message has been detected (received) from another Edison robot. The term 'IR' is short for 'infrared'. Infrared refers to a band of light that is not visible to humans. This makes is useful as a means to communicate data short distances.",
"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_BODY_2" : "The IR message detected block is a diamond shaped block so the data in the block can only be either true (IR message has been received) or false (IR message has not been received).",
"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_BODY_4" : "The IR message detected block does not know the contents of the IR message that was received. It only tells the program if an IR message has been received. To read the data in the IR message use the received IR message block. See the example program. ",
"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_BODY_5" : "Infrared messaging between Edison robots works best indoors away from direct sunlight. The typical range can be up to 10 meters (30 feet).",
"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_EXAMPLE_1_TITLE" : "Example program: Edison remote light on and off",
"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_EXAMPLE_1_BODY" : "In this example, the program begins by entering a forever loop. Inside the forever loop the first if then block tests if an IR message has been received, if this is true then the variable 'IRMessage' is set to the value from the received IR message block. Doing this allows the received message to be read/tested multiple times without being cleared or lost. The next if then statement tests if the data in 'IRMessage' is equal to 1, if this is true, then the left LED is turned on. If this is not true, then the program moves on to the next if then block. This if then block tests if the data in 'IR Message' is equal to 2, if this is true, then the left LED is turned off. The program then loops back to the start of the forever loop. ",
"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_EXAMPLE_2_TITLE" : "The IR message sending Edison robot runs this program.",
"HELP_TEXT_SENSING_IRMESSAGE_DETECTED_EXAMPLE_2_BODY" : "Pressing the triangle button sends an IR message with the number 1 (turn the LED on) and pressing the round button sends an IR message with the number 2 (turn the LED off)",
"HELP_TEXT_SENSING_DRIVESTRAINED_TITLE" : "Drive strain detected",
"HELP_TEXT_SENSING_DRIVESTRAINED_BODY_1" : "The drive strain detected block is a sensor input block that indicates whether or not one or both of the wheels have stopped rotating due to being under strain (physically prevented from rotating when trying to drive).",
"HELP_TEXT_SENSING_DRIVESTRAINED_BODY_2" : "The drive strain detected block is a diamond shaped block so the data in the block can only be either true (wheel is under strain) or false (wheel is not under strain).",
"HELP_TEXT_SENSING_DRIVESTRAINED_EXAMPLE_1_TITLE" : "Example program: Wheel strained alarm",
"HELP_TEXT_SENSING_DRIVESTRAINED_EXAMPLE_1_BODY" : "In this example, the program begins by setting the left wheel to drive forwards, next the program enters a forever loop. Inside the loop there is an if then block that tests if drive strain is detected. When this is true the beep block is run. The beep block will continue to run until the strain is removed and the wheel can rotate.",
"HELP_TEXT_SENSING_REMOTE_NUM_TITLE" : "Received remote code",
"HELP_TEXT_SENSING_REMOTE_NUM_BODY_1" : "The received remote code block is a sensor input block that contains data received from a remote control. The data is a number from 0 to 7.",
"HELP_TEXT_SENSING_REMOTE_NUM_BODY_2" : "When a program runs this block, its contents are cleared. It is always best to put the data from the received remote code block into a variable before testing it with a conditional (if then) block.  See example program.",
"HELP_TEXT_SENSING_REMOTE_NUM_EXAMPLE_1_TITLE" : "Example program: Remote control light on and off",
"HELP_TEXT_SENSING_REMOTE_NUM_EXAMPLE_1_BODY" : "In this example, the program begins by entering a forever loop. The first block inside the forever loop puts the data from the received remote code block into the variable 'RemoteCode'. The variable 'RemoteCode' can now be tested. The first if then block tests if contents of 'RemoteCode' is equal to 1. If this is true then the left LED is turned on. If this is false, then the next if then block tests if contents of 'RemoteCode' is equal to 2. If this is true, then the left LED is turned off. The program then loops back to the start of the forever loop.",
"HELP_TEXT_SENSING_IRMESSAGE_TITLE" : "Received IR message",
"HELP_TEXT_SENSING_IRMESSAGE_BODY_1" : "The received IR message block is a sensor input block that contains data received from another Edison robot. The term 'IR' is short for 'infrared'. Infrared refers to a band of light that is not visible to humans. This makes it useful as a means to communicate data short distances. The data is based on an 8-bit binary number and has a range of 0 to 255.",
"HELP_TEXT_SENSING_IRMESSAGE_BODY_2" : "When a program runs this block its contents is cleared. It is always best to put the data from the received remote code into a variable before testing it with a conditional (if then block) block.",
"HELP_TEXT_SENSING_IRMESSAGE_BODY_3" : "Infrared messaging between Edison robots works best indoors away from direct sunlight. The typical range can be up to 10 meters (30 feet).",
"HELP_TEXT_SENSING_IRMESSAGE_EXAMPLE_1_TITLE" : "Example program: Start a dance revolution",
"HELP_TEXT_SENSING_IRMESSAGE_EXAMPLE_1_BODY" : "In this example, the program begins by entering a forever loop. The first block inside the forever loop clears the IR message sensor data, the program then waits until an IR message is received that is equal to 3. When this happens, the program enters a repeat loop for four times. Inside the repeat loop are the Edison robot's dance manoeuvres. Each of these moves is based on time not distance. This is really important if there is a whole class of Edison robots dancing in sync to music. The dance manoeuvres repeat four times, the program then loops back to the start of the forever loop.",
"HELP_TEXT_SENSING_IRMESSAGE_EXAMPLE_2_TITLE" : "Example program: Send IR message 3",
"HELP_TEXT_SENSING_IRMESSAGE_EXAMPLE_2_BODY" : "In this example, the program begins by entering a forever loop. The first block inside the forever loop waits until the round button is pressed, when this happens the message number 3 is transmitted via infrared light. The program then loops back to the start of the forever loop.",
"HELP_TEXT_SENSING_LIGHTLEVEL_TITLE" : "Light level of sensor",
"HELP_TEXT_SENSING_LIGHTLEVEL_BODY_1" : "The light level of sensor block is a sensor input block that contains data from the light sensors. The light level is a number between 1 and 1000. The light level of sensor block data is constantly updated.",
"HELP_TEXT_SENSING_LIGHTLEVEL_BODY_2" : "There are three light sensor inputs to select from:",
"HELP_TEXT_SENSING_LIGHTLEVEL_BODY_3" : "- left light (sensor at the front left side)",
"HELP_TEXT_SENSING_LIGHTLEVEL_BODY_4" : "- right light (sensor at the front right side)",
"HELP_TEXT_SENSING_LIGHTLEVEL_BODY_5" : "- line tracking (sensor used to detect lines under the robot)",
"HELP_TEXT_SENSING_LIGHTLEVEL_EXAMPLE_1_TITLE" : "Example program: Night light",
"HELP_TEXT_SENSING_LIGHTLEVEL_EXAMPLE_1_BODY" : "In this example, the program begins by entering a forever loop. The first block inside the forever loop tests if the light level reading on the left light sensor is less than 50. If this is true, then the left and right LEDs turn on. If this is false, then the program jumps to else and the left and right LEDs turn off. The program then loops to the start of the forever loop and repeats. This results in Edison's LEDs being on while it's in a dim light.",
"HELP_TEXT_ADDITION_TITLE" : "Addition",
"HELP_TEXT_ADDITION_BODY" : "The addition operator block adds two values together. The values can be a constant (typed into the input and does not vary), a variable, sensing or an operator block. ",
"HELP_TEXT_ADDITION_EXAMPLE_1_TITLE" : "The constant value 2 is added to the constant value 2.",
"HELP_TEXT_ADDITION_EXAMPLE_2_TITLE" : "The variable 'Counter' is added to the constant value 2. ",
"HELP_TEXT_ADDITION_EXAMPLE_3_TITLE" : "The sensor input light level of sensor is added to the constant value 10.",
"HELP_TEXT_SUBTRACTION_TITLE" : "Subtraction",
"HELP_TEXT_SUBTRACTION_BODY" : "The subtraction operator block subtracts one value from another. The values can be a constant (typed into the input and does not vary), a variable, sensing or an operator block.",
"HELP_TEXT_SUBTRACTION_EXAMPLE_1_TITLE" : "The constant value 10 is subtracted from the constant value 200.",
"HELP_TEXT_SUBTRACTION_EXAMPLE_2_TITLE" : "The constant value 100 is subtracted from the variable 'Counter'.",
"HELP_TEXT_SUBTRACTION_EXAMPLE_3_TITLE" : "The constant value 10 is subtracted from the sensor input light level of sensor.",
"HELP_TEXT_SUBTRACTION_EXAMPLE_4_TITLE" : "Example program: Light radiation counter",
"HELP_TEXT_SUBTRACTION_EXAMPLE_4_BODY" : "In this example program, the music tempo is first set to very fast. The program then enters a forever loop. Inside the loop the program sets the variable (Delay) to 1000 minus the left light level (inverting the light level reading). The next block waits for the value in the (Delay) variable. The program then plays the note C and loops back to the start of the forever loop and repeats. This results in the Edison beeping slow when in darkness and faster when the light level is brighter. ",
"HELP_TEXT_MULTIPLICATION_TITLE" : "Multiplication",
"HELP_TEXT_MULTIPLICATION_BODY" : "The multiplication operator block multiplies two values. The values can be a constant (typed into the input and does not vary), a variable, sensing or an operator block.",
"HELP_TEXT_MULTIPLICATION_EXAMPLE_1_TITLE" : "The constant value 2 is multiplied by the constant value 4.",
"HELP_TEXT_MULTIPLICATION_EXAMPLE_2_TITLE" : "The variable 'Counter' is multiplied by the constant value 2.",
"HELP_TEXT_MULTIPLICATION_EXAMPLE_3_TITLE" : "The sensor input light level of sensor is multiplied by the constant value 4.",
"HELP_TEXT_DIVISION_TITLE" : "Division",
"HELP_TEXT_DIVISION_BODY_1" : "The division operator block divides one value by another value. The values can be a constant (typed into the input and does not vary), a variable, sensing or an operator block.",
"HELP_TEXT_DIVISION_BODY_2" : "it is not possible to divide by zero, Edison will experience an error if the right most input is zero.",
"HELP_TEXT_DIVISION_EXAMPLE_1_TITLE" : "The constant value 10 is divided by the constant value 2.",
"HELP_TEXT_DIVISION_EXAMPLE_2_TITLE" : "The variable 'Counter' is divided by the constant value 2. ",
"HELP_TEXT_DIVISION_EXAMPLE_3_TITLE" : "The sensor input light level of sensor is divided by 10.",
"HELP_TEXT_DIVISION_EXAMPLE_4_TITLE" : "Example program: Setting the drive distance using a variable and data from a sensor",
"HELP_TEXT_DIVISION_EXAMPLE_4_BODY" : "In this example program, Edison sets the (Distance) variable to the light level from the left light sensor (a value from 1 to 1,000) divided by 50. The Edison then drives forward for the value in the (Distance) variable at speed 5.  This results in Edison driving further in bright light, to a maximum distance of 20cm.",
"HELP_TEXT_RANDOM_NUMBER_TITLE" : "random number",
"HELP_TEXT_RANDOM_NUMBER_BODY" : "The random number between block generates a random number between two values. The values can be a constant (typed into the input and does not vary), a variable, sensing or an operator block.",
"HELP_TEXT_RANDOM_NUMBER_EXAMPLE_1_TITLE" : "Generate a random number between the constant value 10 and the constant value 100.",
"HELP_TEXT_RANDOM_NUMBER_EXAMPLE_2_TITLE" : "Generate a random number between the variable 'Counter' and the constant value 5000.",
"HELP_TEXT_RANDOM_NUMBER_EXAMPLE_3_TITLE" : "Generate a random number between the constant value 10 and the sensor input light level of sensor.",
"HELP_TEXT_RANDOM_NUMBER_EXAMPLE_4_TITLE" : "Example program: Crazy lights",
"HELP_TEXT_RANDOM_NUMBER_EXAMPLE_4_BODY" : "In this example, the program begins by entering a forever loop. Inside the forever loop, the left and right LEDs are turned on and off. The wait times between turning on and off are controlled by the wait milliseconds blocks. The time in milliseconds is set by the random number blocks inside them. These are set to generate random numbers between 30 and 300 milliseconds. The result is a crazy and inconsistent flashing of the Edison robot's LED lights.",
"HELP_TEXT_ABS_VAL_TITLE" : "abs",
"HELP_TEXT_ABS_VAL_BODY" : "The abs (absolute value) block converts a value to an absolute value. An absolute value is a value that is always positive. The value can be a constant (typed into the input and does not vary), a variable, sensing or an operator block.",
"HELP_TEXT_ABS_VAL_EXAMPLE_1_BODY" : "Has a result of the value 3.",
"HELP_TEXT_ABS_VAL_EXAMPLE_2_BODY" : "Has a result of the value 3.",
"HELP_TEXT_ABS_VAL_EXAMPLE_3_TITLE" : "Example program: report the difference between light levels",
"HELP_TEXT_ABS_VAL_EXAMPLE_3_BODY" : "In this example, the program begins by entering a forever loop. The first block in the forever loop sets the variable 'Difference' to the absolute value of the light level from the right light sensor minus the light level from the left light sensor. The abs block ensures that the result is always positive (no negative numbers). The program then waits for one second and then sends the value in the variable 'Difference' via USB. This value is always a positive (absolute) value.",
"HELP_TEXT_LESS_THAN_TITLE" : "Less than",
"HELP_TEXT_LESS_THAN_BODY_1" : "The less than block compares two input values to determine if the first value is less than the second value and returns a result that is either true or false. The values can be a constant (typed into the input and does not vary), a variable, sensing or an operator block.",
"HELP_TEXT_LESS_THAN_BODY_2" : "The less than block is a diamond shaped block so the result of the block can only be either true or false. ",
"HELP_TEXT_LESS_THAN_EXAMPLE_1_BODY" : "Result: true",
"HELP_TEXT_LESS_THAN_EXAMPLE_2_BODY" : "Result: false",
"HELP_TEXT_LESS_THAN_EXAMPLE_3_TITLE" : "Is the variable 'Counter' less than the constant value 120.",
"HELP_TEXT_LESS_THAN_EXAMPLE_4_TITLE" : "Is the light level from the left sensor less than the constant value 500.",
"HELP_TEXT_LESS_THAN_EQUAL_TITLE" : "Less than or equal to",
"HELP_TEXT_LESS_THAN_EQUAL_BODY_1" : "The less than or equal to block compares two input values to determine if the first value is less than or equal to the second value and returns a result that is either true or false. The values can be a constant (typed into the input and does not vary), a variable, sensing or an operator block.",
"HELP_TEXT_LESS_THAN_EQUAL_BODY_2" : "The less than or equal to block is a diamond shaped block so the result of the block can only be either true or false.",
"HELP_TEXT_LESS_THAN_EQUAL_EXAMPLE_1_BODY" : "Result: true",
"HELP_TEXT_LESS_THAN_EQUAL_EXAMPLE_2_BODY" : "Result: false",
"HELP_TEXT_LESS_THAN_EQUAL_EXAMPLE_3_BODY" : "Result: true",
"HELP_TEXT_LESS_THAN_EQUAL_EXAMPLE_4_TITLE" : "Is the variable 'Counter' less than or equal to the constant value 120.",
"HELP_TEXT_LESS_THAN_EQUAL_EXAMPLE_5_TITLE" : "Is the light level from the left sensor less than or equal to the constant value 500.",
"HELP_TEXT_EQUAL_TITLE" : "Equal to",
"HELP_TEXT_EQUAL_BODY_1" : "The equal to block compares two input values to determine if the first value is equal to the second value and returns a result that is either true or false. The values can be a constant (typed into the input and does not vary), a variable, sensing or an operator block.",
"HELP_TEXT_EQUAL_BODY_2" : "The equal to block is a diamond shaped block so the result of the block can only be either true or false. ",
"HELP_TEXT_EQUAL_EXAMPLE_1_BODY" : "Result: true",
"HELP_TEXT_EQUAL_EXAMPLE_2_BODY" : "Result: false",
"HELP_TEXT_EQUAL_EXAMPLE_3_TITLE" : "Is the variable 'Counter' equal to the constant value 60.",
"HELP_TEXT_EQUAL_EXAMPLE_4_TITLE" : "Is the received remote code equal to the constant value 3.",
"HELP_TEXT_GREATER_THAN_EQUAL_TITLE" : "Greater than or equal to",
"HELP_TEXT_GREATER_THAN_EQUAL_BODY_1" : "The greater than or equal to block compares two input values to determine if the first value is greater than or equal to the second value and returns a result that is either true or false. The values can be a constant (typed into the input and does not vary), a variable, sensing or an operator block.",
"HELP_TEXT_GREATER_THAN_EQUAL_BODY_2" : "The greater than or equal to block is a diamond shaped block so the result of the block can only be either true or false. ",
"HELP_TEXT_GREATER_THAN_EQUAL_EXAMPLE_1_BODY" : "Result: true",
"HELP_TEXT_GREATER_THAN_EQUAL_EXAMPLE_2_BODY" : "Result: false",
"HELP_TEXT_GREATER_THAN_EQUAL_EXAMPLE_3_BODY" : "Result: true",
"HELP_TEXT_GREATER_THAN_EQUAL_EXAMPLE_4_TITLE" : "Is the variable 'Counter' greater than or equal to the constant value 120.",
"HELP_TEXT_GREATER_THAN_EQUAL_EXAMPLE_5_TITLE" : "Is the light level from the left sensor greater than or equal to the constant value 500.",
"HELP_TEXT_GREATER_THAN_TITLE" : "Greater than",
"HELP_TEXT_GREATER_THAN_BODY_1" : "The greater than block compares two input values to determine if the first value is greater than the second value and returns a result that is either true or false. The values can be a constant (typed into the input and does not vary), a variable, sensing or an operator block.",
"HELP_TEXT_GREATER_THAN_BODY_2" : "The greater than block is a diamond shaped block so the result of the block can only be either true or false",
"HELP_TEXT_GREATER_THAN_EXAMPLE_1_BODY" : "Result: true",
"HELP_TEXT_GREATER_THAN_EXAMPLE_2_BODY" : "Result: false",
"HELP_TEXT_GREATER_THAN_EXAMPLE_3_TITLE" : "Is the variable 'Counter' greater than the constant value 120.",
"HELP_TEXT_GREATER_THAN_EXAMPLE_4_TITLE" : "Is the light level from the left sensor greater than the constant value 500.",
"HELP_TEXT_NOT_EQUAL_TITLE" : "Not equal to",
"HELP_TEXT_NOT_EQUAL_BODY_1" : "The not equal to block compares two input values to determine if the first value is not equal to the second value and returns a result that is either true or false. The values can be a constant (typed into the input and does not vary), a variable, sensing or an operator block.",
"HELP_TEXT_NOT_EQUAL_BODY_2" : "The not equal to block is a diamond shaped block so the result of the block can only be either true or false. ",
"HELP_TEXT_NOT_EQUAL_EXAMPLE_1_BODY" : "Result: true",
"HELP_TEXT_NOT_EQUAL_EXAMPLE_2_BODY" : "Result: false",
"HELP_TEXT_NOT_EQUAL_EXAMPLE_3_TITLE" : "Is the variable 'Counter' not equal to the constant value 120.",
"HELP_TEXT_NOT_EQUAL_EXAMPLE_4_TITLE" : "Is the received remote code not equal to the constant value 3.",
"HELP_TEXT_IS_BETWEEN_TITLE" : "Is between ",
"HELP_TEXT_IS_BETWEEN_BODY_1" : "The is between block determines if a value is within a range of two other values. The values can be a constant (typed into the input and does not vary), a variable, sensing or an operator block.",
"HELP_TEXT_IS_BETWEEN_BODY_2" : "The is between block is a diamond shaped block so the result of the block can only be either true or false.",
"HELP_TEXT_IS_BETWEEN_EXAMPLE_1_BODY" : "Result: true",
"HELP_TEXT_IS_BETWEEN_EXAMPLE_2_BODY" : "Result: false",
"HELP_TEXT_IS_BETWEENL_EXAMPLE_3_TITLE" : "Is the variable 'Counter' between the constant value 60 and the constant value 120.",
"HELP_TEXT_IS_BETWEEN_EXAMPLE_4_TITLE" : "Is the sensor light level of left light sensor between the constant value 250 and the constant value 750.",
"HELP_TEXT_AND_TITLE" : "And",
"HELP_TEXT_AND_BODY_1" : "The and block determines if two inputs are both true. If both inputs are true, then the result will also be true. If one or both inputs are false, then the result is false.  The inputs accept diamond shaped blocks that can be either an operator block or sensing block.",
"HELP_TEXT_AND_BODY_2" : "The and block is a diamond shaped block so the result of the block can only be either true or false.",
"HELP_TEXT_AND_EXAMPLE_1_BODY" : "Result: true",
"HELP_TEXT_AND_EXAMPLE_2_BODY" : "Result: false",
"HELP_TEXT_AND_EXAMPLE_3_TITLE" : "Is both the line tracker on reflective surface “and” drive strain detected. ",
"HELP_TEXT_AND_EXAMPLE_4_TITLE" : "Is the variable 'Counter' greater than 50 “and” received remote code is equal to the constant value 3.",
"HELP_TEXT_OR_TITLE" : "Or",
"HELP_TEXT_OR_BODY_1" : "The or block determines if the first input “or” the second input are true. If one or both inputs are true, then the result will be true. If both inputs are false, then the result will be false. The inputs accept diamond shaped blocks that can be either an operator block or sensing block.",
"HELP_TEXT_OR_BODY_2" : "The or block is a diamond shaped block so the result of the block can only be either true or false.",
"HELP_TEXT_OR_EXAMPLE_1_BODY" : "Result: true",
"HELP_TEXT_OR_EXAMPLE_2_BODY" : "Result: true",
"HELP_TEXT_OR_EXAMPLE_3_BODY" : "Result: false",
"HELP_TEXT_OR_EXAMPLE_4_TITLE" : "Is either the line tracker on reflective surface “or” drive strain detected. ",
"HELP_TEXT_OR_EXAMPLE_5_TITLE" : "Is either the variable 'Counter' less than the constant value 50 “or” received remote code is equal to the constant value 3.",
"HELP_TEXT_NOT_TITLE" : "Not",
"HELP_TEXT_NOT_BODY_1" : "The not block determines if the input is “not” true. If the input is false, then the output will be true. If the input is true, then then the output will be false.  The input accepts diamond shaped blocks that can be either an operator block or sensing block.",
"HELP_TEXT_NOT_BODY_2" : "The not block is a diamond shaped block so the result of the block can only be either true or false.",
"HELP_TEXT_NOT_EXAMPLE_1_BODY" : "Result: false",
"HELP_TEXT_NOT_EXAMPLE_2_BODY" : "Result: true",
"HELP_TEXT_NOT_EXAMPLE_3_TITLE" : "Is remote code 0 not received.",
"HELP_TEXT_NOT_EXAMPLE_4_TITLE" : "Example program: Spin on remote control command (works best with the EdRemote)",
"HELP_TEXT_NOT_EXAMPLE_4_BODY" : "In this example, the program begins by entering a forever loop. Inside the forever loop the if then block tests if remote code 0 has been received. If this is true, then both motors are set to spin the robot right. This continues until the wait until block condition passes. To pass, the received remote code must not be remote code 0 (the remote-control button is no longer being pressed). When this happens, the program progresses to stop both motors and then loop to the start of the forever loop. This results in Edison spinning while the remote button is held down.",
"HELP_TEXT_COMMENT_TITLE" : "comment",
"HELP_TEXT_COMMENT_BODY_1" : "The comment block is used to add notes to a program. The notes describe in plain language how the program is intended to work. Making comments in a program helps when someone else needs to edit your program or you need to edit your program a long time after you wrote it.",
"HELP_TEXT_COMMENT_BODY_2" : "Comments are not programmed into Edison so do not change the behaviour of your program.",
"HELP_TEXT_COMMENT_EXAMPLE_1_TITLE" : "Example program: Comments explain how the program works in plain language ",
"HELP_TEXT_SEND_USB_TITLE" : "send via USB",
"HELP_TEXT_SEND_USB_BODY_1" : "The send via USB block transmits a value to a computer via the USB connection. The value can either be a constant (typed into the input and does not vary), a variable, a sensing or an operator block.",
"HELP_TEXT_SEND_USB_BODY_2" : "To see the number on the computer, click the USB button in EdScratch and a pop-up window will appear. Click Run USB to connect to the Edison V3 robot. The data received from the Edison V3 will appear in the Data from USB window. ",
"HELP_TEXT_SEND_USB_BODY_3" : "The send to USB block can also be used to help debug a program.",
"HELP_TEXT_SEND_USB_BODY_4" : "The Edison V3 wheels will not drive while connected to USB. This is due to international safety standards that do not allow products intended for children to be able to drive a motor while connected to a USB port. ",
"HELP_TEXT_SEND_USB_EXAMPLE_1_TITLE" : "Example program: Measure light level",
"HELP_TEXT_SEND_USB_EXAMPLE_1_BODY" : "In this example, the program starts by entering a forever loop. The first block inside the loop sends the light level of the left light sensor via USB. The program then waits one second and repeats.",
"HELP_TEXT_SAVE_USB_TITLE" : "wait for USB data and save to",
"HELP_TEXT_SAVE_USB_BODY_1" : "The wait for USB data and save to block pauses the program until data is received via USB and then places the data into a variable. ",
"HELP_TEXT_SAVE_USB_BODY_2" : "The Edison V3 wheels will not drive while connected to USB. This is due to international safety standards that do not allow products intended for children to be able to drive a motor while connected to a USB port. ",
"HELP_TEXT_SAVE_USB_EXAMPLE_1_TITLE" : "Example program: Number of beeps from USB",
"HELP_TEXT_SAVE_USB_EXAMPLE_1_BODY_1" : "In this example, the program starts by entering a forever loop. The first block inside the loop waits until data is received from USB. When data is received, the data is saved to the variable 'Count'. The program then progresses to the repeat block which repeats for the value of the 'Count' variable. Inside the repeat block the beep block and wait sec blocks run. This results in Edison beeping the number of times sent via USB.",
"HELP_TEXT_SAVE_USB_EXAMPLE_1_BODY_2" : "To test this program, click the USB button in the EdScratch app and a pop-up window will appear. Click Run USB to connect to the Edison V3 robot. To send data to the Edison V3, type a number into the Data to USB box and click the Send to USB button.  ",
"HELP_TEXT_FUNCTION_START_TITLE" : "Function start",
"HELP_TEXT_FUNCTION_START_BODY_1" : "The function start block is where your function begins. Connect blocks to the function start block to create a custom function.",
"HELP_TEXT_FUNCTION_START_BODY_2" : "Function blocks help to simplify a program as the code can be grouped making it easier to read. Functions also help to reduce the size of a program as the repetitive parts of a program only need to be written once.  ",
"HELP_TEXT_FUNCTION_START_BODY_3" : "Function call blocks cannot be placed under function start blocks.",
"HELP_TEXT_FUNCTION_START_EXAMPLE_1_TITLE" : "Example program 1: Drive in the shape of a square",
"HELP_TEXT_FUNCTION_START_EXAMPLE_1_BODY" : "In this example, the program starts by entering a repeat for four times loop. Inside the repeat block is a function call named 'DriveAndTurn'. When the program gets to this block it jumps to the corresponding function start block. Under this block the robot is instructed to drive forwards 10cm, then spin right 90 degrees. This function is called four times inside the repeat loop. This results in Edison driving in a square.  ",
"HELP_TEXT_FUNCTION_START_EXAMPLE_2_TITLE" : "Example program 2: Avoid lines and obstacles ",
"HELP_TEXT_FUNCTION_START_EXAMPLE_2_BODY" : "In this example, the program starts by turning on the obstacle detector and line tracker LED and then enters a forever loop. Inside the forever loop both motors are set to drive forward. Next, the if then block tests for any obstacle detected, if true, then the function call block 'TurnAround' causes the program to jump to the function start block 'TurnAround'. The program then stops the motors, turns on the LED light, beeps, drives backwards, spins 175 degrees and turns the LEDs off and exits back to the main program where it left off. The next if then block tests if the surface is non-reflective (black), if true, then the function call block 'TurnAround' causes the program to jump to the function start block 'TurnAround'. The program then stops the motors, turns on the LED light, beeps, drives backwards, spins 175 degrees and turns the LEDs off and exits back to the main program where it left off. This results in Edison driving away from lines and objects it detects.",
"HELP_TEXT_FUNCTION_CALL_TITLE" : "Function call",
"HELP_TEXT_FUNCTION_CALL_BODY_1" : "The function call block tells the program to jump to the function start block. ",
}








// End of combined translations
